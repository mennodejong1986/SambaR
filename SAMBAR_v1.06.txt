# SAMBAR: Snp DatA Management and Basic Analyses in R 
# Author: Menno de Jong, 
# Affiliations: Durham University (Biosciences Department), Senckenberg Institute (BIK-f) 
# github page: https://github.com/mennodejong1986/SambaR
# R package for SNP data management and analyses
# latest update: 06-02-2020

# To run most SambaR functions, you need to run 10 R commands, which roughly look like this:
example_run<-function()
	{
	source("https://github.com/mennodejong1986/SambaR/raw/master/SAMBAR_v1.05.txt")
	# or:
	# source("SAMBAR_v1.00.txt")
	setwd("C:/path/to/workingdir")
	getpackages(myrepos='http://cran.us.r-project.org')
	importdata(inputprefix="SNPdataprefix",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	calckinship()
	calcdistance()
	calcdiversity()
	selectionanalyses()
	backupdata("mySNPdata")
	}
# For more instructions, see the manual






##### file and package management:

# to get a list of all packages with a certain function name: 
findpackages<-function(myfunction) 
	{
	h 	<- help.search(paste0("^",myfunction,"$"),agrep=FALSE)     
	h$matches[,"Package"] 
	#
	# To know which of the packages is being used when you define the function, simply type the function name
	#
	# To change the order of loaded packages, so that function is no longer masked: simply unload and load the desired packages .
	# For example:
	# unloadNamespace("zoo")
	# library("zoo")
	}  

# function to check if file is open:
# Careful: if not open, this function overrides the existing file with an empty file.
# Plus: opens the file in R, and as a result can only open as read-only and not delete.
# So not useful 
file_opened<-function(myfilename=NULL) 
	{
	if(is.null(myfilename))
		{
		return(cat("ERROR: Please provide the name of a file to flag 'myfilename'.",sep="\n"))
		}
	if(!file.exists(myfilename))
		{
		return(cat("ERROR: Specified file does not exist.",sep="\n"))
		}
	return(suppressWarnings("try-error" %in% class(try(file(myfilename,open="w"),silent=TRUE))))
	}

##### the 2 functions needed to create multi tile plots:

myplotfunctions<-function(function_nr=1)
	{
	# Note: upper margin of the plots should be 2 (i.e. par(mar(.,.,2,.)) in order to allow for tile labels.
	if(function_nr==1){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==2){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==3){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==4){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==5){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==6){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	}

mymultiplot<-function(myplotfunctions=myplotfunctions,doexport=FALSE,plot_name="combinedplot",myscreens=NULL,doexample=FALSE,myheight=6,mywidth=8,tilelabelsize=4.5,tilelabels=NULL,show_screens=FALSE)
	{
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	# mytiles <- rbind(c(0,0.4,0.4,1.0),c(0.4,1.0,0.4,1.0),c(0.0,0.33,0.0,0.4),c(0.33,0.67,0.0,0.4),c(0.67,1.0,0.0,0.4))
	# each row represents a different tile: (xmin, xmax, ymin, ymax), from 0 to 1
	if(doexample)
		{
		myscreens <- rbind(c(0,0.45,0.45,1.0),c(0.45,1.0,0.45,1.0),c(0.0,0.33,0.0,0.45),c(0.33,0.67,0.0,0.45),c(0.67,1.0,0.0,0.45))
		}else{
		if(is.null(myscreens))
			{
			cat("ERROR: please provide input matrix in which you define how to divide the plot into separate screens.",sep="\n")
			cat("This matrix should contain 4 (unnamed) columns defining xmin, xmax, ymin, ymax. Values can range between 0 and 1. One row per screen.",sep="\n")
			cat("For example: to divide the plot into 3 tiles, you could type:",sep="\n")
			return(cat("myscreens=rbind(c(0,0.5,0.4,1.0),c(0.5,1.0,0.4,1.0),c(0.0,1.0,0.0,0.5))",sep="\n"))
			}
		}
	if(is.null(tilelabels))
		{
		tilelabels	<- letters
		}
	nscreens	<- nrow(myscreens)
	cat(paste("Plot will be divided into ",nscreens," tiles.",sep=""),sep="\n") 
	if(doexport)
		{
		combinedplotname	<- paste(plot_name,"pdf",sep=".")
		pdf(combinedplotname,height=myheight,width=mywidth)
		# just for reference: A4 size: 210 × 297 mm or 8.3 × 11.7 inch
		}
	split.screen(myscreens)
	for (myscreennr in c(1:nscreens))
		{
		cat(paste("Generating plot in screen ",myscreennr,".",sep=""),sep="\n")
		screen(myscreennr)
		if(doexample)
			{
			par(oma=c(0.5,0.5,0.5,0.5),mar=c(0.5,0.5,1,0.5))
			plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")
			}else{
			if(show_screens)
				{
				plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")
				}else{
				myplotfunctions(function_nr=myscreennr)
				}
			}
		title(tilelabels[myscreennr],adj=0,cex.main=tilelabelsize)
		}
	# close all tiles:
	close.screen(all.screens = TRUE)
	if(doexport)
		{
		dev.off()
		cat("Plot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}


#####

getcitations<-function()
	{
	mysoftwares			<- c("ade4","adegenet","ape","bibtex","car","circlize","colorspace","curl","devtools","fsthet","factoextra","FactoMineR","gdsfmt","gplots","grid","gridExtra","gridGraphics","LEA","mapplots","MASS","migest","OutFLANK","pcadapt","pegas","plot3D","plyr","poppr","psych","raster","RcppEigen","RColorBrewer","Rcpp","rworldmap","qvalue","scales","scatterplot3d","SNPRelate","StAMPP","stats","tess3r","VennDiagram","vegan","vioplot","zoo") 
	setwd(mysambar$sambardir)
	mybool				<- mysoftwares%in%installed.packages()
	mysoftwares			<- mysoftwares[mybool]
	write.bib(mysoftwares, file = "SambaR_Rpackages.bib", append = FALSE, verbose = TRUE)
	cat("A file called 'SambaR_Rpackages.bib' has been exported to the SambaR directory.",sep="\n")
	cat("This file can be loaded into a referencing software, such as Zotero or Endnote, although it might need some manual editing.",sep="\n")
	}

getversions<-function(return_object=FALSE)
	{
	mysoftwares			<- c("ade4","adegenet","ape","bibtex","circlize","colorspace","curl","devtools","fsthet","gdsfmt","gplots","grid","gridExtra","gridGraphics","LEA","mapplots","MASS","migest","OutFLANK","pcadapt","pegas","phangorn","plot3D","plyr","poppr","qvalue","RcppEigen","RColorBrewer","rworldmap","scales","scatterplot3d","SNPRelate","StAMPP","stats","tess3r","vegan","vioplot","zoo") 
	mysoftwares			<- mysoftwares[order(mysoftwares)]
	mybool				<- mysoftwares%in%installed.packages()
	mysoftwares			<- mysoftwares[mybool]
	myversions			<- vector()
	for (j in c(1:length(mysoftwares)))
		{	
		mypackage		<- mysoftwares[j] 
		myversions[j]	<- packageDescription(mypackage)$Version
		}
	mysoftwares			<- c("R",mysoftwares)
	myversions			<- c(getRversion(),myversions)
	mydf				<- data.frame(package=mysoftwares,version=myversions)	
	mydf$combined		<- paste(mydf$package,mydf$version,sep="-")
	if(return_object)
		{
		return(mydf)
		}
	write.table(mydf,"Rpackage_versions.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
	cat("A list of installed R packages (versions) has been exported to a file named 'Rpackage_versions.txt' in the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}	

exportmethods<-function(ind_miss=0.25,snp_miss=0.1,minmac=2,hefilter=TRUE,minimumspacing=500)
	{
	#if(!exists("mypackageversions"))
	#	{
	#	cat("WARNING: Object 'mypackageversions' not found. This might mean that the importdata function did not finish completely.",sep="\n")
	#	return(cat("Due to the absence of the 'mypackageversions' object, SambaR will not generate the file 'SambaR_methods.txt'. The analyses are unaffected.",sep="\n"))
	#	}
	myversions		<- getversions(return_object=TRUE)
	myrversion		<- myversions$combined[myversions$package=="R"]
	myadegenet		<- myversions$combined[myversions$package=="adegenet"]
	myrworldmap		<- myversions$combined[myversions$package=="rworldmap"]
	mymapplots		<- myversions$combined[myversions$package=="mapplots"]
	myade4			<- myversions$combined[myversions$package=="ade4"]
	myape			<- myversions$combined[myversions$package=="ape"]
	mystampp		<- myversions$combined[myversions$package=="StAMPP"]
	myphangorn		<- myversions$combined[myversions$package=="phangorn"]
	mypoppr			<- myversions$combined[myversions$package=="poppr"]
	mysnprelate		<- myversions$combined[myversions$package=="SNPRelate"]
	mystats			<- myversions$combined[myversions$package=="stats"]
	mymass			<- myversions$combined[myversions$package=="MASS"]
	mylea			<- myversions$combined[myversions$package=="LEA"]
	mypegas			<- myversions$combined[myversions$package=="pegas"]
	mycirclize		<- myversions$combined[myversions$package=="circlize"]
	myfsthet		<- myversions$combined[myversions$package=="fsthet"]
	myoutflank		<- myversions$combined[myversions$package=="OutFLANK"]
	mypcadapt		<- myversions$combined[myversions$package=="pcadapt"]
	myzoo			<- myversions$combined[myversions$package=="zoo"]
	setwd(mysambar$sambardir)
	ntotalinds		<- nrow(inds)
	if(any(!inds$filter))
		{
		npopmin			<- min(as.vector(table(inds$filter,inds$pop)[2,]))
		npopmax			<- max(as.vector(table(inds$filter,inds$pop)[2,]))
		}else{
		npopmin			<- min(as.vector(table(inds$filter,inds$pop)[1,]))
		npopmax			<- max(as.vector(table(inds$filter,inds$pop)[1,]))
		}
	nretainedinds	<- nrow(inds[inds$filter,])
	ntotalsnps		<- nrow(snps)
	nretainedsnps	<- nrow(snps[snps$filter2,])
	nthinnedsnps	<- nrow(snps[snps$filter,])
	if("meandepth"%in%colnames(inds))
		{
		rdmean	<- round(mean(inds$meandepth,na.rm=TRUE),1)
		rdmin	<- round(min(inds$meandepth,na.rm=TRUE),1)
		rdmax	<- round(max(inds$meandepth,na.rm=TRUE),1)
		if(min(inds$miss,na.rm=TRUE)<0.1)
			{
			rd0.1	<- round(min(inds$meandepth[inds$miss<=0.1],na.rm=TRUE),1)
			}else{
			rd0.1	<- NA
			}
		if(min(inds$miss,na.rm=TRUE)<0.005)
			{
			rd0.01	<- round(min(inds$meandepth[inds$miss<=0.01],na.rm=TRUE),1)
			}else{
			rd0.01	<- NA
			}
		if(min(inds$miss,na.rm=TRUE)<0.005)
			{
			rd0.005	<- round(min(inds$meandepth[inds$miss<=0.005],na.rm=TRUE),1)
			}else{
			rd0.005	<- NA
			}
		if(min(inds$miss,na.rm=TRUE)<0.001)
			{
			rd0.001	<- round(min(inds$meandepth[inds$miss<=0.001],na.rm=TRUE),1)
			}else{
			rd0.001	<- NA
			}
		}else{
		rdmean	<- NA
		rdmin	<- NA
		rdmax	<- NA
		rd0.1	<- NA
		rd0.01	<- NA
		rd0.005	<- NA
		rd0.001	<- NA
		}
	if("meandepth"%in%colnames(snps))
		{
		snpmedian	<- round(median(snps$meandepth,na.rm=TRUE),1)
		snpmean		<- round(mean(snps$meandepth,na.rm=TRUE),1)
		snpmax		<- round(max(snps$meandepth,na.rm=TRUE),1)
		snpmin		<- round(min(snps$meandepth,na.rm=TRUE),1)
		}else{
		snpmedian	<- NA
		snpmean		<- NA
		snpmax		<- NA
		snpmin		<- NA
		}
	myGC		<- round(nrow(snps[snps$GC&snps$filter,])/nrow(snps[snps$filter,]),2)
	mytransit	<- round(nrow(snps[snps$transit&snps$filter,])/nrow(snps[snps$filter,]),2)
	fileConn	<- file("SambaR_methods.txt")
	writeLines(c("This file contains a template for your methods section. Remove the lines which are not applicable to your study.",
	"Full citations can be found in the 'SambaR_Rpackages.bib' file.",
	"",
	"DATA PREPARATION",
	"PGD-Spider (Lischer and Excoffier, 2012), plink  (Purcell et al., 2007) or vcftools (Danecek et al., 2011) was used to convert the SNP data into PED and MAP format.",
	"The vcftools (Danecek et al., 2011) flags --depth and --site-depth were used to calculate read depth per individual and per SNP.",
	paste("The mean sequence depth per individual ranged from ",rdmin," to ",rdmax," reads per SNP, with an average of ",rdmean," reads per SNP per individual.",sep=""),
	paste("Individuals with less than 10, 1, 0.5 and 0.25 percent missing data had a minimum cover of respectively ",rd0.1,", ",rd0.01,", ",rd0.005,", and ",rd0.001," reads (see figure 'missingdatapersample').",sep=""), 
	paste("The mean sequence depth per individual per SNP ranged from ",snpmin," to ",snpmax," reads per SNP, with a mean and median of respectively ",snpmean," and ",snpmedian," reads (see figure 'Locusdepth').",sep=""),
	"Binary files (BED, RAW and BIM) were generated from PED and MAP files using PLINK (Purcell et al., 2007, i.e. using the flags --make-bed, --recode A, --chr-set 95, and allow-extra-chr).",
	"DATA MANAGEMENT",
	paste("SNP data management and analyses were performed in ",myrversion," (R Core Team, 2019) using wrapper functions of the R package SambaR (github page: https://github.com/mennodejong1986/SambaR ).",sep=""),
	paste("The data was imported into R and stored in a genlight object using the function 'read.PLINK' of the R package ",myadegenet," (Jombart, 2008; Jombart and Ahmed, 2011).",sep=""), 
	paste("The data was filtered using the function 'filterdata' of the R package SambaR, with indmiss=",ind_miss,", snpmiss=",snp_miss,", min_mac=",minmac,", dohefilter=",hefilter," and min_spacing=",minimumspacing,".",sep=""),
	paste("After filtering ",nretainedinds," out of ",ntotalinds," individuals (",npopmin,"-",npopmax," per population) were retained (see figures 'Missingdata_perpop', 'Retainedinds_perpop' and 'Discardedinds_perpop').",sep=""),
	paste("After filtering ",nretainedsnps," out of ",ntotalsnps," SNPs were retained (see figure 'Filterclasses'). This filtered dataset was used for selection analyses.",sep=""),
	paste("Thinning reduced the dataset further to ",nthinnedsnps," SNPs (see figure 'Filterclasses'). This filtered and thinned dataset was used for structure analyses.",sep=""),
	"Note that SambaR's 'filterdata' function filters individuals based on their proportion of missing datapoints considering all SNPs.",
	"Subsequently, the function filters SNPs based on their proportion of missing datapoints considering retained individuals only.",
	"The opposite order - i.e. first filtering of SNPs, then filtering of individuals - could return different estimates of missing data and, as a result, different numbers of retained SNPs and individuals.",  
	paste("The GC-content of the retained dataset equalled ",myGC," (see figure 'Minoralleles') and the 'transversion vs transition'-ratio equalled ",mytransit," (see figure 'Transitions_vs_transversions.filtered').",sep=""),
	"PLOTTING",
	paste("Geographical maps were generated with the function 'getMap' of the R package ",myrworldmap," (South, 2011). Piecharts were added using the function 'add.pie' of the R package ",mymapplots," (Gerritsen, 2018).",sep=""),
	"STRUCTURE ANALYSES",
	paste("Correspondence analyses (CA) were performed using the function 'dudi.coa' of the R package ",myade4," (Dray and Dufour, 2007; Bougeard and Dray, 2018). Data was imputed per SNP/individual by calculating genotype probabilities from population specific minor allele frequencies'.",sep=""),
	paste("Principal coordinate analyses (PCoA) were performed using the function 'pcoa' of the R package ",myape," (Paradis and Schliep, 2018) on distance matrices containing 3 different measures of genetic distance:",sep=""),
	paste("- Nei's genetic distance, calculated with the function 'stamppNeisD' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	paste("- Hamming's genetic distance, calculated with the function 'bitwise.dist' of the R package ",mypoppr," (Kamvar et al., 2014).",sep=""),
	"- pi (pairwise sequence dissimilarity), calculated with the function 'calcpi' of the R package SambaR.", 
	paste("Principal component analyses (PCA) were performed using the function 'snpgdsPCA' of the R package ",mysnprelate," (Zheng et al., 2012).",sep=""),
	paste("DAPC analyses were performed using the function 'dapc' of the R package ",myadegenet," (Jombart, 2008; Jombart and Ahmed, 2011), both with and without prior population assignment. The number of PCs was set to ... (based on the a-score), the number of clusters was set to ..., and the number of discriminant functions to 3.",sep=""), 
	paste("Multi dimensional scaling (MDS) was performed using the function 'cmdscale' (metric MDS) of the R package ",mystats," (R Core Team, 2019) and the function 'isoMDS' (non-metric MDS) of the R package ",mymass," (Venables and Ripley, 2002), on a Euclidean distance matrix generated with the function 'dist' of the R package ",mystats," (R Core Team, 2019).",sep=""),
	paste("Neighbourhood joining (NJ) clustering was performed using the function 'NJ' of the R package ",myphangorn," (Schliep, 2011), using as input a Hamming’s genetic distance matrix between individuals, calculated with the function 'bitwise.dist' of the R package ",mypoppr," (Kamvar et al. 2014).",sep=""), 
	"Bayesian population assignment (BPA) probabilities were calculated and plotted using the functions 'assign2pop' and 'plotassign2pop' of the R package SambaR.",
	paste("Admixture coefficients were calculated with the functions 'obj.snmf' and 'Q' of the R package ",mylea," (Frichot and Francois, 2014). Alpha was set to 10, tolerance to 0.00001, and number of iterations to 200.",sep=""), 
	"Ancestry coefficients were calculated with the software Admixture-1.3 (Alexander et al., 2009) and plotted using the 'plotstructure'-function of SambaR.",
	#paste("Genotype networks were generated with function 'haploNet' of the R package ",mypegas," (Paradis, 2010).",sep=""),
	"GENETIC DISTANCE ANALYSES",
	paste("Nei's genetic distance was calculated with the function 'stamppNeisD' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	paste("Genome wide 'Weir & Cockerham 1984' Fst estimates (for all pairwise population comparisons) were calculated with the function 'stamppFst' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	"Locus specific Fst estimates (according to Wright (1943), Nei (1977), and Cockerham and Weir (1987) (for all pairwise population comparisons) were calculated with the functions 'runWrightFst', 'locusNeiFst', and 'locusWCFst' of the R package SambaR.",
	"Relatedness between samples was calculated using the softwares PLINK and/or GCTA and plotted using SambaR functions.", 
	"GENETIC DIVERSITY ANALYSES",
	"Linkage disequilibrium (LD) estimates were calculated using PLINK (-genome --r2 --ld-window-kb 1000000 --ld-window -r2 0).", 
	"HWE, (2D) folded site frequency spectra (SFS), Tajima's D and genome wide heterozygosity analyses were executed using the function 'calcdiversity' of the R package SambaR.",
	"More specifically, population specific SFS vectors were generated with the function 'getfoldedsfs' of the R package SambaR, which bins SNPs in classes based on their number of copies of the minor allele, and which subsequently calculated the size of each bin (i.e. number of SNPs within each bin).", 
	"Genome wide He (genomeHe) was calculated for each sample using the formula: genome He = (He_seg * N_seg)/N_total, in which:",
	"N_seg: 	the number of sites segregating within the population to which the investigated individual belonged.",
	"He_seg: 	the proportion of heterozygous sites within the investigated individual for those segregating sites.", 
	"N_total:	the combined length of all sequenced sites (polymorphic as well as monomorphic) which passed the filter settings.",  
	"SELECTION ANALYSES",
	paste("Selection analyses were performed using the R packages ",myfsthet," (Flanagan and Jones, 2018), ", myoutflank," (Whitlock and Lotterhos, 2015), ",mypcadapt," (Luu et al., 2016) and the 'gwdsfisher' function of SambaR.",sep=""), 
	paste("Association analyses (GWAS) were performed using the function 'gwdsfisher' of the R package SambaR.",sep=""),
	paste("Sliding window Fst analyses were performed using the function 'rollapply' of the R package ",myzoo,".",sep=""),
	"DEMOGRAPHY ANALYSES",
	"Historical Ne estimates were inferred from the folded SFS vectors with the software stairway_plot_v2 (Liu and Fu, 2015). The mutation rate was set to ... and, the generation time to ...",
	paste("Migration rates were estimated using BayesAss3-SNPs (Mussmann et al., 2019). The number of iterations was set to 1000000, burn-in to 100000 and delta values to 0.1. Output matrices were converted into gene flow plots with the function 'plotmigration' of the R package SambaR, with use of the R package ",mycirclize,".",sep=""), 
	""),fileConn)
	close(fileConn)
	}

sambarcommands<-function(filename="D:/PhD/General/SAMBAR/SAMBAR_v1.01.txt")
	{
	mysambarfile 	<- readLines(filename) 
	linenrs			<- grep("sambarfunction",mysambarfile,value=FALSE)
	mycommands		<- mysambarfile[linenrs+1]
	mycommands2		<- gsub("\"","'",gsub("\t","",mycommands))
	mycommands2		<- mycommands2[2:length(mycommands2)]
	fileConn		<- file("SambaR_methods2.txt")
	writeLines(mycommands2,fileConn)
	close(fileConn)
	# sambarfunction:
	# This file ('SambaR_methods2.txt') contains an overview of the commands executed by the SambaR pipeline which call functions of other packages.
	# sambarfunction:
	# Execution of the filterdata-function will export another file, called 'SambaR_methods.txt', to the SambaR directory. That file contains a description of the methods.
	# sambarfunction:
	
	}

sambaroptions<-function()
	{
	optionslist			<- list()
	fileConn			<- file("SambaR_options.txt")
	optionslist[[1]]	<- args(getpackages)
	writeLines(optionslist[[1]],fileConn)
	close(fileConn)
	optionslist[[2]]	<- args(importdata)
	optionslist[[3]]	<- args(filterdata)
	optionslist[[4]]	<- args(findstructure)
	optionslist[[5]]	<- args(calcdistance)
	optionslist[[6]]	<- args(calcdiversity)
	optionslist[[7]]	<- args(selectionanalyses)
	optionslist			<<- optionslist
	}



############ INSTALLATION OF PACKAGES #############

remove_all_packages<-function(doremove=FALSE)
	{
	# This function removes all user installed packages.
	# create a list of all installed packages
	ip 				<- as.data.frame(installed.packages())
	# if you use MRO, make sure that no packages in this library will be removed
	ip 				<- subset(ip, !grepl("MRO", ip$LibPath))
	# we don't want to remove base or recommended packages either:
	ip 				<- ip[!(ip[,"Priority"] %in% c("base", "recommended")),]
	# determine the library where the packages are installed
	path.lib 		<- unique(ip$LibPath)
	# create a vector with all the names of the packages you want to remove
	pkgs.to.remove <- as.vector(ip[,1])
	mypackages		<<- pkgs.to.remove
	mylibs			<<- path.lib
	if(doremove)
		{
		# remove the packages
		cat("Removing all user installed packages...",sep="\n")
		sapply(pkgs.to.remove, remove.packages, lib = path.lib)
		cat("All user installed packages removed.",sep="\n")
		}else{
		cat("Type 'mypackages' to see the list of names of user-installed packages.",sep="\n")	
		cat("To remove all these packages, execute:",sep="\n")
		cat("'remove_all_packages(doremove=TRUE)'",sep="\n")
		}
	}

removeoldpackages<-function(doremove=FALSE,myrepos='http://cran.us.r-project.org',keepbasepackages=FALSE)
	{
	pgdf			<- as.data.frame(old.packages(repos=myrepos))
	myoldpackages	<- as.vector(pgdf$Package)
	#
	if(keepbasepackages)
		{
		# if you use MRO, make sure that no packages in this library will be removed
		allpgdf			<- as.data.frame(installed.packages())
		mydf2 			<- subset(allpgdf,grepl("MRO", pgdf$LibPath))
		mymro			<- as.vector(mydf2$Package)
		pgdf			<- pgdf[!(myoldpackages %in% mymro),]
		myoldpackages	<- myoldpackages[!(myoldpackages %in% mymro)]
		#
		# we don't want to remove base or recommended packages either:
		mydf2			<- allpgdf[!(allpgdf[,"Priority"] %in% c("base", "recommended")),]
		mybase			<- as.vector(mydf2$Package)
		pgdf			<- pgdf[!(myoldpackages %in% mybase),]
		myoldpackages	<- myoldpackages[!(myoldpackages %in% mybase)]
		}
	# determine the library where the packages are installed:
	if("pcadapt" %in% myoldpackages)
		{
		if(packageDescription("pcadapt")$Version!="4.1.0")
			{
			# 19-3-2020: this is necessary because later versions want you to use PLINK for conversion from ped to bed.
			cat("WARNING: The PCadapt version on your computer is not 4.1.0.",sep="\n")
			cat("SambaR needs PCadapt version 4.1.0. or lower.",sep="\n")
			}
		pgdf			<- pgdf[myoldpackages!="pcadapt",]
		myoldpackages	<- myoldpackages[myoldpackages!="pcadapt"]
		}
	oldpackagesdf	<<- pgdf[myoldpackages!="pcadapt",]
	myoldpackages	<<- myoldpackages
	# remove
	if(doremove)
		{
		# remove the packages
		cat("Removing outdated packages...",sep="\n")
		sapply(myoldpackages,remove.packages)
		cat("All outdated packages removed.",sep="\n")
		cat("Type 'oldpackagesdf' or 'myoldpackages' to see the list of names of these outdated packages.",sep="\n")
		cat("Now run the getpackages function to install the most recent version of the removed packages.",sep="\n")
		}else{
		cat("Type 'oldpackagesdf' or 'myoldpackages' to see the list of names of outdated packages.",sep="\n")	
		cat("These packages can lead to errors when running the getpackages() function.",sep="\n")
		cat("To remove these packages, execute:",sep="\n")
		cat("'removeoldpackages(doremove=TRUE)'",sep="\n")
		cat("Afterwards run the getpackages function to install the most recent version of the removed packages.",sep="\n")
		}
	}

sambar_getoldpackage<-function(my_package="pcadapt",my_repos='http://cran.us.r-project.org',my_lib=NULL,silent=FALSE)
	{	
	# 06-05-2020: works currently for pcadapt only
	mypackage_nr		<- which(myrpackages$package==my_package)
	if(my_package %in% rownames(installed.packages()))
		{
		if(packageDescription("pcadapt")$Version!="4.1.0")
			{
			# 19-3-2020: this is necessary because later versions want you to use PLINK for conversion from ped to bed.
			cat("The PCadapt version on your computer is not the required version 4.1.0.",sep="\n")
			cat("SambaR will remove this version and install PCadapt 4.1.0 instead.",sep="\n")
			if("pcadapt"%in%(.packages()) == TRUE){detach("package:pcadapt", unload=TRUE)}
			remove.packages("pcadapt")
			}else{
			if(!silent){cat(paste("Package ",my_package," already installed.",sep=""),sep="\n")}
			myrpackages$installed[mypackage_nr]		<<- TRUE
			if(my_package %in% (.packages()) == FALSE)
				{
				if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
				library(my_package,character.only=TRUE)
				myrpackages$loaded[mypackage_nr]		<<- TRUE
				}else{
				myrpackages$loaded[mypackage_nr]		<<- TRUE
				}
			}
		}
	if(my_package %in% rownames(installed.packages()) == FALSE)
		{
		if(is.null(my_lib))
			{
			if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=my_repos)}		
			library("devtools")
			cat("Installing the dependencies of package PCadapt 4.1.0 (which is the version required by SambaR). If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the dependencies of the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("plotly" %in% rownames(installed.packages()) == FALSE) {install.packages("plotly",repos=my_repos)}
			if("robust" %in% rownames(installed.packages()) == FALSE) {install.packages("robust",repos=my_repos)}
			#if("vcfR" %in% rownames(installed.packages()) == FALSE) {install.packages("vcfR",repos=my_repos)}
			if("vcfR" %in% rownames(installed.packages()) == FALSE)
				{
				cat("PCadapt depends on the package vcfR. Unfortunately this package is not available from CRAN anymore as of Spring 2020.",sep="\n")
				cat("Therefore, if you want to use PCadapt, you have to first download the vcfR tarball (on Unix computers) and then execute in R a function similar to:",sep="\n") 	
				cat('install.packages("path/to/vcfR_1.11.0.tar.gz",repos=NULL,type="source"',sep="\n")
				return(cat("Alternatively, edit the mypackageslist.txt file and set the value of PCadapt and vcfR to FALSE in the do_install column, and then run the getpackages() function again.",sep="\n"))
				}
			if("mmapcharr" %in% rownames(installed.packages()) == FALSE) {install.packages("mmapcharr",repos=my_repos)}
			if("RSpectra" %in% rownames(installed.packages()) == FALSE) {install.packages("RSpectra",repos=my_repos)}
			if("rmio" %in% rownames(installed.packages()) == FALSE) {install.packages("rmio",repos=my_repos)}
			cat("Installing the package PCadapt 4.1.0 (which is the version required by SambaR).. If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("pcadapt" %in% rownames(installed.packages()) == FALSE){install_version('pcadapt',version='4.1.0',repos=my_repos,dependencies=FALSE)}
			myrpackages$installed[mypackage_nr]	<<- TRUE
			if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
			library(my_package,character.only=TRUE)
			myrpackages$loaded[mypackage_nr]		<<- TRUE
			}else{
			if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=my_repos,lib=my_lib)}		
			library("devtools")
			cat("Installing the dependencies of package PCadapt 4.1.0 (which is the version required by SambaR).. If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the dependencies of the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("plotly" %in% rownames(installed.packages()) == FALSE) {install.packages("plotly",repos=my_repos,lib=my_lib)}
			if("robust" %in% rownames(installed.packages()) == FALSE) {install.packages("robust",repos=my_repos,lib=my_lib)}
			#if("vcfR" %in% rownames(installed.packages()) == FALSE) {install.packages("vcfR",repos=my_repos,lib=my_lib)}
			if("vcfR" %in% rownames(installed.packages()) == FALSE)
				{
				cat("PCadapt depends on the package vcfR. Unfortunately this package is not available from CRAN anymore as of Spring 2020.",sep="\n")
				cat("Therefore, if you want to use PCadapt, you have to first download the vcfR tarball (on Unix computers) and then execute in R a function similar to:",sep="\n") 	
				cat('install.packages("path/to/vcfR_1.11.0.tar.gz",repos=NULL,type="source"',sep="\n")
				return(cat("Alternatively, edit the mypackageslist.txt file and set the value of PCadapt and vcfR to FALSE in the do_install column, and then run the getpackages() function again.",sep="\n"))
				}
			if("mmapcharr" %in% rownames(installed.packages()) == FALSE) {install.packages("mmapcharr",repos=my_repos)}
			if("RSpectra" %in% rownames(installed.packages()) == FALSE) {install.packages("RSpectra",repos=my_repos)}
			if("rmio" %in% rownames(installed.packages()) == FALSE) {install.packages("rmio",repos=my_repos)}
			cat("Installing the package PCadapt 4.1.0 (which is the version required by SambaR). If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("pcadapt" %in% rownames(installed.packages()) == FALSE){install_version('pcadapt',version='4.1.0',repos=my_repos,lib=my_lib,dependencies=FALSE)}
			myrpackages$installed[mypackage_nr]	<<- TRUE
			if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
			library(my_package,character.only=TRUE)
			myrpackages$loaded[mypackage_nr]		<<- TRUE
			}
		}
	}

sambar_getpackage<-function(my_package="car",my_repos='http://cran.us.r-project.org',my_lib=NULL,github_dir=NULL,silent=FALSE,noupdates=TRUE,doload=TRUE)
	{
	# INSTALL:
	mypackage_nr		<- which(myrpackages$package==my_package)
	if(length(mypackage_nr)==0)
		{
		return(cat("ERROR: specified package is not present in SambaR's list of packages.",sep="\n"))
		}
	if(my_package %in% rownames(installed.packages()) == FALSE) 
		{
		# IF PACKAGE IS NOT YET INSTALLED
		# INSTALL:
		if(!silent){cat(paste("Installing package ",my_package,"...",sep=""),sep="\n")}
		package_source	<- as.vector(myrpackages$source[mypackage_nr])
		if(package_source!="CRAN"&package_source!="Bioconductor"&package_source!="github")
			{
			return(cat("ERROR: package source should be either 'CRAN', 'Bioconductor' or 'github'.",sep="\n")) 
			}
		if(package_source=="CRAN")
			{
			if(is.null(my_lib))
				{
				install_attempt		<- tryCatch(install.packages(my_package,repos=my_repos), error=function(e) e, warning=function(w) w)
				#install_attempt	<- install.packages(my_package,repos=my_repos)
				}else{
				install_attempt		<- tryCatch(install.packages(my_package,repos=my_repos,lib=my_lib), error=function(e) e, warning=function(w) w)
				#install_attempt	<- install.packages(my_package,repos=my_repos,lib=my_lib)
				}
			}
		if(package_source=="Bioconductor")
			{
			if(is.null(my_lib))
				{
				install_attempt		<- tryCatch(BiocManager::install(my_package,suppressUpdates=noupdates), error=function(e) e, warning=function(w) w)
				if(all(install_attempt%in%c("BiocVersion",my_package)))	# needed because BiocManager returns the package argument
					{
					install_attempt	<- NULL
					}
				#install_attempt	<- try(BiocManager::install(my_package,suppressUpdates=noupdates))
				}else{
				install_attempt 	<- tryCatch(BiocManager::install(my_package,suppressUpdates=noupdates,lib=my_lib), error=function(e) e, warning=function(w) w)
				if(all(install_attempt%in%c("BiocVersion",my_package)))	# needed because BiocManager returns the package argument
					{
					install_attempt	<- NULL
					}
				#install_attempt	<- try(BiocManager::install(my_package,suppressUpdates=noupdates,lib=my_lib))
				}
			}
		if(package_source=="github")
			{
			if(is.null(github_dir))
				{
				cat("ERROR: no github directory specified.",sep="\n")
				}
			install_attempt 	<- tryCatch(install_github(github_dir,upgrade=FALSE), error=function(e) e, warning=function(w) w)
			if(all(install_attempt%in%c(my_package)))	# needed because install_github returns the package argument
				{
				install_attempt	<- NULL
				}
			#install_attempt 	<- try(install_github(github_dir,upgrade=FALSE))
			}
		# LOAD:
		#if(class(install_attempt)=="try-error")
		if(!is.null(install_attempt))
			{
			install_problems							<<- install_attempt
			myrpackages$installed[mypackage_nr]			<<- FALSE
			myrpackages$loaded[mypackage_nr]			<<- FALSE
			cat(paste("SambaR did NOT manage to install the package ",my_package," and will therefore not attempt to load this package.",sep=""),sep="\n")
			cat("Type 'install_problems' to see which error or warning SambaR encountered.",sep="\n")
			cat("In case the warning reads that the package is not available, and if you are using an older R version, it could be that installing the latest R version will solve the problem.",sep="\n") 
			}else{
			cat("Package succesfully installed.",sep="\n")
			myrpackages$installed[mypackage_nr]			<<- TRUE
			if(doload)
				{
				if(my_package %in% (.packages()) == FALSE)
					{
					if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
					library(my_package,character.only=TRUE)					# character.only=FALSE gives: Error in library(my_package) : there is no package called 'my_package'
					myrpackages$loaded[mypackage_nr]		<<- TRUE	
					}else{
					cat("Package already loaded.",sep="\n")
					myrpackages$loaded[mypackage_nr]		<<- TRUE
					}
				}else{
				if(my_package %in% (.packages()) == FALSE)
					{
					cat("Not loading package because flag 'doload' is set to FALSE.",sep="\n")
					myrpackages$loaded[mypackage_nr]			<<- FALSE
					}else{
					cat("Flag doload is set to FALSE but package is already loaded anyway.",sep="\n")
					myrpackages$loaded[mypackage_nr]			<<- TRUE
					}
				}
			}
		}else{
		# IF PACKAGE IS ALREADY INSTALLED
		if(!silent){cat(paste("Package ",my_package," already installed.",sep=""),sep="\n")}
		myrpackages$installed[mypackage_nr]	<<- TRUE
		if(doload)
			{
			# LOAD:
			if(my_package %in% (.packages()) == FALSE)
				{
				if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
				load_attempt		<- tryCatch(library(my_package,character.only=TRUE), error=function(e) e)								# character.only=FALSE gives: Error in library(my_package) : there is no package called 'my_package'
				if(is.character(load_attempt))
					{
					load_attempt	<- NULL
					}
				# character.only=FALSE gives: Error in library(my_package) : there is no package called 'my_package'
				if(!is.null(load_attempt))
					{
					install_problems							<<- load_attempt
					myrpackages$loaded[mypackage_nr]			<<- FALSE
					cat(paste("SambaR did NOT manage to load the package ",my_package,".",sep=""),sep="\n")
					cat("Type 'install_problems' to see which error or warning SambaR encountered.",sep="\n")
					}else{
					myrpackages$loaded[mypackage_nr]			<<- TRUE	
					}
				}else{
				cat("Package already loaded.",sep="\n")
				myrpackages$loaded[mypackage_nr]			<<- TRUE
				}
			}else{
			if(my_package %in% (.packages()) == FALSE)
				{
				cat("Not loading package because flag 'doload' is set to FALSE.",sep="\n")
				myrpackages$loaded[mypackage_nr]			<<- FALSE
				}else{
				cat("Flag doload is set to FALSE but package is already loaded anyway.",sep="\n")
				myrpackages$loaded[mypackage_nr]			<<- TRUE
				}
			}
		}
	}

# depends on: sambar_getpackage and sambar_getoldpackage and getversions
getpackages<-function(myrepos='http://cran.us.r-project.org',mylib=NULL,noupdates=TRUE,silent=TRUE,do_halt=TRUE,onlybioconductor=FALSE)
	{
	if(getRversion()<'3.6.0')
		{
		if("car" %in% rownames(installed.packages()))
			{
			cat("WARNING: SambaR depends on the package 'car', which as of February 2020 can only be installed on R versions 3.6.0 or higher (due to the dependency 'pbkrtest').",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
			cat("However, you might still encounter errors because of other packages not being available for your R version.",sep="\n")
			cat("If so, install a newer R version (3.6.0 or newer) and try again.",sep="\n")
			}else{
			cat("ERROR: SambaR depends on the package 'car', which can only be installed on R versions 3.5.0 or higher.",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
			cat("Therefore, you need to install a newer version of R (3.6.0 or newer) and run SambaR on this newer version.",sep="\n")
			return(cat("Dependencies of SambaR have NOT been loaded.",sep="\n"))
			}
		}
	if(file.exists("mypackageslist.txt"))
		{
		cat("Importing file 'mypackageslist.txt' from the directory:",sep="\n")
		cat(getwd(),sep="\n")
		myrpackages	<<- read.table("mypackageslist.txt",header=TRUE)
		if(!"do_load"%in%colnames(myrpackages))
			{
			cat("ERROR: SambaR version 1.03 and higher require the 'mypackageslist.txt' to contain the column 'do_load'.",sep="\n") 
			cat("Either remove or manually edit the existing 'mypackageslist.txt' file.",sep="\n")
			return(cat("Instruction for manually editing: the do_load values for the essential packages 'cli','Rcpp','fs','rlang','usethis','vctrs','carl','curl','colorspace','vegan','sf' and 'spdep' can/should be set to FALSE.",sep="\n"))
			}
		# 28_10_2021:
		pcadaptversion	<- myrpackages$required_version[myrpackages$package=="pcadapt"]
		if(pcadaptversion!="latest")
			{
			cat("ERROR: from 28-10-2021 onwards, SambaR no longer requires (and therefore no longer accepts) PCadapt version 4.1.0.")
			return(cat("Please set in the column 'required_version' in the file 'mypackageslist.txt' the value for PCadapt to 'latest', or simply remove the entire file.",sep="\n"))  
			}
		}else{
		cat("File called 'mypackageslist.txt' not present in directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("SambaR will attempt to install and load all packages (but only if not installed/loaded yet).",sep="\n")
		# to recreate vectors, use: write.csv(matrix(as.character(myrpackages$package),nrow=1),row.names=FALSE)
		mypackagesvec	<- c("cli","Rcpp","fs","rlang","usethis","vctrs","car","curl","colorspace","ape","scales","vegan","sf","spdep","adegenet","StAMPP","scatterplot3d","plot3D","zoo","processx","devtools","vioplot","gplots","RColorBrewer","migest","plyr","circlize","grid","gridGraphics","gridExtra","MASS","poppr","FactoMineR","factoextra","rworldmap","mapplots","VennDiagram","fsthet","PopGenome","bibtex","mnormt","psych","sp","rworldmap","raster","phangorn","seqinr","RcppEigen","gtools","plotly","robust","vcfR","pcadapt","detectRUNS","BiocManager","SNPRelate","LEA","qvalue","gdsfmt","XML","karyoploteR","OutFLANK","tess3r","IRanges","Biostrings","HybridCheck","inbreedR","admixtools")
		# 28_10_2021:
		#versionvec		<- c("latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","4.1.0","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest")
		versionvec		<- c("latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest")
		sourcevec		<- c("CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","Bioconductor","Bioconductor","Bioconductor","Bioconductor","CRAN","Bioconductor","github","github","Bioconductor","Bioconductor","github","CRAN","github")
		githubdirvec	<- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,"whitlock/OutFLANK","bcm-uga/TESS3_encho_sen",NA,NA,"BenJWard/HybridCheck",NA,"uqrmaie1/admixtools")
		requiredvec		<- c("essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","to_be_removed","essential","essential","optional","optional","optional","optional","optional","optional","optional","recommended","recommended","recommended","optional","optional","optional","optional","optional","optional","optional","optional","optional","optional","optional","recommended","TBC","optional","TBC","optional","optional","optional","optional","recommended","recommended","recommended","recommended","optional","TBC","recommended","recommended","optional","optional","optional","optional","optional","optional","optional")
		whichfuncvec	<- c("all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","to_be_removed","all_functions","all_functions","additional_analysis","additional_analysis","additional_analysis","findstructure()","findstructure()","findstructure()","findstructure()","findstructure()","findstructure()","findstructure()","additional_analysis","additional_analysis","selectionanalyses()","selectionanalyses()","selectionanalyses()","importdata()","additional_analysis","additional_analysis","additional_analysis","additional_analysis","additional_analysis","findstructure()","TBC","additional_analysis","TBC","selectionanalyses()","selectionanalyses()","selectionanalyses()","selectionanalyses()","calcdiversity","importdata()","findstructure()","findstructure()","selectionanalyses()","TBC","calcdiversity();calcdistance()","calcdiversity();calcdistance()","selectionanalyses()","additional_analysis","calcdistance()","calcdistance()","calcdistance()","calcdistance()","calcdistance()")
		analysistypevec	<- c("data_management","data_management","data_management","data_management","data_management","data_management","data_management","data_management","data_management","plotting","data_management","data_management","data_management","data_management","data_management","data_management","data_management","plotting","plotting","sliding_window_analyses","install_packages","to_be_removed","plotting","plotting","circosplots_geneflow","circosplots_geneflow","circosplots_geneflow","DAPC_plots","DAPC_plots","DAPC_plots","MDS","Hamming_distance","CA","CA","geographical_maps","geographical_maps","Venn_diagrams","Venn_diagrams","Venn_diagrams","referencing","RDA","RDA","geographical_maps_TESS","geographical_maps_TESS","geographical_maps_TESS","NJtree_plot","TBC","geographical_maps_TESS","TBC","pcadapt","pcadapt","pcadapt","pcadapt","Runs_of_homozygosity","install_bioconductor_packages","PCA","admixture_analysis","qvalue_for_OutFLANK","TBC","karyoplots","karyoplots","OutFLANK","geographical_maps_TESS","HybridCheck","HybridCheck","HybridCheck","Heterozygosity_fitness_correlations","admixtools_statistics")
		#
		do_load			<- rep(TRUE,length(mypackagesvec))
		do_load[1:9]	<- FALSE
		do_load[12:14]	<- FALSE
		do_load[44]		<- FALSE
		#
		myrpackages		<<- data.frame("package"=mypackagesvec,"required_version"=versionvec,"number"=c(1:length(mypackagesvec)),"do_install"=TRUE,"do_load"=do_load,"installed"=NA,"loaded"=NA,"source"=sourcevec,"githubdir"=githubdirvec,"required"=requiredvec,"SambaR_function"=whichfuncvec,"analysis_type"=analysistypevec)
		write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
		cat("SambaR exported the newly created file 'mypackageslist.txt'. You can have a look at this file to see which packages SambaR will attempt to install. The file is exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(any(!(as.vector(unique(myrpackages$source))%in%c("CRAN","Bioconductor","github"))))
		{
		return(cat("ERROR: package source should be either 'CRAN', 'Bioconductor' or 'github'.",sep="\n")) 
		}
	if(!is.null(mylib))
		{
		if(!mylib %in% .libPaths())
			{
			cat("Adding specified library directory (mylib argument) to .libPaths.",sep="\n") 
			.libPaths( c( mylib , .libPaths() ) )
			# 18-06-2020: this doesn't solve the problem because if you don't have root access you can not connect with installed packages in the root, and that will cause problems in the end
			}else{
			cat("Specified library directory (mylib argument) already present in .libPaths. No need to add.",sep="\n")
			}
		}
	npackages			<- nrow(myrpackages)
	if(!silent){cat("Installing and loading packages (if needed)...",sep="\n")}
	if(onlybioconductor)
		{
		cat("Installing Bioconductor packages only...",sep="\n")
		}
	for (my_package_nr in c(1:npackages))
		{
		mypackage			<- as.vector(myrpackages$package[my_package_nr])
		if(!silent){cat(mypackage,sep="\n")}
		mysource			<- as.vector(myrpackages$source[my_package_nr])
		if(!silent){cat(mysource,sep="\n")}
		installbool			<- as.vector(myrpackages$do_install[my_package_nr])
		loadbool			<- as.vector(myrpackages$do_load[my_package_nr])
		mypackageversion	<- as.vector(myrpackages$required_version[my_package_nr])
		if(!onlybioconductor)
			{
			if(!installbool)
				{
				cat(paste("Skipping installation of ", mypackage," because it is set to FALSE in the column 'do_install' of the file 'mypackageslist.txt'.",sep=""),sep="\n")
				myrpackages$installed[my_package_nr]	<<- FALSE
				myrpackages$loaded[my_package_nr]		<<- FALSE
				myrpackages$loaded[my_package_nr]		<<- FALSE
				}else{
				if(mypackageversion=="latest")
					{
					if(mysource=="github")
						{
						mygithubdir	<- as.vector(myrpackages$githubdir[my_package_nr])
						sambar_getpackage(my_package=mypackage,github_dir=mygithubdir,my_lib=mylib,doload=loadbool) 
						}else{
						sambar_getpackage(my_package=mypackage,my_repos=myrepos,my_lib=mylib,doload=loadbool) 
						}
					}else{
					if(mypackage=="pcadapt")
						{
						# cat("Running sambar_getoldpackage.",sep="\n")
						# sambar_getoldpackage(my_package="pcadapt",my_repos='http://cran.us.r-project.org',my_lib=mylib)	
						return(cat("As of 28_10_2021, no longer needed to install old version of PCadapt (v4.1.0). In the column 'required_version' of mypackageslist.txt, set the value for PCadapt to 'latest'.",sep="\n"))  
						}else{
						cat("Unfortunately SambaR does not yet offer the option to install old versions of R package other than for pcadapt (4.1.0).",sep="\n")
						}
					}
				#if(do_halt&myrpackages$loaded[my_package_nr]==FALSE)
				if(do_halt&myrpackages$installed[my_package_nr]==FALSE)
					{
					cat("",sep="\n")
					write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
					cat(paste("ERROR: SambaR did NOT manage to install/load the package ",mypackage," and therefore also did not attempt to install/load remaining packages.",sep=""),sep="\n")
					cat("How to solve this problem?",sep="\n")
					if(mysource=="Bioconductor")
						{
						cat("The package which SambaR did not manage to install is a Bioconductor package.",sep="\n")
						cat("SambaR might interfere with the Bioconductor installation process. To solve this problem, follow the these instructions (also explained in the SambaR manual):",sep="\n")
						cat("Close your R session and start a new R session.",sep="\n")
						cat("Do not change the working directory, do not load SambaR, and do not attempt to run the getpackages function.",sep="\n")
						cat("Instead run the following two commands:",sep="\n")
						cat('if(!requireNamespace("BiocManager", quietly = TRUE)){install.packages("BiocManager")}',sep="\n")
						cat('BiocManager::install(c("gdsfmt","SNPRelate","LEA","qvalue","XML","karyoploteR", "IRanges","Biostrings"),update=FALSE)',sep="\n")
						cat("After succesfull completion, change the working directory, load SambaR, and rerun the getpackages function.",sep="\n")
						}else{
						cat(paste("SambaR exported a file called 'mypackageslist.txt' to the directory: ",getwd(),".",sep=""),sep="\n")
						cat("Observe this file in a plain text editor (e.g. in Notepad). The columns 'installed' and 'loaded' indicate which packages have not been installed and/or loaded yet.",sep="\n")
						cat("All packages which are marked as 'essential' in the column 'required' need to be installed (not necessarily loaded), otherwise SambaR will run into errors sooner or later.",sep="\n")
						cat("Other packages are not strictly needed. (If they are not installed (and loaded), SambaR will omit the analyses which depend on these packages.)",sep="\n")
						cat("To prevent SambaR from trying to install a certain package, change it's value in the 'do_install' column from TRUE to FALSE.",sep="\n") 
						cat("Save the editted file 'mypackageslist.txt' in the working directory and rerun the getpackages() function.",sep="\n")
						cat("Note that other packages might depend on this package, and in that case for those packages you will also have to set the 'do_install' value to FALSE.",sep="\n")  
						if(myrpackages$required[my_package_nr]=="essential")
							{
							cat(paste("However, the package ",mypackage," is essential and therefore this solution might lead to other errors sooner or later.",sep=""),sep="\n")
							}else{
							cat(paste("The package ",mypackage," is not essential and therefore this might indeed be a suitable workaround for now.",sep=""),sep="\n")
							}
						cat("",sep="\n")
						getversions()
						return(cat("",sep="\n"))
						}
					}
				}
			}else{
			# only install Bioconductor packages:
			if(mysource=="Bioconductor")
				{
				if(!installbool)
					{
					cat(paste("Skipping installation of ", mypackage," because it is set to FALSE in the column 'do_install' of the file 'mypackageslist.txt'.",sep=""),sep="\n")
					myrpackages$installed[my_package_nr]	<<- FALSE
					myrpackages$loaded[my_package_nr]		<<- FALSE
					myrpackages$loaded[my_package_nr]		<<- FALSE
					}else{
					sambar_getpackage(my_package=mypackage,my_repos=myrepos,my_lib=mylib,doload=loadbool) 
					}
				if(do_halt&myrpackages$installed[my_package_nr]==FALSE)
					{
					cat("",sep="\n")
					write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
					cat(paste("ERROR: SambaR did NOT manage to install/load the package ",mypackage," and therefore also did not attempt to install/load remaining packages.",sep=""),sep="\n")
					cat("How to solve this problem?",sep="\n")
					cat(paste("SambaR exported a file called 'mypackageslist.txt' to the directory: ",getwd(),".",sep=""),sep="\n")
					cat("Observe this file in a plain text editor (e.g. in Notepad). The columns 'installed' and 'loaded' indicate which packages have not been installed and/or loaded yet.",sep="\n")
					cat("All packages which are marked as 'essential' in the column 'required' need to be installed (not necessarily loaded), otherwise SambaR will run into errors sooner or later.",sep="\n")
					cat("Other packages are not strictly needed. (If they are not installed (and loaded), SambaR will omit the analyses which depend on these packages.)",sep="\n")
					cat("To prevent SambaR from trying to install a certain package, change it's value in the 'do_install' column from TRUE to FALSE.",sep="\n") 
					cat("Save the editted file 'mypackageslist.txt' in the working directory and rerun the getpackages() function.",sep="\n")
					cat("Note that other packages might depend on this package, and in that case for those packages you will also have to set the 'do_install' value to FALSE.",sep="\n")  
					if(myrpackages$required[my_package_nr]=="essential")
						{
						cat(paste("However, the package ",mypackage," is essential and therefore this solution might lead to other errors sooner or later.",sep=""),sep="\n")
						}else{
						cat(paste("The package ",mypackage," is not essential and therefore this might indeed be a suitable workaround for now.",sep=""),sep="\n")
						}
					cat("",sep="\n")
					getversions()
					return(cat("",sep="\n"))
					}
				}
			
			}
		}
	cat("DONE",sep="\n")
	cat("Reminder: if after this line you receive the error 'cannot open file 'mypackageslist.txt': Permission denied', the file 'mypackageslist.txt' is very likely open in a file viewer (like Excel).",sep="\n")  
	write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
	#mybool					<- myrpackages$loaded
	mybool					<- myrpackages$installed
	mybool[is.na(mybool)]	<- FALSE
	mybool					<- mybool[myrpackages$do_install]
	# create table which lists R versions:
	pgversions				<- getversions(return_object=TRUE)
	pcadaptversion			<- pgversions$version[pgversions$package=="pcadapt"]
	if(any(!mybool))
		{
		cat("",sep="\n")
		cat("WARNING: SambaR did NOT manage to install and load all requested packages. Do NOT attempt yet to import your data.",sep="\n")
		cat("How to solve this problem?",sep="\n")
		cat(paste("SambaR exported a file called 'mypackageslist.txt' to the directory: ",getwd(),".",sep=""),sep="\n")
		cat("Observe this file in Excel or by typing on the R command line: myrpackages. The columns 'installed' and 'loaded' indicate which packages have not been installed and/or loaded yet.",sep="\n")
		cat("All packages which are marked as 'essential' in the column 'required' need to be installed and loaded, otherwise SambaR will run into errors sooner or later.",sep="\n")
		cat("Other packages are not strictly needed.  (If they are not installed and loaded, SambaR will omit the analyses which depend on these packages.)",sep="\n")
		cat("To prevent SambaR from trying to install a certain package, change it's value in the 'do_install' column from TRUE to FALSE.",sep="\n") 
		cat("Save the editted file 'mypackageslist.txt' in the working directory and rerun the getpackages() function.",sep="\n")
		cat("",sep="\n")
		}else{
		cat("All requested packages succesfully installed (and optionally loaded) :-)",sep="\n")
		# 28_10_2021:
		if(pcadaptversion=="4.1.0")
			{
			cat("However, currently an old version of PCadapt (4.1.0) is installed. SambaR no longer requires and therefore no longer accepts this version.")
			cat("Please remove the PCadapt installation - using the command: removepackages('pcadapt') - and afterwards rerun the getpackages function. This will install the latest version of PCadapt.",sep="\n") 
			return(cat("Depending on your current version of Rcpp, the selectionanalyses might run into an error related to Rcpp. If so, remove Rcpp as well (and then reinstall with the getpackages function.",sep="\n"))
			}
		if(onlybioconductor)
			{
			cat("Rerun the getpackages function with the flag 'onlybioconductor' set to FALSE.",sep="\n")
			}else{
			cat("You can proceed with importing your data using the importdata() or genlight2sambar() function.",sep="\n")
			}
		}
	}	

# depreciated on 06-05-2020, replaced by get_packages:
getpackages_old<-function(myrepos='http://cran.us.r-project.org',noupdates=TRUE,do_github=TRUE,do_pcadapt=TRUE,do_vioplot=TRUE,silent=FALSE)
	{
	if(getRversion()<'3.6.0')
		{
		if("car" %in% rownames(installed.packages()))
			{
			cat("WARNING: SambaR depends on the package 'car', which as of February 2020 can only be installed on R versions 3.6.0 or higher (due to the dependency 'pbkrtest').",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
			cat("However, you might still encounter errors because of other packages not being available for your R version.",sep="\n")
			cat("If so, install a newer R version (3.6.0 or newer) and try again.",sep="\n")
			}else{
			cat("ERROR: SambaR depends on the package 'car', which can only be installed on R versions 3.5.0 or higher.",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
			cat("Therefore, you need to install a newer version of R (3.6.0 or newer) and run SambaR on this newer version.",sep="\n")
			return(cat("Dependencies of SambaR have NOT been loaded.",sep="\n"))
			}
		}
	# from CRAN:
	mysoftwares	<- c("adegenet","ape","bibtex","car","circlize","colorspace","curl","devtools","fs","gplots","grid","gridExtra","gridGraphics","MASS","migest","pcadapt","phangorn","plot3D","plyr","poppr","psych","RColorBrewer","Rcpp","scales","scatterplot3d","StAMPP","usethis","vegan","vioplot","zoo")  
	myvector	<- rep(NA,length(mysoftwares))
	for (i in c(1:length(mysoftwares)))
		{
		myvector[i]	<- !(mysoftwares[i] %in% rownames(installed.packages()))
		}
	if(!any(myvector))
		{
		cat("All required CRAN packages already installed.",sep="\n")
		}	
	if("Rcpp" %in% rownames(installed.packages()) == FALSE) {install.packages('Rcpp',repos=myrepos)}							# basic package
	if("fs" %in% rownames(installed.packages()) == FALSE) {install.packages('fs',repos=myrepos)}								# basic package
	if("usethis" %in% rownames(installed.packages()) == FALSE) {install.packages('usethis',repos=myrepos)}						# basic package
	if("car" %in% rownames(installed.packages()) == FALSE) {install.packages('car',repos=myrepos)}								# basic package
	if("curl" %in% rownames(installed.packages()) == FALSE) {install.packages('curl',repos=myrepos)}							# basic package
	if("colorspace" %in% rownames(installed.packages()) == FALSE) {install.packages("colorspace",repos=myrepos)}
	if("ape" %in% rownames(installed.packages()) == FALSE) {install.packages("ape",repos=myrepos)}								# to create PCoA plot, NJ-tree, among other functions
	if("scales" %in% rownames(installed.packages()) == FALSE) {install.packages("scales",repos=myrepos)}						# needed to install adegenet
	if("vegan" %in% rownames(installed.packages()) == FALSE) {install.packages("vegan",repos=myrepos,dep=TRUE)}					# needed to install adegenet
	if("sf" %in% rownames(installed.packages()) == FALSE) {install.packages('sf',repos=myrepos)}								# needed to install adegenet
	if("spdep" %in% rownames(installed.packages()) == FALSE) {install.packages('spdep',repos=myrepos)}							# needed to install adegenet
	if("adegenet" %in% rownames(installed.packages()) == FALSE) {install.packages("adegenet",repos=myrepos,dep=TRUE)}			# to save/manipulate data in genlight format
	if("StAMPP" %in% rownames(installed.packages()) == FALSE) {install.packages("StAMPP",repos=myrepos)}						# for AMOVA and Nei's D
	if("scatterplot3d" %in% rownames(installed.packages()) == FALSE) {install.packages("scatterplot3d",repos=myrepos,dep=TRUE)}	# to create DAPCplot
	if("plot3D" %in% rownames(installed.packages()) == FALSE) {install.packages("plot3D",repos=myrepos,dep=TRUE)}				# to create DAPCplot
	if("zoo" %in% rownames(installed.packages()) == FALSE) {install.packages("zoo",repos=myrepos)}								# to do sliding window analyses
	if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=myrepos)}					# to install OUTFLANK (selection analysis) and TESS3
	# 11-03-2011: Note: if you don't include installation of devtools (above line), you will run into the error:
	# 'WARNING: Rtools is required to build R packages, but is not currently installed.'
	# Please download and install Rtools custom from...
	# Error: failed to install..
	if("vioplot" %in% rownames(installed.packages()) == FALSE) {install.packages("vioplot",repos=myrepos)}						# to create violin plots	
	if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages("gplots",repos=myrepos)}						# to create heatmap
	if("RColorBrewer" %in% rownames(installed.packages()) == FALSE) {install.packages("RColorBrewer",repos=myrepos)}			# to create heatmap
	if("migest" %in% rownames(installed.packages()) == FALSE) {install.packages("migest",repos=myrepos)}						# to create circosplots
	if("plyr" %in% rownames(installed.packages()) == FALSE) {install.packages("plyr",repos=myrepos)}							# to create circosplots
	if("circlize" %in% rownames(installed.packages()) == FALSE) {install.packages("circlize",repos=myrepos)}					# to create circosplots	
	if("grid" %in% rownames(installed.packages()) == FALSE) {install.packages("grid",repos=myrepos)}							# to make multi-tile heatmaps (for dapc)
	if("gridGraphics" %in% rownames(installed.packages()) == FALSE) {install.packages("gridGraphics",repos=myrepos)}			# to make multi-tile heatmaps (for dapc)
	if("gridExtra" %in% rownames(installed.packages()) == FALSE) {install.packages("gridExtra",repos=myrepos)}					# to make multi-tile heatmaps (for dapc)
	if("MASS" %in% rownames(installed.packages()) == FALSE) {install.packages("MASS",repos=myrepos)}							# non-metric MDS (multi-dimensional scaling)
	if("poppr" %in% rownames(installed.packages()) == FALSE) {install.packages("poppr",repos=myrepos)}							# Hamming's genetic distance
	if("FactoMineR" %in% rownames(installed.packages()) == FALSE) {install.packages("FactoMineR",repos=myrepos)}				# correspondence analysis
	if("factoextra" %in% rownames(installed.packages()) == FALSE) {install.packages("factoextra",repos=myrepos)}				# correspondence analysis
	if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages('rworldmap',repos=myrepos)}					# geographical maps (getMap function) 
	if("mapplots" %in% rownames(installed.packages()) == FALSE) {install.packages('mapplots',repos=myrepos)}					# geographical maps (addpie function) 
	if("VennDiagram" %in% rownames(installed.packages()) == FALSE) {install.packages('VennDiagram',repos=myrepos)}				# venn diagram
	if("fsthet" %in% rownames(installed.packages()) == FALSE) {install.packages('fsthet',repos=myrepos)}						# selection analysis
	if("PopGenome" %in% rownames(installed.packages()) == FALSE) {install.packages('PopGenome',repos=myrepos)}					# selection analysis
	if("bibtex" %in% rownames(installed.packages()) == FALSE) {install.packages('bibtex',repos=myrepos)}						# selection analysis
	if("mnormt" %in% rownames(installed.packages()) == FALSE) {install.packages('mnormt',repos=myrepos)}						# needed for for psych (RDA analysis)
	if("psych" %in% rownames(installed.packages()) == FALSE) {install.packages('psych',repos=myrepos)}							# needed for RDA analysis
	if("sp" %in% rownames(installed.packages()) == FALSE) {install.packages("sp",repos=myrepos)}								# tess3r plots
	if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages("rworldmap",repos=myrepos)}					# tess3r plots
	if("raster" %in% rownames(installed.packages()) == FALSE) {install.packages("raster",repos=myrepos)}						# tess3r plots
	if("phangorn" %in% rownames(installed.packages()) == FALSE) {install.packages("phangorn",repos=myrepos)}					# tree plots
	if("seqinr" %in% rownames(installed.packages()) == FALSE) {install.packages("seqinr",repos=myrepos)}						# tree plots?
	if("RcppEigen" %in% rownames(installed.packages()) == FALSE) {install.packages("RcppEigen",repos=myrepos)}					# tess3r plots
	if("gtools" %in% rownames(installed.packages()) == FALSE) {install.packages("gtools",repos=myrepos)}						# for permutations, calcoverlap DAPC
	#if("pcadapt" %in% rownames(installed.packages()) == FALSE) {install.packages("pcadapt",repos=myrepos)}						# for selection analysis with pcadapt
	if(do_pcadapt)
		{
		if("pcadapt" %in% rownames(installed.packages()))
			{
			if(packageDescription("pcadapt")$Version!="4.1.0")
				{
				# 19-3-2020: this is necessary because later versions want you to use PLINK for conversion from ped to bed.
				cat("The PCadapt version on your computer is not the required version 4.1.0.",sep="\n")
				cat("SambaR will remove this version and install PCadapt 4.1.0 instead.",sep="\n")
				if("pcadapt"%in%(.packages()) == TRUE){detach("package:pcadapt", unload=TRUE)}
				remove.packages("pcadapt")
				}
			}
		if("pcadapt" %in% rownames(installed.packages()) == FALSE)
			{
			if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=myrepos)}		
			library("devtools")
			cat("Installing the dependencies of package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("plotly" %in% rownames(installed.packages()) == FALSE) {install.packages("plotly",repos=myrepos)}
			if("robust" %in% rownames(installed.packages()) == FALSE) {install.packages("robust",repos=myrepos)}
			if("vcfR" %in% rownames(installed.packages()) == FALSE) {install.packages("vcfR",repos=myrepos)}
			cat("Installing the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("pcadapt" %in% rownames(installed.packages()) == FALSE){install_version('pcadapt',version='4.1.0',repos='http://cran.us.r-project.org',dependencies=FALSE)}
			library(pcadapt)
			}
		}
	#if("Demerelate" %in% rownames(installed.packages()) == FALSE) {install.packages('Demerelate',repos=myrepos)}				# relatedness estimates (does not work for me coz does not give the matrix I want) 
	#if("synbreed" %in% rownames(installed.packages()) == FALSE) {install.packages('synbreed',repos=myrepos)}					# relatedness estimates (does not work for me coz cannot get package BGLR) 
	#if("GENESIS" %in% rownames(installed.packages()) == FALSE) {install.packages('GENESIS',repos=myrepos)}						# relatedness estimates
	#
	# from Bioconductor:
	myvector	<- rep(NA,4)
	mysoftwares	<- c("gdsfmt","karyoploteR","OutFLANK","LEA","SNPRelate","qvalue")
	for (i in c(1:length(mysoftwares)))
		{
		myvector[i]	<- !(mysoftwares[i] %in% rownames(installed.packages()))
		}
	if(any(myvector))
		{
		if(getRversion()>='3.5.0')									
			{
			if(!requireNamespace("BiocManager", quietly = TRUE))		{install.packages("BiocManager",repos=myrepos)}
			if("SNPRelate" %in% rownames(installed.packages()) == FALSE){BiocManager::install("SNPRelate",suppressUpdates=noupdates)}	# for PCA analysis SNPRelate
			if("LEA" %in% rownames(installed.packages()) == FALSE)		{BiocManager::install("LEA",suppressUpdates=noupdates)}			# for PCA analysis LEA as well as admixture analysis
			if("qvalue" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("qvalue",suppressUpdates=noupdates)}		# for selection analysis OUTFLANK  
			if("gdsfmt" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("gdsfmt",suppressUpdates=noupdates)}
			if("karyoploteR" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("karyoploteR",suppressUpdates=noupdates)}# for karyoplots
			#if("DNAcopy" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("DNAcopy",suppressUpdates=noupdates)}	# for Genesis
			#if("GENESIS" %in% rownames(installed.packages()) == FALSE) 	{BiocManager::install("GENESIS",suppressUpdates=noupdates)}	# for relatedness
			}else{
			source("http://bioconductor.org/biocLite.R")
			if("qvalue" %in% rownames(installed.packages()) == FALSE) 	{biocLite("qvalue",suppressUpdates=noupdates)}					# for selection analysis OUTFLANK  
			if("gdsfmt" %in% rownames(installed.packages()) == FALSE) 	{biocLite("gdsfmt",suppressUpdates=noupdates)}					# for PCA analysis SNPRelate
			if("SNPRelate" %in% rownames(installed.packages()) == FALSE){biocLite("SNPRelate",suppressUpdates=noupdates)}				# for PCA analysis SNPRelate
			if("LEA" %in% rownames(installed.packages()) == FALSE) 		{biocLite("LEA",suppressUpdates=noupdates)}												# for PCA analysis LEA as well as structure analysis
			#if("DNAcopy" %in% rownames(installed.packages()) == FALSE) {biocLite("DNAcopy")}											# for Genesis
			#if("GENESIS" %in% rownames(installed.packages()) == FALSE) {biocLite("GENESIS")}		# for relatedness (PCrelate function)
			}
		}else{
		cat("All required Bioconductor packages already installed.",sep="\n")
		}
	# from github:
	if(do_github)
		{
		if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=myrepos)}					# to install OUTFLANK (selection analysis) and TESS3
		library(devtools)
		mysoftwares	<- c("HybridCheck","OutFLANK","tess3r")
		for (i in c(1:length(mysoftwares)))
			{
			myvector[i]	<- !(mysoftwares[i] %in% rownames(installed.packages()))
			}
		if(any(myvector))
			{
			cat("Installing the packages 'OutFLANK' and 'tess3r' from github. If you receive an error after this line, rerun the getpackages function with the do_github flag set to FALSE (i.e.: getpackages(do_github=FALSE)).",sep="\n")  
			library(devtools)
			cat("If you receive an error after this line stating 'Error: could not find function 'install_github'', run the command 'install.packages('devtools',repos='http://cran.us.r-project.org')' and try again.",sep="\n") 
			if("OutFLANK" %in% rownames(installed.packages()) == FALSE) {install_github("whitlock/OutFLANK")}							# for selection analysis OUTFLANK 
			if("tess3r" %in% rownames(installed.packages()) == FALSE)  {install_github("bcm-uga/TESS3_encho_sen")}						# tess3r plots	
			if("HybridCheck" %in% rownames(installed.packages()) == FALSE) {devtools::install_github("BenJWard/HybridCheck", build_vignettes = FALSE,upgrade="never")}	# D-statistics
			#if("CubSFS" %in% rownames(installed.packages()) == FALSE) {install_github("blwaltoft/CubSFS")}								# this doesn't work, should be installed from source.
			}else{
			cat("All required github packages already installed.",sep="\n")
			}
		}
	# load libraries:
	if(!silent){cat("Loading fs...",sep="\n")}
	library(fs)
	if(!silent){cat("Loading usethis...",sep="\n")}
	library(usethis)
	if(!silent){cat("Loading car...",sep="\n")}
	library(car)
	if(!silent){cat("Loading curl...",sep="\n")}
	library(curl)
	if(!silent){cat("Loading colorspace...",sep="\n")}
	library(colorspace)
	if(!silent){cat("Loading ape...",sep="\n")}
	library(ape)
	if(!silent){cat("Loading scales...",sep="\n")}
	library(scales)
	if(!silent){cat("Loading adegenet...",sep="\n")}
	library(adegenet)
	if(!silent){cat("Loading StAMPP...",sep="\n")}
	library(StAMPP)
	if(!silent){cat("Loading parallel...",sep="\n")}
	library(parallel)
	if(!silent){cat("Loading scatterplot3d...",sep="\n")}
	library(scatterplot3d)																										# DAPC
	if(!silent){cat("Loading plot3D...",sep="\n")}
	library(plot3D)																												# DAPC
	if(!silent){cat("Loading zoo...",sep="\n")}
	library(zoo)
	if(!silent){cat("Loading devtools...",sep="\n")}
	library(devtools) 
	if(do_vioplot)
		{
		if(!silent){cat("Loading vioplot...",sep="\n")}
		library(vioplot)
		}else{
		if(!silent){cat("Skipping vioplot...",sep="\n")}
		}
	if(!silent){cat("Loading gplots...",sep="\n")}
	library(gplots)
	if(!silent){cat("Loading RColorBrewer...",sep="\n")}
	library(RColorBrewer)
	if(!silent){cat("Loading migest...",sep="\n")}
	library(migest)																												# circosplot
	if(!silent){cat("Loading plyr...",sep="\n")}
	library(plyr)																												# circosplot
	if(!silent){cat("Loading circlize...",sep="\n")}
	library(circlize)																											# circosplot
	if(!silent){cat("Loading SNPRelate...",sep="\n")}
	library(SNPRelate)
	if(!silent){cat("Loading LEA...",sep="\n")}
	library(LEA)	
	if(!silent){cat("Loading qvalue...",sep="\n")}
	library(qvalue)
	if(do_pcadapt)
		{
		if(!silent){cat("Loading pcadapt...",sep="\n")}
		library(pcadapt)
		}
	if(!silent){cat("Loading grid...",sep="\n")}
	library(grid)
	if(!silent){cat("Loading GridGraphics...",sep="\n")}
	library(gridGraphics)
	if(!silent){cat("Loading gridExtra...",sep="\n")}
	library(gridExtra)
	if(!silent){cat("Loading MASS...",sep="\n")}
	library(MASS)
	if(!silent){cat("Loading poppr...",sep="\n")}
	library(poppr)
	if(!silent){cat("Loading FactoMineR...",sep="\n")}
	library(FactoMineR)
	if(!silent){cat("Loading factoextra...",sep="\n")}
	library(factoextra)
	if(!silent){cat("Loading rworldmap...",sep="\n")}
	library(rworldmap)
	if(!silent){cat("Loading mapplots...",sep="\n")}
	library(mapplots)
	if(!silent){cat("Loading VennDiagram...",sep="\n")}
	library(VennDiagram)
	if(!silent){cat("Loading fsthet...",sep="\n")}
	library(fsthet)
	if(!silent){cat("Loading PopGenome...",sep="\n")}
	library(PopGenome)
	if(!silent){cat("Loading bibtex...",sep="\n")}
	library(bibtex)
	if(!silent){cat("Loading vegan...",sep="\n")}
	if("vegan"%in%(.packages()) == FALSE) {library(vegan)}
	if(!silent){cat("Loading psych...",sep="\n")}
	if("psych"%in%(.packages()) == FALSE) {library(psych)}	
	if(!silent){cat("Loading sp...",sep="\n")}
	library(sp)
	if(!silent){cat("Loading raster...",sep="\n")}
	library(raster)
	if(do_github)
		{
		if(!silent){cat("Loading OutFLANK...",sep="\n")}
		library(OutFLANK) 
		if(!silent){cat("Loading tess3r...",sep="\n")}
		library(tess3r)
		if(!silent){cat("Loading HybridCheck...",sep="\n")}
		if("HybridCheck" %in% (.packages()) == FALSE){library(HybridCheck)}
		}
	if(!silent){cat("Loading phangorn...",sep="\n")}
	library(phangorn)
	if(!silent){cat("Loading seqinr...",sep="\n")}
	library(seqinr)
	if(!silent){cat("Loading RcppEigen...",sep="\n")}
	library(RcppEigen)
	if(!silent){cat("Loading gtools...",sep="\n")}
	library(gtools)
	if(!silent){cat("Loading karyoploteR...",sep="\n")}
	library(karyoploteR)
	if(!silent){cat("Loading HybridCheck...",sep="\n")}
	#library(Demerelate)
	#library(synbreed)
	#library(DNAcopy)
	#library(GENESIS)
	cat("ALL PACKAGES SUCCESSFULLY LOADED.",sep="\n")
	getversions()
	if(!do_github)
		{
		cat("WARNING: Because you set the flag 'do_github' to FALSE, SambaR did NOT try to install the github R packages 'OutFLANK' and 'tess3r'.",sep="\n")
		cat("These packages are not strictly needed, but are optionally used for creating geographical structure maps and for selection analyses.",sep="\n")
		cat("To avoid errors when running the findstructure() function, set the do_tess flag to FALSE (i.e. findstructure(do_tess=FALSE)).",sep="\n")
		cat("To avoid errors when running the selectionanalyses() function, set the do_outflank flag to FALSE (i.e. selectionanalyses(do_outflank=FALSE)).",sep="\n")
		cat("Alternatively, you could try to install these packages yourself:",sep="\n")
		#cat("If so, first install and load the package devtools, in order to get the function 'install_github' to work. On a Windows computer you would do so by typing:",sep="\n")
		#cat("install.packages('devtools',repos='http://cran.us.r-project.org')",sep="\n")
		#cat("library(devtools)",sep="\n")
		#cat("And then afterwards run:",sep="\n")
		cat('install_github("whitlock/OutFLANK")',sep="\n") 
		cat('install_github("bcm-uga/TESS3_encho_sen")',sep="\n")
		}
	if(!do_pcadapt)
		{
		cat("WARNING: Because you set the flag 'do_pcadapt' to FALSE, SambaR did NOT try to install the R package 'pcadapt'.",sep="\n")
		cat("This package is not strictly needed, but is optionally used for selection analyses.",sep="\n")
		cat("To avoid errors when running the selectionanalyses() function, set the do_pcadapt flag to FALSE (i.e. selectionanalyses(do_pcadapt=FALSE)).",sep="\n")
		cat("Alternatively, you could try to install these package and it's dependencies yourself.",sep="\n")
		cat("Note that you need the version '4.1.0', which is not the latest version.",sep="\n")
		cat("This are the steps:",sep="\n")
		cat("install.packages('plotly',repos='http://cran.us.r-project.org')",sep="\n")
		cat("install.packages('robust',repos='http://cran.us.r-project.org')",sep="\n")
		cat("install.packages('vcfR',repos='http://cran.us.r-project.org')",sep="\n")
		cat('install_version("pcadapt",version="4.1.0",repos="http://cran.us.r-project.org",dependencies=FALSE)',sep='\n')
		}
	}

#information originally in SambaR manual:
#Trouble shooting
#Here is a list of potential solutions (in ascending order of effort):
#1.	Restart R and/
#2.	Restart the computer.
#3.	Use the install_version() function to install an older version of a particular package.
#If the getpackages() function throws the error ‘ERROR: package '…' is not available for R x.x.x,’ this package might have been recently updated. Either install the latest version of R (option 4), or try to download an older version of the particular package using the install_version function of the devtools package. For example, if you want to install version 0.9.1 of the ggplot2 package, run the command:
#install_version('ggplot2',version='0.9.1',repos='http://cran.us.r-project.org')
#Afterwards rerun the getpackages() and repeat the same procedure if a similar error appears for another package, until the getpackages() stops throwing errors. This approach might save time if you have a relatively recent version of R and there only a few packages causing problems. In other instances, option 4 is probably the better option.   
#4.	Reinstall a different version of R (and optionally remove the older version).
#This only takes a few minutes and provides the best chance the problem will be solved. Even if you have a recent version installed, installing another version of R (both older or newer) might solve the problem, because all packages will be newly installed. Note that you should not install an R version older than 3.6.



#################################################################










################## IMPORT DATA ###################


# import biallelic data from PLINK raw format:
importdata<-function(inputprefix=NULL,sumstatsfile=FALSE,snpinfofile=NULL,samplefile=NULL,vcfsamplefile=NULL,allow_edit=FALSE,geofile=NULL,depthfile=FALSE,poolsfile=NULL,nchroms=NULL,namechars=10,colourvector=NULL,popcol_by_alphabetical_order_popname=TRUE,popnchars=10,silent=TRUE,heplot=TRUE,qcplot=TRUE,do_citations=TRUE,dosoftwarecheck=FALSE,acceptalleles=FALSE,legend_cex=3,pop_order=NULL)
	{
	# poolsfile: Name of optional input file (default is NULL) with the names of the sequencing library pool names of the samples. 
	# Input file should contain two tab-separated columns called ‘sample’ and ‘pool’. Sample names in the poolsfile should be identical to sample names in PED-file. 
	# The information in the poolsfile will in a subsequent step be used to create plots with show data quality per library pool. 
	#
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	options(scipen=999)		# 08-04-2020: to prevent that scaffold 900000 is renamed 9e+05
	cat("Importing data from the directory:",sep="\n")
	cat(getwd(),sep="\n")
	if(!"adegenet"%in%(.packages()))
		{
		cat("ERROR: 'adegenet' package (and likely other required packages) has not been installed and/or loaded yet. Did you run the getpackages() function?",sep="\n")
		return(cat("Note that the getpackages() function needs to complete without errors before you can proceed to importing the data, because sooner or later you will run into errors.",sep="\n"))
		}
	if(dosoftwarecheck)
		{
		# other software not present:
		mysoftwares			<- c("ade4","adegenet","ape","bibtex","circlize","colorspace","curl","devtools","fsthet","gdsfmt","gplots","grid","gridExtra","gridGraphics","LEA","mapplots","MASS","migest","OutFLANK","pcadapt","pegas","plot3D","plyr","poppr","qvalue","RcppEigen","RColorBrewer","rworldmap","scales","scatterplot3d","SNPRelate","StAMPP","stats","tess3r","vegan","vioplot","zoo") 
		if("bibtex" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="bibtex"]
			cat("WARNING: non-essential R package bibtex not installed.",sep="\n")
			}
		if("OutFLANK" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="OutFLANK"]
			cat("WARNING: non-essential R package OutFLANK not installed.",sep="\n")
			}else{
			if(!"OutFLANK" %in% (.packages()))
				{
				cat("WARNING: non-essential R package OutFLANK installed but not loaded.",sep="\n")
				mysoftwares		<- mysoftwares[mysoftwares!="OutFLANK"]
				}
			}
		if("vioplot" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="vioplot"]
			cat("WARNING: non-essential R package vioplot not installed.",sep="\n")
			}else{
			if(!"vioplot" %in% (.packages()))
				{
				cat("WARNING: non-essential R package vioplot installed but not loaded.",sep="\n")
				mysoftwares		<- mysoftwares[mysoftwares!="vioplot"]
				}
			}
		if("pcadapt" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="pcadapt"]
			cat("WARNING: non-essential R package pcadapt not installed.",sep="\n")
			}
		if("tess3r" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="tess3r"]
			cat("WARNING: non-essential R package tess3r not installed.",sep="\n")
			}
		mybool	<- !(mysoftwares %in% (.packages()))
		mybool2	<- !(mysoftwares %in% rownames(installed.packages()))
		if(any(mybool))
			{
			if(any(mybool2))
				{
				cat("ERROR: some packages are not yet installed.",sep="\n")
				packages_notinstalled	<<- as.vector(mysoftwares[mybool2])
				packages_notloaded		<<- as.vector(mysoftwares[mybool]) 
				cat("To see the list of packages which still not to be installed, type: packages_notinstalled.",sep="\n")
				cat("To see the list of packages which still not to be loaded, type: packages_notloaded.",sep="\n")
				}else{
				cat("ERROR: all packages are installed, but one or more packages are not yet loaded.",sep="\n") 
				packages_notloaded		<<- as.vector(mysoftwares[mybool]) 
				cat("To see the list of packages which still not to be loaded, type: packages_notloaded.",sep="\n")
				}
			cat("First run or rerun the getpackages() function and make sure it finishes without errors (stating: 'ALL PACKAGES SUCCESSFULLY LOADED').",sep="\n")
			return(cat("Unfortunately the getpackages() function needs to complete without errors before you can proceed to importing the data, otherwise sooner or later you will run into errors.",sep="\n"))
			}
		}
	if(is.null(inputprefix))
		{
		return(cat("ERROR: provide the prefix of the input RAW file to the inputprefix flag.",sep="\n"))
		}
	if(!file.exists(paste(inputprefix,"raw",sep=".")))
		{
		cat(paste("ERROR: SambaR couldn't find a file called '",inputprefix,".raw' in the working directory.",sep=""),sep="\n")
		cat("Did you set the right working directory using the setwd() function?",sep="\n")
		cat("And did you run PLINK to convert PED/MAP to RAW/BIM files?",sep="\n") 
		return(cat("See manual for further details.",sep="\n"))
		}
	if(!file.exists(paste(inputprefix,"bim",sep=".")))
		{
		cat(paste("ERROR: SambaR couldn't find a file called '",inputprefix,".bim' in the working directory.",sep=""),sep="\n")
		cat("Did you set the right working directory using the setwd() function?",sep="\n")
		cat("And did you run PLINK to convert PED/MAP to RAW/BIM files?",sep="\n") 
		return(cat("See manual for further details.",sep="\n"))
		}
	if(sumstatsfile)
		{
		if(!file.exists("sumstats.tsv"))
			{
			cat("ERROR: SambaR couldn't find a file called 'sumstats.tsv' in the working directory.",sep="\n")
			return(cat("Either set the flag sumstatsfile to FALSE or make sure the file 'sumstats.tsv' is present (see manual for further details).",sep="\n"))
			}
		}
	if(!is.null(vcfsamplefile))
		{
		cat("ERROR: the 'vcfsamplefile' flag has been depreciated and replaced by the 'samplefile' flag.",sep="\n")
		return(cat(paste('So try again like this: importdata(samplefile="',vcfsamplefile,'")',sep=''),sep='\n'))
		}
	if(!is.null(samplefile))
		{
		if(!file.exists(samplefile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",samplefile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag samplefile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}else{
		cat("No samplefile provided. SambaR will infer population names from the PED-file.",sep="\n")
		}		
	if(!is.null(geofile))
		{
		if(!file.exists(geofile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",geofile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag geofile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(!is.null(poolsfile))
		{
		if(!file.exists(poolsfile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",poolsfile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag poolsfile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(depthfile)
		{
		inddepthfile	<- paste(inputprefix,"idepth",sep=".") 
		if(!(file.exists("out.idepth")|file.exists(inddepthfile)))
			{
			cat(paste("ERROR: SambaR couldn't find a file called 'out.idepth' or '",inddepthfile,"' in the working directory.",sep=""),sep="\n")
			return(cat("Either set the flag depthfile to FALSE or make sure the file 'out.idepth' is present. See manual for more details.",sep="\n"))
			}
		snpdepthfile	<- paste(inputprefix,"ldepth.mean",sep=".") 
		if(!(file.exists("out.ldepth.mean")|file.exists(snpdepthfile)))
			{
			cat(paste("ERROR: SambaR couldn't find a file called 'out.ldepth.mean' or '",snpdepthfile,"' in the working directory.",sep=""),sep="\n")
			return(cat("Either set the flag depthfile to FALSE or make sure the file 'out.ldepth.mean' is present. See manual for more details.",sep="\n"))
			}
		}
	#
	# define colours:
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours	
		}
	mysambarcolours		<- colourvector
	#
	# create genlight:
	# sambarfunction_importdata:
	##### IMPORT DATA #####
	# sambarfunction_importdata:
	mygenlight 			<<- read.PLINK((paste(inputprefix,"raw",sep=".",collapse = NULL)),parallel=FALSE)
	if(is.null(samplefile))
		{
		if(any(grepl("_",pop(mygenlight))))
			{
			if(allow_edit)
				{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
				mypops			<- as.character(pop(mygenlight))
				pop(mygenlight)	<<- gsub("_","",mypops)
				}else{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("To solve this issue, you can choose any of the following three options:",sep="\n")
				cat("Option 1: Edit population names in the PED-file, convert PED/MAP to raw/bim using PLINK, and afterwards rerun the importdata() function.",sep="\n")
				cat("Option 2: Create a sample file as explained in the manual (e.g. called 'popfile.txt') and afterwards run: importdata(samplefile='popfile.txt').",sep="\n")
				return(cat("Option 3: Allow SambaR to remove underscores from population names by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		if(any(nchar(as.character(pop(mygenlight)))>popnchars))
			{
			if(allow_edit)
				{
				cat("WARNING: Because of plot margins, by default SambaR does by default not accept population names which contain more than 10 characters (or any other value defined to popnchars flag).",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will truncate population names (if longer than 10 characters) and continue.",sep="\n")
				mypops		<- as.character(pop(mygenlight))
				mypops		<- ifelse(nchar(mypops)>popnchars,substr(mypops,1,popnchars),mypops)
				pop(mygenlight)	<<- mypops
				}else{
				cat("ERROR: Because of plot margins, by default SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("To solve this issue, you can choose any of the following four options:",sep="\n")
				cat("Option 1: Rerun the importdata function with another value for popnchars (which by default is set to 10). Some output plots might, as a result, not fully display the population name.",sep="\n")
				cat("Option 2: Edit population names in the PED-file, convert PED/MAP to raw/bim using PLINK, and afterwards rerun the importdata() function.",sep="\n")
				cat("Option 3: Create a sample file as explained in the manual (e.g. called 'popfile.txt') and afterwards run: importdata(samplefile='popfile.txt').",sep="\n")
				return(cat("Option 4: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		mynind	<- as.vector(table(as.character(pop(mygenlight))))
		#if(min(mynind)<2)
		#	{
		#	if(allow_edit)
		#		{
		#		cat("WARNING: SambaR does not accept populations consisting of 1 sample only.",sep="\n")
		#		cat("Because you set the flag allow_edit to TRUE, SambaR will assign all individuals to the same population (pop1).",sep="\n")
		#		pop(mygenlight)	<<- as.factor(rep("pop1",length(pop(mygenlight))))
		#		}else{
		#		return(cat("ERROR: SambaR does not accept populations consisting of 1 sample only.\nPlease either set to flag allow_edit to TRUE or alternatively edit population names (in either PED file or samplefile) and then rerun the importdata function. \nIf you make changes in the PED-file, do not forget to convert PED/MAP to raw/bim.",sep="\n"))
		#		}
		#	}
		}
	#
	# create snps dataframe:
	cat("Creating snps dataframe...",sep="\n")
	snps 				<<- read.table((paste(inputprefix,"bim",sep=".",collapse = NULL)))
	colnames(snps) 		<<- c("chr","name","morgan","pos","minor","major")
	snps$genlightname	<<- mygenlight@loc.names
	snps$nr				<<- c(1:nrow(snps))
	#snps$genlightname	<<- colnames(as.matrix(mygenlight))
	if(any(is.na(snps$chr)))
		{
		return(cat("ERROR: NA-value(s) present in snps$chr column. Please check the first column of the BIM-file and remove/replace NA-values. Afterwards rerun the importdata function.",sep="\n"))	
		}
	if(is.logical(snps$minor))
		{
		# addition 15-06-2021
		cat("WARNING: snps$minor (fifth column of input bim file) is imported as class 'logical' (TRUE or FALSE), likely because all values are set to 'T'. Resetting to 'T'.",sep="\n")
		snps$minor		<<- NULL
		snps$minor		<<- "T"
		}
	if(is.logical(snps$major))
		{
		# addition 15-06-2021
		cat("WARNING: snps$major (sixth column of input bim file) is imported as class 'logical' (TRUE or FALSE), likely because all values are set to 'T'. Resetting to 'T'.",sep="\n")
		snps$major		<<- NULL
		snps$major		<<- "T"
		}
	if(any(is.na(snps$genlightname)))
		{
		return(cat("ERROR: NA-values in second column of BIM-file.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(all(snps$name=="."))
		{
		cat("WARNING: all snp names (second column of MAP and BIM files are equal to '.'), which SambaR does not accept. Replacing with SNP1, SNP2, etc.",sep="\n")
		snps$name		<<- paste("SNP",c(1:nrow(snps)),sep="")
		}
	if(any(snps$name=="."))
		{
		return(cat("ERROR: one or more snp names (second column of MAP and BIM files are equal to '.'), which SambaR does not accept. Please edit and try again.",sep="\n"))
		}
	if(length(as.vector(unique(snps$chr)))==1)
		{
		cat("WARNING: Only 1 chromosome/contig specified.",sep="\n")
		}
	if(any(duplicated(snps$name)))
		{
		cat("WARNING: input bim/map file contains duplicated SNP names. Adding numbers to make them unique, in order to avoid errors downstream.",sep="\n")
		snps$name_old	<<- snps$name
		snps$name		<<- paste(snps$name,c(1:nrow(snps)),sep="_")
		}
	any(duplicated(mygenlight@loc.names))
		{
		cat("WARNING: input raw/ped file contains duplicated SNP names. Adding numbers to make them unique, in order to avoid errors downstream.",sep="\n")
		#
		snpnames			<- paste(mygenlight@loc.names,c(1:nrow(snps)),sep="_")
		indnames			<- mygenlight$ind.names
		popnames			<- pop(mygenlight)
		#
		mymatrix			<- as.matrix(mygenlight)
		colnames(mymatrix)	<- snpnames
		mygenlight			<<- as.genlight(mymatrix)
		#if(length(unique(as.vector(popnames)))!=nrow(mymatrix))
		#	{
			mygenlight@pop	<<- popnames
		#	}
		mygenlight@ind.names<<- indnames
		mygenlight@loc.names<<- snpnames
		snps$genlightname	<<- snpnames
		}
	# for brown bears:
	# snps$chr3			<<- as.numeric(as.character(gsub("HiC_scaffold_","",snps$chr)))
	# snps$chr2			<<- as.numeric(as.integer(snps$chr))	
	if(!silent){cat("Assigning index based on length of chromosomes...",sep="\n")}
	mychrs				<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
	mychrs2				<- mychrs[order(-mychrs$x),]
	mychrs2$chr2		<- c(1:nrow(mychrs2))
	colnames(mychrs2)	<- c("chr","chrlength","chr2")
	mychrs2$chrcol		<- ifelse(mychrs2$chr2%%2==0,"black","grey40")
	snps				<<- merge(snps,mychrs2,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(colnames(as.matrix(mygenlight))!=snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Counting number of SNPs per scaffold...",sep="\n")}
	myn					<- table(snps$chr)
	myndf				<- data.frame("chr"=names(myn),"nsnps"=as.vector(myn))
	snps				<<- merge(snps,myndf,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#
	# 11-03-2020: newer versions of STACKs add ":+" and ":-" to SNP names (forward/reverse). For some applications we need to get rid of those:
	# To make matters worse, snps which occur on chromosome 7 position 122, are encoded as 7:123. So plus 1. (This problem occurs for both :+ and :- SNPs). 
	if(length(grep("\\+",snps$name))>0)
		{
		cat("Removing ':+' and ':-' from SNP names...",sep="\n")
		snps$strand		<<- NA
		myforward		<- grep("\\+",snps$name)
		myreverse		<- grep("\\-",snps$name)
		snps$strand[myforward]	<<- "forward"
		snps$strand[myreverse]	<<- "reverse"
		snps$name3		<<- NA
		# forward:
		tempname		<- gsub("\\:\\+","",snps$name[myforward])
		tempname2		<- gsub("\\:","_",tempname)
		# now we need to subtract 1 from position:
		for(j in c(1:length(tempname2)))
			{
			mylocus		<- as.numeric(strsplit(tempname2[j],"_")[[1]][1])
			mypos		<- as.numeric(strsplit(tempname2[j],"_")[[1]][2])
			mypos		<- mypos-1
			tempname2[j]<- paste(mylocus,mypos,sep="_")
			}
		snps$name3[myforward]	<<-  tempname2
		# same for reverse:
		tempname		<- gsub("\\:\\-","",snps$name[myreverse])
		tempname2		<- gsub("\\:","_",tempname)
		# now we need to subtract 1 from position:
		for(j in c(1:length(tempname2)))
			{
			mylocus		<- as.numeric(strsplit(tempname2[j],"_")[[1]][1])
			mypos		<- as.numeric(strsplit(tempname2[j],"_")[[1]][2])
			mypos		<- mypos-1
			tempname2[j]<- paste(mylocus,mypos,sep="_")
			}
		snps$name3[myreverse]	<<-  tempname2
		}else{
		snps$strand		<<- "unknown"
		snps$name3		<<- snps$name
		}
	if(any(snps$minor=="0"))
		{
		monofilter	<- snps$minor=="0"
		nmono		<- length(monofilter[monofilter])
		nloci		<- nrow(snps)
		cat(paste("WARNING: ",nmono," non-polymorphic sites (out of ",nloci," sites) present in inputfile. SambaR will ignore them.",sep=""),sep="\n")
		monolist	<- snps$name[monofilter]
		write.table(monolist,"monomorphicsites.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
		cat("A file called 'monomorphicsites.txt' has been written to the working directory.",sep="\n")
		}
	if(!sumstatsfile&!any(snps$chr!=0))	# if no info in first column
		{
		if(any(snps$pos!=0))			# if info in the fourth column	
			{
			cat("ERROR: The input bim file has zero's only in the first column (contig) but non-zero's in the fourth column (position).",sep="\n")	
			cat("Either both columns should contain zero's (i.e. denovo snpcalling) or both columns should contain non-zero's (i.e. refmap snpcalling).",sep="\n")
			cat("As mentioned in the SambaR manual, if you convert from vcf to PED/MAP format, the first column of your map file will likely contain zero's only.",sep="\n") 
			cat("To solve that problem, you can execute the following command on the Linux command line (and afterwards convert again to raw/bim):",sep="\n")
			cat("cut -f2 yourfile.map | cut -f1 -d ':' > mycontigs.txt && cut -f2,3,4 yourfile.map > mymap.txt && paste mycontigs.txt mymap.txt > yourfile.map && rm mycontigs.txt mymap.txt",sep="\n")   
			cat("Alternatively, if the map file does have non-zero's in the the first column, then something went wrong during the conversion from ped/map to raw/bim (see SambaR manual).",sep="\n")
			cat("If so, try redoing the conversion (using PLINK, see Sambar manual), or edit the first and fourth column in the input bim file yourself (e.g. in Excel).",sep="\n")
			}else{
			cat("WARNING: No positional information found in first and fourth column of bim file (i.e. zero's only).",sep="\n")
			cat("If you generated your SNP data with a denovo pipeline, this is correct.",sep="\n")
			cat("If you generated your SNP data with a refmap pipeline, then why is this information lacking?",sep="\n")
			}
		}
	myposmax	<- max(snps$pos)
	if(!sumstatsfile&any(snps$chr!=0)&myposmax<500)
		{
		cat(paste("WARNING: According to information in map-file, the snps are positioned at maximum",myposmax,"bp.",sep=" "),sep="\n")
		cat("Hence, SambaR will assume that the information in the second column of your mapfile refers to read positions rather than contig/chromosome positions.",sep="\n")	
		}
	#	
	# addition 29-04-2021, to prevent error: 'encountered unexpected allele' which happens when snps$minor is a factor with 1,2,3,4 values 
	if(is.factor(snps$minor))
		{
		minorvec		<- as.character(snps$minor)
		if(any(c("A","C","T","G")%in%minorvec))
			{
			cat("Converting snps$minor factor to character vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- minorvec
			}else{
			cat("Converting snps$minor factor to integer vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- as.integer(minorvec)
			}
		}else{
		cat("snps$minor not factor class.",sep="\n")
		}
	if(is.factor(snps$major))
		{
		majorvec		<- as.character(snps$major)
		if(any(c("A","C","T","G")%in%majorvec))
			{
			cat("Converting snps$major factor to character vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- majorvec
			}else{
			cat("Converting snps$major factor to integer vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- as.integer(majorvec)
			}
		}else{
		cat("snps$major not factor class.",sep="\n")
		}
	#
	snps$minor[snps$minor==0]	<<- NA	# In case data is non-polymorphic
	myalleles	<- as.vector(unique(snps$minor))
	if(any(is.na(myalleles)))
		{
		cat("WARNING: non-defined allele (NA or 0) present in bim-file.",sep="\n")
		myalleles	<- myalleles[!is.na(myalleles)]
		}
	#
	if(is.integer(snps$minor)|is.numeric(snps$minor))
		{
		if(any(myalleles!=1&myalleles!=2&myalleles!=3&myalleles!=4))
			{
			myalleles	<<- myalleles
			return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 (integer) or A,C,T,G. You can observe the alleles by typing 'myalleles'.",sep="\n")) 
			}
		snps$minor2										<<- NA
		snps$minor2[snps$minor==1&!is.na(snps$minor)]	<<- "A"
		snps$minor2[snps$minor==2&!is.na(snps$minor)]	<<- "C"
		snps$minor2[snps$minor==3&!is.na(snps$minor)]	<<- "G"
		snps$minor2[snps$minor==4&!is.na(snps$minor)]	<<- "T"
		}else{
		if(is.character(snps$minor))
			{
			if(any(myalleles!="A"&myalleles!="C"&myalleles!="G"&myalleles!="T"))
				{
				myalleles	<<- myalleles
				return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 or A,C,T,G (character). You can observe the alleles by typing 'myalleles'.",sep="\n")) 
				}
			snps$minor2										<<- snps$minor
			snps$minor										<<- NA
			snps$minor[snps$minor2=="A"&!is.na(snps$minor2)]<<- 1
			snps$minor[snps$minor2=="C"&!is.na(snps$minor2)]<<- 2
			snps$minor[snps$minor2=="G"&!is.na(snps$minor2)]<<- 3
			snps$minor[snps$minor2=="T"&!is.na(snps$minor2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	#
	if(is.integer(snps$major)|is.numeric(snps$major))
		{
		snps$major2										<<- NA
		snps$major2[snps$major==1&!is.na(snps$major)]	<<- "A"
		snps$major2[snps$major==2&!is.na(snps$major)]	<<- "C"
		snps$major2[snps$major==3&!is.na(snps$major)]	<<- "G"
		snps$major2[snps$major==4&!is.na(snps$major)]	<<- "T"
		}else{		# if in bim-file data is encoded as A,C,G,T rather than 1,2,3,4.
		if(is.character(snps$major))
			{
			snps$major2										<<- snps$major
			snps$major										<<- NA
			snps$major[snps$major2=="A"&!is.na(snps$major2)]<<- 1
			snps$major[snps$major2=="C"&!is.na(snps$major2)]<<- 2
			snps$major[snps$major2=="G"&!is.na(snps$major2)]<<- 3
			snps$major[snps$major2=="T"&!is.na(snps$major2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	snps$minor2[snps$minor2=="0"]	<<- NA
	#
	# check if expected alleles (A, C, T, G) only:
	myalleles1			<- names(table(snps$minor2))
	myalleles1			<- myalleles1[myalleles1!="A"&myalleles1!="C"&myalleles1!="G"&myalleles1!="T"&myalleles1!="0"]
	myalleles2			<- names(table(snps$major2))
	myalleles2			<- myalleles2[myalleles2!="A"&myalleles2!="C"&myalleles2!="G"&myalleles2!="T"&myalleles2!="0"]
	myalleles			<- c(myalleles1,myalleles2)
	if(length(myalleles)>0)
		{
		myalleles		<- myalleles[!is.na(myalleles)]
		if(length(myalleles)>0)
			{
			myotheralleles	<<- myalleles
			if(!acceptalleles)
				{
				cat("ERROR: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("If you want to continu trying to import the data anyway, set the 'acceptalleles' flag to TRUE (i.e. importdata(acceptalleles=TRUE)).",sep="\n")
				return(cat("Note however that downstream this could lead to errors.",sep="\n"))
				}else{
				cat("WARNING: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("Because the flag 'acceptalleles' is set to TRUE, SambaR will continu to import the data. However, you might encounter errors downstream.",sep="\n")
				}
			}
		}
	snps$polyfilter			<<- ifelse(is.na(snps$minor),FALSE,TRUE)
	#
	# create inds dataframe:
	cat("Creating inds dataframe...",sep="\n")
	inds      			<<- as.data.frame(cbind(nr=1:nInd(mygenlight),name=indNames(mygenlight)))
	inds$pop			<<- pop(mygenlight)	# 06_02_2020: this line needs to be separate (i.e. do not include in the previous line), because pop(genlight) will otherwise be converted in 1,2,3
	inds$nr 			<<- 1:nrow(inds)
	inds$pop2			<<- inds$pop		# 24-04-2020: this column will remain the same as inds$pop, except when column pop2 (with subpopulations) are defined in samplefile (see below) 
	#	
	# in case there are duplicated sample names, we changes names to Ind1, Ind2, etc.
	if(length(unique(inds$name))<nrow(inds))
		{
		#cat("WARNING: duplicate sample names found. Sambar changes sample names to Ind1, Ind2, etc.",sep="\n")
		#inds$name				<<- paste("Ind",c(1:nrow(inds)),sep="")
		#indNames(mygenlight)	<<- inds$name
		cat("ERROR: duplicate sample names found in input data (PED file).",sep="\n")
		myduplicates			<<- as.vector(inds$name[duplicated(inds$name)])
		cat("A list of the duplicated sample name(s) is saved in the vector 'myduplicates'.",sep="\n")
		return(cat("Makes changes to filenames in the PED file (second column), convert to raw, and afterwards try running the importdata() function again.",sep="\n"))
		}
	# reorder inds dataframe:
	inds$sample_nr		<<- c(1:nrow(inds))				# this info is needed ro reorder data in mygenlight (in case not yet ordered by samplename)
	inds				<<- inds[order(inds$name),]
	# reorder mygenlight data (in case just not yet ordered by samplename):
	mymatrix			<- as.matrix(mygenlight)
	mymatrix			<- mymatrix[inds$sample_nr,]
	mygenlight			<<- as.genlight(mymatrix)
	pop(mygenlight)		<<- inds$pop
	inds$sample_nr		<<- NULL
	inds$nr				<<- NULL
	inds$nr				<<- c(1:nrow(inds))
	rownames(inds)		<<- inds$nr
	#
	# if sample file is provided population assignment is extracted from additional input file (samplefile):
	# This is necessary when the ped file is generated from vcf file (because vcf file does not contain pop info), but is also useful in general to quickly change population names and to insert hierarchial structure (inds$pop2) 
	if(!is.null(samplefile))
		{
		cat("Extracting information from sample file...",sep="\n")
		cat("If you receive an error stating 'Error in scan : line ... did not have ... elements', please double check if your samplefile does not contain white spaces (for example in the population names).",sep="\n")
		# 21-2-20: I originally called this vcfinput file and I decided not to change it.
		vcfinput		<- read.table(samplefile,header=TRUE)
		if(ncol(vcfinput)<2)
			{
			return(cat("ERROR: Sample file should contain at least two columns ('name' and 'pop').",sep="\n"))
			}
		if(!"name"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop'). Please edit the sample file and try again.",sep="\n"))
			}
		if(!"pop"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop'). Please edit the sample file and try again.",sep="\n"))
			}
		if(!"pop2"%in%colnames(vcfinput))
			{
			vcfinput$pop2	<- vcfinput$pop
			}
		# reorder vcf-file:
		vcfinput$name	<- as.character(vcfinput$name) 
		vcfinput		<- vcfinput[order(vcfinput$name),]
		# now extract information:
		if(nrow(vcfinput)<nrow(inds))
			{
			return(cat("ERROR: less samples in sample file than in PED/RAW file. Please edit the sample file.",sep="\n")) 
			}
		if(nrow(vcfinput)>nrow(inds))
			{
			cat("WARNING: more samples in sample file than in PED/RAW file. SambaR will select try to select samples occuring in PED/RAW file.",sep="\n")
			boolvec		<- as.character(vcfinput$name)%in%as.character(inds$name)
			if(!any(boolvec))
				{
				cat("ERROR: not a single sample name in sample file corresponds with sample name in PED/RAW file. Please edit the sample file.",sep="\n") 
				samplefilenames	<<- as.vector(vcfinput$name) 
				indsdatanames	<<- as.vector(inds$name)
				booldatanames	<<- as.vector(as.character(vcfinput$name))==as.vector(as.character(inds$name))
				cat("Sample names in sample file can be observed by typing: samplefilenames.",sep="\n")
				cat("Sample names in inds dataset can be observed by typing: indsdatanames.",sep="\n")
				return(cat("The similarity between both vectors can be observed by typing: booldatanames.",sep="\n"))
				}
			vcfinput	<- droplevels(vcfinput[boolvec,])
			}
		if(any(as.vector(as.character(vcfinput$name))!=as.vector(as.character(inds$name))))
			{
			cat("ERROR: Sample names in sample file do not correspond with names in inds dataset.",sep="\n")
			samplefilenames	<<- as.vector(vcfinput$name) 
			indsdatanames	<<- as.vector(inds$name)
			booldatanames	<<- as.vector(as.character(vcfinput$name))==as.vector(as.character(inds$name))
			cat("Sample names in sample file can be observed by typing: samplefilenames.",sep="\n")
			cat("Sample names in inds dataset can be observed by typing: indsdatanames.",sep="\n")
			return(cat("The similarity between both vectors can be observed by typing: booldatanames.",sep="\n"))
			}
		if(any(grepl("_",vcfinput$pop))|any(grepl("_",vcfinput$pop2)))
			{
			if(allow_edit)
				{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
				mypops			<- as.character(vcfinput$pop)
				vcfinput$pop	<- gsub("_","",mypops)
				mypops2			<- as.character(vcfinput$pop2)
				vcfinput$pop2	<- gsub("_","",mypops2)
				}else{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("To solve this issue, you can choose any of the following two options:",sep="\n")
				cat("Option 1: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 2: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		if(any(nchar(as.character(vcfinput$pop))>popnchars))
			{
			if(allow_edit)
				{
				cat("WARNING: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will truncate population names (if longer than 10 characters) and continue.",sep="\n")
				mypops		<- as.character(vcfinput$pop)
				vcfinput$pop<- ifelse(nchar(mypops)>popnchars,substr(mypops,1,popnchars),mypops)
				mypops2		<- as.character(vcfinput$pop2)
				vcfinput$pop2<- ifelse(nchar(mypops2)>popnchars,substr(mypops2,1,popnchars),mypops2)
				}else{
				cat("ERROR: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("To solve this issue, you can choose any of the following three options:",sep="\n")
				cat("Option 1: Rerun the importdata function with another value for popnchars (which by default is set to 10). Some output plots might, as a result, not fully display the population name.",sep="\n")
				cat("Option 2: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 3: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		mynind	<- as.vector(table(vcfinput$pop))
		#if(min(mynind)<2)
		#	{
		#	vcfinput2	<<- vcfinput 
		#	return(cat("ERROR: SambaR does not accept populations consisting of 1 sample only.\nPlease edit population names and try again. \nThis means: make changes in the samplefile, and afterwards rerun the importdata() function.",sep="\n"))
		#	}
		inds$pop		<<- vcfinput$pop
		inds$pop2		<<- vcfinput$pop2
		if("sex"%in%colnames(vcfinput))
			{
			inds$sex	<<- vcfinput$sex
			}	
		if("type"%in%colnames(vcfinput))
			{
			inds$type2	<<- vcfinput$type
			if(is.logical(inds$type2))
				{
				inds$type	<<- inds$type2
				}else{
				inds$type	<<- ifelse(inds$type2==as.vector(unique(inds$type2))[1],TRUE,FALSE)
				}
			if(length(as.vector(unique(inds$type2)))!=2)
				{
				cat("WARNING: number of classes defined in inds$type column does not equal 2.",sep="\n")
				}
			}
		if("longitude"%in%colnames(vcfinput))
			{
			#if(any(is.na(vcfinput$longitude)))
			#	{
			#	return(cat("ERROR: SambaR does not accept NA-values in longitude column of input samplefile.",sep="\n"))
			#	}
			inds$longitude	<<- as.numeric(gsub(",",".",as.character(vcfinput$longitude)))
			}
		if("latitude"%in%colnames(vcfinput))
			{
			#if(any(is.na(vcfinput$latitude)))
			#	{
			#	return(cat("ERROR: SambaR does not accept NA-values in latitude column of input samplefile.",sep="\n"))
			#	}
			inds$latitude	<<- as.numeric(gsub(",",".",as.character(vcfinput$latitude)))
			}
		if("plotname"%in%colnames(vcfinput))
			{
			inds$plotname	<<- vcfinput$plotname
			}
		if("mtDNA"%in%colnames(vcfinput))
			{
			inds$mtDNA	<<- vcfinput$mtDNA
			}
		if("mtsymbol"%in%colnames(vcfinput))
			{
			inds$mtsymbol	<<- vcfinput$mtsymbol
			}
		# assign population labels to genlight object:
		mygenlight@pop	<<- as.factor(inds$pop)
		}
	# in case number of populations equals number of samples, we set number of populations to 1:
	nuniqpop		<- length(unique(inds$pop))
	if(nuniqpop==nrow(inds))
		{
		cat("Warning: number of populations equals number of samples.",sep="\n") 
		cat(paste("Number of populations:",nuniqpop,sep=" "),sep="\n")
		cat(paste("Number of individuals:",nrow(inds),sep=" "),sep="\n")
		cat("Did you maybe switch the first two columns of the PED-file?",sep="\n")
		cat("Or did you generate the PED/MAP file from a vcf file and forget to provide the name of the sample file to the samplefile flag?",sep="\n")
		cat("Because Sambar does not accept that all samples belong to different populations, Sambar will assign all samples to 1 population.",sep="\n")
		inds$pop  		<<- "Pop1"
		pop(mygenlight)	<<- inds$pop
		inds$pop2		<<- inds$pop
		}
	# assign population colours:
	if(!silent){cat("Assigning population colours...",sep="\n")}
	populations			<- as.vector(unique(pop(mygenlight)))
	ncolours			<- length(mysambarcolours)
	npops				<- length(populations)
	if(ncolours<npops)
		{
		cat(paste("ERROR: Currently more populations (",npops,") defined than popcolours (",ncolours,").",sep=""),sep="\n")
		cat("Please provide a (longer) vector with colours to the colourvector argument (i.e.: 'importdata(colourvector=c('col1','col2','col3'))'",sep="\n")
		cat("The default colours of SambaR (if you don't specify anything) are:",sep="\n")
		cat(defaultcolours,sep=", ")
		sambarpopulations	<<- populations
		sambarpopcolours	<<- mysambarcolours
		cat(" ",sep="\n")
		cat(" ",sep="\n")
		cat("Currently defined population names are stored in the vector: 'sambarpopulations'.",sep="\n")
		cat("Currently defined colour names are stored in the vector 'sambarpopcolours'.",sep="\n")
		return(cat(" ",sep="\n"))
		}
	mydatapopcolours		<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		# assign colours in alphabetical order of population names (e.g.: Apop gets colour1, Bpop gets colour2, etc)
		cat("Assigning populations colours based on alphabetical order of population names.",sep="\n")
		populations			<- popNames(mygenlight)	 	# this is needed downstream to correctly assign colours at mysambar$mycolours
		inds$popcol			<<- mydatapopcolours[as.factor(inds$pop)]	
		}else{
		# assign colours in order of occurence of populations in datasets. (e.g. Apop, Apop, Cpop, Bpop, Bpop, Cpop would result in Cpop being assigned colour2)
		cat("Assigning populations colours based on order of occurrence of populations in ped-file.",sep="\n")
		populations			<- as.vector(unique(pop(mygenlight)))	
		inds$popcol			<<- NA
		for (i in (1:(length(populations))))
			{
			for (j in (1:nrow(inds)))
				{
				if (inds$pop[j]==populations[i])
					{
					inds$popcol[j] <<- mydatapopcolours[i]
					}
				}
			}
		}
	# assign plotting symbols:
	symbolvector		<- c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype		<<- symbolvector[as.factor(inds$pop)]
	inds$symboltype2	<<- symbolvector[as.factor(inds$pop)]
	if(any(as.vector(inds$pop)!=as.vector(inds$pop2)))
		{
		populations		<- as.vector(unique(inds$pop))
		populations		<- populations[order(populations)] 
		npops			<- length(populations)
		for(j in c(1:npops))
			{
			mypop		<- populations[j]
			subpops		<- as.vector(inds$pop2[inds$pop==mypop])
			inds$symboltype2[inds$pop==mypop]	<<- symbolvector[as.factor(subpops)]
			}
		}
	#
	# optionally add additional information to snps dataframe:
	if(sumstatsfile)
		{
		# positional information can be derived either from map file or from sumstats file.
		cat("Extracting information from STACKS sumstats file...",sep="\n")
		cat("If you receive an error after this line, you could opt to omit this step (i.e. importdata(sumstatsfile=FALSE)).",sep="\n")
		cat("Note that the population names defined in the sumstats file should not contain spaces, otherwise you might encounter the error stating: line ... did not have ... elements.",sep="\n")
		#chrom			<- read.table("sumstats.tsv",skip=(length(populations)+1),header=FALSE)
		chrom			<- read.table("sumstats.tsv",comment.char="#",header=FALSE)		# this way users can import sumstats file even if using a different number of populations then when running STACKS
		if(length(unique(chrom[,1]))==1)		# if old sumstats version which lists batch number in first column
			{
			chrom			<- chrom[,c(2:5)]
			}else{
			chrom			<- chrom[,c(1:4)]
			}
		colnames(chrom)	<- c("Stack_ID","Chromosome","ChromBasepair","StackBasepair")
		chrom$name3		<- paste(chrom$Stack_ID,chrom$StackBasepair,sep="_")
		chrom			<- unique(chrom)			# filter out redundant information (multiple lines per site, one for each population)
		chrom			<<- chrom
		if(nrow(chrom)!=nrow(snps))
			{
			cat("WARNING: Number of loci in sumstatsfile does not agree with number of loci in PED/MAP file.",sep="\n")
			cat(paste("Number of snps in PED/MAP file: ",nrow(snps),".",sep=""),sep="\n")
			cat(paste("Number of loci in sumstats file: ",nrow(chrom),".",sep=""),sep="\n")
			ignoredloci	<- chrom$name3[which(!chrom$name3%in%snps$name3)]
			chrom		<- chrom[which(chrom$name3%in%snps$name3),]
			cat("SambaR will ignore loci in the sumstatsfile which are not present in the PED/MAP file.",sep="\n")
			write.table(ignoredloci,"sumstatsfile.ignoredloci.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
			cat("The names of these loci are exported to a file called 'sumstatsfile.ignoredloci.txt'.",sep="\n")
			}
		snpstemp		<- snps[order(as.character(snps$name3)),]
		chrom			<- chrom[order(as.character(chrom$name3)),]
		chrom_ordered	<<- chrom
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snps$name3)])
		mygenlight		<<- as.genlight(mymatrix)	
		mygenlight@pop	<<- as.factor(inds$pop)
		snps			<<- snpstemp
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		if(any(chrom$name3!=snps$name3))
			{
			cat("ERROR: SNP names in snps dataframe do not correspond with SNP names in sumstats file.",sep="\n")
			return(cat("You can compare the columns snps$name3 and chrom_ordered$name3 to observe the differences.",sep="\n")) 
			}else{
			snps_test		<<- snps
			chrom_test		<<- chrom
			snps$chr		<<- chrom$Chromosome
			snps$pos		<<- chrom$ChromBasepair
			snps$stackID	<<- chrom$Stack_ID
			snps$stackbp	<<- chrom$StackBasepair
			snps_test2		<<- snps
			}
		snps$readpos	<<- as.numeric(sub(".*_","",snps$name3))			# Note: this function assumes that name of snp indicates position of SNP on stacks data. This is not always true.
		if(!silent){cat("End of sumstatsfile section.",sep="\n")}
		}else{
		snps$readpos	<<- NA
		}
	if(any(snps$pos!=0)&any(snps$pos>=500)&any(snps$chr!=0))	# 27-09-2020
	#if(any(snps$pos!=0)&any(snps$pos>=500))
		{
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		cat("Reordering data based on locations within the reference genome.",sep="\n")
		if(length(unique(snps$chr))==nrow(snps))
			{
			cat("WARNING: Number of chromosomes/contigs specified in map and bim file equals number of SNPs.",sep="\n")
			cat("Are these really contigs or in fact sequencing reads?",sep="\n")
			}
		if(length(unique(snps$chr))>0.4*nrow(snps))	# 0.4 is randomly chosen
			{
			cat("WARNING: High number of chromosomes/contigs specified in map and bim file.",sep="\n")
			cat("Are these really contigs or in fact sequencing reads?",sep="\n")
			}
		## REFMAP:
		snps$name2		<<- paste(snps$chr,snps$pos,sep="_")
		# Are snps located on chromosomes or on unplaced contigs?
		chr(mygenlight) <<- snps$chr
		if(!is.null(nchroms))
			{
			cat("Defining first n (as defined by nchroms) scaffolds as chromosomes, which will be used for plotting.",sep="\n")
			snps$placed		<<- snps$chr2<=nchroms
			snps$autosomal	<<- snps$chr2<=nchroms 
			snps$placedcol	<<- ifelse(snps$placed,"black","red")
			}else{
			snps$placed		<<- FALSE
			snps$autosomal	<<- FALSE 
			snps$placedcol	<<- "black"
			}
		#snps$placed	<<- !(grepl("\\.",snps$chr))	# This is assuming that the names of unplaced contigs contain a dot, wheras chromosomes do not
		#snps$autosomal	<<- (!(grepl("\\.",snps$chr)))&snps$chr!="X"
		### Reorder the snps to the order they occur in the genome:
		# First reorder the snps dataframe:
		snpstemp		<- snps
		snps			<<- snpstemp[order(snpstemp$chr,snpstemp$pos),]
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snpstemp$chr,snpstemp$pos)])
		mygenlight		<<- as.genlight(mymatrix)
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		### Spacing between snps:
		new_chr			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
		new_chr			<- c(TRUE,new_chr[1:(length(new_chr)-1)])
		snps$new_chr	<<- TRUE
		mydist			<- c(as.vector(snps$pos[2:length(snps$pos)]),NA)-snps$pos
		mydist			<- c(NA,mydist[1:(length(mydist)-1)])
		mydist[new_chr]	<- NA
		snps$dist		<<- as.numeric(mydist)
		snps$dist2		<<- !(is.na(snps$dist))
		# Are snps on same position? (STACKS sometimes outputs two snps which are in fact on same position within genome)
		snps$samepos	<<- (duplicated(snps$name2,fromLast=FALSE))|(duplicated(snps$name2,fromLast=TRUE))
		snps$uniqpos	<<- !(snps$samepos)
		}else{
		# output from DENOVO pipeline, or from PyRAD pipeline (which returns read pos rather than chromosome/contig pos):
		snps$placed		<<- FALSE
		snps$autosomal	<<- FALSE
		snps$placedcol	<<- "black"
		snps$new_chr	<<- NA
		snps$uniqpos	<<- TRUE
		snps$samepos	<<- FALSE
		snps$name2		<<- snps$name
		# reorder the snps dataframe:
		snpstemp		<- snps
		snps			<<- snpstemp[order(snpstemp$name),]		# if denovo, we order on name, rather than on position.
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snpstemp$name)])
		mygenlight		<<- as.genlight(mymatrix)
		}
	# optionally add additional information to snps and inds dataframe about read depth:
	if(depthfile)
		{
		cat("Extracting read depth information...",sep="\n")
		snps$chr		<<- tolower(as.character(snps$chr))
		#
		if(file.exists(inddepthfile))
			{
			depth1			<- read.table(inddepthfile,header=TRUE)
			}else{
		 	depth1			<- read.table("out.idepth",header=TRUE)
			}
		if("MEAN.DEPTH"%in%colnames(depth1))
			{
			if(!silent){cat("Changing period to underscore in out.idepth file.",sep="\n")} 
			depth1$MEAN_DEPTH	<- depth1$MEAN.DEPTH 
			depth1$MEAN.DEPTH	<- NULL
			depth1$N_SITES		<- depth1$N.SITES 
			depth1$N.SITES		<- NULL
			depth1				<<- depth1
			}
		if(any(!(c("INDV","N_SITES","MEAN_DEPTH")%in%colnames(depth1))))
			{
			return(cat("ERROR: One more expected column names ('INDV','N_SITES','MEAN_DEPTH') missing in out.idepth file. Edit the out.idepth file or set depthfile flag to FALSE.",sep="\n"))
			}
		#
		if(file.exists(snpdepthfile))
			{
			depth2		<- read.table(snpdepthfile,header=TRUE)
			}else{
			depth2		<- read.table("out.ldepth.mean",header=TRUE)
			}
		if("MEAN.DEPTH"%in%colnames(depth2))
			{
			if(!silent){cat("Changing period to underscore in out.ldepth.mean file.",sep="\n")} 
			depth2$MEAN_DEPTH	<- depth2$MEAN.DEPTH 
			depth2$MEAN.DEPTH	<- NULL
			depth2$VAR_DEPTH	<- depth2$VAR.DEPTH 
			depth2$VAR.DEPTH	<- NULL
			depth2				<<- depth2
			}
		if(any(!(c("CHROM","POS","MEAN_DEPTH","VAR_DEPTH")%in%colnames(depth2))))
			{
			return(cat("ERROR: One or more expected column names ('CHROM','POS','MEAN_DEPTH' and 'VAR_DEPTH') missing in out.ldepth.mean file. Edit the out.ldepth.mean file or set depthfile flag to FALSE.",sep="\n"))
			}
		depth1$INDV		<- as.character(depth1$INDV)
		depth1			<- depth1[order(depth1$INDV),]
		depth2			<- depth2[order(as.factor(depth2$CHROM),as.numeric(depth2$POS)),]
		if((nrow(inds)!=nrow(depth1))|(any(as.character(inds$name)!=as.character(depth1$INDV))))
			{
			cat("ERROR: Some individuals listed in PED file are not listed in out.idepth file.",sep="\n")
			cat("Sample names need to be identical (including upper/lower case).",sep="\n")
			depthsamplenames	<<- as.character(depth1$INDV)
			indsamplenames		<<- as.character(inds$name)
			cat("You can observe sample names by typing 'depthsamplenames' and 'indsamplenames'.",sep="\n")
			return(cat("Make sure that sample names correspond or set depthfile to FALSE.",sep="\n"))
			}
		if(any(!is.finite(depth1$MEAN_DEPTH)))
			{
			return(cat("ERROR: Infinite values in out.idepth file. Edit the out.idepth file or set depthfile flag to FALSE.",sep="\n"))
			}
		if(any(!is.finite(depth2$MEAN_DEPTH)))
			{
			return(cat("ERROR: Infinite values in out.ldepth.mean file. Edit the out.ldepth.mean file or set depthfile flag to FALSE.",sep="\n"))
			}
		inds$meandepth	<<- depth1$MEAN_DEPTH
		if(nrow(snps)==nrow(depth2))
			{
			if(!silent){cat("nsnps == nrow(depth2)",sep="\n")}
			snps$meandepth	<<- depth2$MEAN_DEPTH
			if(!silent){cat("Added depth info.",sep="\n")}
			}else{
			cat(paste("WARNING: The number of snps in out.ldepth.mean file (",nrow(depth2),") is not the same as number of snps in ped file (",nrow(snps),").",sep=""),"\n")
			cat("This can arise from glitches in the SNP calling pipeline or file conversion.",sep="\n")
			cat("SambaR will ignore sites in out.ldepth.mean file which are not present in ped file.",sep="\n")
			snps$chr_pos	<<- paste(snps$chr,snps$pos,sep="_")
			snpstemp		<- snps[snps$uniqpos,]
			snpsdup			<- snps[snps$samepos,]
			nsnpsdup		<- length(unique(snpsdup$chr_pos))
			if(nsnpsdup>0)
				{
				snpsdup$MEAN_DEPTH 	<- NA
				snpsdup$VAR_DEPTH 	<- NA	
				snpsdup$dup			<- TRUE
				cat(paste("Found",nsnpsdup,"duplicated snp(s) in snps dataset. Marked as TRUE in snps$samepos column.",sep=" "),sep="\n")
				}
			depth2$CHROM	<- tolower(as.character(depth2$CHROM))
			depth2$POS		<- as.character(depth2$POS)
			depth2$chr_pos	<- paste(depth2$CHROM,depth2$POS,sep="_")
			temp			<- depth2[order(depth2$chr_pos),]
			temp$dup		<- (duplicated(temp$chr_pos,fromLast=FALSE))|(duplicated(temp$chr_pos,fromLast=TRUE))
			ndup			<- length(unique(temp$chr_pos[temp$dup]))
			if(ndup>0)
				{
				cat(paste("Found",ndup,"duplicated snp(s) in out.ldepth.mean file. SambaR will ignore this/these site(s).",sep=" "),sep="\n")
				}
			depth2			<- temp[order(as.factor(temp$CHROM),as.numeric(temp$POS)),]
			depth2temp		<- depth2[!depth2$dup,]
			combitemp		<- merge(x=snpstemp, y=depth2temp, by="chr_pos", all=TRUE)
			combitemp2		<- combitemp[!is.na(combitemp$chr),]
			combitemp2$CHROM<- NULL
			combitemp2$POS	<- NULL
			if(nsnpsdup>0)
				{
				combitemp3		<- rbind(combitemp2,snpsdup)
				}else{
				combitemp3		<- combitemp2
				}
			snps			<<- combitemp3[order(combitemp3$chr,combitemp3$pos),]
			colnames(snps)[which(colnames(snps)=="MEAN_DEPTH")]	<<- "meandepth" 
			}
		if(!silent){cat("Adding depth info.",sep="\n")}
		temp			<- snps$meandepth[snps$meandepth<quantile(snps$meandepth,0.995,na.rm=TRUE)]
		mythreshold		<- qnorm((1-0.05/length(snps$meandepth)), mean = mean(temp,na.rm=TRUE), sd = sd(temp,na.rm=TRUE), lower.tail = TRUE, log.p = FALSE)
		snps$depthfilter<<- snps$meandepth<mythreshold
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		if(!silent){cat("Added depth filter.",sep="\n")}
		}else{
		snps$depthfilter<<- TRUE
		}
	if(!is.null(snpinfofile))
		{
		addsnpinfo()
		}
	# optionally add longitude and latitude information to inds dataframe:
	if(!is.null(geofile))
		{
		if(!file.exists(geofile))
			{
			cat(paste("ERROR: could not find file:",geofile,sep=" ",sep="\n"))
			return(cat("Check the name of the file and whether you stored it in the right directory.",sep="\n"))
			}
		cat("Adding geographical coordinates to inds dataframe...",sep="\n")
		mygeo			<- read.table(geofile,header=TRUE)
		if(any(!(c("sample","longitude","latitude")%in%colnames(mygeo))))
			{
			return(cat("ERROR: geofile should contain columns named 'sample', 'longitude' and 'latitude'.",sep="\n"))
			}
		mygeo			<- mygeo[order(as.character(mygeo$sample)),]
		if(any(!as.vector(as.character(mygeo$sample))==as.vector(as.character(inds$name))))
			{
			cat("WARNING: Sample names in geofile do not correspond with names in inds dataset. SambaR will not add geographical coordinates.",sep="\n")
			mygeo			<<- mygeo
			cat("To view the sample names in geofile, type: 'mygeo$sample'.",sep="\n")
			cat("To view the sample names in inds dataset, type: 'inds$name'.",sep="\n")
			}else{
			inds$longitude	<<- mygeo$longitude
			inds$latitude	<<- mygeo$latitude
			if(class(inds$longitude)=="factor")
				{
				cat("WARNING: Longitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
				inds$longitude	<<- as.numeric(sub(",",".",as.character(inds$longitude)))
				
				}
			if(class(inds$latitude)=="factor")
				{	
				cat("WARNING: Latitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
				inds$latitude	<<- as.numeric(sub(",",".",as.character(inds$latitude)))
				}
			}
		}
	if("longitude"%in%colnames(inds))
		{
		# pacific or atlantic centred map?
		inds$longitude2	<<- ifelse(inds$longitude>=0,inds$longitude,abs(inds$longitude)+180)
		inds$longitude3	<<- ifelse(inds$longitude>=-15,inds$longitude,180+(180-abs(inds$longitude)))
		}
	if(length(unique(inds$pop))>length(unique(inds$pop2)))
		{
		cat("WARNING: inds$pop contains more unique population names than inds$pop2 column. SambaR expects it to be the other way around.",sep="\n") 
		}
	# optionally add pool information to inds dataframe:
	if(!is.null(poolsfile))
		{
		if(!silent){cat("Adding pool information.",sep="\n")}
		mypools	<- read.table(poolsfile,header=TRUE)
		mypools	<- mypools[order(mypools$sample),]
		if(any(!mypools$sample==inds$name))
			{
			cat("WARNING: Sample names in poolsinfo file do not correspond with names in inds dataset. SambaR will not add pool info.",sep="\n")
			}else{
			inds$pool	<<- mypools$pool
			}
		}
	# short names for individuals:
	inds$name2			<<- NA
	if(grepl(".",as.vector(inds$name[1])))
		{
		for (i in c(1:nrow(inds)))
			{
			inds$name2[i]	<<- strsplit(as.vector(inds$name[i]), "[.]")[[1]][1]
			}
		}else{
		inds$name2			<<- substr(inds$name,start=1,stop=namechars)
		}
	#
	# short names for populations:
	mypops				<- as.vector(inds$pop)
	myshort1			<- ifelse(nchar(mypops)>2,substr(mypops,1,2),mypops)
	myshort2			<- ifelse(nchar(mypops)>3,substr(mypops,1,3),mypops)
	if(length(unique(myshort1))<length(unique(myshort2)))
		{
		inds$shortpop	<<- myshort2
		}else{
		inds$shortpop	<<- myshort1
		}
	# short names for subpopulations:
	mypops				<- as.vector(inds$pop2)
	myshort1			<- ifelse(nchar(mypops)>2,substr(mypops,1,2),mypops)
	myshort2			<- ifelse(nchar(mypops)>3,substr(mypops,1,3),mypops)
	if(length(unique(myshort1))<length(unique(myshort2)))
		{
		inds$shortpop2	<<- myshort2
		}else{
		inds$shortpop2	<<- myshort1
		}
	#
	if(sumstatsfile)
		{
		if(!silent){cat("Marking SNPs which are derived from same sequencing read...",sep="\n")}
		# 18042019: For some reason the output is incorrect if I include this line in sumstatsfile section.
		# Is snps on same stack (sequencing read) as previous snp?
		snps$sameread	<<- (duplicated(snps$stackID,fromLast=FALSE))
		}
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- populations
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	if(popcol_by_alphabetical_order_popname)
		{
		mysambar[[17]]	<<- mydatapopcolours[order(populations)]
		}else{
		mysambar[[17]]	<<- mydatapopcolours
		}
	mysambar[[18]]			<<- geomapsdir
	names(mysambar)			<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$populations2	<<- mysambar$populations	# needed for excludepop()
	mysambar$mycolours2		<<- mysambar$mycolours		# needed for excludepop()
	mysambar$defaultcolours	<<- defaultcolours
	mysambar$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambar$datasource		<<- "imported_from_ped"
	#
	# check:
	checkpopcolours()
	if(mysambar$colourerror){return(cat(" ",sep="\n"))}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: row names of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#
	if(!is.null(pop_order))
		{
		if(any(!as.character(inds$pop)%in%as.character(pop_order)))
			{
			return(cat("ERROR: not all populations specified at inds$pop present in pop_order vector.",sep="\n"))
			}
		if(any(!as.character(pop_order)%in%as.character(inds$pop)))
			{
			return(cat("ERROR: not all populations specified in pop_order vector present in inds$pop column.",sep="\n"))
			}
		}
	reorderpop(poporder=pop_order)
	#
	# cat("Removing snps which are on the same position...")
	posfilter		<- snps$samepos
	if(any(posfilter))
		{
		removedloci		<- snps[posfilter,c("name","chr","pos","readpos")]		# this loci will give problems down the line when merging datasets.
		write.table(removedloci,"removedloci.txt",row.names=FALSE,col.names=TRUE,quote=FALSE)	
		snps			<<- snps[!posfilter,]
		mymatrix		<- as.matrix(mygenlight)
		mymatrix		<- mymatrix[,!posfilter]
		mygenlight		<<- as.genlight(mymatrix)
		cat(paste("Removed",nrow(removedloci),"snps which share the same position in the genome. The names of these loci are listed in a file called removedloci.txt.",sep=" "),sep="\n")
		}
	#
	# assignment of neworder number has to be after removal of SNPs, otherwise it will lead to errors downstream
	snps$nr_neworder 			<<- 1:nrow(snps)
	# export information for individuals:
	setwd(mysambar$sambardir)
	cat("Exporting sample information...",sep="\n")
	indstable	<- inds[,c("name","nr","pop","pop2","popcol")]
	write.table(indstable,"SambaR_samples.txt",row.names=FALSE,sep="\t",quote=FALSE)
	#
	if(do_citations)
		{
		cat("Exporting citations of the R packages...",sep="\n")
		cat("If you receive an error after this line, rerun the importdata function with the do_citations flag set to FALSE (i.e.: importdata(do_citations=FALSE)).",sep="\n")  
		getcitations()
		}else{
		cat("Omitting BibTex library because do_citations FLAG is set to FALSE.",sep="\n")
		}
	#
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	if(qcplot)
		{	
		cat("Creating data_quality plot...",sep="\n")
		cat("If you receive an error after this line, rerun the importdata()-function with the flag 'qcplot' set to FALSE. I.e.: importdata(qcplot=FALSE).",sep="\n")
		calcretainedsnps(export="pdf",logy=TRUE)
		calcretainedsnps(export="pdf",logy=FALSE)
		}
	if(heplot)
		{
		cat("Creating He_vs_miss plot...",sep="\n")
		cat("If you receive an error after this line, type 'dev.off()' and rerun the importdata()-function with the flag 'heplot' set to FALSE. I.e.: importdata(heplot=FALSE).",sep="\n")
		indhetero_allsnps()
		#myminsites	<- ifelse(0.01*nrow(snps)<200,200,0.01*nrow(snps))
		He_vs_miss(export="pdf",allsites=TRUE,minsites=200,legendcex=legend_cex)
		#cat("Not included in the plot are samples with less than 250 non-missing data points.",sep="\n")
		}
	cat("DATA SUCCESSFULLY IMPORTED.",sep="\n")
	cat("The data is stored in 'mygenlight'. For an overview, type on the command line: 'mygenlight'.",sep="\n") 
	cat("You can observe a subset of the data by typing: as.matrix(mygenlight[1:10,1:10]).",sep="\n")
	cat("SNP information is and will be stored in an object called 'snps'. You can observe the first ten lines by typing: head(snps,10). Or, if working on a Windows computer, type: fix(snps).",sep="\n")
	cat("Sample information is and will be stored in an object called 'inds'. You can observe the first ten lines by typing: head(inds,10). Or, if working on a Windows computer, type: fix(inds).",sep="\n")
	cat("Sample information (including population colours and sample numbers) is also exported to a file called 'SambaR_samples.txt', which you can find in your SambaR directory.",sep="\n")
	cat("Reruns of the importdata() function will be much quicker than the first run, and the same is true for the filterdata() function.",sep="\n")
	cat("Therefore there is no need to save the workspace image when exiting R.",sep="\n")
	cat("ROUGH GUIDELINES BEFORE RUNNING THE FILTERDATA() FUNCTION:",sep="\n")
	cat("Before running the filterdata() function, observe the figures 'Data_quality' and/or 'He_vs_miss_ind.allsites.pop' to determine an appropriate value for the indmiss and snpmiss arguments.",sep="\n")
	cat("If you are mainly interested in structure analyses, set snpmiss to 0 (or if needed a bit higher, but preferably not higher than 0.05) and indmiss to the highest value which returns at least a few thousands SNPs scattered across the entire genome (see black line in 'Data_quality.log_yaxis').",sep="\n")
	cat("The reason is that variation in missingness among samples will affect the outcome of structure analyses. A few thousand SNPs from across the entire genome are generally sufficient to detect population structure (although this obviously depends on your study system).",sep="\n")
	cat("For other purposes (e.g. genetic diversity and selection analyses (especially the latter), you are probably better off by setting a more strict threshold for indmiss (default is 0.25) and more relaxed threshold for snpmiss (default is 0.1).",sep="\n")
	cat("If you are mainly interested in comparing genetic diversity among your study populations, observe the 'He_vs_miss_ind.allsites.pop'.",sep="\n")
	cat("Set indmiss to the highest value (which might be as low as 0.05) such that for retained individuals there is no relation between heterozygosity and their proportions of missing data.",sep="\n")
	options(scipen=0)	# 08-04-2020: reset scientific notation (because disabled at start of function)
	}

getpopninds<-function(popnames=mysambar$populations)
	{
	popninds	<- vector()
	npops		<- length(popnames)
	for(j in c(1:npops))
		{
		mypop		<- popnames[j]
		cat(mypop,sep="\n")
		indfilter	<- (inds$pop==mypop)&inds$filter
		ninds		<- length(indfilter[indfilter])
		popninds[j]	<- ninds 
		}
	names(popninds)	<- popnames
	mysambar$popninds	<<- popninds
	}

checkpopcolours<-function(popnames=mysambar$populations2,silent=TRUE)
	{
	if(is.null(mysambar$colourerror))
		{
		mysambar$colourerror	<<- FALSE
		}
	if(any(is.na(inds$popcol)))
		{
		mysambar$colourerror	<<- TRUE
		return(cat("ERROR: NA-values present in inds$popcol column.",sep="\n")) 
		}
	for(k in c(1:length(popnames)))
		{
		mypop			<- popnames[k]
		if(!silent){cat(mypop,sep="\n")}
		indsdfpopcols	<- inds$popcol[inds$pop==mypop]
		indsdfpopcol	<- as.vector(unique(indsdfpopcols))
		if(!silent){cat(paste("Colour defined in inds dataframe: ",indsdfpopcol,".",sep=""),sep="\n")}
		if(!silent){cat(paste("Object type: ",class(indsdfpopcol),".",sep=""),sep="\n")}
		if(length(indsdfpopcol)!=1)
			{
			mysambar$colourerror	<<- TRUE
			return(cat(paste("ERROR: in inds dataframe more than 1 colour defined for population ",mypop,". Contact the developer of SambaR.",sep=""),sep="\n")) 
			}
		sambarpopcol	<- mysambar$mycolours2[k]
		if(!silent){cat(paste("Colour defined in mysambar$mycolours2: ",sambarpopcol,".",sep=""),sep="\n")}
		if(!silent){cat(paste("Object type: ",class(sambarpopcol),".",sep=""),sep="\n")}
		if(indsdfpopcol!=sambarpopcol)
			{
			mysambar$colourerror	<<- TRUE
			return(cat(paste("ERROR: colours defined in inds dataframe for population ",mypop," do not correspond with colours defined in mysambar list. Contact the developer of SambaR.",sep=""),sep="\n")) 
			}
		}
	cat("All colours defined in mysambar$mycolours2 correspond with colours defined in inds$popcol column.",sep="\n") 
	}

reorderpop<-function(poporder=NULL)
	{
	cat("Assigning population order to be used in output plots.",sep="\n")
	if(is.null(poporder))
		{
		cat("No population order defined. Populations will be sorted alphabetically.",sep="\n") 
		poporder			<- mysambar$populations2
		}else{
		cat("Ordering populations based on user defined input (poporder or pop_order flag).",sep="\n")
		}
	if(length(mysambar$populations)<length(mysambar$populations2))
		{
		cat("WARNING: resetting population filter using excludepop() command.",sep="\n")
		excludepop()
		}
	if(length(poporder)!=length(mysambar$populations2))
		{
		return(cat(paste("ERROR: length of input vector to poporder (or pop_order) flag, does not correspond with the number of populations in data. Type 'mysambar$populations2' to see which populations are expected.",sep=""),sep="\n")) 
		}
	if(any(!mysambar$populations2%in%poporder))
		{
		missingpop			<<- mysambar$populations2[!mysambar$populations2%in%poporder]
		return(cat(paste("ERROR: one or more populations present in data are not listed in the input vector to the poporder (or pop_order) flag. Type 'missingpop' to see which populations are missing.",sep=""),sep="\n")) 
		}
	if(any(!poporder%in%mysambar$populations2))
		{
		missingpop			<<- poporder[!poporder%in%mysambar$populations2]
		return(cat(paste("ERROR: one or more populations listed in the input vector to the poporder (or pop_order) flag are not present in the data. Type 'missingpop' to see which populations are missing.",sep=""),sep="\n")) 
		}
	inds$poporder			<<- factor(inds$pop,levels=poporder)
	mysambar$poporder		<<- poporder
	mysambar$poporder2		<<- poporder
	mycolorder				<- vector()
	myordernr				<- vector()
	for(i in c(1:length(poporder)))
		{
		mypop				<- as.character(poporder[i])
		mypopnr				<- which(as.character(mysambar$populations2)==mypop)
		if(length(mypopnr)==0)
			{
			return(cat(paste("ERROR: Population name ",mypop," not present in actual data.",sep=""),sep="\n"))
			}
		mycolorder[i]		<- mysambar$mycolours2[mypopnr]
		myordernr[i]		<- mypopnr
		}
	mysambar$colorder		<<- mycolorder
	mysambar$colorder2		<<- mycolorder
	#
	# population order in numbers (relative to alphabetical order):
	mysambar$popordernr		<<- myordernr
	mysambar$popordernr2	<<- myordernr
	cat("Finished reordering. Type mysambar$poporder2 to observe the new population order.",sep="\n")
	}

editchr2<-function(silent=FALSE,countsnps=FALSE,nchroms=NULL)
	{
	snps$chrlength		<<- NULL 
	snps$chr2			<<- NULL 
	snps$chrcol			<<- NULL
	snps$nsnps			<<- NULL
	#	
	if(!silent){cat("Assigning index based on length of chromosomes...",sep="\n")}
	mychrs				<- aggregate(snps$pos,by=list(as.character(snps$chr)),FUN=max)
	mychrs2				<- mychrs[order(-mychrs$x),]
	mychrs2$chr2		<- c(1:nrow(mychrs2))
	colnames(mychrs2)	<- c("chr","chrlength","chr2")
	mychrs2$chrcol		<- ifelse(mychrs2$chr2%%2==0,"black","grey40")
	snps				<<- merge(snps,mychrs2,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(as.character(colnames(as.matrix(mygenlight)))!=as.character(snps$genlightname)))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#	
	if(!is.null(nchroms))
		{
		cat("Defining first n (as defined by nchroms) scaffolds as chromosomes, which will be used for plotting.",sep="\n")
		snps$placed		<<- snps$chr2<=nchroms
		snps$autosomal	<<- snps$chr2<=nchroms 
		snps$placedcol	<<- ifelse(snps$placed,"black","red")
		}else{
		snps$placed		<<- FALSE
		snps$autosomal	<<- FALSE 
		snps$placedcol	<<- "black"
		}
	#	
	if(countsnps)
		{
		if(!silent){cat("Counting number of SNPs per scaffold...",sep="\n")}
		myn					<- table(as.character(snps$chr))
		myndf				<- data.frame("chr"=names(myn),"nsnps"=as.vector(myn))
		snps				<<- merge(snps,myndf,by="chr",all=TRUE)
		snps				<<- snps[order(snps$nr),]
		if(any(!colnames(as.character(as.matrix(mygenlight)))==as.character(snps$genlightname)))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		}
	snps$placed		<<- TRUE
	snps$autosomal	<<- ifelse(snps$chr=="X",FALSE,TRUE)
	}

indsscatter<-function(export=NULL,addlegend=TRUE,legendcex=2.5,plottitle=NULL,plotname="Indscatter",xscore="snp_he",yscore="hetero_all",labelscore=NULL,xlabel="Genome-wide He (%)",ylabel="TE He",legendpos="topleft",yline=5.5,symbolsize=3.5,logx=FALSE,logy=FALSE,labelcex=1,corrpos=NULL,corrcex=1.75)
	{
	ind				<- droplevels(inds[inds$filter,])
	mypops			<- as.character(mysambar$populations)
	mycolours		<- as.character(mysambar$mycolours)
	#
	if(!xscore%in%colnames(inds))
		{
		return(cat("ERROR: xscore not present in ind dataframe.",sep="\n"))
		}
	if(!yscore%in%colnames(inds))
		{
		return(cat("ERROR: yscore not present in ind dataframe.",sep="\n"))
		}
	if(!is.null(labelscore))
		{
		if(!labelscore%in%colnames(inds))
			{
			return(cat("ERROR: labelscore not present in ind dataframe.",sep="\n"))
			}
		inputlabels	<- inds[,labelscore]
		}
	inputdf			<- inds[,c(xscore,yscore)]
	mydf			<<- inputdf
	colnames(inputdf)<- c("xscore","yscore")
	#
	xmax			<- max(inputdf$xscore)
	xmin			<- min(inputdf$xscore)
	ymax			<- max(inputdf$yscore)
	ymin			<- min(inputdf$yscore)
	if(!is.null(export))
		{
		plotname	<- ifelse(!is.null(labelscore),paste(plotname,"indnames",sep="_"),plotname)
		legendlabel	<- ifelse(addlegend,"withlegend","NOlegend")
		if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,8.5,2.5,0.5),cex.axis=2.5,cex.lab=3,cex.main=3)
	mylog	<- ifelse(logx,ifelse(logy,"xy","x"),ifelse(logy,"y",""))
	if(is.null(labelscore))
		{
		plot(inputdf$xscore,inputdf$yscore,pch=16,log=mylog,col=as.character(ind$popcol),xlim=c(xmin,xmax),ylim=c(ymin,ymax),cex=symbolsize,xlab=xlabel,ylab="",las=1)
		}else{
		plot(inputdf$xscore,inputdf$yscore,pch=16,log=mylog,col="white",xlim=c(xmin,xmax),ylim=c(ymin,ymax),cex=3,xlab=xlabel,ylab="",las=1)
		text(inputdf$xscore,inputdf$yscore,inputlabels,col=as.character(ind$popcol),cex=labelcex)
		}
	mtext(side=2,line=yline,ylabel,cex=3)
	if(!is.null(corrpos))
		{
		mycorr1		<- round(cor(inputdf$xscore,inputdf$yscore,method="pearson"),2)
		mycorr2		<- round(cor(inputdf$xscore,inputdf$yscore,method="spearman"),2)
		legend(corrpos,legend=c(paste("Pearson r: ",mycorr1,sep=""),paste("Spearman r: ",mycorr2,sep="")),bty='n',fill=NA,border=NA,cex=corrcex)
		}
	if(addlegend)
		{
		legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,cex=2.5,line=0.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

poppairscatter<-function(export=NULL,addlegend=TRUE,legendcex=2.5,plottitle=NULL,plotname="Poppair_scatter",xscore=mysambar$popneivector,yscore=mysambar$WC1983fstvector,xlabel="Nei's genetic distance (D)",ylabel="Weir & Cockerham 1983 Fst",legendpos="bottomright",yline=5.5,symbolsize=3.5,logx=FALSE,logy=FALSE,labelcex=1,corrpos=NULL,corrcex=1.75,alignaxes=FALSE)
	{
	pop1		<- mysambar$poppair1
	pop2		<- mysambar$poppair2
	if(is.null(mysambar$pairpopcol1))
		{
		cat("Generating mysambar$pairpop1 and mysambar$pairpop2.",sep="\n")
		popnames				<- mysambar$populations
		popcols					<- mysambar$mycolours
		npops					<- length(popnames)
		nsnps					<- nrow(snps)
		combitable				<- combn(popnames,m=2)
		mysambar$pairpop1		<<- combitable[1,]
		mysambar$pairpop2		<<- combitable[2,]
		mysambar$pairpopcol1	<<- vector()
		mysambar$pairpopcol2	<<- vector()
		for(k in c(1:ncol(combitable)))
			{
			mysambar$pairpopcol1[k]	<<- popcols[which(popnames==mysambar$pairpop1[k])]
			mysambar$pairpopcol2[k]	<<- popcols[which(popnames==mysambar$pairpop2[k])]
			}
		}
	popcol1		<- mysambar$pairpopcol1
	popcol2		<- mysambar$pairpopcol2
	if(is.null(xscore))
		{
		return(cat("ERROR: xscore not present.",sep="\n"))
		}
	if(is.null(yscore))
		{
		return(cat("ERROR: yscore not present.",sep="\n"))
		}
	inputdf			<- data.frame("xscore"=xscore,"yscore"=yscore)
	colnames(inputdf)<- c("xscore","yscore")
	#
	xmax			<- max(inputdf$xscore)
	xmin			<- min(inputdf$xscore)
	ymax			<- max(inputdf$yscore)
	ymin			<- min(inputdf$yscore)
	if(!is.null(export))
		{
		legendlabel	<- ifelse(addlegend,"withlegend","NOlegend")
		alignlabel	<- ifelse(alignaxes,"aligned","NOTaligned")
		if(export=="eps"){postscript(paste(plotname,alignlabel,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,alignlabel,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,alignlabel,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,alignlabel,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,8.5,2.5,0.5),cex.axis=2.5,cex.lab=3,cex.main=3)
	mylog	<- ifelse(logx,ifelse(logy,"xy","x"),ifelse(logy,"y",""))
	if(alignaxes)
		{
		axismin	<- min(c(inputdf$xscore,inputdf$yscore))
		axismax	<- max(c(inputdf$xscore,inputdf$yscore))
		plot(inputdf$xscore,inputdf$yscore,pch=21,lwd=5,log=mylog,col=as.character(popcol1),bg=as.character(popcol2),xlim=c(axismin,axismax),ylim=c(axismin,axismax),cex=symbolsize,xlab=xlabel,ylab="",las=1)
		lines(c(0,1),c(0,1),lty=2)
		}else{
		plot(inputdf$xscore,inputdf$yscore,pch=21,lwd=5,log=mylog,col=as.character(popcol1),bg=as.character(popcol2),xlim=c(xmin,xmax),ylim=c(ymin,ymax),cex=symbolsize,xlab=xlabel,ylab="",las=1)
		}
	mtext(side=2,line=yline,ylabel,cex=3)
	if(addlegend)
		{
		legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)
		}
	if(!is.null(corrpos))
		{
		mycorr1		<- round(cor(inputdf$xscore,inputdf$yscore,method="pearson"),2)
		mycorr2		<- round(cor(inputdf$xscore,inputdf$yscore,method="spearman"),2)
		legend(corrpos,legend=c(paste("Pearson r: ",mycorr1,sep=""),paste("Spearman r: ",mycorr2,sep="")),bty='n',fill=NA,border=NA,cex=corrcex)
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,cex=2.5,line=0.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# if not importing data, but instead converting from a genlight object:
genlight2sambar<-function(genlight_object=NULL,do_confirm=FALSE,colourvector=NULL,popvector=NULL,major=1,minor=4,qcplot=TRUE,heplot=TRUE,silent=TRUE,allow_edit=FALSE,pop_order=NULL)
	{
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	options(scipen=999)		# 08-04-2020: to prevent that scaffold 900000 is renamed 9e+05
	#
	if(is.null(genlight_object))
		{
		return(cat("ERROR: provide name of the genlight object to the flag genlight_object.",sep="\n"))
		}
	if(!do_confirm)
		{
		cat("WARNING: this function will create (and if necessary overwrite) SambaR output directories in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("If you agree, set the flag 'do_confirm' (i.e. genlight2sambar(do_confirm=TRUE)) to TRUE.",sep="\n")
		return(cat("If not, first navigate to another directory.",sep="\n"))
		}
	cat("REMINDER: use quotes when specifying the input genlight_object, otherwise you will run into the error: 'Error in get(genlight_object, envir = myglobal) : invalid first argument'.",sep="\n")
	myglobal	<- globalenv()
	mygenlight	<- get(genlight_object,envir=myglobal)
	if(is.null(mygenlight@ind.names))
		{
		cat("WARNING: slot ind.names not present in genlight object. Adding uninformative names instead.",sep="\n")
		nrinds					<- nrow(as.matrix(mygenlight))
		mygenlight@ind.names	<- paste("Ind",c(1:nrinds),sep="")
		}
	if(is.null(mygenlight@loc.names))
		{
		cat("WARNING: slot loc.names not present in genlight object. Adding uninformative names instead.",sep="\n")
		nrsnps					<- ncol(as.matrix(mygenlight))
		mygenlight@loc.names	<- paste("SNP",c(1:nrsnps),sep="")
		}	
	#
	cat("Creating inds object...",sep="\n")
	nrinds		<- length(mygenlight@ind.names)
	if(is.null(mygenlight@pop))
		{
		mypops	<- rep("pop1",nrinds)		
		}else{
		mypops	<- as.vector(as.character(mygenlight@pop))
		}
	inds		<<- data.frame("name"=as.vector(mygenlight@ind.names),"nr"=c(1:nrinds),"pop"=mypops,"pop2"=mypops)
	if(!is.null(popvector))
		{
		cat("WARNING: basing population assignment on information provided to the popvector flag. Assuming that the order of the samples in the genlight object corresponds to the order of the popvector.",sep="\n") 
		inds$pop		<<- as.character(popvector)
		inds$pop2		<<- as.character(popvector)
		mygenlight@pop	<- as.factor(popvector)
		mypops			<-  as.character(popvector)
		}
	if(any(grepl("_",mypops)))
		{
		if(allow_edit)
			{
			cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
			cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
			mypops			<- as.character(inds$pop2)
			popvector		<- gsub("_","",mypops)
			inds$pop		<<- as.character(popvector)
			inds$pop2		<<- as.character(popvector)
			mygenlight@pop	<- as.factor(popvector)
			mypops			<-  as.character(popvector)
			}else{
			cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
			cat("To solve this issue, edit population names and try again.",sep="\n")
			return(cat("Alternatively, allow SambaR to remove underscores from population names by setting the flag allow_edit to TRUE.",sep="\n"))
			}
		}
	popnames	<- as.vector(unique(as.character(mypops)))
	popnames	<- popnames[order(popnames)] 	
	npops		<- length(popnames)
	if(!silent){cat(paste("Number of populations: ",npops,sep=""),sep="\n")}
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours
		}
	ncolours			<- length(colourvector)
	if(npops>ncolours)
		{
		return(cat(paste("ERROR: more populations (",npops,") defined than population colours (",ncolours,"). Please provide a longer vector of colour names to the colourvector flag.",sep=""),sep="\n"))
		}
	colvector			<-  colourvector[1:npops]
	# Note: this does not work correctly if inds$pop is originally a factor in which one or more levels are not present in the actual data. 
	# (Sounds strange, but this can happen. You would not notice when running the command 'unique(inputfactorvector)', only when running the command 'table(inputfactorvector)'. 
	inds$popcol			<<- colvector[as.factor(inds$pop)]
	if(any(is.na(inds$popcol)))
		{
		colvector		<<- colvector
		return(cat("ERROR: NA-values in inds$popcol column. Contact the developer of SambaR.",sep="\n"))
		}
	symbolvector		<-  c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype		<<- symbolvector[as.factor(inds$pop)]
	inds$symboltype2	<<- symbolvector[as.factor(inds$pop)]
	#
	mypopcolours		<-vector()
	for(k in c(1:npops))
		{
		mypop			<- popnames[k]
		mypopcolours[k]	<- inds$popcol[inds$pop==mypop][1]	
		}
	cat("Creating snps object...",sep="\n")
	nrsnps				<- length(mygenlight@loc.names)	
	snps				<<- data.frame("name"=as.vector(mygenlight@loc.names),"nr"=c(1:nrsnps),"chr"=rep("un",nrsnps),pos=seq(1:nrsnps))
	snps$name2			<<- snps$name
	snps$morgan			<<- 0
	snps$uniqpos		<<- TRUE
	snps$genlightname	<<- snps$name
	snps$nr_neworder	<<- snps$nr
	#
	# edit minor/major alleles columns:
	if(length(minor)==1|length(major)==1)
		{
		cat(" ",sep="\n")
		#cat("WARNING: genlight object does not contain info about type of allele (A,C,G,T). Assuming either A or T, or any other combination specified by minor and major flags.",sep="\n")
		cat("WARNING: only 1 allele type specified to the minor and/or major flag.",sep="\n")
		cat("SambaR will assume that all SNPs have the same type of minor or major allele (by default A for major and T for minor).",sep="\n")
		cat("This does not affect subsequent analyses, except for calculation of transition-transversion ratios and GC-content.",sep="\n")
		cat("Still, if you have the information on allele types (e.g. 1,2,3,4, or alternatively A,C,G,T, why not provide these vectors to the minor and major flags?",sep="\n") 
		cat(" ",sep="\n")
		}else{
		if(length(minor)!=nrow(snps)|length(major)!=nrow(snps))
			{
			return(cat("ERROR: length of vector(s) provided to minor/major flag not equal to number of SNPs in dataset, nor to 1.",sep="\n"))
			}else{
			minor		<- as.factor(minor)
			major		<- as.factor(major)
			}
		}
	snps$minor			<<- minor
	snps$major			<<- major
	#
	# addition 29-04-2020:
	if(is.factor(snps$minor))
		{
		minorvec		<- as.character(snps$minor)
		if(any(c("A","C","T","G")%in%minorvec))
			{
			cat("Converting snps$minor factor to character vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- minorvec
			}else{
			cat("Converting snps$minor factor to integer vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- as.integer(minorvec)
			}
		}else{
		cat("snps$minor not factor class.",sep="\n")
		}
	if(is.factor(snps$major))
		{
		majorvec		<- as.character(snps$major)
		if(any(c("A","C","T","G")%in%majorvec))
			{
			cat("Converting snps$major factor to character vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- majorvec
			}else{
			cat("Converting snps$major factor to integer vector...")
			snps$major	<<- NULL
			snps$major	<<- as.integer(majorvec)
			}
		}else{
		cat("snps$major not factor class.",sep="\n")
		}
	#
	snps$minor[snps$minor==0]	<<- NA	# In case data is non-polymorphic
	#
	myalleles		<- as.vector(unique(snps$minor))
	if(any(is.na(myalleles)))
		{
		cat("WARNING: non-defined allele (NA or 0) present in vectors given as input to minor flag.",sep="\n")
		myalleles	<- myalleles[!is.na(myalleles)]
		}
	if(is.integer(snps$minor)|is.numeric(snps$minor))
		{
		if(any(myalleles!=1&myalleles!=2&myalleles!=3&myalleles!=4))
			{
			myalleles	<<- myalleles
			return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 (integer) or A,C,T,G. You can observe the alleles by typing 'myalleles'.",sep="\n")) 
			}
		snps$minor2										<<- NA
		snps$minor2[snps$minor==1&!is.na(snps$minor)]	<<- "A"
		snps$minor2[snps$minor==2&!is.na(snps$minor)]	<<- "C"
		snps$minor2[snps$minor==3&!is.na(snps$minor)]	<<- "G"
		snps$minor2[snps$minor==4&!is.na(snps$minor)]	<<- "T"
		}else{
		if(is.character(snps$minor))
			{
			if(any(myalleles!="A"&myalleles!="C"&myalleles!="G"&myalleles!="T"))
				{
				myalleles	<<- myalleles
				return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 or A,C,T,G (character). You can observe the alleles by typing 'myalleles'.",sep="\n")) 
				}
			snps$minor2										<<- snps$minor
			snps$minor										<<- NA
			snps$minor[snps$minor2=="A"&!is.na(snps$minor2)]<<- 1
			snps$minor[snps$minor2=="C"&!is.na(snps$minor2)]<<- 2
			snps$minor[snps$minor2=="G"&!is.na(snps$minor2)]<<- 3
			snps$minor[snps$minor2=="T"&!is.na(snps$minor2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	#
	if(is.integer(snps$major)|is.numeric(snps$major))
		{
		snps$major2										<<- NA
		snps$major2[snps$major==1&!is.na(snps$major)]	<<- "A"
		snps$major2[snps$major==2&!is.na(snps$major)]	<<- "C"
		snps$major2[snps$major==3&!is.na(snps$major)]	<<- "G"
		snps$major2[snps$major==4&!is.na(snps$major)]	<<- "T"
		}else{		# if in bim-file data is encoded as A,C,G,T rather than 1,2,3,4.
		if(is.character(snps$major))
			{
			snps$major2										<<- snps$major
			snps$major										<<- NA
			snps$major[snps$major2=="A"&!is.na(snps$major2)]<<- 1
			snps$major[snps$major2=="C"&!is.na(snps$major2)]<<- 2
			snps$major[snps$major2=="G"&!is.na(snps$major2)]<<- 3
			snps$major[snps$major2=="T"&!is.na(snps$major2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	snps$minor2[snps$minor2=="0"]	<<- NA
	#
	# check if expected alleles (A, C, T, G) only:
	myalleles1			<- names(table(snps$minor2))
	myalleles1			<- myalleles1[myalleles1!="A"&myalleles1!="C"&myalleles1!="G"&myalleles1!="T"&myalleles1!="0"]
	myalleles2			<- names(table(snps$major2))
	myalleles2			<- myalleles2[myalleles2!="A"&myalleles2!="C"&myalleles2!="G"&myalleles2!="T"&myalleles2!="0"]
	myalleles			<- c(myalleles1,myalleles2)
	if(length(myalleles)>0)
		{
		myalleles		<- myalleles[!is.na(myalleles)]
		if(length(myalleles)>0)
			{
			myotheralleles	<<- myalleles
			if(!acceptalleles)
				{
				cat("ERROR: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("If you want to continu trying to import the data anyway, set the 'acceptalleles' flag to TRUE (i.e. importdata(acceptalleles=TRUE)).",sep="\n")
				return(cat("Note however that downstream this could lead to errors.",sep="\n"))
				}else{
				cat("WARNING: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("Because the flag 'acceptalleles' is set to TRUE, SambaR will continu to import the data. However, you might encounter errors downstream.",sep="\n")
				}
			}
		}
	snps$polyfilter			<<- ifelse(is.na(snps$minor),FALSE,TRUE)
	#
	#snps$minor2		<<- c("A","C","G","T")[minor]
	#snps$major2		<<- c("A","C","G","T")[major]
	snps$placed			<<- FALSE
	snps$autosomal		<<- FALSE
	snps$placedcol		<<- "black"
	snps$new_chr		<<- NA
	snps$uniqpos		<<- TRUE
	snps$samepos		<<- FALSE
	snps$depthfilter	<<- TRUE
	#
	cat("Creating mygenlight object...",sep="\n")
	mymatrix			<- as.matrix(mygenlight)
	colnames(mymatrix)	<- snps$genlightname
	rownames(mymatrix)	<- inds$name
	mygenlight			<<- as.genlight(mymatrix)
	mygenlight@pop		<<- as.factor(inds$pop)
	mygenlight@ind.names<<- as.character(rownames(mymatrix))
	mygenlight@loc.names<<- as.character(colnames(mymatrix))
	#
	if(!silent){cat("Assigning index based on length of chromosomes...",sep="\n")}
	mychrs				<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
	mychrs2				<- mychrs[order(-mychrs$x),]
	mychrs2$chr2		<- c(1:nrow(mychrs2))
	colnames(mychrs2)	<- c("chr","chrlength","chr2")
	mychrs2$chrcol		<- ifelse(mychrs2$chr2%%2==0,"black","grey40")
	snps				<<- merge(snps,mychrs2,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(colnames(as.matrix(mygenlight))!=snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Counting number of SNPs per scaffold...",sep="\n")}
	myn					<- table(snps$chr)
	myndf				<- data.frame("chr"=names(myn),"nsnps"=as.vector(myn))
	snps				<<- merge(snps,myndf,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	cat("SambaR output directory created in the directory:",sep="\n")
	cat(getwd(),sep="\n")
	#
	cat("Creating mysambar list object...",sep="\n")
	mysambar				<<- list()
	mysambar[[1]]			<<- popnames
	mysambar[[5]]			<<- inputdatadir
	mysambar[[6]]			<<- sambardir
	mysambar[[7]]			<<- QCdir
	mysambar[[8]]			<<- structuredir
	mysambar[[9]]			<<- divergencedir
	mysambar[[10]]			<<- diversitydir
	mysambar[[11]]			<<- demographydir
	mysambar[[12]]			<<- selectiondir
	mysambar[[13]]			<<- inputfilesdir
	mysambar[[14]]			<<- "sans"
	mysambar[[17]]			<<- mypopcolours
	mysambar[[18]]			<<- geomapsdir
	names(mysambar)			<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$os				<<- as.vector(Sys.info()["sysname"])
	mysambar$populations2	<<- mysambar$populations
	mysambar$mycolours2		<<- mysambar$mycolours
	mysambar$defaultcolours	<<- defaultcolours	
	mysambar$datasource		<<- "converted_from_genlight"
	#
	# check:
	if(!silent){cat("Checking pop colours...",sep="\n")}
	checkpopcolours()
	if(mysambar$colourerror){return(cat(" ",sep="\n"))}
	#
	reorderpop(poporder=pop_order)
	#
	cat("DATA SUCCESFULLY CONVERTED TO SAMBAR OBJECTS.",sep="\n")
	cat("ANY ERRORS OCCURRING AFTER THIS LINE ARE RELATED TO CREATING QUALITY CONTROL TABLES AND PLOTS AND WILL NOT DENY YOU FROM RUNNING SUBSEQUENT FUNCTIONS.",sep="\n")
	cat(" ",sep="\n")
	#
	cat("Creating list of installed R package versions...",sep="\n")
	getversions()
	#
	cat(" ",sep="\n")
	cat("Creating quality control plots which can be used for choosing the right settings when running the filterdata function...",sep="\n")
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	if(qcplot)
		{	
		cat("Creating data_quality plot...",sep="\n")
		cat("If you receive an error after this line, rerun the genlight2sambar()-function with the flag 'qcplot' set to FALSE. I.e.: genlight2sambar(qcplot=FALSE).",sep="\n")
		calcretainedsnps(export="pdf",logy=TRUE)
		calcretainedsnps(export="pdf",logy=FALSE)
		}
	if(heplot)
		{
		cat("Creating He_vs_miss plot...",sep="\n")
		cat("If you receive an error after this line, type 'dev.off()' and rerun the genlight2sambar()-function with the flag 'heplot' set to FALSE. I.e.: genlight2sambar(heplot=FALSE).",sep="\n")
		indhetero_allsnps()
		#myminsites	<- ifelse(0.01*nrow(snps)<200,200,0.01*nrow(snps))
		He_vs_miss(export="pdf",allsites=TRUE,minsites=200)
		#cat("Not included in the plot are samples with less than 250 non-missing data points.",sep="\n")
		}
	#
	cat(" ",sep="\n")
	cat("Conversion finished :-)",sep="\n")
	cat("New inds, snps and mygenlight objects, as well as data quality plots have been succesfully created.",sep="\n")
	cat("ROUGH GUIDELINES BEFORE RUNNING THE FILTERDATA() FUNCTION:",sep="\n")
	cat("Before running the filterdata() function, observe the figures 'Data_quality' and/or 'He_vs_miss_ind.allsites.pop' to determine an appropriate value for the indmiss and snpmiss arguments.",sep="\n")
	cat("If you are mainly interested in structure analyses, set snpmiss to 0 (or if needed a bit higher, but preferably not higher than 0.05) and indmiss to the highest value which returns at least a few thousands SNPs scattered across the entire genome (see black line in 'Data_quality.log_yaxis').",sep="\n")
	cat("The reason is that variation in missingness among samples will affect the outcome of structure analyses. A few thousand SNPs from across the entire genome are generally sufficient to detect population structure (although this obviously depends on your study system).",sep="\n")
	cat("For other purposes (e.g. genetic diversity and selection analyses (especially the latter), you are probably better off by setting a more strict threshold for indmiss (default is 0.25) and more relaxed threshold for snpmiss (default is 0.1).",sep="\n")
	cat("If you are mainly interested in comparing genetic diversity among your study populations, observe the 'He_vs_miss_ind.allsites.pop'.",sep="\n")
	cat("Set indmiss to the highest value (which might be as low as 0.05) such that for retained individuals there is no relation between heterozygosity and their proportions of missing data.",sep="\n")
	options(scipen=0)	# 08-04-2020: reset scientific notation (because disabled at start of function)
	}	

addsnpinfo<-function()
	{
	mynamevec	<- c("class","impact","gene","exon","nucl_mut","aa_mut","codon_nr","aa_nr")
	if(any(mynamevec%in%colnames(snps)))
		{
		cat("Removing existing columns in snps dataframe...",sep="\n")
		mynrs	<- which(mynamevec %in% colnames(snps))
		for(i in mynrs)
			{
			mycolname	<- mynamevec[i]
			snps[,colnames(snps)==mycolname]	<<- NULL
			}
		}
	cat("Adding columns with snps information to snps dataframe...",sep="\n")
	setwd(mysambar$inputdatadir)
	myann		<<- read.table("snp_ann.txt",header=TRUE)
	myann$name3	<<- as.factor(paste(myann$chrom,myann$pos,sep=":"))
	myann$chrom	<<- NULL
	myann$pos	<<- NULL
	myann		<<- myann[myann$name3%in%snps$name3,]
	snpstemp	<<- merge(snps,myann,by="name3",all=TRUE)
	snps		<<- snpstemp[order(snpstemp$chr,snpstemp$pos),]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	snps$impact		<<- as.character(snps$impact)
	snps$gene		<<- as.character(snps$gene)
	snps$exon		<<- as.character(snps$exon)
	snps$nucl_mut	<<- as.character(snps$nucl_mut)
	snps$aa_mut		<<- as.character(snps$aa_mut)
	snps$codon_nr	<<- as.character(snps$codon_nr)
	snps$aa_nr		<<- as.character(snps$aa_nr)
	snps$class		<<- as.character(snps$class)
	#
	snps$impact[is.na(snps$class)]	<<- "intergenic"
	snps$gene[is.na(snps$class)]	<<- "intergenic"
	snps$exon[is.na(snps$class)]	<<- "intergenic"
	snps$nucl_mut[is.na(snps$class)]<<- "intergenic"
	snps$aa_mut[is.na(snps$class)]	<<- "intergenic"
	snps$codon_nr[is.na(snps$class)]<<- "intergenic"
	snps$aa_nr[is.na(snps$class)]	<<- "intergenic"
	snps$class[is.na(snps$class)]	<<- "intergenic"
	}

getsymbol2<-function(mysambarcolours=mysambar$mycolours)
	{
	symbolvector		<- c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype2	<<- symbolvector[as.factor(inds$pop)]
	if(any(as.vector(inds$pop)!=as.vector(inds$pop2)))
		{
		populations		<- as.vector(unique(inds$pop))
		populations		<- populations[order(populations)] 
		npops			<- length(populations)
		for(j in c(1:npops))
			{
			mypop		<- populations[j]
			subpops		<- as.vector(inds$pop2[inds$pop==mypop])
			inds$symboltype2[inds$pop==mypop]	<<- symbolvector[as.factor(subpops)]
			}
		}
	}

# define popcol2 (for subpopulations, if applicable). Doesn't give nice results, so not used.
getcol2<-function(mysambarcolours=mysambar$mycolours)
	{
	inds$popcol2		<<- inds$popcol
	if(any(as.vector(inds$pop)!=as.vector(inds$pop2)))
		{
		populations		<- as.vector(unique(inds$pop))
		populations		<- populations[order(populations)] 
		npops			<- length(populations)
		for(j in c(1:npops))
			{
			mypop		<- populations[j]
			mypopcol	<- mysambarcolours[j]
			cat(mypop,sep="\n")
			#
			popinds		<- as.vector(inds$name[inds$pop==mypop])
			subpops		<- as.vector(inds$pop2[inds$pop==mypop])
			npopinds	<- length(popinds) 
			#
			subpopnames	<- unique(subpops)
			subpopnames	<- subpopnames[order(subpopnames)]
			nsubpop		<- length(subpops)
			#
			if(length(grep("grey",mypopcol))==0)
				{
				cat("grey is NOT main colour",sep="\n")
				mycolfunc 	<- colorRampPalette(c("grey",mypopcol))
				mycolours	<- mycolfunc(nsubpop+1)
				mycolours	<- mycolours[2:(nsubpop+1)]
				}else{
				cat("grey is main colour",sep="\n")
				mycolfunc 	<- colorRampPalette(c("grey90",mypopcol))
				mycolours	<- mycolfunc(nsubpop+1)
				mycolours	<- mycolours[2:(nsubpop+1)]
				}
			for (k in c(1:npopinds))
				{
				myind	<- popinds[k]
				mysubpop<- subpops[k]
				mypopnr	<- which(subpopnames==mysubpop)
				mycol	<- as.vector(mycolours[mypopnr])
				inds$popcol2[inds$name==myind]	<<- mycol
				}
			}
		}
	}

addgeofile<-function(geofile=NULL)
	{
	if(is.null(geofile))
		{
		return(cat("Error: provide input to geofile flag.",sep="\n"))
		}else{
		cat("Looking for input file in the following directory:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		setwd(mysambar$inputdatadir)
		cat("Adding geographical coordinates to inds dataframe...",sep="\n")
		mygeo			<- read.table(geofile,header=TRUE)
		if(any(!(c("sample","longitude","latitude")%in%colnames(mygeo))))
			{
			return(cat("ERROR: geofile should contain columns named 'sample', 'longitude' and 'latitude'.",sep="\n"))
			}
		mygeo			<- mygeo[order(mygeo$sample),]
		inds$longitude	<<- mygeo$longitude
		inds$latitude	<<- mygeo$latitude
		if(class(inds$longitude)=="factor")
			{
			cat("WARNING: Longitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
			inds$longitude	<<- as.numeric(as.character(inds$longitude))
			}
		if(class(inds$latitude)=="factor")
			{	
			cat("WARNING: Latitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
			inds$latitude	<<- as.numeric(as.character(inds$latitude))
			}
		# pacific or atlantic centred map?
		inds$longitude2	<<- ifelse(inds$longitude>=0,inds$longitude,abs(inds$longitude)+180)
		inds$longitude3	<<- ifelse(inds$longitude>=-15,inds$longitude,180+(180-abs(inds$longitude)))
		}
	}

addsampleinfo<-function(samplefile="sample_info.txt",filteronly=TRUE)
	{
	if(is.null(samplefile))
		{
		return(cat("Error: provide input to samplefile flag.",sep="\n"))
		}else{
		cat("Looking for input file in the following directory:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		setwd(mysambar$inputdatadir)
		myinfo			<<- read.table(samplefile,header=TRUE)
		if(!"name"%in%colnames(myinfo))
			{
			return(cat("ERROR: sample info file should contain a column named 'name'.",sep="\n"))
			}
		myinfo			<<- myinfo[order(myinfo$name),]
		if(filteronly)
			{
			indsretained<- inds[inds$filter,]
			}else{
			indsretained<- inds
			}
		indsretained<- indsretained[order(indsretained$name),]
		if(nrow(myinfo)!=nrow(indsretained))
			{
			if(filteronly)
				{
				return(cat("ERROR: number of samples in sample info does not correspond with number of retained individuals in inds dataframe.",sep="\n"))	
				}else{
				return(cat("ERROR: number of samples in sample info does not correspond with number of individuals in inds dataframe.",sep="\n"))	
				}
			}
		if(any(!as.character(myinfo$name)==as.character(indsretained$name)))
			{
			return(cat("ERROR: sample names in sample info file do not correspond with inds$name column.",sep="\n"))	
			}
		mycolnames		<- colnames(myinfo)
		mycolnames		<- mycolnames[!mycolnames=="name"]
		present_in_inds	<- mycolnames%in%colnames(inds)
		if(any(present_in_inds))
			{
			cat("WARNING: removing from inds dataframe columns with columnnames with match with column names in info file.",sep="\n")	
			for(j in c(1:length(mycolnames)))
				{
				mycolname	<- as.character(mycolnames[j])
				#mynewname	<- paste(mycolname,"old",sep="_")
				#cat(mynewname,sep="\n")
				colfilter	<- colnames(inds)!=mycolname
				inds		<- inds[,colfilter] 
				}
			#return(cat("ERROR: one or more column names within sample info file (apart from 'name') already present in inds data frame. Not adding information.",sep="\n"))	
			}
		#myinfotemp			<- myinfo[,!present_in_inds]
		#myinfotemp$name	<- myinfo$name
		myinfotemp			<- myinfo
		indstemp			<- merge(inds,myinfotemp,all=TRUE,by="name")
		indstemp			<- indstemp[order(indstemp$name),]
		indstemp			<<- indstemp
		if(any(!as.character(row.names(as.matrix(mygenlight)))==as.character(as.vector(indstemp$name))))
			{
			return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
			}
		inds		<<- indstemp
		cat("Information added to the inds dataframe.",sep="\n")
		}
	}	

addinfo2inds<-function(namevec=sampleinfo$name,infovec=sampleinfo$regionhe,infovec2=sampleinfo$regionhe2)
	{
	inds$regionhe	<<- NA
	inds$regionhe2	<<- NA
	namevec			<- as.character(namevec)
	for(j in c(1:nrow(inds)))
		{
		cat(j,sep="\n")
		myname				<- as.character(inds$name[j])
		mynr				<- which(namevec==myname)
		cat(mynr,sep="\n")
		if(length(mynr)==0)
			{
			inds$regionhe[j]	<<- NA 
			inds$regionhe2[j]	<<- NA 
			}else{
			inds$regionhe[j]	<<- infovec[mynr] 
			inds$regionhe2[j]	<<- infovec2[mynr] 
			}
		}
	}

# function to add a second population structure (columns 'inds$subpop' and 'inds$subpopcol'):
# 24-04-2020: depreciated since inds$pop2 is now used to defined subpopulations	
addpop<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(is.null(samplefile))
		{
		return(cat("ERROR: Provide an input file to samplefile flag."),sep="\n")
		}
	# cat("Extracting information from sample file...",sep="\n")
	popinput			<- read.table(samplefile,header=FALSE)
	colnames(popinput)	<- c("name","pop")
	# reorder vcf-file:
	popinput			<- popinput[order(popinput$name),]
	# now extract information:
	inds$subpop			<<- popinput$pop
	#
	# add colours:
	mypops				<- as.vector(unique(inds$subpop))
	colvector			<- mycolours[1:length(mypops)] 
	inds$subpopcol		<<- colvector[as.factor(inds$subpop)]
	# add to mysambar list:
	mysambar$subpop		<<- mypops[order(mypops)]
	mysambar$subpopcol	<<- mycolours
	cat("Columns 'subpop' and 'subpopcol' added to inds dataframe.",sep="\n")
	cat("Vectors 'subpop' and 'subpopcol' added to mysambar list.",sep="\n")
	}

# 27-07-2021: function to change population assignment of a single sample.
addpop<-function(myind="TorontoZoo",mypop="zoohybrid",mycol="red")
	{
	# edit mysambar list:
	mysambar$populations2						<<- c(mysambar$populations2,mypop)
	mysambar$mycolours2							<<- c(mysambar$mycolours2,mycol)
	myorder										<- order(mysambar$populations2)
	mysambar$populations2						<<- mysambar$populations2[myorder]
	mysambar$mycolours2							<<- mysambar$populations2[myorder]
	#
	# edit inds dataframe:
	inds$pop3									<<- as.character(inds$pop)
	inds$pop3[as.character(inds$name)==myind]	<<- "zoohybrid"
	inds$pop									<<- as.factor(inds$pop3)
	#
	excludepop()
	snpsmissingness()
	snp_maf()
	}

# function to redefine population assignment:	
replacepop<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(!is.null(samplefile))
		{
		cat("Extracting information from sample file...",sep="\n")
		# 21-2-20: I originally called this vcfinput file and I decided not to change it.
		vcfinput		<- read.table(samplefile,header=TRUE)
		if(ncol(vcfinput)<2)
			{
			return(cat("ERROR: Sample file should contain at least two columns ('name' and 'pop').",sep="\n"))
			}
		if("name"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop').",sep="\n"))
			}
		if("pop"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop').",sep="\n"))
			}
		if("pop2"%in%colnames(vcfinput))
			{
			vcfinput$pop2	<- vcfinput$pop
			}
		# reorder vcf-file:
		vcfinput$name	<- as.character(vcfinput$name) 
		vcfinput		<- vcfinput[order(vcfinput$name),]
		# now extract information:
		if(any(as.vector(as.character(vcfinput$name))!=as.vector(as.character(inds$name))))
			{
			cat("ERROR: Sample names in sample file do not correspond with names in inds dataset.",sep="\n")
			samplefilenames	<<- as.vector(vcfinput$name) 
			indsdatanames	<<- as.vector(inds$name)
			booldatanames	<<- as.vector(as.character(vcfinput$name))==as.vector(as.character(inds$name))
			cat("Sample names in sample file can be observed by typing: samplefilenames.",sep="\n")
			cat("Sample names in inds dataset can be observed by typing: indsdatanames.",sep="\n")
			return(cat("The similarity between both vectors can be observed by typing: booldatanames.",sep="\n"))
			}
		if(any(grepl("_",vcfinput$pop))|any(grepl("_",vcfinput$pop2)))
			{
			if(allow_edit)
				{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
				mypops			<- as.character(vcfinput$pop)
				vcfinput$pop	<- gsub("_","",mypops)
				mypops2			<- as.character(vcfinput$pop2)
				vcfinput$pop2	<- gsub("_","",mypops2)
				}else{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("To solve this issue, you can choose any of the following two options:",sep="\n")
				cat("Option 1: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 2: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		if(any(nchar(as.character(vcfinput$pop))>10))
			{
			if(allow_edit)
				{
				cat("WARNING: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will truncate population names (if longer than 10 characters) and continue.",sep="\n")
				mypops		<- as.character(vcfinput$pop)
				vcfinput$pop<- ifelse(nchar(mypops)>10,substr(mypops,1,10),mypops)
				mypops2		<- as.character(vcfinput$pop2)
				vcfinput$pop2<- ifelse(nchar(mypops2)>10,substr(mypops2,1,10),mypops2)
				}else{
				cat("ERROR: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("To solve this issue, you can choose any of the following two options:",sep="\n")
				cat("Option 1: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 2: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		mynind	<- as.vector(table(vcfinput$pop))
		#if(min(mynind)<2)
		#	{
		#	return(cat("ERROR: SambaR does not accept populations consisting of 1 sample only.\nPlease edit population names and try again. \nThis means: make changes in the samplefile, and afterwards rerun the importdata() function.",sep="\n"))
		#	}
		inds$pop		<<- vcfinput$pop
		inds$pop2		<<- vcfinput$pop2		
		# assign population labels to genlight object:
		mygenlight@pop	<<- as.factor(inds$pop)
		cat("Population assignment has been succesfully updated.",sep="\n")
		}
	}

# depreciated 24-04-2020:
replacepop_old<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(is.null(samplefile))
		{
		return(cat("ERROR: Provide an input file to samplefile flag."),sep="\n")
		}
	setwd(mysambar$inputdatadir)
	if(!file.exists(samplefile))
		{
		cat(paste("ERROR: SambaR couldn't find a file called",samplefile,"in the directory:",sep=" "),sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Either set the flag samplefile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
		}
	# cat("Extracting information from sample file...",sep="\n")
	popinput			<- read.table(samplefile,header=FALSE)
	colnames(popinput)	<- c("name","pop")
	# reorder vcf-file:
	popinput			<- popinput[order(popinput$name),]
	if(any(!as.vector(popinput$name)==as.vector(inds$name)))
		{
		return(cat("ERROR: Sample names in vcfinput file do not correspond with names in inds dataset.",sep="\n"))
		}
	mypops			<- as.vector(unique(popinput$pop))
	mypops			<- mypops[order(mypops)]
	if(length(mypops)>length(mycolours))
		{
		return(cat("ERROR: Number of populations exceeds number of colours. Provide a vector with colour names to the 'mycolours' argument.",sep="\n"))
		}
	# now extract information:
	inds$pop		<<- popinput$pop
	inds$pop2		<<- inds$pop
	#
	# add colours:
	inds$popcol		<- mycolours[1:length(mypops)] 
	inds$popcol		<<- colvector[as.factor(inds$pop)]	
	# add to mysambar list:
	mysambar$populations<<- mypops[order(mypops)]
	mysambar$mycolours	<<- mycolours
	# add to genlight:
	mygenlight@pop		<<- as.factor(inds$pop)
	cat("Population assignment has been succesfully updated.",sep="\n")
	}

################ MULTI-ALLELIC DATA #################	
	
# import multiallelic data from structure format (using adegenet):
importmultidata<-function(structurefile="allsamples.stru",colourvector=NULL,onerow=TRUE,popfile=NULL,nloc=NULL,silent=TRUE,popcol_by_alphabetical_order_popname=TRUE,pop_order=NULL,qcplot=TRUE)
	{
	# define colours:
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours	
		}
	mysambarcolours		<- colourvector
	# create genlight object:
	if(onerow)
		{
		mydata				<- read.table(structurefile)
		colnames(mydata)	<- c("name","pop")
		if(any(grepl("_",mydata$pop)))
			{
			return(cat("SambaR does not accept population names which contain an underscore.\nPlease edit population names and try again.",sep="\n"))	
			}
		nloc				<- (ncol(mydata)-2)/2
		nind				<- nrow(mydata)
		mygenind			<- read.structure(structurefile,n.ind=nind,n.loc=nloc,onerowperind=TRUE,col.lab=1,col.pop=2,col.others=0,row.marknames=0)
		}else{
		sampleinfo			<- read.table(popfile,header=TRUE)
		sampleinfo2			<- sampleinfo[,c("name","pop","popcol")]
		nind				<- nrow(sampleinfo)
		if(is.null(nloc))
			{
			return(cat("ERROR: specify number of loci to the nloc flag.",sep="\n"))
			}
		mygenind			<- read.structure(structurefile,n.ind=nind,n.loc=nloc,onerowperind=FALSE,col.lab=1,col.pop=1,col.others=0,row.marknames=0)
		# Note: the function read.structure is meant for DIPLOID DATA ONLY. Haploid data with the STRUCTURE format can easily be read into R using read.table or read.csv and then converted using df2genind.
		# for example:
		# x <- read.table("dm0row.tsv",header=TRUE)
		# transpose data:
		# y <- t(x)
		# convert to genind:
		# mygenind <- df2genind(X=y,ncode=1,ploidy=1,ind.names=rownames(y))
		#
		mydata				<- data.frame("name"=sub("_1","",mygenind@pop),"nr"=c(1:nrow(as.matrix(mygenind))))
		mydata				<- merge(mydata,sampleinfo2,by="name")	
		mydata				<- mydata[order(mydata$nr),]
		popNames(mygenind)	<- mydata$pop
		indNames(mygenind)	<- mydata$name
		mygenind			<- mygenind[order(mydata$name),]
		}
	cat("Data imported to genind. Next converting into genlight...",sep="\n")
	#mygenind			<<- mygenind
	mymatrix			<- as.matrix(mygenind@tab)
	mygenlight			<<- as.genlight(mymatrix)
	mygenlight@pop		<<- as.factor(mydata$pop)
	#
	cat("Creating inds dataframe...",sep="\n")
	# create populations vector:
	populations			<<- as.vector(unique(mydata$pop))
	# create inds dataframe:
	inds 				<<- mydata[,c("name","pop")]
	inds				<<- inds[order(mydata$name),]
	inds$pop2			<<- inds$pop
	temp				<- as.factor(inds$pop)
	inds$popcol			<<- colourvector[temp]
	inds$nr				<<- c(1:nrow(inds))
	#
	cat("Creating inds dataframe...",sep="\n")
	# create snps dataframe:
	snps				<<- as.data.frame(cbind(mygenlight@loc.names,mygenind@loc.fac,as.vector(unlist(mygenind@all.names))))
	colnames(snps)		<<- c("name","locus","allele")
	snps$allele2		<<- as.numeric(as.character(snps$allele))
	snps$nalleles		<<- as.vector(rep(mygenind@loc.n.all,mygenind@loc.n.all))
	nmissing			<- apply(mymatrix,2,function(x) length(x[is.na(x)])) # number of NA per allele
	snps$allelecount	<<- round(colSums(mymatrix,na.rm=TRUE))
	snps$nonmiss		<<- 2*nind-2*nmissing
	snps$allelefreq		<<- round(colSums(mymatrix,na.rm=TRUE)/(2*nind-2*nmissing),4)
	snps$genlightname	<<- mygenlight@loc.names
	snps$nr				<<- c(1:nrow(snps))
	snps$nr_neworder	<<- snps$nr
	# calculate allelefreq per population:
	#
	mydatapopcolours		<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		# assign colours in alphabetical order of population names (e.g.: Apop gets colour1, Bpop gets colour2, etc)
		cat("Assigning populations colours based on alphabetical order of population names.",sep="\n")
		populations			<- popNames(mygenlight)	 	# this is needed downstream to correctly assign colours at mysambar$mycolours
		inds$popcol			<<- mydatapopcolours[as.factor(inds$pop)]	
		}else{
		# assign colours in order of occurence of populations in datasets. (e.g. Apop, Apop, Cpop, Bpop, Bpop, Cpop would result in Cpop being assigned colour2)
		cat("Assigning populations colours based on order of occurrence of populations in ped-file.",sep="\n")
		populations			<- as.vector(unique(pop(mygenlight)))	
		inds$popcol			<<- NA
		for (i in (1:(length(populations))))
			{
			for (j in (1:nrow(inds)))
				{
				if (inds$pop[j]==populations[i])
					{
					inds$popcol[j] <<- mydatapopcolours[i]
					}
				}
			}
		}
	#
	cat("Calculating population specific allele frequencies...",sep="\n")
	for (i in c(1:length(populations)))
		{
		mypop			<- populations[i]
		if(!silent){cat(mypop,sep="\n")}
		mypopmatrix		<- mymatrix[as.character(inds$pop)==as.character(mypop),,drop=FALSE]
		npopind			<- nrow(mypopmatrix)
		if(length(npopind>0))
			{
			nmissing		<- apply(mypopmatrix,2,function(x) length(x[is.na(x)])) # number of NA per allele 
			snps$freqtemp	<<- round(colSums(mypopmatrix,na.rm=TRUE)/(2*npopind-2*nmissing),4)
			names(snps)[names(snps) == "freqtemp"] <<- paste("allelefreq",mypop,sep = "_")
			}else{
			cat("WARNING: population not found.",sep="\n")
			}
		}
	#
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- populations
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	mydatapopcolours		<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		mysambar[[17]]	<<- mydatapopcolours[order(populations)]
		}else{
		mysambar[[17]]	<<- mydatapopcolours
		}
	mysambar[[18]]			<<- geomapsdir
	names(mysambar)			<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$populations2	<<- mysambar$populations	# needed for excludepop()
	mysambar$mycolours2		<<- mysambar$mycolours		# needed for excludepop()
	mysambar$defaultcolours	<<- defaultcolours
	mysambar$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambar$datasource		<<- "imported_from_ped"
	mysambar$genind			<<- mygenind
	#
	reorderpop(poporder=pop_order)
	# check:
	checkpopcolours()
	if(mysambar$colourerror){return(cat(" ",sep="\n"))}
	#
	if(qcplot)
		{	
		cat("Creating data_quality plot...",sep="\n")
		cat("If you receive an error after this line, rerun the importdata()-function with the flag 'qcplot' set to FALSE. I.e.: importdata(qcplot=FALSE).",sep="\n")
		calcretainedsnps(export="pdf",logy=TRUE)
		calcretainedsnps(export="pdf",logy=FALSE)
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: row names of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	# Print info on screen:
	cat("Created two dataframes called 'snps' and 'inds', as well as a genlight object called 'mygenlight'.",sep="\n")
	}

genindlea<-function(mindemes=2,maxdemes=6,order_on_longitude=FALSE,exportdata=FALSE,poporder=NULL,popnames=mysambar$populations,myfile="LEAinput.stru")
	{
	if(exportdata)
		{
		## EXPORT STRUCTURE FILE:
		mygenind		<- mysambar$genind[inds$filter,snps$filter]
		genind2structure(obj=mygenind,file=myfile,pops=FALSE)
		# genind2structure(obj=mygenind,file="LEAinput.stru",pops=FALSE)
		# Note: if your data contains allele 9, then afterwards in plain text editor:
		# - replace -9 with NAN (assuming no sample or locus name contains string 'NAN')
		# - replace 9 with 13 (because 9 is going to be used by the software as code for missing data)
		# - replace NA back to 9
		}
	#
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		indstemp		<- inds[inds$filter,]
		}
	## LOAD DATA:
	struct2geno(myfile,ploidy=2,FORMAT=2,extra.row=1,extra.column=1)
	# Check (and replace with -9) in Notepad++ for NA-values, otherwise you might run into the error:
	# Error in struct2geno("mymicrosats.stru", ploidy = 2, FORMAT = 2, extra.row = 0,  :  Multiple values for missing data.
	# Also replace alleles encoded as 9 to another value, because the struct2geno function will replace -9 with 9, assuming it is not used as code for alleles.
	# The outcome would be another error ('out of bound')
	myfile			<- paste(myfile,"geno",sep=".")
	obj.snmf		<- LEA::snmf(myfile,K=mindemes:maxdemes,ploidy=2,entropy=T,alpha = 100,project="new")
	#
	# RUN ANALYSES:
	# Creating LEA matrices:
	mydemes			<- c(mindemes:maxdemes)
	totalnr			<- length(mydemes)
	leaqmatrixlist	<- vector(mode="list",length=length(totalnr))
	for(mynr in c(1:totalnr))
		{
		ndemes		<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		# sambarfunction_findstructure:
		obj.snmf	<- LEA::snmf(myfile,K=ndemes,alpha=100,project="new")
		# sambarfunction_findstructure:
		qmatrix 	<- LEA::Q(obj.snmf, K = ndemes)
		#
		if(!is.null(poporder))
			{
			qmatrix				<- qmatrix[order(indstemp$poporder),]
			}
		leaqmatrixlist[[mynr]]	<- qmatrix
		}
	names(leaqmatrixlist)		<- paste("K",mydemes,sep="_")
	if(order_on_longitude)
		{
		mysambar$genindlealist_longitude	<<- leaqmatrixlist
		}else{
		mysambar$genindlea					<<- leaqmatrixlist
		}
	# sambarfunction_findstructure:
	# remove.snmfProject("mymicrosats.filtered2.stru.snmfProject")
	myfile2	<- gsub("geno","snmfProject",myfile)
	remove.snmfProject(myfile2)
	# if function above doesn't work, delete directory and files like this:
	# sambarfunction_findstructure:
	#unlink("mymicrosats.filtered2.stru.snmf", recursive=TRUE)
	unlink(paste(myfile,"snmf",sep="."),recursive=TRUE)
	#  LEAstructureplot(mymatrixlist=mysambar$genindlea,mindemes=2,maxdemes=6,export=NULL,exportname=NULL,popnames=mysambar$populations,poporder=NULL,addindnr=TRUE)
	}
	
genindbarcode<-function(popnames=mysambar$populations,mygenind=mysambar$genind)
	{
	popgenindlist	<- seppop(mygenind)
	npops			<- length(popnames)
	#
	genindmat		<- as.matrix(mygenind[,snps$filter])
	maxalleles		<- max(snps$allele2,na.rm=TRUE)
	snpstemp		<- snps[snps$filter,]
	myloci			<- unique(snpstemp$locus)
	nloci			<- length(myloci)
	nmarkers		<- maxalleles*nloci
	#
	alleledf		<<- as.data.frame(matrix(NA,nrow=nmarkers,ncol=npops))
	colnames(alleledf)<<- popnames
	alleledf$locus	<<- rep(myloci,each=maxalleles)
	alleledf$allele	<<- rep(c(1:maxalleles),times=nloci)
	#
	popninds		<- vector()
	for(j in c(1:npops))
		{
		mypop		<- popnames[j]
		cat(mypop,sep="\n")
		indfilter	<- (inds$pop==mypop)&inds$filter
		ninds		<- length(indfilter[indfilter])
		popninds[j]	<- ninds 
		if(length(ninds)==0)
			{
			cat("WARNING: zero retained individuals.",sep="\n")
			}
		for (k in c(1:nloci))
			{
			mylocus		<- myloci[k]
			locusfilter	<- snpstemp$locus==mylocus
			snpstemp2	<- snpstemp[locusfilter,]
			snpmat		<- genindmat[,locusfilter]
			myalleles	<- snpstemp2$allele2
			for(i in c(1:maxalleles))
				{
				if(!i%in%myalleles)
					{
					alleledf[(k-1)*maxalleles+i,j]	<<- 0
					}else{
					mymarker	<- as.character(snpstemp2$name[snpstemp2$allele2==i])
					markermat	<- genindmat[indfilter,as.character(snpstemp$name)==mymarker]
					alleledf[(k-1)*maxalleles+i,j]	<<- sum(markermat,na.rm=TRUE)
					}
				}
			}
		}
	#
	tempdf	<- alleledf[,1:npops]
	run_ca(mydf=tempdf)
	plot_ca()
	#
	mysambar$popninds	<<- popninds
	allelefreqdf		<<- tempdf/(rep(2*mysambar$popninds,each=nrow(tempdf)))
	}


plotgenind<-function(myBreaks=NULL,my_col="orange",nbins=4,nmarkers=500,popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	#tempdf		<- alleledf[1:nmarkers,1:npops]
	tempdf		<- allelefreqdf[1:nmarkers,1:npops]
	tempdf2		<- tempdf[rowSums(tempdf)!=0,]
	tempdf3		<- tempdf2[,mysambar$popordernr]
	mymatrix	<- as.matrix(tempdf3)
	if(is.null(myBreaks))
		{
		floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
		ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
		mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
		if(max(mymatrix,na.rm=TRUE)==1)
			{
			mymax	<- 1
			}else{
			mymax	<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
			}
		binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
		myBreaks	<- seq(mymin,mymax,binsize)
		}
	mycolfunc 	<- colorRampPalette(c("white",my_col))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	#
	heatpos		<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
	}

findhybrid<-function(pop1="Ural",pop2="Jakutia",admixpop="CentreRus")
	{
	# detect admixed population:
	myloci		<- unique(alleledf$locus)
	nloci		<- length(myloci)
	maxalleles	<- max(alleledf$allele)
	#
	pop1vec		<- alleledf[,colnames(alleledf)==pop1]
	pop2vec		<- alleledf[,colnames(alleledf)==pop2]
	admixpopvec	<- alleledf[,colnames(alleledf)==admixpop]
	triodf		<- data.frame("pop1"=pop1vec,"pop2"=pop2vec,"admixpop"=admixpopvec)
	#
	alleledf$bool1	<<- triodf$pop1>0&triodf$admixpop>0&triodf$pop2==0
	alleledf$bool2	<<- triodf$pop1==0&triodf$admixpop>0&triodf$pop2>0
	alleledf$bool3	<<- triodf$pop1>0&triodf$admixpop==0&triodf$pop2>0
	alleledf$bool4	<<- triodf$pop1==0&triodf$admixpop>0&triodf$pop2==0
	#
	alleledf$admix	<<- NA
	alleledf$private<<- NA
	for(j in c(1:nloci))
		{
		mylocus									<- myloci[j]
		locusdf									<- alleledf[alleledf$locus==mylocus,]
		alleledf$admix[alleledf$locus==mylocus]<<- any(locusdf$bool1)&any(locusdf$bool2)&(!any(locusdf$bool3))
		#alleledf$admix[alleledf$locus==mylocus]<<- any(locusdf$bool1)&any(locusdf$bool2)
		#alleledf$admix[alleledf$locus==mylocus] <<- any(locusdf$bool1)
		alleledf$private[alleledf$locus==mylocus]<<- any(locusdf$bool4)
		}
	nadmix		<- nrow(alleledf[alleledf$admix==TRUE,])/maxalleles
	cat("Number of loci indicative of admixture:",sep="\n")
	nprivate	<- nrow(alleledf[alleledf$private==TRUE,])/maxalleles
	cat(nadmix,sep="\n")
	cat("Number of private alleles:",sep="\n")
	cat(nprivate,sep="\n")
	admixdf		<<- alleledf[alleledf$admix==TRUE,c("locus","allele",pop1,admixpop,pop2,"bool1","bool2","admix")]
	}

# calculate he per individual:
indhe<-function(silent=TRUE,do_analysis,do_compare=FALSE)
	{
	if(do_analysis)
		{
		x				<- read.table("mymicrosats.stru",header=TRUE)
		ninds			<- nrow(inds)
		inds$nmicro		<<- NA
		inds$nmicrohe	<<- NA
		inds$microhe	<<- NA
		for (j in c(1:ninds))
			{
			if(!silent){cat(j,sep="\n")}
			allele1			<- x[j*2-1,]
			allele2			<- x[j*2,]
			mybool			<- allele1!=(-9)&allele2!=(-9)
			allele1			<- allele1[mybool]
			allele2			<- allele2[mybool]
			ngeno			<- length(allele1)
			inds$nmicro[j]	<<- ngeno
			nhe				<- length(which(allele1!=allele2)) 
			inds$nmicrohe[j]<<- nhe
			inds$microhe[j]	<<- round(nhe/ngeno,5)
			}
		}
	if(do_compare)
		{
		hedf	<- brownauto_data$inds[,c("name","pop","popcol","F2")]
		tempdf	<- brownmicrosat_data$inds[,c("name","microhe")]
		hedf	<- merge(hedf,tempdf,by="name")
		plot(hedf$microhe,hedf$F,cex=3,pch=16,col=as.character(pophe$popcol),ylim=c(-1.25,1.25))
		}
	}

# calculates he per pop:
genindhe<-function(export=NULL,popnames=mysambar$populations,legendcex=2,do_analysis=TRUE,mygenind=mysambar$genind[,snps$filter])
	{
	popgenindlist	<- seppop(mysambar$genind)
	if(do_analysis)
		{
		mystats 				<- summary(mygenind)
		popgenindlist			<- seppop(mygenind) 
		Hobs	 				<- t(sapply(popgenindlist,function(ls) summary(ls)$Hobs))
		Hexp 					<- t(sapply(popgenindlist,function(ls) summary(ls)$Hexp))
		Hobs[!is.finite(Hobs)]	<- NA
		Hexp[!is.finite(Hexp)]	<- NA
		Hobs.pop 				<- apply(Hobs,1,mean,na.rm=TRUE)
		Hexp.pop 				<- apply(Hexp,1,mean,na.rm=TRUE) 
		#par(mfrow=c(2,1))
		#barplot(Hexp.pop,ylim=c(0,1),las=3,ylab="Expected heterozygosity")
		#barplot(Hobs.pop,ylim=c(0,1),las=3,ylab="Observed heterozygosity")
		names(Hobs.pop)			<- names(popgenindlist)
		names(Hexp.pop)			<- names(popgenindlist)
		mysambar$Hobs.pop		<<- Hobs.pop
		mysambar$Hexp.pop		<<- Hexp.pop
		}
	if(is.null(mysambar$Hobs.pop))
		{
		return(cat("ERROR: mysambar$Hobs.pop is missing.",sep="\n"))
		}
	if(is.null(mysambar$Hexp.pop))
		{
		return(cat("ERROR: mysambar$Hexp.pop is missing.",sep="\n"))
		}
	Hobs.pop	<- mysambar$Hobs.pop
	Hexp.pop	<- mysambar$Hexp.pop
	#
	if(!is.null(export))
		{
		plotname		<- "Microsat_Hobs"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(Hexp.pop[order(names(Hexp.pop))],Hobs.pop[order(names(Hobs.pop))],col=mysambar$mycolours,pch=16,cex=4,xlim=c(0,0.5),ylim=c(0,0.5),xlab="",ylab="")
	mtext(side=1,"Expected He",cex=2.75,line=3.5)
	mtext(side=2,"Observed He",cex=2.75,line=3.5)
	abline(c(0,0),c(1,1))
	legend("topleft",legend=popnames,fill=mysambar$mycolours,border=mysambar$mycolours,cex=1.75,bty='n')
	if(!is.null(export)){dev.off()}
	#
	#excludepop(c("polar","Black"))
	#hedf			<- dwd$ind[,c("name","pop","popcol","regionhe")]
	#pophe			<- aggregate(hedf$regionhe,list(hedf$pop),mean)
	#colnames(pophe)<- c("pop","regionhe")
	#pophe$microsat	<- mysambar$Hobs.pop
	#tempdf			<- aggregate(hedf$popcol,list(hedf$pop),unique)
	#pophe$popcol	<- as.character(tempdf$x)
	#plot(pophe$regionhe,pophe$microsat,cex=3,pch=16,col=as.character(pophe$popcol))
	}

genindfst<-function(mygenind=mysambar$genind[,snps$filter],nmarkers=2000)
	{
	matFst 		<- pairwise.fst(mygenind[,c(1:nmarkers)],res.type="matrix")
	matFst 		<- pairwise.fst(mysambar$genind,res.type="matrix")
	mytree 		<- nj(matFst)
	plot(mytree,type="unrooted",tip.col=funky(17)[-17],font=2)
	annot 		<- round(mytree$edge.length,2)
	edgelabels(annot[annot>0],which(annot>0),frame="n")
	add.scale.bar()
	}

genindhwe<-function()
	{
	# hwe test:
	popgenindlist	<- seppop(mysambar$genind)
	HWE.test 		<- data.frame(sapply(popgenindlist,function(ls) pegas::hw.test(ls,B=0)[,3]))
	HWE.test.chisq 	<- t(data.matrix(HWE.test))
	# with 1000 Monte Carlo permutations (takes ages):
	# HWE.test <- data.frame(sapply(seppop(mysambar$genind),function(ls) pegas::hw.test(ls,B=1000)[,4]))
	# HWE.test.MC <- t(data.matrix(HWE.test))
	# value per population:
	alpha					<- 0.05
	Prop.pops.out.of.HWE 	<- vector()
	for (k in c(1:ncol(HWE.test)))
		{
		mycolumn	<- HWE.test[,k]
		mycolumn	<- mycolumn[!is.na(mycolumn)]
		Prop.pops.out.of.HWE[k] <- length(mycolumn[mycolumn<alpha])/length(mycolumn)
		}
	names(Prop.pops.out.of.HWE)<- names(popgenindlist)
	}

genindpca<-function(mygenind=NULL,naxes=3,return_object=FALSE)
	{
	if(is.null(mygenind))
		{
		return(cat("ERROR: define the name of the genind object to the mygenind flag.",sep="\n"))
		}
	mymat 		<- tab(mygenind,freq=TRUE,NA.method="mean")
	if(any(is.na(mymat)))
		{
		cat("WARNING: na-values present.",sep="\n")
		mymat[is.na(mymat)]	<- 0
		}
	mypca 					<- dudi.pca(mymat,center=TRUE,scale=FALSE,nf=naxes,scannf=FALSE)
	mypops					<- unique(pop(mygenind))
	# histogram explained variance:
	fviz_eig(mypca)
	# pca plot:
	fviz_pca_ind(mypca,col.ind="cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),repel=TRUE)
	# pca plot with labels:
	s.class(mypca$li,fac=pop(mygenind),col=funky(length(mypops)))
	#
	# get explained variance:
	myeigen					<- get_eig(mypca)
	#mypca					<<- mypca
	#points(mypca$li[,1],mypca$li[,2])
	mysambar$pcascores$vectors	<<- mypca$li
	if(return_object)
		{
		mypcalist <- list("eig"=mypca$eig,"vectors"=mypca$li)
		mypcalist$values$Relative_eig	<- myeigen$variance.percent/100
		return(mypcalist)
		}
	}

genindassign<-function(mygenind=NULL,mindemes=2,maxdemes=6,mycolours=mysambar$mycolours,poporder=NULL,popnames=mysambar$populations)
	{
	if(is.null(mygenind))
		{
		return(cat("ERROR: define the name of the genind object to the mygenind flag.",sep="\n"))
		}
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		}
	inds	<<- inds
	#
	mydemes		<- c(mindemes:maxdemes)
	totalnr		<- length(mydemes)
	qmatrixlist	<- vector(mode="list",length=length(totalnr))
	for(mynr in c(1:totalnr))
		{
		ndemes				<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		mygrp 				<- find.clusters(mygenind,max.n.clust=20,n.pca=75,n.clust=ndemes)
		mydapc 				<- dapc(mysambar$genind[inds$filter,snps$filter],n.pca=75,n.da=14,pop=mygrp$grp)
		mypred				<- predict(mydapc)
		qmatrix				<- round(mypred$posterior,3)
		#
		if(!is.null(poporder))
			{
			indstemp		<- inds[inds$filter,]
			qmatrix			<- qmatrix[order(indstemp$poporder),]
			}
		qmatrixlist[[mynr]]	<- qmatrix
		#barplot(t(100*round(mypred$posterior,2)),col=mycolours,ylab="% assignment",las=3)
		}
	names(qmatrixlist)		<- paste("K",mydemes,sep="_")
	mysambar$genindqlist	<<- qmatrixlist
	}

# export genind to structure file
# function from github page of Lindsay Clark:
genind2structure<-function(obj=mysambar$genind,file="LEAinput.stru",pops=FALSE)
	{
	if(is.null(file))
		{
		return(cat("Specify the name of output structure file to the 'file' flag.",sep="\n"))
		}
	if(is.null(obj))
		{
		return(cat("Specify an (existing) genind object to the 'obj' flag.",sep="\n"))
		}
	if(!"genind" %in% class(obj))
		{
		warning("Function was designed for genind objects.")
		}
	# get the max ploidy of the dataset
	pl <- max(obj@ploidy)
	# get the number of individuals
	S <- adegenet::nInd(obj)
	# column of individual names to write; set up data.frame
	tab <- data.frame(ind=rep(indNames(obj), each=pl))
	# column of pop ids to write
	if(pops)
		{
		popnums <- 1:adegenet::nPop(obj)
		names(popnums) <- as.character(unique(adegenet::pop(obj)))
		popcol <- rep(popnums[as.character(adegenet::pop(obj))], each=pl)
		tab <- cbind(tab, data.frame(pop=popcol))
		}
	loci <- adegenet::locNames(obj) 
	# add columns for genotypes
	tab <- cbind(tab, matrix(-9, nrow=dim(tab)[1], ncol=adegenet::nLoc(obj),dimnames=list(NULL,loci)))
	# begin going through loci
	for(L in loci)
		{
		thesegen <- obj@tab[,grep(paste("^", L, "\\.",sep=""),dimnames(obj@tab)[[2]]),drop = FALSE] # genotypes by locus
		al <- 1:dim(thesegen)[2] # numbered alleles
		for(s in 1:S)
			{
			if(all(!is.na(thesegen[s,])))
				{
				tabrows <- (1:dim(tab)[1])[tab[[1]] == indNames(obj)[s]] # index of rows in output to write to
				tabrows <- tabrows[1:sum(thesegen[s,])] # subset if this is lower ploidy than max ploidy
				tab[tabrows,L] <- rep(al, times = thesegen[s,])
				}
			}
		}
	# export table
	write.table(tab,file=file,sep="\t",quote=FALSE,row.names=FALSE)
	}

# correlation between multi allelic allele frequencies:
corrfrequencies<-function()
	{
	combitable	<- combn(populations,m=2)
	mycorr1		<- rep(NA,ncol(combitable))	# pearson
	mycorr2		<- rep(NA,ncol(combitable))	# spearman
	for (i in c(1:ncol(combitable)))
		{
		pop1	<- combitable[1,i]	
		freq1	<- snps[,names(snps)==paste("allelefreq",pop1,sep="_")]
		pop2	<- combitable[2,i]	
		freq2	<- snps[,names(snps)==paste("allelefreq",pop2,sep="_")]
		mycorr1[i]	<- cor(freq1,freq2,method="pearson")
		mycorr2[i]	<- cor(freq1,freq2,method="spearman")
		}
	mycorr						<<- rbind(combitable,mycorr1,mycorr2)
	b							<<- matrix(1,nrow=length(populations),ncol=length(populations))
	b[lower.tri(b, diag=FALSE)] <<- mycorr1
	b							<<- t(b)
	b[lower.tri(b, diag=FALSE)] <<- mycorr2
	colnames(b)				<<- populations
	rownames(b)				<<- populations
	}

# histogram of allele frequencies for multiallelic data:
allelefreqhisto<-function(export=FALSE)
	{
	# reorder:
	snpstemp	<- snps[order(as.integer((levels(snps$allele))),as.integer((levels(snps$allele)))),]
	if(export){pdf("Allelefrequencies.pdf",width=12,height=20)}
	par(mfrow=c(16,4),mar=c(3,0.5,0.5,0.5),oma=c(1,5,3,1),cex.axis=1.25,cex.lab=1,cex.main=1.5)
	for (j in (c(1:16)))
		{
		npop		<- length(populations)
		temp		<- snpstemp[snpstemp$locus==j,c(8:(8+npop-1))]
		myymax		<- max(temp)
		for (i in c(1:length(populations)))
			{
			mypop	<- populations[i]
			myfreq	<- snpstemp[,names(snpstemp)==paste("allelefreq",mypop,sep="_")]
			myyaxt	<- ifelse(i == 1,"s","n")
			barplot(myfreq[snpstemp$locus==j],las=2,names.arg=snpstemp$allele[snpstemp$locus==j],col=mypop,ylim=c(0,myymax),ylab="",yaxt=myyaxt)
			if(i == 1){mtext(paste("locus",j,sep=""),side=2,line=3.5,cex=1.5)}
			if(j == 1){mtext(mypop,side=3,line=0.25,cex=1.5)}
			}
		}
	if(export){dev.off()}
	}

# These plots are useless: there is no reason to expect correlation between Fst and Fis, other than when populations are wrongly defined. 
# maples plot for each population:
# locusspecific Fst (pairwise comparison) vs locusspecific Fis
# y-axis: Fis	(Hexp_pop-Hobs_pop)/Hexp_pop		# if true population (no substructure), Fis hovers around 0.   
# x-axis: Fst 	(Hexp_meta-Hobs_meta)Hexp_meta		# high if many homozygotes due to popstructure (e.g AA in pop1 and aa in pop2)	
# So flat plot if population has no substructure.
# If more than 2 populations, we have to select a pairwise population comparison for running the fst analysis.  

# for snps (binned):
waples_snps<-function(mysteps=0.05,mypop=snps$F_Busen,myfst=snps$WeirFst_Busen_Norway)
	{
	mybreaks	<- seq(0,1,mysteps)
	myhalf		<- mysteps/2
	mylabels	<- seq(myhalf,1-myhalf,mysteps)
	fstbins		<- cut(windowfstdf$WeirFst_Eurasia_polar,mybreaks)
	fisperbin		<- aggregate(mypop[myselection], by=list(fstbins),FUN=mean) 
	nperbin			<- aggregate(mypop[myselection], by=list(fstbins),FUN=length)
	nbins			<- nrow(fisperbin)
	ndata			<- nperbin$x
	mylabels2		<- mylabels[1:nbins]
	myfis			<- cbind(mylabels2,fisperbin$x) 
	plot(myfis[ndata>10,],xlab="Fst",ylab="Fis",xlim=c(0,1),ylim=c(-1,1))
	}

# for microsatellites:
waples<-function(export=FALSE,histo=FALSE,multi=FALSE,compare_to_fst=FALSE)
	{
	myseploc 		<- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	library(hierfstat)
	# warning: hierfstat masks pcoa function of ape
	# fst:
	myseplocfst 	<<- lapply(myseploc,pairwise.fst)	# pairwise fst values for each locus (multiple values per locus)
	# locfst		<- sapply(myseplocfst, mean)		# mean of pairwise fst values for each locus (one value per locus)
	# fst between two main clusters(ocean and sea of japan)
	locfst			<- as.vector(unlist(myseplocfst))	#
	locfst			<- locfst[seq(5,95,6)]				# this depends on position of the pairwise comparison we are interested in.
	locfst			<<- locfst
	# fis of all populations combined:
	metasummary		<- summary(mygenind)
	metafis 		<- (metasummary$Hexp-metasummary$Hobs)/metasummary$Hexp
	# fis_all or fst as comparison?
	if(compare_to_fst)
		{
		mycontrast		<- locfst 
		}else{
		mycontrast		<- metafis
		}
	# fis per population:
	mypops			<- popNames(mygenind)
	npops			<- length(mypops)
	popfislist		<<- list()
	for (i in c(1:4))
 		{
		mypop		<- mypops[i]
		# mymatrix	<- as.matrix(mygenind[inds$pop==mypop,])
		mymatrix	<- as.matrix(mygenind[mygenind$pop==mypop,])
		popgenind	<- as.genind(mymatrix)
		popsummary	<- summary(popgenind)
		popfislist[[i]]	<- (popsummary$Hexp-popsummary$Hobs)/popsummary$Hexp
		}
	# plot:
	myxlim			<- c(min(mycontrast),max(mycontrast))
	myylim			<- c(min(unlist(popfislist)),max(unlist(popfislist)))
	mylim			<- c(min(c(myxlim,myylim)),max(c(myxlim,myylim)))
	if(histo)
		{
		if(multi)
			{
			graphics.off()
			if(export){pdf("mapleshisto.multi.pdf",height=13.5,width=13.5)}
			par(mfrow=c(2,2),mar=c(2.5,3,3,3),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
			for (i in c(1:4))
				{
				mypop		<- mypops[i]
				popfis		<- popfislist[[i]]
				hist(mycontrast,col="grey",br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005),main=mypop,ylab="",xlab="",ylim=c(0,4))
				hist(popfis,col=mypop,add=TRUE,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005))
				}
			if(compare_to_fst)
				{
				mtext(side=1,"Fst (grey) and Fis (colour)",outer=TRUE,line=2,cex=3)
				}else{
				mtext(side=1,"Fis",outer=TRUE,line=2,cex=3)
				}
			mtext(side=2,"Frequency",outer=TRUE,line=1,cex=3)
			}else{
			graphics.off()
			if(export){pdf("mapleshisto.single.pdf",height=9,width=9)}
			par(cex.axis=1.5,cex.lab=2,cex.main=2)
			for (i in c(1:4))
				{
				mypop		<- mypops[i]
				popfis		<- popfislist[[i]]
				if(i==1)
					{
					hist(popfis,col=mypop,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005),main="",ylab="",xlab="",ylim=c(0,4))
					mtext(side=1,"Fis",line=3,cex=3)
					#mtext(side=2,"Frequency",line=1,cex=3)	
					}else{
					hist(popfis,col=mypop,add=TRUE,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005))
					}
				}
			}
		if(export){dev.off()}
		}else{
		if(export){pdf("maplesscatter.pdf",height=13.5,width=13.5)}
		par(mfrow=c(2,2),mar=c(1,1,1.5,0.5),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
		for (i in c(1:4))
			{
			mypop		<- mypops[i]
			nind		<- nrow(inds[inds$pop==mypop,])
			popfis		<- popfislist[[i]]
			# plot:
			myyaxt		<- ifelse(i==1|i==3,"s","n")
			myxaxt		<- ifelse(i>2,"s","n")
			plot(locfst,popfis,xlim=mylim,ylim=mylim,ylab="",xlab="",pch=16,xaxt=myxaxt,yaxt=myyaxt,col=mypop,cex=1.5)
			fit 		<- lm(popfis ~ locfst)
			fit2		<- summary(fit)
			mypos		<- c(mylim[1],mylim[1])
			mtext(bquote("n" == .(nind)),at = mylim[1],adj=0,line=-1.5,cex=1.5)
			mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=-3.5,cex=1.5)
			mtext(mypop,cex=2)
			# regression:
			mydata		<-	as.data.frame(cbind(popfis,locfst)) 
			abline(lm(popfis ~ locfst,data=mydata),lty=2)
			}
		mtext(side=1,"Fst",outer=TRUE,line=3,cex=2.5)
		mtext(side=2,"Fis",outer=TRUE,line=2,cex=2.5)
		if(export){dev.off()}
		}
	}
	
# Fis within populations vs Fst between population for multiallelic data:
waples_random<-function(export=FALSE,mysizes=c(100,250,500,1000,2000,4000),mycolours=c("blue","darkgreen","darkred","orange","purple","grey50"))
	{
	myseploc 		<- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	library(hierfstat)
	myseplocfst 	<- lapply(myseploc,pairwise.fst)	# pairwise fst values for each locus (multiple values per locus)
	locfst			<- sapply(myseplocfst, mean)		# mean of pairwise fst values for each locus (one value per locus)
	# fst between two main clusters(ocean and sea of japan):
	locfst			<- as.vector(unlist(myseplocfst))	#
	locfst			<- locfst[seq(5,95,6)]				# this depends on position of the pairwise comparison we are interested in.
	popfislist		<- list()
	for (i in c(1:6))
 		{
		mysize			<- mysizes[i]
		mymatrix		<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
		randomgenind	<- as.genind(mymatrix)
		randomsum		<- summary(randomgenind)
		popfislist[[i]]	<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
		}
	# plot:
	myxlim			<- c(min(locfst),max(locfst))
	myylim			<- c(min(unlist(popfislist)),max(unlist(popfislist)))
	#mylim			<- c(min(c(myxlim,myylim)),max(c(myxlim,myylim)))
	mylim			<- myxlim
	if(export){pdf("maplesplot.randomsubsets.pdf",height=10,width=13.5)}
	par(mfrow=c(2,3),mar=c(1,1,1.5,0.5),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)	
	for (i in c(1:6))
 		{
		mysize		<- mysizes[i]
		randomfis	<- popfislist[[i]]
		myyaxt		<- ifelse(i==1|i==4,"s","n")
		myxaxt		<- ifelse(i>3,"s","n")
		plot(locfst,randomfis,xlim=mylim,ylim=mylim,ylab="",xlab="",pch=16,xaxt=myxaxt,yaxt=myyaxt)
		fit 		<- lm(randomfis ~ locfst)
		fit2		<- summary(fit)
		mtext(bquote("n" == .(mysize)),cex=1.5)
		mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=-1.5)
		mydata		<-	as.data.frame(cbind(randomfis,locfst)) 
		abline(lm(randomfis ~ locfst,data=mydata),lty=2)
		for(j in c(1:length(mycolours)))
			{
			mycol		<- mycolours[j]
			mymatrix	<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
			randomgenind<- as.genind(mymatrix)
			randomsum	<- summary(randomgenind)
			randomfis	<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
			points(locfst,randomfis,pch=16,col=mycol)
			fit 		<- lm(randomfis ~ locfst)
			fit2		<- summary(fit)
			mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=((j+1)*-1.5),col=mycol)
			mydata		<-	as.data.frame(cbind(randomfis,locfst)) 
			abline(lm(randomfis ~ locfst,data=mydata),lty=2,col=mycol)
			}
 		}
	mtext(side=1,"Fst",outer=TRUE,line=3,cex=2.5)
	mtext(side=2,"Fis",outer=TRUE,line=2,cex=2.5)
	if(export){dev.off()}
	}

# expected correlation between fst and fis for this dataset if neutral subset:
meanr2<-function(mysize=500,ntimes=100)
	{
	myoutput<<- rep(NA,ntimes)
	# fst per locus:
	myseploc <- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	myseplocfst <- lapply(myseploc,pairwise.fst)
	locfst<- as.vector(unlist(myseplocfst))
	locfst<- locfst[seq(4,94,6)]
	# fis per locus, and regression with fst:
	for (i in c(1:ntimes))
		{
		cat(i,sep="\n")
		mymatrix<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
		randomgenind<- as.genind(mymatrix)
		randomsum<- summary(randomgenind)
		randomfis<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
		fit <- lm(randomfis ~ locfst)
		fit2<- summary(fit)
		myoutput[i]<- round(fit2$r.squared,3)
		}
	}






#################### DATA PREPARATION ################### 

filtermultidata<-function(indmiss=0.65,snpmiss=0.4,silent=TRUE)
	{
	setwd(mysambar$QCdir)
	indsmissingness(indthreshold=indmiss)
	snpsmissingness(indthreshold=indmiss,snpthreshold=snpmiss)
	inds$filter	<<- ifelse(inds$miss>indmiss,FALSE,TRUE)
	inds$filter2<<- inds$filter
	snps$filter	<<- ifelse(snps$miss>snpmiss,FALSE,TRUE)
	snps$filter2<<- snps$filter
	#
	nretainedinds	<- nrow(inds[inds$filter,])
	ntotalinds		<- nrow(inds)
	nretainedsnps	<- nrow(snps[snps$filter2,])
	nthinnedsnps	<- nrow(snps[snps$filter,])
	ntotalsnps		<- nrow(snps)	
	cat(paste("After filtering retained",nretainedinds,"out of",ntotalinds,"individuals.",sep=" "),sep="\n")
	cat(paste("After filtering retained",nretainedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
	cat(paste("After filtering and thinning retained",nthinnedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
	#
	plot_indsmissingdata(indthreshold=indmiss,export="pdf")
	if(!silent){cat("plot_snpsmissingdata",sep="\n")}
	plot_snpsmissingdata(snpthreshold=snpmiss,export="eps")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="pdf")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="png")
	if(mysambar$os=="Windows"){plot_snpsmissingdata(snpthreshold=snpmiss,export="wmf")}
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("missingness_perpop",sep="\n")}
		missingness_perpop(export="eps")
		missingness_perpop(export="pdf")
		missingness_perpop(export="png")
		if(mysambar$os=="Windows"){missingness_perpop(export="wmf")}
		if(min(inds$miss,na.rm=TRUE)>0)
			{
			missingness_perpop(export="eps",logy=TRUE)
			missingness_perpop(export="pdf",logy=TRUE)
			missingness_perpop(export="png",logy=TRUE)
			if(mysambar$os=="Windows"){missingness_perpop(export="wmf",logy=TRUE)}
			}
		}
	snp_maf(indthreshold=indmiss)
	setwd(mysambar$inputdatadir)
	}

# This function executes all steps of the data preparation at once: 
filterdata<-function(indmiss=0.25,snpmiss=0.1,min_mac=2,dohefilter=TRUE,maxprop_hefilter=0.05,snpdepthfilter=TRUE,min_spacing=500,silent=TRUE,nchroms=NULL,do_calckin=FALSE,TsTvfilter=NULL,ychrom=NULL,do_distplot=TRUE,do_highestsd=TRUE,do_mafdiff=FALSE,F_correct_maf=TRUE,plot_inbreeding=TRUE,paralog_threshold1=0.5,paralog_threshold2=0.05,stop_correctmaf=FALSE,legend_cex=3,old_distfilter=FALSE)
	{
	if(!exists("inds"))
		{
		return(cat("ERROR: Object 'inds' is missing. First (re)run the importdata() or genlight2sambar() function.",sep="\n"))
		}
	if(!exists("snps"))
		{
		return(cat("ERROR: Object 'snps' is missing. First (re)run the importdata() or genlight2sambar() function.",sep="\n"))
		}
	if(!exists("mygenlight"))
		{
		return(cat("ERROR: Object 'mygenlight' is missing. First (re)run the importdata() or genlight2sambar() function.",sep="\n"))
		}
	if(!exists("mysambar"))
		{
		return(cat("ERROR: Object 'mysambar' is missing. First (re)run the importdata() or genlight2sambar() function and make sure it finishes without errors.",sep="\n"))
		}	
	#if(indmiss>=1|indmiss<=0)
	if(indmiss>1|indmiss<0)
		{
		return(cat("ERROR: Value of indmiss argument should be between 0 and 1.",sep="\n"))
		}
	#if(snpmiss>=1|snpmiss<=0)
	if(snpmiss>1|snpmiss<0)
		{
		return(cat("ERROR: Value of snpmiss argument should be between 0 and 1.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(is.na(snps$genlightname)))
		{
		cat("WARNING: NA-values in snps$genlightname column.",sep="\n")
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(min_spacing<0)
		{
		return(cat("ERROR: value to min_spacing flag should be positive.",sep="\n"))
		}
	if(is.null(inds$poporder))
		{
		return(cat("ERROR: inds$poporder is NULL. Was the data succesfully imported?",sep="\n"))
		}
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	setwd(mysambar$QCdir)
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	cat("Step 1 out of 6: Checking data quality...",sep="\n")
	# Reorder the snps to the order they occur in the genome:
	# Not necessary when data is created with importdata function, but possibly necessary if created with findoverlap() or dummydata() or subsetdata() functions:
	# First reorder the snps dataframe:
	snpstemp		<- snps
	#snps			<<- snpstemp[order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos)),]
	#snps			<<- snpstemp[order(snpstemp$chr,as.numeric(snpstemp$pos)),]
	if(!"nr_neworder"%in%colnames(snps))
		{
		return(cat("ERROR: column snps$nr_neworder is missing.",sep="\n"))
		}
	snps			<<- snps[snps$nr_neworder,]			# 10-11-2020
	# Second reorder the data in the genlight object:
	#mymatrix		<- as.matrix(mygenlight[,order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos))])
	#mymatrix		<- as.matrix(mygenlight[,order(snpstemp$chr,as.numeric(snpstemp$pos))])
	mymatrix		<- as.matrix(mygenlight[,snpstemp$nr_neworder])	# 10-11-2020
	mygenlight		<<- as.genlight(mymatrix)
	pop(mygenlight)	<<- inds$pop
	if(any(is.na(snps$genlightname)))
		{
		cat("WARNING: after reordering, NA-values in snps$genlightname column.",sep="\n")
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after reordering, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	# general statistics and missing data:
	# if(mysambar$datasource=="converted_from_genlight")
	#	{
	#	cat("Skipping GC-content table and transition-vs-transition plot because data has been converted from a genlight object, and this information got lost.",sep="\n")
	#	}else{
		if(!silent){cat("calcGC",sep="\n")}
		calcGC()
		if(!silent){cat("calctransit",sep="\n")}
		calctransit()
	#}
	if("dist" %in% colnames(snps))
		{
		if(any(snps$dist2))
			{
			mymaxdist	<- max(snps$dist,na.rm=TRUE)
			if(mymaxdist<=1000)
				{
				cat("WARNING: No pair of adjacent snps is separated by more than 1 kb.",sep="\n")
				cat("Are you sure the information in the first column of your MAP file refers to chromosomes/contigs and not to reads?",sep="\n")
				}
			if(do_distplot)
				{
				cat("Creating plots showing distances between adjacent SNPs.",sep="\n")
				cat("If you receive an error after this line, set the flag do_distplot to FALSE.",sep="\n")
				if(!silent){cat("readpos",sep="\n")}
				readpos(export="eps")
				readpos(export="pdf")
				readpos(export="png")
				if(mysambar$os=="Windows"){readpos(export="wmf")}
				if(!silent){cat("plotspacing",sep="\n")}
				plotspacing(export="eps")
				plotspacing(export="pdf")
				plotspacing(export="png")
				if(mysambar$os=="Windows"){plotspacing(export="wmf")}
				}
			}else{
			cat("Skipping distance plots because no contig/chromosome with more than 1 SNP, which means it is impossible to calculate and plot distance between SNPs.",sep="\n")  
			}
		}
	# 13-08-2020: depreciated
	#if(chromosomes)
	#	{
	#	if(!silent){cat("distperchrom",sep="\n")}
	#	distperchrom()
	#	#plotspacingperchrom(export="pdf") # replaced by distperchrom
	#	}
	if(!silent){cat("indsmissingness",sep="\n")}
	indsmissingness(indthreshold=indmiss)	
	if(!any(inds$miss<=indmiss))
		{
		cat("ERROR: no individuals retained after filtering on missingness.",sep="\n")
		if(!silent){cat("barplot missing data",sep="\n")}
		barplot(inds$miss,ylab="Proportion missing data per sample",xlab="Sample number",ylim=c(0,1),names=inds$nr,las=2,cex.names=0.5)
		abline(h=0.1,lty=2)
		return(cat("Change filter settings (i.e. choose a higher value for indmiss) and rerun the filterdata() function.",sep="\n"))
		}
	if(!silent){cat("plot_indsmissingdata",sep="\n")}
	plot_indsmissingdata(indthreshold=indmiss,export="eps")
	plot_indsmissingdata(indthreshold=indmiss,export="pdf")
	plot_indsmissingdata(indthreshold=indmiss,export="png")
	if(mysambar$os=="Windows"){plot_indsmissingdata(indthreshold=indmiss,export="wmf")}
	if(!silent){cat("snpsmissingness",sep="\n")}
	snpsmissingness(indthreshold=indmiss,snpthreshold=snpmiss)
	if(!any(snps$miss<=snpmiss))
		{
		cat("ERROR: no snps retained after filtering on missingness.",sep="\n")
		cat("Change filter settings (i.e. choose a higher value for snpmiss) and rerun the filterdata() function.",sep="\n")
		return(cat("For an overview of missing data per snp, have a look at the 'missingdataperlocus' plot in the QC subdirectory.",sep="\n"))
		}
	if(!silent){cat("plot_snpsmissingdata",sep="\n")}
	plot_snpsmissingdata(snpthreshold=snpmiss,export="eps")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="pdf")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="png")
	if(mysambar$os=="Windows"){plot_snpsmissingdata(snpthreshold=snpmiss,export="wmf")}
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("missingness_perpop",sep="\n")}
		missingness_perpop(export="eps")
		missingness_perpop(export="pdf")
		missingness_perpop(export="png")
		if(mysambar$os=="Windows"){missingness_perpop(export="wmf")}
		if(min(inds$miss,na.rm=TRUE)>0)
			{
			missingness_perpop(export="eps",logy=TRUE)
			missingness_perpop(export="pdf",logy=TRUE)
			missingness_perpop(export="png",logy=TRUE)
			if(mysambar$os=="Windows"){missingness_perpop(export="wmf",logy=TRUE)}
			}
		}
	#if(any(inds$miss==1))
	#	{
	#	cat("ERROR: The following sample(s) has/have zero data:",sep="\n")
	#	cat(as.vector(inds$name[inds$miss==1]),sep="\n")
	#	cat("For an overview of missing data per sample, have a look at the 'missingdatapersample' plot in the QC subdirectory.",sep="\n")
	#	cat("SambaR does not accept samples with zero data.", sep="\n")
	#	return(cat("Remove this/these sample(s) from input file (i.e ped file) and run the plink --make-bed and Sambar importdata() function again to import reduced dataset.",sep="\n"))
	#	}
	cat("Step 2 out of 6: Calculating locus specific minor allele frequencies and heterozygosities...",sep="\n")
	if(!silent){cat("snp_maf",sep="\n")}
	snp_maf(indthreshold=indmiss)
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(length(mysambar$popnoind)>0)
		{
		cat("ERROR: SambaR does not accept populations with zero retained individuals.",sep="\n")
		cat("You have three options:",sep="\n")
		cat("Option 1: Change filter settings (i.e. choose a higher value for indmiss) and run the filterdata() again.",sep="\n")
		cat("Option 2: Use SambaR's mergepop(sourcepop='...',targetpop='...') function to merge a population (the 'sourcepop') into another population (the 'targetpop') and afterwards rerun the filterdata() function.",sep="\n")
		cat("Option 3: Alternatively, remove samples/populations from input file (i.e. ped file) and rerun the plink --make-bed --recode A and Sambar importdata() function to import reduced dataset.",sep="\n")
		return(cat("For an overview of missing data per population, have a look at the 'Missingdata.perpop' plot in the QC subdirectory.",sep="\n"))
		}
	if(!stop_correctmaf)
		{
		if(!silent){cat("correctmaf",sep="\n")}
		correctmaf(silent=TRUE)
		if(!silent){cat("corrected maf",sep="\n")}
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		if(!silent){cat("getpopmaf",sep="\n")}
		getpopmaf(snpthreshold=snpmiss)
		if(!silent){cat("mafsd",sep="\n")}
		mafsd()
		if(!silent){cat("snp_hetero",sep="\n")}
		snp_hetero(indthreshold=indmiss,snpthreshold=snpmiss)
		#if(chromosomes)
		#	{
		#	if(!silent){cat("chrom_He_maf",sep="\n")}
		#	chrom_He_maf(export="eps")	
		#	chrom_He_maf(export="pdf")
		#	chrom_He_maf(export="png")
		#	if(mysambar$os=="Windows"){chrom_He_maf(export="wmf")}
		#	}
		# filter:
		cat("Step 3 out of 6: Setting filters...",sep="\n")
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		filters(indthreshold=indmiss,snpthreshold=snpmiss,mac=min_mac,mindistance=min_spacing,hefilter=dohefilter,paralogthreshold1=paralog_threshold1,paralogthreshold2=paralog_threshold2,snpdepth_filter=snpdepthfilter,TsTv_filter=TsTvfilter,olddistfilter=old_distfilter)
		plotfilters(export="eps",plotdiscarded=TRUE)
		plotfilters(export="pdf",plotdiscarded=TRUE)
		plotfilters(export="png",plotdiscarded=TRUE)
		if(mysambar$os=="Windows"){plotfilters(export="wmf",plotdiscarded=TRUE)}
		plotfilters(export="eps",plotdiscarded=FALSE)
		plotfilters(export="pdf",plotdiscarded=FALSE)
		plotfilters(export="png",plotdiscarded=FALSE)
		if(mysambar$os=="Windows"){plotfilters(export="wmf",plotdiscarded=FALSE)}
		if(!any(snps$filter))
			{
			cat("ERROR: No snps retained after overall filtering.",sep="\n")
			cat("Change filter settings (i.e. choose a higher value for snpmiss) and run the filterdata() again.",sep="\n")
			return(cat("For an overview of missing data per snp, have a look at the 'missingdataperlocus' plot in the QC subdirectory.",sep="\n"))
			}
		mynind	<- as.vector(table(inds$pop))
		#if(min(mynind)<2)
		#	{
		#	cat("ERROR: SambaR does not accept populations which contain only 1 retained individual only.",sep="\n")
		#	cat("Change filter settings (i.e. choose a higher value for indmiss) and run the filterdata() again.",sep="\n")
		#	cat("Alternatively, remove samples/populations from input file (i.e. ped file) and run the plink --make-bed and Sambar importdata() function again to import reduced dataset.",sep="\n")
		#	return(cat("For an overview of missing data per population, have a look at the 'Missingdata.perpop' plot in the QC subdirectory.",sep="\n"))
		#	}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values. Contact the developer of SambaR.",sep="\n"))
			}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values. Contact developer of SambaR.",sep="\n"))
			}
		if(dohefilter)
			{
			prop_hefiltered	<- nrow(snps[!snps$hefilter,])/nrow(snps)
			cat(paste("Proportion SNPs which did not pass the heterozygosity excess filter: ",round(prop_hefiltered,3),".",sep=""),sep="\n")
			#if(prop_hefiltered>0.05&paralog_threshold1==0.5)
			if(prop_hefiltered>maxprop_hefilter)
				{
				plotparalogs(export="pdf")
				cat(" ",sep="\n")
				cat("ERROR: proportion of SNPs that do not pass the heterozygosity excess filter is higher than the limit set by the flag 'maxprop_hefilter' (default is 0.05).",sep="\n")
				cat("Observe the 'He_vs_maf' plot to evaluate whether the discarded SNPs do indeed exhibit excessive levels of heterozygosity, indicative of paralogous loci.",sep="\n")
				cat("If so, rerun the filterdata function with a higher threshold 'maxprop_hefilter' value.",sep="\n")
				cat("If not, set the flag dohefilter to FALSE, or rerun the filterdata function with different heterozygosity filter settings, as defined by the 'paralog_threshold1' (default=0.5) and 'paralog_threshold2' flags (default=0.05).",sep="\n")
				return(cat("SambaR's heterozygosity excess filter defines he-excess as: He>(2pq+zq) for q>w, with p and q representing major and minor allele frequency, and z and w representing threshold1 and threshold2.",sep="\n"))  
				}
			}
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		#
		mysambar$indmissfilter	<<- indmiss
		mysambar$snpmissfilter	<<- snpmiss
		mysambar$min_mac		<<- min_mac
		mysambar$hefilter		<<- dohefilter
		mysambar$snpdepthfilter	<<- snpdepthfilter&("meandepth"%in%colnames(snps))
		#
		indsmissingness(prior2snpfilter=FALSE)		# calculate missingness per individual for retained snp dataset
		nretainedinds	<- nrow(inds[inds$filter,])
		ntotalinds		<- nrow(inds)
		nretainedsnps	<- nrow(snps[snps$filter2,])
		nthinnedsnps	<- nrow(snps[snps$filter,])
		ntotalsnps		<- nrow(snps)	
		cat(paste("After filtering retained",nretainedinds,"out of",ntotalinds,"individuals.",sep=" "),sep="\n")
		cat(paste("After filtering retained",nretainedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
		cat(paste("After filtering and thinning retained",nthinnedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
		#
		# 25-04-2021: moved to function: calckinship()
		if(do_calckin)
			{
			cat("As of 25-04-2021, relatedness calculations are no longer part of the filterdata function.",sep="\n")
			cat("Instead, run the calckinship() function.",sep="\n")
			}
		# inds maf/he:
		cat ("Step 4 out of 6: Calculating sample specific minor allele frequencies and heterozygosities...",sep="\n")
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		if(!silent){cat("ind_maf",sep="\n")}
		ind_maf(allsites=FALSE)
		ind_maf(allsites=TRUE)
		if(!silent){cat("ind_hetero",sep="\n")}
		ind_hetero(allsites=FALSE)
		ind_hetero(allsites=TRUE)
		if(!silent){cat("hwe",sep="\n")}
		if(length(mysambar$populations)<9){hwe(export="eps")}
		hwe(export="pdf")			
		hwe(export="png")
		if(mysambar$os=="Windows"){hwe(export="wmf")}
		cat("FILTERS HAVE BEEN SUCCESFULLY SET. ANY ERRORS OCCURRING AFTER THIS LINE ARE (MOSTLY) RELATED TO CREATING QUALITY CONTROL TABLES AND PLOTS AND WILL NOT DENY YOU FROM RUNNING SUBSEQUENT FUNCTIONS.",sep="\n")
		#
		cat("Step 5 out of 6: Generating summary table...",sep="\n")
		mysummarytable()
		cat("Step 6 out of 6: Generating summary plots...",sep="\n")
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		if(!any(snps$pos!=0))
			{
			cat("No information on genomic positions of SNP. Not creating 'Chrom_length' plots.",sep="\n")
			}else{
			if(length(unique(snps$chr))>1)
				{
				if(!silent){cat("plotscaffoldsize",sep="\n")}
				plotscaffoldsize(export="eps",n_chroms=nchroms)
				plotscaffoldsize(export="pdf",n_chroms=nchroms)
				plotscaffoldsize(export="png",n_chroms=nchroms)
				if(mysambar$os=="Windows"){plotscaffoldsize(export="wmf",n_chroms=nchroms)}
				if(any(snps$chrlength!=0))
					{
					if(!silent){cat("chrlength_vs_nsnps",sep="\n")}
					chrlength_vs_nsnps(export="eps")
					chrlength_vs_nsnps(export="pdf")
					chrlength_vs_nsnps(export="png")
					if(mysambar$os=="Windows"){chrlength_vs_nsnps(export="wmf")}
					}
				if(!is.null(nchroms))
					{
					if(!silent){cat("barplotnsnps",sep="\n")}
					barplotnsnps(n_chroms=nchroms,export="eps")
					barplotnsnps(n_chroms=nchroms,export="pdf")
					barplotnsnps(n_chroms=nchroms,export="png")
					if(mysambar$os=="Windows"){barplotnsnps(n_chroms=nchroms,export="wmf")}
					if(!silent){cat("chromhetero",sep="\n")}
					chromhetero(nchroms=nchroms,export="pdf")	# determine male and females based on X-chromosome
					}
				}else{
				cat("Not plotting nsnps per scaffold, because only 1 scaffold detected.",sep="\n")
				}
			}
		if(!is.null(ychrom))
			{
			plot_Ychrom(export="pdf",y_chrom=ychrom)	# determine male and females based on Y-chromosome
			}
		if(is.null(mysambar$missdf))
			{
			nind		<- nrow(inds)
			npairwise	<- (nind*(nind-1))/2
			nsnp		<- nrow(snps[snps$filter,])
			ntotal		<- nsnp*nind
			if(ntotal>6000000)
				{
				cat("The dataset is quite big. Omitting pairwise sample missingness plots for sake of calculation time.",sep="\n")
				cat("If you want to create these plots, run the functions:",sep="\n")
				cat("calcpairmiss(exporttype='pdf',definebreaks=TRUE,snpsfilter=TRUE,silent=FALSE)",sep="\n")
				cat("showmiss(export='pdf')",sep="\n")
				}else{
				if(min(inds$miss,na.rm=TRUE)>0)
					{
					if(!silent){cat("calcpairmiss",sep="\n")}
					calcpairmiss(exporttype="pdf",definebreaks=TRUE,use_currentdir=TRUE,silent=TRUE,snpsfilter=TRUE,legendcex=1.4,nrbins=20,addmiss=TRUE)
					}
				if(!silent){cat("showmiss",sep="\n")}
				if(min(inds$miss,na.rm=TRUE)>0)
					{
					showmiss(export="pdf")
					}
				}
			}else{
			if(min(inds$miss,na.rm=TRUE)>0)
				{
				if(!silent){cat("calcpairmiss",sep="\n")}
				calcpairmiss(exporttype="pdf",definebreaks=TRUE,use_currentdir=TRUE,silent=TRUE,snpsfilter=TRUE,legendcex=1.4,nrbins=20,addmiss=TRUE)	# only plotting (in built conditional to omit calculations if mysambar$kindf is already present.
				#calcpairmiss(exporttype="pdf",definebreaks=TRUE,use_currentdir=TRUE,silent=TRUE,snpsfilter=FALSE,legendcex=1.4,nrbins=20,addmiss=TRUE)
				}
			}
		if(!silent){cat("plotHe_perind",sep="\n")}
		plotHe_perind(export="eps")
		plotHe_perind(export="pdf")
		plotHe_perind(export="png")
		if(mysambar$os=="Windows"){plotHe_perind(export="wmf")}
		if(!silent){cat("plotgenocounts_ind",sep="\n")}
		plotgenocounts_inds(export=TRUE,addlabels=TRUE,metapop=TRUE)
		plotgenocounts_inds(export=TRUE,addlabels=FALSE,metapop=TRUE)
		plotgenocounts_inds(export=TRUE,addlabels=TRUE,metapop=FALSE)
		plotgenocounts_inds(export=TRUE,addlabels=FALSE,metapop=FALSE)
		#if(!silent){cat("plotn2",sep="\n")}
		#plotn2(export="pdf")
		if(!silent){cat("plotgenotri",sep="\n")}
		plotgenotri(export="eps",allsites=FALSE)
		plotgenotri(export="pdf",allsites=FALSE)
		plotgenotri(export="png",allsites=FALSE)
		if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
		plotgenotri(export="eps",allsites=TRUE)
		plotgenotri(export="pdf",allsites=TRUE)
		plotgenotri(export="png",allsites=TRUE)
		if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
		heall_vs_he(export="eps")
		heall_vs_he(export="pdf")
		heall_vs_he(export="png")
		if(mysambar$os=="Windows"){heall_vs_he(export="wmf")}
		if(!silent){cat("glPlot",sep="\n")}
		genoheatmap(export=TRUE,dofilter=TRUE)
		genoheatmap(export=TRUE,dofilter=FALSE)
		if(length(mysambar$populations)>1)
			{
			if(!silent){cat("retainedinds_perpop",sep="\n")}
			retainedinds_perpop(export="eps")
			retainedinds_perpop(export="pdf")
			retainedinds_perpop(export="png")
			if(mysambar$os=="Windows"){retainedinds_perpop(export="wmf")}
			if(!silent){cat("discardedinds_perpop",sep="\n")}
			if(any(!inds$filter))
				{
				discardedinds_perpop(export="eps")
				discardedinds_perpop(export="pdf")
				discardedinds_perpop(export="png")
				if(mysambar$os=="Windows"){discardedinds_perpop(export="wmf")}
				}else{
				cat("All individuals retained. Omitting 'Discardedinds.perpop' plots.",sep="\n")
				}
			# showing retained and discarded combined in one plot:
			if(!silent){cat("indsfilter_perpop",sep="\n")}
			indsfilter_perpop(export="eps",popnames=mysambar$populations)
			indsfilter_perpop(export="pdf",popnames=mysambar$populations)
			indsfilter_perpop(export="png",popnames=mysambar$populations)
			if(mysambar$os=="Windows"){indsfilter_perpop(export="wmf",popnames=mysambar$populations)}
			if(!silent){cat("retainedsites_perpop",sep="\n")}
			retainedsites_perpop(export="eps")
			retainedsites_perpop(export="pdf")
			retainedsites_perpop(export="png")
			if(mysambar$os=="Windows"){retainedsites_perpop(export="wmf")}
			}
		if("meandepth"%in%colnames(snps))
			{
			if(!silent){cat("plotlocusdepth",sep="\n")}
			plotlocusdepth(export=TRUE)			# This is in fact mean individual depth, different from plot created in snpsmissingness function.
			}
		if(!silent){cat("plot_number_segregating_sites",sep="\n")}
		plot_number_segregating_sites(export="eps",dofilter=TRUE)
		plot_number_segregating_sites(export="pdf",dofilter=TRUE)
		plot_number_segregating_sites(export="png",dofilter=TRUE)
		if(mysambar$os=="Windows"){plot_number_segregating_sites(export="wmf",dofilter=TRUE)}
		plot_number_segregating_sites(export="eps",dofilter=FALSE)
		plot_number_segregating_sites(export="pdf",dofilter=FALSE)
		plot_number_segregating_sites(export="png",dofilter=FALSE)
		if(mysambar$os=="Windows"){plot_number_segregating_sites(export="wmf",dofilter=FALSE)}
		#if(mysambar$datasource=="converted_from_genlight")
		#	{
		#	cat("Skipping GC-content table and transition-vs-transition plot because data has been converted from a genlight object, and this information got lost.",sep="\n")
		#	}else{
			if(!silent){cat("plotminor",sep="\n")}
			plotminor(export="eps")
			plotminor(export="pdf")
			plotminor(export="png")
			if(mysambar$os=="Windows"){plotminor(export="wmf")}
			if(!silent){cat("plottransits",sep="\n")}
			plottransits(filter=FALSE,export="eps")
			plottransits(filter=FALSE,export="pdf")
			plottransits(filter=FALSE,export="png")
			if(mysambar$os=="Windows"){plottransits(filter=FALSE,export="wmf")}
			plottransits(filter=TRUE,export="eps")
			plottransits(filter=TRUE,export="pdf")
			plottransits(filter=TRUE,export="png")
			if(mysambar$os=="Windows"){plottransits(filter=TRUE,export="wmf")}
		#	}
		if(!silent){cat("plotfiltermaf",sep="\n")}
		if(length(mysambar$populations)<9){plotfiltermaf(export="eps")}	# figure margins too large if 10 pops
		plotfiltermaf(export="pdf")
		plotfiltermaf(export="png")
		if(mysambar$os=="Windows"){plotfiltermaf(export="wmf")}
		if("dist" %in% colnames(snps)&do_mafdiff)
			{
			if(!silent){cat("multimafdiff",sep="\n")}
			multimafdiff()
			}
		if(length(mysambar$populations)>1)
			{
			if(!silent){cat("histo_locusHe",sep="\n")}
			if(length(mysambar$populations)<9){histo_locusHe(export="eps")}
			histo_locusHe(export="pdf")
			histo_locusHe(export="png")
			if(mysambar$os=="Windows"){histo_locusHe(export="wmf")}
			if(!silent){cat("boxplot_locusHe",sep="\n")}
			boxplot_locusHe(export="eps")
			boxplot_locusHe(export="pdf")
			boxplot_locusHe(export="png")
			if(mysambar$os=="Windows"){boxplot_locusHe(export="wmf")}
			}
		if(!silent){cat("plotparalogs",sep="\n")}
		plotparalogs(export="eps")
		plotparalogs(export="pdf")
		plotparalogs(export="png")
		if(mysambar$os=="Windows"){plotparalogs(export="wmf")}
		plotparalogs(export="eps",dothin=TRUE)
		plotparalogs(export="pdf",dothin=TRUE)
		plotparalogs(export="png",dothin=TRUE)
		if(mysambar$os=="Windows"){plotparalogs(export="wmf",dothin=TRUE)}
		if("meandepth"%in%colnames(inds))
			{
			if(!silent){cat("He_vs_readdepth",sep="\n")}
			He_vs_readdepth(export="eps",allsites=TRUE,legendcex=legend_cex)
			He_vs_readdepth(export="pdf",allsites=TRUE,legendcex=legend_cex)
			He_vs_readdepth(export="png",allsites=TRUE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_readdepth(export="wmf",allsites=TRUE,legendcex=legend_cex)}
			He_vs_readdepth(export="eps",allsites=FALSE,legendcex=legend_cex)
			He_vs_readdepth(export="pdf",allsites=FALSE,legendcex=legend_cex)
			He_vs_readdepth(export="png",allsites=FALSE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_readdepth(export="wmf",allsites=FALSE,legendcex=legend_cex)}
			}
		if(!silent){cat("He_vs_miss",sep="\n")}
		if(max(inds$miss,na.rm=TRUE)>0)
			{
			He_vs_miss(export="eps",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="pdf",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="png",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_miss(export="wmf",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)}
			He_vs_miss(export="eps",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="pdf",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="png",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_miss(export="wmf",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)}
			}else{
			cat("No missing data. Skipping He_vs_miss plot.",sep="\n")
			}
		#
		# optionally plot statistics per sequencing pool:
		if(!silent){cat("plotperpool",sep="\n")}
		plotperpool()
		# stacks_demultiplex()
		#
		# create a report of filter settings:
		mysettings			<- data.frame("settings"=c("date/time","indmiss","snpmiss","minimum_minor_allele_count","dohefilter","min_spacing"),"value"=rep(NA,6))
		mysettings$value[1]	<- as.character(Sys.time())
		mysettings$value[2]	<- as.character(indmiss)
		mysettings$value[3]	<- as.character(snpmiss)
		mysettings$value[4]	<- ifelse(is.null(min_mac),"0",as.character(min_mac))
		mysettings$value[5]	<- as.character(dohefilter)
		mysettings$value[6]	<- as.character(ifelse("dist"%in%colnames(snps),min_spacing,0))
		write.table(mysettings,"SambaR_filtersettings.txt",row.names=FALSE,col.names=FALSE,quote=FALSE,sep="\t")
		# create a file with information about filter settings per individual:
		if(!silent){cat("SambaR_samples.filterinfo.txt",sep="\n")}
		indstable	<- inds[,c("name","nr","pop","pop2","popcol","filter","miss","nsites2","hetero_all","hetero")]
		colnames(indstable)<- c("name","nr","pop","pop2","popcol","filter","prop_miss","n_retained_sites","hetero_retained_sites","hetero_segregating_sites")
		write.table(indstable,"SambaR_samples.filterinfo.txt",row.names=FALSE,sep="\t",quote=FALSE)
		#
		if(!silent){cat("exporthighestsd",sep="\n")}
		if(do_highestsd)
			{
			if(length(mysambar$populations)>1)
				{
				cat("Exporting data subsets with highly informative SNPs.",sep="\n") 
				cat("By default, subsets are exported with the most informative 10, 20, 50, 100, 150, and 250 SNPs.",sep="\n")
				cat("To export a subset with a different number of most informative SNPs (for example: 500), type on the command line: exporthighestsd(nsnps=500).",sep="\n")  
				cat("If you receive an error after this line, rerun the filterdata function with the flag 'do_highestsd' set to FALSE.",sep="\n") 
				exporthighestsd(nsnps=c(10,20,50,100,150,250),silent=TRUE)
				}else{
				cat("Only 1 population defined. Skipping selection of most informative SNPs.",sep="\n")
				}
			}else{
			cat("The flag 'do_highestsd' is set to FALSE. Skipping selection of most informative SNPs.",sep="\n")
			}
		#
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values. Contact the developer of SambaR.",sep="\n"))
			}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values. Contact developer of SambaR.",sep="\n"))
			}
		cat("Finished filtering dataset. Summary plots and tables have been written to:",sep="\n")
		cat(mysambar$QCdir,sep="\n")
		#
		setwd(mysambar$sambardir)
		exportmethods(ind_miss=indmiss,snp_miss=snpmiss,minmac=min_mac,hefilter=dohefilter,minimumspacing=min_spacing)
		cat("A description of the methods has been written to a txt.file called 'SambaR_methods.txt' within the directory:",sep="\n")
		cat(mysambar$sambardir,sep="\n")
		setwd(mysambar$inputdatadir)
		cat("To export the retained dataset in immanc format (i.e. Bayesass input) as well as PED/MAP format (for relatedness and LD calculations in plink), type on the command line:",sep="\n")
		cat("exportsambarfiles()",sep="\n")
		cat("Note: as of 25-04-2021 (Sambar version 1.04), inbreeding and kinship calculations/plots are executed/generated with the calckinship function and outputted to the 'Kinship' subdirectory.",sep="\n")  
		}
	}

runthinfilter<-function(overwrite_bin=TRUE,binsize=500,silent=TRUE)
	{
	if(binsize<0)
		{
		return(cat("ERROR: binsize should be positive.",sep="\n"))
		}
	if(binsize==0)
		{
		snps$distfilter							<<- TRUE
		return(cat("WARNING: binsize set to 0. As a consequence, no thinning will be applied. All values in distfilter column will be set to TRUE.",sep="\n"))
		}
	if(!"pos"%in%colnames(snps))
		{
		return(cat("ERROR: column snps$pos is missing.",sep="\n"))
		}
	if(any(is.na(snps$pos)))
		{
		cat("WARNING: NA-values present in snps$pos column.",sep="\n")
		}
	if("dist" %in% colnames(snps))
		{
		if("distclass"%in%colnames(snps)&!overwrite_bin)
			{
			cat("WARNING: Using existing position bins defined in column snps$distclass.",sep="\n")
			cat("If you want to create new position bins, set the flag overwrite_bin to TRUE or alternatively delete existing column.",sep="\n")
			}else{
			cat("Dividing snps into bins based on position in genome...",sep="\n")
			cat(paste("Using bins of ",binsize," bp width.",sep=""),sep="\n")  
			snps$distclass	<<- NA
			mychroms		<- as.vector(unique(snps$chr))
			for(mychrom in mychroms)
				{
				if(!silent){cat(mychrom,sep="\n")}
				mysnpspos							<- snps$pos[snps$chr==mychrom]
				if(length(mysnpspos)>1)
					{
					mybreaks						<- seq(0,max(mysnpspos,na.rm=TRUE)+binsize,binsize)
					if(length(mybreaks)==1)
						{
						if(mybreaks==0)
							{
							snps$distclass[snps$chr==mychrom]<<- paste(as.character(mychrom),as.character(binsize/2),sep="_")
							}else{
							mylabelstemp	<- mybreaks-binsize/2
							mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
							snps$distclass[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
							}
						}else{
						mylabelstemp		<- mybreaks[2:length(mybreaks)]-binsize/2
						mylabels			<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
						snps$distclass[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
						}
					}else{
					snps$distclass[snps$chr==mychrom]	<<- paste(as.character(mychrom),as.character(mysnpspos),sep="_")
					}
				}
			if(any(is.na(snps$distclass)))
				{
				nna	<- length(which(is.na(snps$distclass)))
				cat(paste("WARNING: ",nna," NA-values in distclass column.",sep=""),sep="\n")
				}
			#
			cat("Selecting one snp per position bin.",sep="\n")
			snps$distfilter						<<- NA
			snps$distfilter						<<- !duplicated(snps$distclass)
			#
			# adjusting NA's:
			myclass1					<- snps$distclass[1:(nrow(snps)-1)]
			myclass2					<- snps$distclass[2:nrow(snps)]
			mybool						<- c(TRUE,myclass1!=myclass2)
			snps$distfilter				<<- ifelse(is.na(snps$distfilter),mybool,snps$distfilter)	
			#
			if(any(is.na(snps$distfilter)))
				{
				nna	<- length(which(is.na(snps$distfilter)))
				cat(paste("WARNING: ",nna," NA-values in distfilter column. Replacing with FALSE.",sep=""),sep="\n")
				}
			snps$distfilter[is.na(snps$distfilter)]	<<- FALSE
			nretained								<- nrow(snps[snps$distfilter,])
			cat(paste("Number of SNPs retained after thinning: ",nretained,".",sep=""),sep="\n")  
			}
		}else{
		cat("WARNING: No positional information. All values in distfilter column will be set to TRUE.",sep="\n")
		snps$distfilter							<<- TRUE
		}
	}

mergepop<-function(sourcepop=NULL,targetpop=NULL)
	{
	if(is.null(sourcepop))
		{
		return(cat("ERROR: provide name(s) of population(s) to be merged into another population.",sep="\n"))
		}
	if(is.null(targetpop))
		{
		return(cat("ERROR: provide name(s) of population(s) in which other populations should be merged into.",sep="\n"))
		}
	if(length(sourcepop)!=length(targetpop))
		{
		return(cat("ERROR: input vectors provided to sourcepop and targetpop should be of the same length.",sep="\n"))
		}
	popvector		<- as.character(inds$pop)
	mypops			<- mysambar$populations
	mycolours		<- mysambar$mycolours
	for(j in c(1:length(sourcepop)))
		{
		mysource	<- as.character(sourcepop[j])
		mytarget	<- as.character(targetpop[j])
		cat(paste("Merging population ",mysource," into population ",mytarget,".",sep=""),sep="\n")
		if(mysource==mytarget)
			{
			return(cat("ERROR: sourcepop and targetpop can not be the same.",sep="\n"))
			}
		if(!mysource%in%popvector)
			{
			return(cat("ERROR: sourcepop does not occur inds$pop column.",sep="\n"))
			}
		if(!mytarget%in%popvector)
			{
			return(cat("ERROR: sourcepop does not occur inds$pop column.",sep="\n"))
			}
		popvector[popvector==mysource]	<- mytarget
		mycolours	<- mycolours[!mypops%in%sourcepop]
		mypops		<- mypops[!mypops%in%sourcepop]
		}
	inds$pop				<<- as.factor(popvector)
	mysambar$populations	<<- mypops
	mysambar$populations2	<<- mypops
	mysambar$mycolours		<<- mycolours
	mysambar$mycolours2		<<- mycolours
	}

excludepop<-function(do_exclude=NULL,retain=FALSE,popvector=NULL)
	{
	if((!exists("inds"))|(!exists("mysambar")))
		{
		return(cat("ERROR: objects inds and/or mysambar not found.",sep="\n"))
		}
	if(!is.null(do_exclude))
		{
		cat("WARNING: as of 28-10-2021, the flag do_exclude has been replaced by the flag 'popvector'.",sep="\n")
		cat("The input vector to the popvector flag defines the names of populations to be either excluded or retained, depending on the flag 'retain' (default is FALSE, meaning: exclude).",sep="\n")
		cat("Renaming do_exclude to popvector and continuing...",sep="\n")
		popvector	<- do_exclude 	
		}
	# exclude population:
	if(!"filter2"%in%colnames(inds))
		{
		return(cat("ERROR: Column filter2 not present in inds dataframe. Did you run the filterdata() function?",sep="\n"))
		}
	if(is.null(mysambar$poporder))
		{
		return(cat("ERROR: mysambar$poporder missing.",sep="\n"))
		}
	cat("Resetting filters...",sep="\n")
	mysambar$mycolours	<<- mysambar$mycolours2
	mysambar$populations<<- mysambar$populations2
	mysambar$poporder	<<- mysambar$poporder2
	mysambar$colorder	<<- mysambar$colorder2
	mysambar$popordernr	<<- mysambar$popordernr2
	inds$filter			<<- inds$filter2
	if(is.null(popvector))
		{
		return(cat("WARNING: no population name provided to the popvector flag. Not excluding any population.",sep="\n"))
		}else{
		if(retain)
			{
			cat("The flag 'retain' is set to TRUE, meaning that the specified populations will be retained.",sep="\n")
			mybool				<- mysambar$populations2%in%popvector
			mybool2				<- mysambar$poporder2%in%popvector
			excludepopvector	<- mysambar$populations2[!mysambar$populations2%in%popvector]
			}else{
			cat("The flag 'retain' is set to FALSE, meaning that the specified populations will be excluded.",sep="\n")
			mybool				<- !mysambar$populations2%in%popvector
			mybool2				<- !mysambar$poporder2%in%popvector
			excludepopvector	<- popvector
			}
		mysambar$populations	<<- mysambar$populations2[mybool]
		mysambar$mycolours		<<- mysambar$mycolours2[mybool]
		mysambar$poporder		<<- mysambar$poporder2[mybool2]
		mysambar$colorder		<<- mysambar$colorder2[mybool2]
		#
		for (k in c(1:length(excludepopvector)))
			{
			my_pop				<- excludepopvector[k]
			cat(paste("Excluding population: ",my_pop,".",sep=""),sep="\n")
			inds$filter			<<- inds$filter&inds$pop!=my_pop
			}
		#
		popordernr				<- vector()
		for(i in c(1:length(mysambar$poporder)))
			{
			mypop				<- as.character(mysambar$poporder[i])
			mypopnr				<- which(as.character(mysambar$populations)==mypop)
			if(length(mypopnr)==0)
				{
				return(cat(paste("ERROR: Population name ",mypop," not present in actual data.",sep=""),sep="\n"))
				}
			popordernr[i]		<- mypopnr
			}
		mysambar$popordernr		<<- popordernr
		}
	}

exporthighestsd<-function(nsnps=c(10,20,50,100,150,250),silent=TRUE)
	{
	if(!"sd_popmaf"%in%colnames(snps))
		{
		return(cat("ERROR: Column 'sd_popmaf' not present in snps dataframe. First run the filterdata() function.",sep="\n")) 
		}
	mywd	<- getwd()
	setwd(mysambar$inputfilesdir)
	# 18-3-2020: this myfilter and sd filter still needs to be included in pcoa function:
	# first get filter settings:
	popmafs 				<- snps[,grep("maf_",colnames(snps))]
	mafmin					<- apply(popmafs,1,min)
	nodatavec				<- !is.na(rowSums(popmafs))
	mysd					<- snps$sd_popmaf
	myfilter				<- (snps$filter)&(mafmin>0)&(nodatavec)&is.finite(mysd)&!is.na(mysd)
	n_snps					<- nrow(snps[myfilter,])
	if(n_snps<250)
		{
		return(cat("Less than 250 retained SNPs of which the minor allele is present in all populations. Aborting exporthighestsd() function.",sep="\n")) 
		}
	# now select:
	mysd					<- mysd[myfilter] 
	snpsfiltered			<- snps[myfilter,]
	snpstemp				<- snpsfiltered[order(-mysd),]
	for (nsubset in nsnps)
		{
		if(!silent){cat(paste(nsubset,"SNPs",sep=" "),sep="\n")}
		snpsubset	<- head(snpstemp,nsubset)
		thres		<- min(snpsubset$sd_popmaf,na.rm=TRUE)
		myselection	<- snps$sd_popmaf>=thres&myfilter
		genlight2ped(snpsfilter=myselection,indsfilter=inds$filter,exportname=paste("metapop",nsubset,"SNPs.highest_popmaf_sd.number",sep="."),quiet=TRUE) 
		}
	cat("Datasets with small subsets of most informative SNPs (highest standard deviation of population minor allele frequencies) exported to:",sep="\n")
	cat(getwd(),sep="\n")
	setwd(mywd)
	}

exportsambarfiles<-function(do_immanc=TRUE,do_pednumber=TRUE,do_pedletter=TRUE,do_treemix=TRUE)
	{
	setwd(mysambar$inputfilesdir)
	if(do_immanc)
		{
		if(length(mysambar$populations)>1)
			{
			cat("Exporting input for Bayesass ('Bayesassinput.immanc.txt')...",sep="\n")
			genlight2immanc(quiet=TRUE)
			}else{
			cat("Currently only 1 population defined. Not exporting Bayesass input ('Bayesassinput.immanc.txt').",sep="\n")
			}
		}
	#
	if(do_treemix)
		{
		exporttreemix()
		}
	if(do_pednumber)
		{
		cat("Exporting input for plink relatedness (pi_hat) calculations ('metapop.allinds.filter.number.ped' and 'metapop.allinds.filter.number.map)...",sep="\n")
		genlight2ped(snpsfilter=snps$filter,indsfilter=rep(TRUE,nrow(inds)),exportname="metapop.allinds.filter.number",quiet=TRUE) 		
		cat("Exporting input for Admixture software and plink relatedness (pi_hat) calculations ('metapop.filter.number.ped' and 'metapop.filter.number.map)...",sep="\n")
		genlight2ped(snpsfilter=snps$filter,indsfilter=inds$filter,exportname="metapop.retainedinds.filter.number",quiet=TRUE)
		# 17-06-2019: This was originally called 'Relatednessinput'
		# 16-03-2019: I made changes to include all samples in the output file.
		cat("Exporting input for plink LD calculations (files ending on 'filter2.number.ped' and 'filter2.number.map'). This make take a while...",sep="\n")	
		exportdata(snpsfilter=snps$filter2,indsfilter=inds$filter,export_name="filter2.number",quiet2=TRUE)
		}
	#
	if(do_pedletter)
		{
		cat("Exporting input for 'plink --recode vcf' command (files ending on 'filter.number.ped' and 'filter.number.map'), in case you would like to convert filtered datasets (back) to vcf format.",sep="\n")
		exportdata(snpsfilter=snps$filter,indsfilter=inds$filter,export_name="filter.letter",geno_nr=FALSE,quiet2=TRUE)
		}
	#
	setwd(mysambar$inputdatadir)
	cat("Filtered datasets have been written to:",sep="\n")
	cat(mysambar$inputfilesdir,sep="\n")
	}

calcretainedsnps<-function(export=NULL,logy=FALSE,silent=FALSE,wide_plot=FALSE,linewidth=3)
	{
	my_wd			<- getwd()
	indmissvector	<- c(0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.075,0.1,0.15,0.2,0.25,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)
	snpmissvector	<- c(0.2,0.1,0.05,0.02,0.01,0)
	if(!"miss"%in%colnames(inds))
		{
		mat 		<- as.matrix(mygenlight)
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		}
	if(!is.null(export))
		{
		if(wide_plot)
			{
			mywidth=16
			myheight=8
			mywidth2=1200
			myheight2=600
			}else{
			mywidth=10.5
			myheight=10.5
			mywidth2=720
			myheight2=720
			}
		mylabel	<- ifelse(logy,"log_yaxis","linear_yaxis")
		if(export=="eps"){postscript(paste("Data_quality",mylabel,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste("Data_quality",mylabel,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste("Data_quality",mylabel,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste("Data_quality",mylabel,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	par(mar=c(5,7,8.5,1.5),cex.axis=2.5,cex.lab=3)
	if(logy)
		{
		x			<- c(1,nrow(mygenlight))
		y			<- c(1,ncol(mygenlight))
		plot(x,y,col="white",log="y",xlab="",ylab="",las=1,yaxt='n')
		myaxis		<- c(100,500,1000,5000,10000,50000,100000)
		axis(2,at=myaxis,labels=myaxis/1000,las=1)
		abline(h=myaxis,col="grey95")
		}else{
		x			<- c(0,nrow(mygenlight))
		y			<- c(0,ncol(mygenlight))
		plot(x,y,col="white",yaxt='n',xlab="",ylab="")
		if(ncol(mygenlight)>20000)
			{
			myaxis		<- seq(0,ncol(mygenlight),10000)
			}else{
			myaxis		<- seq(0,ncol(mygenlight),1000)
			}
		axis(2,at=myaxis,labels=myaxis/1000,las=1)
		abline(h=myaxis,col="grey95")
		}
	if(is.null(mysambar$snpmissmat))
		{
		setwd(mysambar$sambardir)
		if(file.exists("Data_quality.txt"))
			{
			cat("Using existing table 'Data_quality.txt' in the directory:",sep="\n")
			cat(getwd(),sep="\n")
			snpmissmat			<- read.table("Data_quality.txt",header=FALSE)
			do_analysis			<- FALSE
			mysambar$snpmissmat	<<- snpmissmat
			nretainedinds		<- snpmissmat[nrow(snpmissmat),]
			}else{
			do_analysis			<- TRUE
			snpmissmat			<- matrix(NA,nrow=length(snpmissvector)+1,ncol=length(indmissvector))
			cat("Data_quality.txt file is not present. Creating datafile now.",sep="\n")
			cat("This will take some time, but the next time you run the importdata() function this step will be automatically omitted and then it will be much faster.",sep="\n") 
			nretainedinds		<- snpmissmat[nrow(snpmissmat),] 
			}
		}else{
		cat("Using existing table saved at mysambar$snpmissmat.",sep="\n")
		do_analysis				<- FALSE
		snpmissmat				<- mysambar$snpmissmat
		nretainedinds			<- snpmissmat[nrow(snpmissmat),]
		}
	if(length(nretainedinds)!=length(indmissvector))
		{
		cat("WARNING: number of columns of data quality matrix does not equal expected length (length 'indmissvector').",sep="\n")
		cat("Redoing analyses...")
		cat("This will take some time, but the next time you run the importdata() function this step will be automatically omitted and then it will be much faster.",sep="\n") 
		do_analysis			<- TRUE
		snpmissmat			<- matrix(NA,nrow=length(snpmissvector)+1,ncol=length(indmissvector))
		nretainedinds		<- snpmissmat[nrow(snpmissmat),] 
		}
	mycolfunc 					<- colorRampPalette(c("orange","grey80"))
	mycolours					<- mycolfunc(length(snpmissvector)-1)
	mycolours					<- c(mycolours,"black")
	for (k in c(1:length(snpmissvector)))
		{
		max_miss				<- snpmissvector[k]
		if(!do_analysis)
			{
			nretainedinds		<- snpmissmat[nrow(snpmissmat),]
			nretainedsnps		<- snpmissmat[k,]
			}else{
			nretainedinds		<- vector()
			nretainedsnps		<- vector()
			for (j in c(1:length(indmissvector)))
				{
				mymiss			<- indmissvector[j]
				myselection		<- inds$miss<=mymiss
				ninds			<- length(myselection[myselection])
				indmiss			<- inds$miss[myselection]
				nretainedinds[j]<- ninds 
				if(ninds==0)
					{
					nretainedsnps[j]	<- 0
					}else{
					tempgenlight		<- mygenlight[myselection,]
					missingpersnp		<- glNA(tempgenlight,alleleAsUnit=FALSE)/nInd(tempgenlight)
					nretainedsnps[j]	<- length(which(missingpersnp<=max_miss))
					}
				}
			if(k==1)
				{
				snpmissmat[nrow(snpmissmat),]<- nretainedinds
				}
			snpmissmat[k,]					<- nretainedsnps	
			}
		if(k==1)
			{
			abline(v=nretainedinds,col="grey95")
			}
		points(x=nretainedinds[nretainedinds>0],y=nretainedsnps[nretainedinds>0],col=mycolours[k],lwd=linewidth,type='b')
		setwd(my_wd)
		}
	legend("bottomleft",legend=snpmissvector,fill=mycolours,bty='n',cex=2.5,title="snpmiss:")
	axis(side=3,at=nretainedinds,labels=indmissvector,las=2)
	mtext(side=1,"Retained individuals",line=3.5,cex=3)
	mtext(side=2,"Retained SNPs (k)",line=4.75,cex=3)
	mtext(side=3,"indmiss",line=6,cex=3)
	mtext(text=indmissvector,side=1,line=-0.1,at=nretainedinds,adj=0,cex=0.25,las=2)
	if(!is.null(export))
		{
		dev.off()
		if(!silent)
			{
			myplotname	<- paste("Data_quality",mylabel,sep=".")
			cat(paste("File called '",myplotname, "' written to directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	if(do_analysis)
		{
		setwd(mysambar$sambardir)
		colnames(snpmissmat)	<- indmissvector
		rownames(snpmissmat)	<- c(snpmissvector,"ninds")
		mysambar$snpmissmat		<<- snpmissmat
		write.table(snpmissmat,"Data_quality.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=FALSE)
		}
	setwd(my_wd)
	}
	
miss_sd<-function(popnames=mysambar$populations)
	{
	npops				<- length(popnames)
	if(npops>1)
		{
		popmiss 			<- snps[,grep("miss_",colnames(snps))]
		snps$sd_popmiss		<<- apply(popmiss,1,function(x) sd(x))
		}else{
		snps$sd_popmiss		<<- NA
		}
	snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	boxplot(snps$sd_popmiss~snps$filter)
	}

# 13-03-20: Not sure this plot is very useful. 
showmiss<-function(export=NULL,doindsfilter=TRUE,dosnpsfilter=FALSE)
	{
	ninds	<- nrow(inds)
	nsnps	<- nrow(snps)
	# next lines are to ensure that matrix does not contain more than 500 columns.
	if(nsnps>1000000)
		{
		return(cat("More than 1000000 SNPs. Omitting 'Missingdata.matrix'.",sep="\n"))
		}
	if(nsnps<=1000000)
		{
		winsize		<- 2000
		}
	if(nsnps<=500000)
		{
		winsize		<- 1000
		}
	if(nsnps<=100000)
		{
		winsize		<- 200
		}
	if(nsnps<=50000)
		{
		winsize		<- 100
		}
	my_wd	<- getwd()
	setwd(mysambar$QCdir)
	if(!file.exists("Miss.matrix.txt"))
		{
		mybreaks		<- seq(0,nsnps,winsize)
		nbreaks			<- length(mybreaks)
		mystartvec		<- mybreaks[1:(nbreaks-1)]
		mystartvec		<- mystartvec+1
		myendvec		<- mybreaks[2:nbreaks]
		nwin			<- length(mybreaks)-1
		mymissmatrix	<- matrix(NA,nrow=ninds,ncol=nwin)
		for(j in c(1:nwin))
			{
			mystart		<- mystartvec[j]
			myend		<- myendvec[j]
			mat 		<- as.matrix(mygenlight[,c(mystart:myend)])
			nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) 	# number of NA per individual
			mymissmatrix[,j]<- nNA/ncol(mat) 								# fraction of NA per individual
			}
		write.table(mymissmatrix,"Miss.matrix.txt",row.names=FALSE,col.names=FALSE,sep="\t",quote=FALSE)
		}else{
		mymissmatrix	<- as.matrix(read.table("Miss.matrix.txt",header=FALSE))
		}
	myorder						<- order(inds$pop)
	indstemp					<- inds[myorder,]
	mymissmatrix				<- mymissmatrix[myorder,]
	mypopcols					<- indstemp$popcol
	if(doindsfilter)
		{
		mypopcols				<- mypopcols[indstemp$filter]
		mymissmatrix			<- mymissmatrix[indstemp$filter,]
		indstemp				<- indstemp[indstemp$filter,]
		}
	# create heatmap:
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- c(0,0.01,0.05,0.2,0.5,1)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	if(!is.null(export))
		{
		exportname	<- "Missingdata.matrix"
		mywidth		<- 20
		mywidth2	<- 1440 
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		}
	heatmap.2(mymissmatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,Colv=NA,scale="none",RowSideColors=mypopcols,breaks=myBreaks,col=myColours,dendrogram="none",trace="none")
	mytitle		<- "Proportion missing data"
	subtitle	<- paste("per window of ",winsize," SNPS",sep="")
	mtext(mytitle, side = 3, line = 1.5, cex = 3)
	mtext(subtitle, side = 3, line = 0, cex = 2)
	mtext("SNPs", side = 1, cex = 2, line = 3.5)
	mtext("Individuals", side = 4, cex = 2, line = 0.5)
	if(!is.null(export)){dev.off()}
	setwd(my_wd)
	}

# 03042017: could still incorporate this function, but not an essential analysis:
# minor allele frequency range per stack:
stackdata<-function(mypop="Barff",myfilter=snps$filter2)
	{
	if(!("stackID2" %in% colnames(snps)))
		{
		snps$stackID2	<- as.factor(as.character(snps$stackID))
		}
	mymaf				<- snps[,paste("maf",mypop,sep="_")]			
	mymin				<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=min)
	mymax				<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=max)
	stack_data			<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=length)
	colnames(stack_data)		<- c("stackID2","stack_nsnps")
	stack_data$stack_mafrange	<- mymax$x-mymin$x   
	snpstemp			<<- merge(snps,stack_data,by="stackID2",all=TRUE)
	}
	
calcGC<-function()
	{
	# The rationale behind this function is that the distribution of major alleles reflects the distribution of nucleotides in the species genome. 
	if(!("GC" %in% colnames(snps)))
		{
		snps$GC	<<-	(snps$major2=="C")|(snps$major2=="G")
		}	
	}

calctransit<-function()
	{
	if(!("transit" %in% colnames(snps)))
		{
		snps$transit<<-	(snps$minor==1&snps$major==3)|(snps$minor==3&snps$major==1)|(snps$minor==2&snps$major==4)|(snps$minor==4&snps$major==2)
		}	
	}

chrlength_vs_nsnps<-function(export=NULL)
	{
	snpstemp	<- snps[,c("chr","chr2","placedcol","chrlength","nsnps")]
	snpstemp	<- unique(snpstemp)
	if(!any(snpstemp$chrlength!=0))
		{
		return(cat("No non-zero values found in the column snps$chrlength. Execution halted.",sep="\n"))  
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_length.vs.nsnps.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Chrom_length.vs.nsnps.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Chrom_length.vs.nsnps.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Chrom_length.vs.nsnps.wmf",family=mysambar$myfont,width=10,height=10)} 
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(snpstemp$chrlength,snpstemp$nsnps,col=snpstemp$placedcol,log="xy",pch=16,cex=2,yaxt='n',xaxt='n',xlab="Scaffold length (log bp)",ylab="log(# SNPs)")
	mypos	<- c(0,1,2,3,4,5,6,7,8)
	mypos2	<- 10^mypos
	axis(side=1,at=mypos2,labels=mypos)
	axis(side=2,at=mypos2,labels=mypos)
	legend("topleft",legend=c("chromosomes","unplaced"),bty='n',fill=c("black","red"),cex=3)
	if(!is.null(export)){dev.off()}
	}

barplotnsnps<-function(n_chroms=NULL,export=NULL)
	{
	if(is.null(n_chroms))
		{
		return(cat("ERROR: Provide value to n_chroms flag.",sep="\n"))
		}
	nuniqchrom	<- length(unique(snps$chr2))
	if(n_chroms>nuniqchrom)
		{
		return(cat("ERROR: value specified to n_chroms flag higher than number of unique values at snps$chr2 column. Not creating barplot with number of SNPs per chromosome/scaffold.",sep="\n"))
		}
	snpstemp	<- snps[snps$chr2<=n_chroms,]
	myn			<- table(snpstemp$chr2)
	snpstemp2	<- snps[snps$chr2<=n_chroms&snps$filter2,]
	myn2		<- table(snpstemp2$chr2)
	snpstemp3	<- snps[snps$chr2<=n_chroms&snps$filter,]
	myn3		<- table(snpstemp3$chr2)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_nsnps.eps",family=mysambar$myfont,width=12,height=6)}
		if(export=="pdf"){pdf("Chrom_nsnps.pdf",family=mysambar$myfont,width=12,height=6)}
		if(export=="png"){png("Chrom_nsnps.png",family=mysambar$myfont,width=1200,height=600)}
		if(export=="wmf"){win.metafile("Chrom_nsnps.wmf",family=mysambar$myfont,width=12,height=6)} 
		}
	par(mar=c(5,8,5,2),cex.axis=1.5,cex.lab=2,cex.main=3)
	xx<-barplot(myn,las=2,border="grey50",col="grey50",ylim=c(0,max(myn,na.rm=TRUE)*1.2))
	barplot(myn2,border="grey50",col="grey60",add=TRUE,xaxt='n',yaxt='n')
	barplot(myn3,border="grey50",col="white",add=TRUE,xaxt='n',yaxt='n')
	text(x = xx, y = myn,label=myn,col="black",cex=0.75,pos=3)
	mtext("# SNPs",side=2,line=5,cex=2.25)
	mtext("Chromosome index",side=1,line=3.5,cex=2.25)
	if(!is.null(export)){dev.off()}
	}

chromhetero<-function(nchroms=NULL,export=NULL)
	{
	if("sex" %in% colnames(inds))
		{
		mycols	<- ifelse(as.character(inds$sex)=="M","blue",ifelse(as.character(inds$sex)=="unknown","black","red"))
		}else{
		return(cat("WARNING: No column called 'sex' (with gender information) in inds dataframe. Skipping plot showing male and female heterozygosities per chromosome.",sep="\n"))
		}
	if(is.null(nchroms))
		{
		return(cat("ERROR: Provide a value to the nchroms argument.",sep="\n"))
		}
	chromnames	<- vector()
	chromlengths<<- vector()
	chromhetM	<<- vector()
	chromhetF	<<- vector()
	for (i in c(1:nchroms))
		{
		mymatrix 		<- as.matrix(mygenlight[inds$sex=="M",snps$filter&snps$chr2==i])
		chromhetM[i]	<<- mean(apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)])))
		chromnames[i]	<- as.vector(snps$chr[snps$chr2==i][1])
		chromlengths[i]	<<- as.vector(snps$chrlength[snps$chr2==i][1])
		}
	for (i in c(1:nchroms))
		{
		mymatrix 	<- as.matrix(mygenlight[inds$sex=="F",snps$filter&snps$chr2==i])
		chromhetF[i]<<- mean(apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)])))
		}
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_hetero.eps",family=mysambar$myfont,width=12,height=6)}
		if(export=="pdf"){pdf("Chrom_hetero.pdf",family=mysambar$myfont,width=12,height=6)}
		if(export=="png"){png("Chrom_hetero.png",family=mysambar$myfont,width=1200,height=600)}
		if(export=="wmf"){win.metafile("Chrom_hetero.wmf",family=mysambar$myfont,width=12,height=6)} 
		}
	par(mar=c(5,8,5,2),cex.axis=1.5,cex.lab=2,cex.main=3)
	mymax	<- max(c(chromhetM,chromhetF),na.rm=TRUE)*1.1
	barplot(chromhetF,las=2,border="grey60",col="white",ylim=c(0,mymax),names.arg=c(1:length(chromhetM)))
	barplot(chromhetM,border="grey60",col="grey60",add=TRUE,xaxt='n',yaxt='n')
	mtext("Heterozygosity",side=2,line=5,cex=2.25)
	mtext("Chromosome index",side=1,line=3.5,cex=2.25)
	mtext("Mean male (grey) vs female (white) heterozygosity per chromosome",side=3,line=-1,cex=2)
	if(!is.null(export)){dev.off()}
	#
	# Determine x_chrom:
	myhediff	<- abs(chromhetF-chromhetM)
	mymaxdiff	<- max(myhediff,na.rm=TRUE)
	myxchrom	<- which(myhediff==mymaxdiff)
	mymeandiff	<- mean(myhediff[-1],na.rm=TRUE)
	#
	mychrs			<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
	mychrs2			<- mychrs[order(-mychrs$x),]
	if(mymaxdiff>5*mymeandiff)
		{
		myxchromname	<- chromnames[myxchrom]
		cat(paste("Putative X chromosome is ",myxchromname,".",sep=""),sep="\n")
		}
	#
	# Calculate X chrom heterozygosity per individual:
	inds$het_Xchrom		<<- NA
	for (i in c(1:nrow(inds)))
		{
		mymatrix 			<- as.matrix(mygenlight[i,snps$filter&snps$chr2==myxchrom])
		inds$het_Xchrom[i]	<<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		}
	snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	indstemp			<- inds[inds$filter,]
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Xchrom_hetero_boxplot.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Xchrom_hetero_boxplot.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Xchrom_hetero_boxplot_png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Xchrom_hetero_boxplot.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	boxplot(indstemp$het_Xchrom~indstemp$sex,col="grey90",border="grey50",outline=FALSE,xlab="Sex",ylab="Heterozygosity X-chrom")
	stripchart(het_Xchrom~sex,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("red","blue","black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
	#mtext("X-chrom He",side=2,line=2.5,cex=2)
	#mtext("Sex",side=1,line=3.5,cex=2)
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_hetero_vs_length.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Chrom_hetero_vs_length.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Chrom_hetero_vs_length.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Chrom_hetero_vs_length.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(chromlengths,chromhetF,pch=16,cex=3,xlab="Chromosome length",ylab="Heterozygosity",col="red",ylim=c(0,max(c(chromhetF,chromhetM))))
	points(chromlengths,chromhetM,pch=16,cex=3,col="blue")
	legend("bottomleft",legend=c("female","male"),bty='n',fill=c("red","blue"),cex=3)	
	if(!is.null(export)){dev.off()}
	#
	cat("A column called 'het_Xchrom', with X-chrom heterozygosity has been added to the inds dataframe.",sep="\n")
	}

plot_Ychrom<-function(minFmiss=0.8,y_chrom=NULL,export=NULL,minsnps=20,silent=TRUE)
	{
	if(is.null(y_chrom))
		{
		return(cat("ERROR: Provide the name of the Y chromosome to the flag y_chrom.",sep="\n"))
		}
	if(!any(snps$chr==y_chrom))
		{
		return(cat("ERROR: The specified chromosome does not occur in the SNP dataset (snps$chr) column.",sep="\n"))
		}
	nsnps	<- nrow(snps[snps$chr==y_chrom,])
	cat(paste("Number of SNPs on the Y-chromosome: ",nsnps,sep=""),sep="\n")
	if(nsnps<minsnps)
		{
		return(cat("ERROR: Too low amount of SNPs to reliable infer sex information based on Y-chromosome data.",sep="\n"))
		}
	# first part of the bear Y-chrom has 0 percent missing data in females (repetitive region?)
	# select SNPs which high amount of missing data in females:
	if("sex" %in% colnames(inds))
		{
		mat 			<- as.matrix(mygenlight[inds$sex=="F",snps$chr==y_chrom])
		}else{
		cat("No prior gender information for samples present in inds dataframe.",sep="\n")
		mat				<- as.matrix(mygenlight[,snps$chr==y_chrom])
		}
	nNA 			<- apply(mat,2,function(x) length(x[is.na(x)])) # number of NA per SNP
	snps$Y_missF	<<-nNA/nrow(mat)
	#
	# calculate proportion missing data for SNP subset:
	if(!any(snps$Y_missF>=minFmiss,na.rm=TRUE))
		{
		if(!silent){cat(max(snps$Y_missF,na.rm=TRUE),sep="\n")}
		return(cat("ERROR: No snps$Y_missF>=minFmiss. Choose a higher value of minFmiss.",sep="\n"))
		}
	mat2			<- as.matrix(mygenlight[,snps$Y_missF>=minFmiss&snps$chr==y_chrom])
	nNA2 			<- apply(mat2,1,function(x) length(x[is.na(x)])) # number of NA per inds
	inds$miss_Ychrom<<-nNA2/ncol(mat2) 
	#
	# determine sex based on proportion missing data for Y chromosome:
	inds$sex_Y		<<- ifelse(inds$miss_Ychrom<=0.25,"M",ifelse(inds$miss_Ychrom>=0.6,"F","unknown"))
	#
	# calculate individual heterozygosity for SNP subset:
	inds$het_Ychrom	<<- apply(mat2,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	#
	# calculate locus heterozygosity for SNP subset:
	if("sex" %in% colnames(inds))
		{
		mat3			<- as.matrix(mygenlight[inds$sex=="M",snps$Y_missF>=minFmiss&snps$chr==y_chrom])
		}else{
		mat3			<- as.matrix(mygenlight[,snps$Y_missF>=minFmiss&snps$chr==y_chrom])
		}
	nNA3 			<- apply(mat3,2,function(x) length(x[is.na(x)])) # number of NA per inds
	snps$het_Ychrom	<<- NA
	snps$het_Ychrom[snps$Y_missF>=minFmiss&snps$chr==y_chrom]	<<- nNA3/nrow(mat3)
	#
	snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	#
	if("sex" %in% colnames(inds))
		{
		mycols	<- ifelse(as.character(inds$sex)=="M","blue",ifelse(as.character(inds$sex)=="unknown","black","red"))
		}else{
		mycols	<- inds$popcol
		}
	#
	if(!silent){cat("Plotting Ychrom_missingness",sep="\n")}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Ychrom_missingness.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Ychrom_missingness.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Ychrom_missingness.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Ychrom_missingness.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	plot(inds$miss_Ychrom,col=mycols,pch=16,xlab="Individuals",ylab="Missing data Y-chrom",cex=2)
	if("sex" %in% colnames(inds)){legend("right",legend=c("male","female","unknown"),fill=c("blue","red","black"),bty='n',cex=3)}
	if(!is.null(export)){dev.off()}
	#
	if("sex" %in% colnames(inds))
		{
		if(!silent){cat("Plotting Ychrom_missingness_boxplot",sep="\n")}
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Ychrom_missingness_boxplot.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("Ychrom_missingness_boxplot.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("Ychrom_missingness_boxplot.png",family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile("Ychrom_missingness_boxplot.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
			par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
			}
		boxplot(inds$miss_Ychrom~inds$sex,col="grey90",border="grey50",outline=FALSE,xlab="Sex",ylab="Missing data Y-chrom")
		stripchart(miss_Ychrom~sex,data=inds,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("red","blue","black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
		if(!is.null(export)){dev.off()}
		}
	#
	if(!silent){cat("Plotting Ychrom_miss_vs_samplequality",sep="\n")}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Ychrom_miss_vs_samplequality.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Ychrom_miss_vs_samplequality.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Ychrom_miss_vs_samplequality.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Ychrom_miss_vs_samplequality.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	plot(inds$miss,inds$miss_Ychrom,ylim=c(0,1),xlim=c(0,1),pch=16,col=mycols,xlab="Missing data overall",ylab="Missing data Y-chrom",cex=2)
	if("sex" %in% colnames(inds)){legend("bottomright",legend=c("male","female","unknown"),fill=c("blue","red","black"),bty='n',cex=3)}
	if(!is.null(export)){dev.off()}
	#
	if("het_Xchrom"%in%colnames(inds))
		{
		if(!silent){cat("Plotting Y_vs_X_hetero",sep="\n")}
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Y_vs_X_hetero.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("Y_vs_X_hetero.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("Y_vs_X_hetero.png",family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile("Y_vs_X_hetero.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
			par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
			}
		plot(inds$het_Ychrom,inds$het_Xchrom,col=mycols,pch=16,xlim=c(0,1),ylim=c(0,0.5),xlab="Heterozygosity Y-chrom",ylab="Heterozygosity X-chrom",cex=2)
		if(!is.null(export)){dev.off()}
		}
	#
	if(!silent){cat("Plotting Ychrom_miss_vs_hetero",sep="\n")}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Ychrom_miss_vs_hetero.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Ychrom_miss_vs_hetero.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Ychrom_miss_vs_hetero.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Ychrom_miss_vs_hetero.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	plot(inds$miss_Ychrom,inds$het_Ychrom,col=mycols,pch=16,xlim=c(0,1),ylim=c(0,0.5),xlab="Missing data Y-chrom",ylab="Heterozygosity Y-chrom",cex=2)
	if("sex" %in% colnames(inds)){legend("bottomleft",legend=c("male","female","unknown"),fill=c("blue","red","black"),bty='n',cex=3)}
	if(!is.null(export))
		{
		dev.off()
		cat("Plots with proportion of missing data and missingness values have been written to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("A column called 'sex_Y', with sex determination of the samples based on levels of missing data of the Y-chromosome, has been added to the inds dataframe.",sep="\n")
		}
	}

plotscaffoldsize<-function(export=NULL,n_chroms=NULL,mychrs2=NULL)
	{
	if(!any(snps$pos!=0))
		{
		return(cat("WARNING: no information on genomic positions of SNP. Not creating 'Chrom_length' plots.",sep="\n"))
		}
	if(is.null(mychrs2))
		{
		mychrs			<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
		mychrs2			<- mychrs[order(-mychrs$x),]
		}
	#
	if(!is.null(n_chroms))
		{
		minlength		<- as.numeric(as.character(mychrs2$x[n_chroms]))
		mychrs2$colour	<- ifelse(as.numeric(as.character(mychrs2$x))>=minlength,"black","red") 
		}else{
		mychrs2$colour	<- "black"
		}
	#mychrs2				<<- mychrs2
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_length.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Chrom_length.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Chrom_length.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Chrom_length.wmf",family=mysambar$myfont,width=10,height=10)} 
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(mychrs2$x,pch=16,col=mychrs2$colour,log="y",yaxt='n',ylab="Max SNP position (log bp)",xlab="Scaffold index")
	mypos	<- c(0,1,2,3,4,5,6,7,8)
	mypos2	<- 10^mypos
	axis(side=2,at=mypos2,labels=mypos)
	if(!is.null(n_chroms))
		{
		legend("topright",legend=c("chromosomes","unplaced"),bty='n',fill=c("black","red"),cex=3)
		}
	if(!is.null(export)){dev.off()}
	}

readpos<-function(export=NULL)
	{
	if(any(is.na(snps$readpos)))
		{
		return()
		}
	mymax			<- max(snps$readpos)
	if(mymax<250)
		{
		mycounts		<- hist(snps$readpos,breaks=seq(0,mymax,1))
		mysd			<- sd(mycounts$counts[mycounts$counts!=0])
		mymean			<- mean(mycounts$counts[mycounts$counts!=0])
		mydev			<- mycounts$counts<(mymean+mysd)&mycounts$counts>(mymean-mysd)
		mylower			<- which(mydev==TRUE)[1]
		mydev2			<- rev(mydev)
		myupper			<- length(mydev2)-which(mydev2==TRUE)[1]+1
		snps$readpos2	<<- snps$readpos>=mylower&snps$readpos<=myupper
		snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		# plot:
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPalongreads.eps",family=mysambar$myfont,width=16,height=10)}
			if(export=="pdf"){pdf("SNPalongreads.pdf",family=mysambar$myfont,width=16,height=10)}
			if(export=="png"){png("SNPalongreads.png",family=mysambar$myfont,width=1260,height=720)}
			if(export=="wmf"){win.metafile("SNPalongreads.wmf",family=mysambar$myfont,width=16,height=10)}
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist(snps$readpos,breaks=seq(0,mymax,1),xlab="Position along read (bp)",ylab="Frequency",main="Distribution of snps along reads")
		hist(snps$readpos[!snps$readpos2],breaks=seq(0,mymax,1),add=TRUE,col="orange")
		mtext("dashed line = mean; solid lines = mean +/- sd", side = 3, line = -1, cex = 2)
		abline(mymean,0,lty=2)
		abline(mymean-mysd,0)
		abline(mymean+mysd,0)
		if(!is.null(export)){dev.off()}
		}
	}	

plotspacing<-function(export=NULL)
	{
	mymaxdist	<- max(snps$pos,na.rm=TRUE)
	if(mymaxdist>1000)
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.eps",family=mysambar$myfont,width=18,height=10)}
			if(export=="pdf"){pdf("SNPspacing.pdf",family=mysambar$myfont,width=18,height=10)}
			if(export=="png"){png("SNPspacing.png",family=mysambar$myfont,width=1296,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.wmf",family=mysambar$myfont,width=18,height=10)}
			}
		par(mfrow=c(1,2),mar=c(5,8,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist(snps$dist[snps$dist>1000],xlim=c(1000,1000000),breaks=1000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,1000000,250000)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("Frequency",side=2,cex=3,line=5)
		mtext("10 kb bins", side = 3, cex = 2.5, line = -1)
		hist((snps$dist),xlim=c(0,500),breaks=1000000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,500,100)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("0.01 kb bins", side = 3, cex = 2.5, line = -1)
		mtext("Distance between adjacent snps", side = 3, cex = 3.5, line = -3.5, outer=TRUE)
		if(!is.null(export)){dev.off()}
		}else{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("SNPspacing.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("SNPspacing.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5,8,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist((snps$dist),xlim=c(0,500),breaks=1000000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,500,100)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("0.01 kb bins", side = 3, cex = 2.5, line = -1)
		mtext("Distance between adjacent snps", side = 3, cex = 3.5, line = -3.5, outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	#
	# indicate intra- and interread distances:
	if("sameread"%in%colnames(snps))
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.intra_vs_interread.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("SNPspacing.intra_vs_interread.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("SNPspacing.intra_vs_interread.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.intra_vs_interread.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5.5,8,2.5,2),cex.axis=2.5,cex.lab=2.5,cex.main=2.5)
		hist(snps$dist[snps$dist<500&snps$sameread],breaks=seq(0,1000,10),xlim=c(0,500),las=1,ylab="",xlab="Distance (bp)",main="SNP spacing",col="grey")
		hist(snps$dist[snps$dist<500&!snps$sameread],breaks=seq(0,1000,10),add=TRUE)
		legend("topright",legend=c("same read","different read"),fill=c("grey","white"),bty='n',cex=2.5)
		if(!is.null(export)){dev.off()}
		}	
	}

distperchrom<-function(dothin=FALSE,export=NULL)
	{
	if(!"filter"%in%colnames(snps))
		{
		return(cat("Column snps$filter missing; (re)run filterdata() function.",sep="\n"))
		}
	# Table:
	nrchroms	<- length(unique(snps$chr[snps$placed]))
	if(nrchroms==0)
		{
		return(cat("No placed scaffolds. Omitting distperchrom table and plot.",sep="\n")) 
		}
	statsfunction 	<- function(x){c(mean = mean(x), std = sd(x), quantiles = quantile(x))}
	snpstemp		<- snps[order(snps$chr2),]
	distancetable	<- cbind(as.vector(table(as.vector(snpstemp$chr[snpstemp$dist2&snpstemp$placed]))),do.call(rbind,tapply(snpstemp$dist[snpstemp$dist2&snpstemp$placed],snpstemp$chr[snpstemp$dist2&snpstemp$placed],statsfunction)))
	distancetable	<- round(distancetable)
	colnames(distancetable)<-c("nsnps","mean","stdv","min","25%","median","75%","max")
	write.table(distancetable,"Distperchrom.txt",col.names=TRUE,row.names=TRUE,quote=FALSE)
	if(!dothin)
		{
		myselection<- snpstemp$filter2
		}else{
		myselection<- snpstemp$filter
		}
	# boxplot:
	if(!is.null(export))
		{
		plotname	<- ifelse(!dothin,"Chrom_SNPspacing.filtered","Chrom_SNPspacing.thinned")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=6,width=12)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=6,width=12)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=600,width=1200)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=6,width=12)}
		}
	myselection2<- snpstemp$placed&myselection
	mychroms	<- as.vector(snpstemp$chr2[myselection2])
	mydist		<- snpstemp$dist[myselection2]
	mydist[mydist==0]	<-NA
	mydata		<- data.frame("mychroms"=mychroms,"mydist"=mydist)
	boxplot(mydist~mychroms,las=2,col="white",border="white",outline=TRUE,xlab="",ylab="",yaxt="n",cex.lab=2,cex.axis=1.5,log="y")
	boxplot(mydist~mychroms,las=2,col="grey90",border="grey50",outline=FALSE,add=TRUE,xlab="",ylab="",yaxt="n",xaxt='n')
	stripchart(mydist~mychroms,data=mydata,vertical=TRUE,method="jitter",pch=16,cex=0.5,col="orange",bg="bisque",las=2,xlab="",ylab="",add=TRUE) 
	aty 		<- axTicks(2)
	atylog		<- log10(aty)
	axis(2,at=aty,labels=atylog,las=1,cex=2)
	mtext("Distance (log Mb)",side=2,line=2.5,cex=2)
	mtext("Chromosome index",side=1,line=3.5,cex=2)
	if(!is.null(export)){dev.off()}
	}

# replaced by distperchrom
plotspacingperchrom<-function(myyrange=c(0,500000),export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("SNPspacingperchrom.eps",family=mysambar$myfont,width=18,height=10)}
		if(export=="pdf"){pdf("SNPspacingperchrom.pdf",family=mysambar$myfont,width=18,height=10)}
		if(export=="png"){png("SNPspacingperchrom.png",family=mysambar$myfont,width=1296,height=720)}
		if(export=="wmf"){win.metafile("SNPspacingperchrom.wmf",family=mysambar$myfont,width=18,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=1.5,cex.lab=3,cex.main=3.5)
	boxplot(snps$dist[snps$placed]~as.vector(snps$chr[snps$placed]),ylim=myyrange,main="Distance between adjacent snps",xlab="Chromosome",ylab="Distance (bp)")
	if(!is.null(export)){dev.off()}
	}	
	
indsmissingness<-function(indthreshold=0.25,export=NULL,prior2snpfilter=TRUE,max_miss=NULL)
	{
	if(prior2snpfilter&is.null(max_miss))
		{
		# missingness per individual for all SNPs:
		if(!"miss"%in%colnames(inds))
			{
			mat 		<- as.matrix(mygenlight)
			nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
			inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
			}
		# which samples meet the predefined threshold?
		inds$fmiss	<<- inds$miss <= indthreshold
		# change column name:
		names(inds)[names(inds) == "fmiss"] <<- paste("fmiss",indthreshold,sep = "")
		inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	if((!prior2snpfilter)&is.null(max_miss))
		{
		# missingness per individual for retained SNPs:
		mat 		<- as.matrix(mygenlight[,snps$filter])
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss2 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		inds 		<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	if(!is.null(max_miss))
		{
		# missingness per individual for subset of SNPs with 'max_miss' missing data:
		mat 		<- as.matrix(mygenlight[,snps$miss<=max_miss])
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss3 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		inds 		<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	}

plot_indsmissingdata<-function(export=NULL,indthreshold=0.25)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("missingdatapersample.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("missingdatapersample.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("missingdatapersample.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("missingdatapersample.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,2,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(!("meandepth" %in% colnames(inds)))
		{
		hist(inds$miss,breaks=seq(0,1,0.01),main="Missing data per sample",xlab="Proportion of missing data points",ylab="Number of samples")
		hist(inds$miss[inds$miss>indthreshold],breaks=seq(0,1,0.01),add=T,col="red")
		}else{
		plot(inds$meandepth,inds$miss,pch=16,cex=2,main="",xlab="Read depth per sample",ylab="Missing data per sample",ylim=c(0,1))
		points(inds$meandepth[inds$miss>indthreshold],inds$miss[inds$miss>indthreshold],pch=16,cex=2,col="red")
		legend("topright",legend=c("FALSE","TRUE"),title="Pass filter",bty='n',fill=c("red","black"),cex=2)
		}
	if(!is.null(export)){dev.off()}
	}

snpsmissingness<-function(indthreshold=0.25,snpthreshold=0.1,popnames=mysambar$populations,sanity_check=TRUE)
	{
	indmissfilter			<- inds$miss<=indthreshold
	if(!any(indmissfilter))
		{
		return(cat("ERROR: no individuals retained after filtering on missing data points. Please try again with a less strict (i.e. higher) individual missingness filter threshold.",sep="\n")) 
		}
	#snps$misscount			<<- glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)										# for each locus, calculate number of individuals (from filtered subset) with missing data
	#snps$nonmissallelecount <<- 2*(nInd(mygenlight[indmissfilter,])-snps$misscount)									# The opposite of snps$misscount
	snps$nind				<<- nInd(mygenlight[indmissfilter,])
	snps$misscount			<<- 2*glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)									# 16-03-2021: for each locus, calculate number of alleles (from filtered subset) with missing data
	snps$nonmissallelecount <<- (2*nInd(mygenlight[indmissfilter,]))-snps$misscount										# 16-03-2021
	snps$miss				<<- glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)/nInd(mygenlight[indmissfilter,])	# as snps$misscount, but divided by length of indmissfilter, giving us a frequency:	
	snps$miss2				<<- glNA(mygenlight,alleleAsUnit=FALSE)/nInd(mygenlight)									# same, but now for all individuals, for comparison
	snps$fmiss				<<- snps$miss <= snpthreshold																# which loci meet the predefined threshold?			
	#
	if(sanity_check&any((2*snps$nind)!=snps$misscount+snps$nonmissallelecount))
		{
		return(cat("ERROR: absent and present allele counts does not add up to expected number for diploid datasets (i.e, 2x number of retained individuals). Please contact the developer of SambaR or set the flag sanity_check to FALSE.",sep="\n"))
		}
	#
	# change column name:
	names(snps)[names(snps) == "fmiss"] <<- paste("fmiss",snpthreshold,sep = "")
	# missingness per SNP per population:
	# Per population:
	for (i in (1:length(popnames)))
		{
		mypop			<- popnames[i]
		popfilter		<- indmissfilter&inds$pop==mypop
		if(!any(popfilter,na.rm=TRUE))
			{
			cat(paste("WARNING: Zero retained individuals for population ",mypop,". Please try again with a less strict (i.e. higher) individual missingness filter threshold.",sep=""),sep="\n") 
			snps$misscountpop	<<- 2*(nInd(mygenlight[indmissfilter,]))
			snps$misspop		<<- 1
			}else{
			snps$misscountpop	<<- 2*glNA(mygenlight[popfilter,],alleleAsUnit=FALSE)
			snps$misspop		<<- glNA(mygenlight[popfilter,],alleleAsUnit=FALSE)/nInd(mygenlight[popfilter,])
			}
		names(snps)[names(snps) == "misscountpop"] 	<<- paste("misscount",mypop,sep ="_")
		names(snps)[names(snps) == "misspop"] 		<<- paste("miss",mypop,sep ="_")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}
	
plot_snpsmissingdata<-function(snpthreshold=0.1,export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("missingdataperlocus.eps",family=mysambar$myfont,width=12,height=10)}
		if(export=="pdf"){pdf("missingdataperlocus.pdf",family=mysambar$myfont,width=12,height=10)}
		if(export=="png"){png("missingdataperlocus.png",family=mysambar$myfont,width=900,height=720)}
		if(export=="wmf"){win.metafile("missingdataperlocus.wmf",family=mysambar$myfont,width=12,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)	
	if(!("meandepth" %in% colnames(snps)))
		{
		hist(snps$miss,breaks=seq(0,1,0.01),main="",xlab="Proportion of missing data points",ylab="")
		hist(snps$miss[snps$miss>snpthreshold],breaks=seq(0,1,0.01),add=T,col="red")
		mtext("Number of loci",side=2,cex=3,line=7)
		}else{
		if(any(!is.na(snps$meandepth)))
			{
			plot(snps$meandepth,snps$miss,pch=16,cex=2,log='x',xlab="Read depth per SNP",ylab="Missing data per SNP",ylim=c(0,1))
			points(snps$meandepth[snps$miss>snpthreshold],snps$miss[snps$miss>snpthreshold],pch=16,cex=2,col="red")
			legend("topright",legend=c("FALSE","TRUE"),title="Pass filter",bty='n',fill=c("red","black"),cex=2)
			}else{
			hist(snps$miss,breaks=seq(0,1,0.01),main="",xlab="Proportion of missing data points",ylab="")
			hist(snps$miss[snps$miss>snpthreshold],breaks=seq(0,1,0.01),add=T,col="red")
			mtext("Number of loci",side=2,cex=3,line=7)
			}
		}
	if(!is.null(export)){dev.off()}
	}

snp_maf<-function(popnames=mysambar$populations,indthreshold=mysambar$indmissfilter,indfilter=NULL,do_subset=FALSE,silent=TRUE)	
	{
	if(is.null(indfilter))
		{
		if(is.null(indthreshold))
			{
			return(cat("ERROR: please provide a value to the indthreshold flag.",sep="\n"))
			}
		indfilter			<- inds$miss<=indthreshold
		}else{
		cat("Excluding individuals from the calculation as defined by input to the indfilter flag.",sep="\n")
		}
	# What is minor allele count and major allele count:
	snps$minorcount		<<- as.vector(glSum(mygenlight[indfilter,]))	#glSum counts number of second alleles
	snps$majorcount		<<- snps$nonmissallelecount-snps$minorcount	
	#
	# Calculate maf per locus:
	# Overall dataset:
	# snps$maf 			<<- glMean(mygenlight[indfilter,])		# glMean gives wrong estimate if data consists of 1 snp only (17-3-2021: not sure what I meant by '1 snp only'
	# snps$maf			<<- round(snps$minorcount/snps$nonmissallelecount,3)
	snps$maf			<<- snps$minorcount/snps$nonmissallelecount		# 17-03-2021: no rounding
	snps$maf[!is.finite(snps$maf)]	<<- NA
	# check for SNPs for with no data left after filtering: (this is captured by snps$polyfilter)
	# if(any(is.na(snps$maf)))
	#	{
	#	cat("WARNING: After filtering, no data retained for 1 or more snps",sep="\n")
	#	}
	if(any(snps$maf!=snps$minorcount/snps$nonmissallelecount,na.rm=TRUE))
		{
		return(cat("ERROR: minor allele frequency does not equal minor allele count divided by total allele count. Please contact the developer of SambaR.",sep="\n"))
		}
	#
	# Per population:
	popnoind			<- vector()
	for (i in (1:length(popnames)))
		{
		# popminor			<- as.vector(glSum(mygenlight[indfilter&inds$pop==popnames[i],]))
		# popmiss			<- glNA(mygenlight[indfilter&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		# popmiss			<- glNA(mygenlight[indfilter&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		# nind				<- nrow(inds[inds$pop==popnames[i]&inds$filter,])
		# popall			<- 2*nind-popmiss
		# snps$maftemp		<<- round(popminor/popall,3)			# this leads to ERROR when correcting maf (something about NA's)	
		mypop				<- popnames[i]
		if(!silent){cat(mypop,sep="\n")}
		popfilter			<- indfilter&inds$pop==mypop
		if(any(popfilter,na.rm=TRUE))
			{
			popmisscount		<- paste("misscount",popnames[i],sep="_")
			if(!popmisscount%in%colnames(snps))
				{
				return(cat("ERROR: popmisscount is missing from snps data frame. Did you run the snpsmissingness function?",sep="\n"))
				}
			npopind					<- nrow(inds[popfilter,])
			snps$actemp				<<- 2*npopind-as.vector(snps[,popmisscount])
			snps$mactemp			<<- as.vector(glSum(mygenlight[popfilter,]))
			#snps$maftemp 			<<- glMean(mygenlight[indfilter&inds$pop==popnames[i],])	# 17-03-2021: replaced with next line just to be consistent with calculation for metapopulation
			#snps$maftemp			<<- round(snps$mactemp/snps$actemp,3)
			snps$maftemp			<<- snps$mactemp/snps$actemp				# 17-03-2021: no rounding
			snps$maftemp[!is.finite(snps$maftemp)]	<<- NA
			#			
			if(any(is.na(snps$maftemp)))
				{
				cat(paste("WARNING: No data for 1 or more snps in population:",popnames[i],sep=" "),sep="\n")
				}
			if(any(snps$actemp%%1!=0,na.rm=TRUE))
				{
				return(cat("ERROR: unrounded population allele counts. Please contact the developer of SambaR.",sep="\n"))
				}
			if(any(snps$maftemp!=snps$mactemp/snps$actemp,na.rm=TRUE))
				{
				return(cat("ERROR: population minor allele frequency does not equal minor allele count divided by total allele count. Please contact the developer of SambaR.",sep="\n"))
				}
			if(do_subset)
				{
				# calculate minor allele frequency for two random subsets within population
				# needed for f-statistics
				if(npopind==1)
					{
					cat("WARNING: population contains 1 individual. Not possible to calculate minor allele frequency for within population subsets.",sep="\n")
					snps$actemp_a			<<- snps$actemp
					snps$actemp_b			<<- snps$actemp
					snps$mactemp_a			<<- snps$mactemp
					snps$mactemp_b			<<- snps$mactemp
					snps$maftemp_a			<<- snps$maftemp		
					snps$maftemp_b			<<- snps$maftemp
					}else{
					popgenlight				<- mygenlight[popfilter,]
					if(npopind%%2==0)
						{
						aindices				<- 1:(npopind/2)
						bindices				<- (1+npopind/2):npopind
						}else{
						aindices				<- 1:floor(npopind/2)
						bindices				<- ceiling(npopind/2):npopind
						}
					agenlight				<- popgenlight[aindices,]
					bgenlight				<- popgenlight[bindices,]
					amiss					<- 2*glNA(agenlight,alleleAsUnit=FALSE)
					bmiss					<- 2*glNA(bgenlight,alleleAsUnit=FALSE)
					snps$actemp_a			<<- 2*length(aindices)-amiss
					snps$actemp_b			<<- 2*length(bindices)-bmiss
					snps$mactemp_a			<<- as.vector(glSum(agenlight))
					snps$mactemp_b			<<- as.vector(glSum(bgenlight))
					snps$maftemp_a			<<- snps$mactemp_a/snps$actemp_a		
					snps$maftemp_b			<<- snps$mactemp_b/snps$actemp_b
					snps$maftemp_a[!is.finite(snps$maftemp_a)]	<<- NA
					snps$maftemp_b[!is.finite(snps$maftemp_b)]	<<- NA
					if(any(snps$actemp!=snps$actemp_a+snps$actemp_b,na.rm=TRUE))
						{
						#return(cat("ERROR: Allele counts of subsets do not add up to total allele count. Please contact the developer of SambaR.",sep="\n"))
						cat("WARNING: Allele counts of subsets do not add up to total allele count. Please contact the developer of SambaR.",sep="\n")
						}
					if(any(snps$mactemp!=snps$mactemp_a+snps$mactemp_b,na.rm=TRUE))
						{
						#return(cat("ERROR: Minor allele counts of subsets do not add up to total minor allele count. Please contact the developer of SambaR.",sep="\n"))
						cat("WARNING: Minor allele counts of subsets do not add up to total minor allele count. Please contact the developer of SambaR.",sep="\n")
						}
					}
				}
			}else{
			cat(paste("No individuals retained in population:",popnames[i],sep=" "),sep="\n")
			popnoind			<- c(popnoind,popnames[i])   
			snps$actemp			<<- NA
			snps$mactemp		<<- NA
			snps$maftemp 		<<- NA
			if(do_subset)
				{
				snps$actemp_a	<<- NA
				snps$actemp_b	<<- NA
				snps$mactemp_a	<<- NA
				snps$mactemp_b	<<- NA
				snps$maftemp_a	<<- NA		
				snps$maftemp_b	<<- NA
				}
			}
		names(snps)[names(snps) == "actemp"] 	<<- paste("ac",popnames[i],sep = "_")
		names(snps)[names(snps) == "mactemp"] 	<<- paste("mac",popnames[i],sep = "_")
		names(snps)[names(snps) == "maftemp"] 	<<- paste("maf",popnames[i],sep = "_")
		if(do_subset)
			{
			names(snps)[names(snps) == "actemp_a"] <<- paste("ac",popnames[i],"a",sep = "_")
			names(snps)[names(snps) == "mactemp_a"]<<- paste("mac",popnames[i],"a",sep = "_")
			names(snps)[names(snps) == "maftemp_a"]<<- paste("maf",popnames[i],"a",sep = "_")
			names(snps)[names(snps) == "actemp_b"] <<- paste("ac",popnames[i],"b",sep = "_")
			names(snps)[names(snps) == "mactemp_b"]<<- paste("mac",popnames[i],"b",sep = "_")
			names(snps)[names(snps) == "maftemp_b"]<<- paste("maf",popnames[i],"b",sep = "_")
			}
		}
	mysambar$popnoind		<<- popnoind
	# if this function has been executed before, remove columns produced during previous execution:
	snps 					<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}

pheno_maf<-function(indthreshold=0.25)	
	{
	if(is.null(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	indfilter			<- inds$miss<=indthreshold
	snps$maf_pheno1 	<<- glMean(mygenlight[indfilter&inds$type,])
	snps$maf_pheno2 	<<- glMean(mygenlight[indfilter&(!inds$type),])
	# if this function has been executed before, remove columns produced during previous execution:
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	

snp_mymaf<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# snp_maf uses the function glMean.
	# glMean gives wrong estimates of maf when one or more samples don't have all genotypes (0,1,2) at least represented once in your subset of loci. 
	# If so, you might consider using this script, which is a bit slower:
	indfilter	<- inds$miss<=indthreshold
	mafmyway	<- vector()
	mymatrix	<- as.matrix(mygenlight[indmissfilter,])
	for (i in c(1:(ncol(mymatrix))))
		{
		temp1		<- mymatrix[,i]
		bool		<- !is.na(temp1)
		temp		<- temp1[bool]
		temp2		<- as.data.frame(table(temp))
		if(nrow(temp2)==3)
			{
			maf		<- (temp2[3,2]+((1/2)*temp2[2,2]))/(temp2[1,2]+temp2[2,2]+temp2[3,2])
			}
		if(nrow(temp2)==2)
			{
			if(temp2$temp[1]==0&temp2$temp[2]==1){maf	<- (1/2)*temp2[2,2]/(temp2[1,2]+temp2[2,2])}
			if(temp2$temp[1]==1&temp2$temp[2]==2){maf	<- ((1/2)*temp2[1,2]+temp2[2,2])/(temp2[1,2]+temp2[2,2])}
			if(temp2$temp[1]==0&temp2$temp[2]==2){maf	<- temp2[2,2]/(temp2[1,2]+temp2[2,2])}
			}
		if(nrow(temp2)==1)
			{
			if(temp2$temp[1]==0){maf	<- 0}
			if(temp2$temp[1]==1){maf	<- 0.5}
			if(temp2$temp[1]==2){maf	<- 1}
			}
		mafmyway[i]	<- maf
		}
	snps$mafmyway	<<- mafmyway
	}

correctmaf<-function(popnames=mysambar$populations,indthreshold=0.25,silent=TRUE,make_global=FALSE)
	{
	if(!"genlightname"%in%colnames(snps))
		{
		cat("WARNING: column snps$genlightname missing. Adding now.",sep="\n")
		snps$genlightname			<<- as.character(mygenlight$loc.names)
		}
	if(make_global)
		{
		snpsstart					<<- snps
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: before running correctmaf() function, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}		
	# Due to excluding datapoints, the allele which is listed as minor might have become major
	# For example: if you have: 1 2 2 0 0, and the last individual is removed, then the minor allele has become the major allele
	# this function makes the correction 
	indfilter						<- inds$miss<=indthreshold
	currentmaf						<- snps$maf
	currentmaf[is.na(currentmaf)]	<- 0		# Otherwise following error: Error in snps$minor[currentmaf > 0.5] <- mymajor[currentmaf > 0.5] : NAs are not allowed in subscripted assignments
	n_above0.5						<- length(currentmaf[currentmaf>0.5])
	if(n_above0.5==0)
		{
		return(cat("No snps with maf > 0.5. No need to correct maf.",sep="\n"))
		}
	# else we need to make the correction:
	if(!silent){cat("Editing minor and major columns in snps df...",sep="\n")}
	myminor							<- snps$minor
	mymajor							<- snps$major
	snps$minor[currentmaf>0.5]		<<- mymajor[currentmaf>0.5]
	snps$major[currentmaf>0.5]		<<- myminor[currentmaf>0.5]
	myminorcount					<- snps$minorcount
	mymajorcount					<- snps$majorcount
	snps$minorcount[currentmaf>0.5]	<<- mymajorcount[currentmaf>0.5] 
	snps$majorcount[currentmaf>0.5]	<<- myminorcount[currentmaf>0.5]
	snps$maf[currentmaf>0.5]		<<- (1-currentmaf)[currentmaf>0.5]
	for (j in popnames)
		{
		mypopmaf					<- snps[,names(snps) == paste("maf",j,sep="_")]
		snps[currentmaf>0.5,names(snps) == paste("maf",j,sep="_")]	<<- (1-mypopmaf)[currentmaf>0.5] 
		}
	if(!silent){cat("Editing data in genlight object...",sep="\n")}
	# edit data in genlight object:
	mymatrix					<- as.matrix(mygenlight)
	mymatrix1					<- mymatrix[,currentmaf>0.5]
	mymatrix2					<- mymatrix[,currentmaf<=0.5]
	tempmatrix					<- mymatrix1
	mymatrix1[tempmatrix==0]	<- 2
	mymatrix1[tempmatrix==2]	<- 0
	if(n_above0.5==1)
		{
		temp					<- as.matrix(mymatrix1)
		colnames(temp)			<- colnames(mymatrix)[currentmaf>0.5]
		mymatrix1				<- temp
		}
	mymatrix3					<- cbind(mymatrix1,mymatrix2)
	if(ncol(mymatrix3)!=ncol(mymatrix))
		{
		return(cat("ERROR: number of columns in new dataset does not correspond with old dataset.",sep="\n"))
		}
	mymatrix4					<- mymatrix3[,order(colnames(mymatrix3))]
	if(!silent){cat("Reordering...",sep="\n")}
	# now reorder matrix3 to order of snps in snps dataframe:
	# snpstemp					<- snps[order(snps$name),]
	snpstemp					<- snps[order(snps$genlightname),]	# 04-09-2020: instead of previous line
	# mymatrix5					<- mymatrix4[,order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos))]
	# mymatrix5					<- mymatrix4[,order(snpstemp$chr,as.numeric(snpstemp$pos))]
	mymatrix5					<- mymatrix4[,order(snpstemp$nr_neworder)]
	mygenlight					<<- as.genlight(mymatrix5)
	mygenlight@pop				<<- as.factor(inds$pop)
	# if this function has been executed before, remove columns produced during previous execution:
	snps 						<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	#
	if(make_global)
		{
		currentmaf					<<- currentmaf
		mymatrix					<<- mymatrix
		mymatrix1					<<- mymatrix1
		mymatrix2					<<- mymatrix2
		mymatrix3					<<- mymatrix3
		mymatrix4					<<- mymatrix4
		mymatrix5					<<- mymatrix5
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after running correctmaf() function, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	}
	
# depreciated:
correctmaf_old<-function(popnames=mysambar$populations,indthreshold=0.25)
	{
	# Due to excluding datapoints, the allele which is listed as minor might have become major
	# For example: if you have: 1 2 2 0 0, and the last individual is removed, then the minor allele has become the major allele
	# this function makes the correction 
	indfilter	<- inds$miss<=indthreshold
	mymatrix	<- as.matrix(mygenlight)
	for (i in (1:(ncol(mymatrix))))
		{
		if (snps$maf[i]>0.5)
			{
			# edit snps-dataframe:
			myminor				<- snps$minor[i]
			mymajor				<- snps$major[i]
			snps$minor[i]		<<- mymajor
			snps$major[i]		<<- myminor
			myminorcount		<- snps$minorcount[i]
			mymajorcount		<- snps$majorcount[i]
			snps$minorcount[i]	<<- mymajorcount 
			snps$majorcount[i]	<<- myminorcount
			mymaf				<- snps$maf[i]
			snps$maf[i]			<<- 1-mymaf
			for (j in popnames)
				{
				mypopmaf		<- snps[i,names(snps) == paste("maf",j,sep="_")]
				snps[i,names(snps) == paste("maf",j,sep="_")]	<<- 1-mypopmaf 
				}
			# edit data in genlight object:
			temp				<- mymatrix[,i]
			temp[temp==0]		<- 3
			temp[temp==2]		<- 0
			temp[temp==3]		<- 2
			mymatrix[,i]		<- temp
			}
		}
	mygenlight		<<- as.genlight(mymatrix)
	mygenlight@pop	<<- as.factor(inds$pop)
	# Per population: (double?)
	#for (i in (1:length(popnames)))
	#	{
	#	snps$maftemp 	<<- glMean(mygenlight[indfilter&inds$pop==popnames[i],])
	#	names(snps)[names(snps) == "maftemp"] <<- paste("maf",popnames[i],sep = "_")
	#	}
	# if this function has been executed before, remove columns produced during previous execution:
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	
	
getpopmaf<-function(popnames=mysambar$populations,dofilter=TRUE,snpthreshold=0.1)
	{
	# It can happen that a certain allele is the minor allele in the meta population but the major allele in the subpopulation.
	# The maf_popname columns in the snp dataset define minor alleles based on the meta pop reference.
	# This function will create new columns (maf2_popname) which define minor allele based on the subpopulation.
	# This maf2-column is needed for intrapopulation analyses, such as sfs plot. 
	# For comparisons between populations, use maf-column rather than maf2-column.   
	inds$popmaf			<<- NA
	inds$popmaf_all		<<- NA
	popnames			<- as.vector(popnames) 
	for (i in (1:length(popnames)))
		{
		mymaf					<- snps[names(snps) == paste("maf",popnames[i],sep="_")]
		mymaf					<- as.vector(unlist(mymaf))
		snps$mymaf				<<- mymaf
		mymaf[is.na(mymaf)]		<- 0
		snps$mymaf[mymaf>0.5]	<<- 1-mymaf[mymaf>0.5] 
		if(!dofilter)
			{
			snpfilter				<- snps$miss<=snpthreshold
			myfilter1				<- snpfilter&is.finite(snps$mymaf)
			myfilter2				<- snpfilter&snps$mymaf>0&is.finite(snps$mymaf)
			}else{
			myfilter1				<- is.finite(snps$mymaf)
			myfilter2				<- is.finite(snps$mymaf)
			}
		inds$popmaf[inds$pop==popnames[i]]			<<- mean(snps$mymaf[myfilter2],na.rm=TRUE)
		inds$popmaf_all[inds$pop==popnames[i]]		<<- mean(snps$mymaf[myfilter1],na.rm=TRUE)
		inds$expHe[inds$pop==popnames[i]]			<<- mean(2*snps$mymaf[myfilter2]*(1-snps$mymaf[myfilter2]),na.rm=TRUE)				# all sites
		inds$expHe_all[inds$pop==popnames[i]]		<<- mean(2*snps$mymaf[myfilter1]*(1-snps$mymaf[myfilter1]),na.rm=TRUE)	
		names(snps)[names(snps) == "mymaf"] 		<<- paste("maf2",popnames[i],sep = "_")
		}
	snps$mymaf	<<- NULL
	inds 		<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}

snp_hetero<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1,make_global=FALSE,silent=TRUE)
	{
	# Locusspecific heterozygosities:
	indfilter	<- inds$miss <= indthreshold
	snpfilter	<- snps$miss <= snpthreshold
	mymatrix 	<- as.matrix(mygenlight[indfilter,])
	#snps$hetero	<<- apply(mymatrix,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	mymatrix[is.na(mymatrix)]	<- 3
	snps$hetero	<<- apply(mymatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
	# get genotype counts:
	n_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c!=3))))
	AA_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==0))))
	Aa_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==1))))
	aa_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==2))))
	#na_vector	<- as.vector(apply(mymatrix, 2, function(c)length(c[is.na(c)])))
	na_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==3))))
	snps$n		<<- n_vector
	snps$AA		<<- AA_vector	
	snps$Aa		<<- Aa_vector	
	snps$aa		<<- aa_vector	
	if(any(snps$n!=(snps$AA+snps$Aa+snps$aa)))
		{
		return(cat("ERROR: total number of genotypes not equal to the sum of AA, Aa and aa genotypes. Please contact the developer of SambaR.",sep="\n"))
		}
	if(any(snps$n!=(snps$nonmissallelecount/2)))
		{
		return(cat("ERROR: allele count does is not double the the total number of genotypes. Please contact the developer of SambaR.",sep="\n"))
		}
	# snps$mono	<<- snps$Aa+snps$aa==0		# 1801220: snps with no variation after filtering, but this is already captured by snps$polyfilter
	# optionally check if everything adds up:
	mysum		<- AA_vector+Aa_vector+aa_vector+na_vector
	mysum2		<- AA_vector+Aa_vector+aa_vector
	if(make_global)
		{
		myhetero2	<<- snps$Aa/mysum2			# if(snps$hetero!=snps$hetero2), something is wrong
		}
	# to compare observed genotypes with expected genotypes:
	snps$expAA	<<- round((1-snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expAa	<<- round(2*(snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expaa	<<- round(snps$maf*snps$maf*snps$nonmissallelecount/2)
	# Per population:
	for (i in (1:length(popnames)))
		{
		if(!silent){cat(popnames[i],sep="\n")}
		snps$nindtemp							<<- nrow(inds[indfilter&inds$pop==popnames[i],])
		matrixtemp								<- as.matrix(mygenlight[indfilter&inds$pop==popnames[i],])
		#snps$heterotemp						<<- apply(matrixtemp,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		matrixtemp[is.na(matrixtemp)]			<- 3		# because otherwise NA's are counted as 1.
		snps$ntemp								<<- apply(matrixtemp,2,function(z){length(which(z!=3))})
		snps$AAtemp								<<- apply(matrixtemp,2,function(z){length(which(z==0))})
		snps$Aatemp								<<- apply(matrixtemp,2,function(z){length(which(z==1))})
		snps$aatemp								<<- apply(matrixtemp,2,function(z){length(which(z==2))})
		if(any(snps$ntemp!=(snps$AAtemp+snps$Aatemp+snps$aatemp)))
			{
			return(cat("ERROR: total number of genotypes per population not equal to the sum of AA, Aa and aa genotypes. Please contact the developer of SambaR.",sep="\n"))
			}
		popac									<- as.vector(snps[,paste("ac",as.vector(popnames[i]),sep = "_")])							
		if(any(snps$ntemp!=(popac/2)))
			{
			#return(cat("ERROR: population allele count does is not double the the total number of genotypes. Please contact the developer of SambaR.",sep="\n"))
			cat("WARNING: population allele count does is not double the the total number of genotypes. Please contact the developer of SambaR.",sep="\n")
			}
		snps$heterotemp							<<- apply(matrixtemp,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		names(snps)[names(snps) == "nindtemp"]	<<- paste("nind",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "ntemp"] 	<<- paste("n",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "AAtemp"] 	<<- paste("AA",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "Aatemp"] 	<<- paste("Aa",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "aatemp"] 	<<- paste("aa",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "heterotemp"]<<- paste("hetero",as.vector(popnames[i]),sep = "_")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	

snp_hetero_old<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# Locusspecific heterozygosities:
	indfilter	<- inds$miss <= indthreshold
	snpfilter	<- snps$miss <= snpthreshold
	mymatrix 	<- as.matrix(mygenlight[indfilter,])
	snps$hetero	<<- apply(mymatrix,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	for (i in (1:nrow(snps)))
		{
		temp2		<- mymatrix[,i]
		temp		<- temp2==0
		temp		<- ifelse(is.na(temp),FALSE,temp)
		snps$AA[i]	<<- length(temp[temp])
		snps$Aa[i]	<<- sum(temp2[temp2==1],na.rm=TRUE)
		snps$aa[i]	<<- 1/2*sum(temp2[temp2==2],na.rm=TRUE)
		#snps$hetero2[i]	<<- snps$Aa[i]/(snps$AA[i]+snps$Aa[i]+snps$aa[i])
		# if(snps$hetero!=snps$hetero2), something is wrong
		}
	# to compare observed genotypes with expected genotypes:
	#nrofinds	<- length(inds$nr[indmissfilter])
	snps$expAA	<<- round((1-snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expAa	<<- round(2*(snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expaa	<<- round(snps$maf*snps$maf*snps$nonmissallelecount/2)
	# Per population:
	for (i in (1:length(popnames)))
		{
		matrixtemp						<- as.matrix(mygenlight[indfilter&inds$pop==popnames[i],])
		# snps$heterotemp				<<- apply(matrixtemp,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		matrixtemp[is.na(matrixtemp)]	<- 3		# because otherwise NA's are counted as 1.
		snps$heterotemp					<<- apply(matrixtemp,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		names(snps)[names(snps) == "heterotemp"] <<- paste("hetero",as.vector(popnames[i]),sep = "")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}		
	
chrom_He_maf<-function(mychroms=NULL,addX=TRUE,export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("MAF_He_perchrom.eps",family=mysambar$myfont,width=25,height=10)}
		if(export=="pdf"){pdf("MAF_He_perchrom.pdf",family=mysambar$myfont,width=25,height=10)}
		if(export=="png"){png("MAF_He_perchrom.png",family=mysambar$myfont,width=1800,height=720)}
		if(export=="wmf"){win.metafile("MAF_He_perchrom.wmf",family=mysambar$myfont,width=25,height=10)}
		}
	par(mfrow=c(2,1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	boxplot(snps$maf[snps$placed]~as.vector(snps$chr[snps$placed]),main="",xaxt='n',ylab="Minor allele frequencies")
	boxplot(snps$hetero[snps$placed]~as.vector(snps$chr[snps$placed]),main="",xlab="Chromosome",ylab="Heterozygosities")
	mtext("Chromosome",side=1,cex=2.5,line=3)
	if(!is.null(export)){dev.off()}
	}

filters<-function(indthreshold=0.25,snpthreshold=0.1,mac=2,mindistance=500,hefilter=TRUE,snpdepth_filter=TRUE,TsTv_filter=NULL,paralogthreshold1=0.5,paralogthreshold2=0.05,silent=TRUE,olddistfilter=FALSE)
	{
	##### For individuals:
	# 05-03-2020: I decided not to filter on mean read depth per individual, because read depth is correlated to missingness, and therefore a read depth filter is redundant.
	#if("meandepth"%in%colnames(inds)&!is.null(mindepth))
	#	{
	#	inds$depthfilter	<<- inds$meandepth>=mindepth
	#	}else{
	#	inds$depthfilter	<<- TRUE	
	#	}
	#inds$filter	<<- inds$miss<=indthreshold&inds$depthfilter
	inds$filter		<<- inds$miss<=indthreshold
	inds$filter2	<<- inds$filter		# back up for when using excludepop()
	mynind			<- as.data.frame(table(inds$pop[inds$filter]))
	inds$pop_ninds	<<- NA
	for (i in c(1:nrow(inds)))
		{
		mypop				<- inds$pop[i]
		mypop2				<- which(mynind$Var1==mypop)
		inds$pop_ninds[i]	<<- mynind$Freq[mypop2]
		}
	#
	##### For snps:
	# missing data:
	snps$missfilter			<<- snps$miss<=snpthreshold
	# filter out paralogs (based on maf-he relationship):
	if(hefilter)
		{
		snps$hefilter		<<- (snps$maf<paralogthreshold2)|(snps$hetero<(paralogthreshold1*snps$maf+(2*snps$maf*(1-snps$maf))))
		# 25-3-2020: if snps$maf is NA, this results in NA-values. Replace:
		snps$hefilter[is.na(snps$hefilter)] <<- FALSE
		}else{
		snps$hefilter		<<- TRUE
		}
	# Is snp on different contig or at least certain number of bp away from previous snp?
	chrfilter				<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	chrfilter				<- c(TRUE,chrfilter[1:(length(chrfilter)-1)])
	if("dist" %in% colnames(snps))
		{
		if(olddistfilter)
			{
			# 29-06-2021: more correct
			snps$distfilter		<<- chrfilter|(snps$dist>=mindistance)
			}else{
			runthinfilter(binsize=mindistance)
			}
		}else{
		snps$distfilter		<<- TRUE
		}
	# Does snp have at least certain number of minor alleles?
	if(!is.null(mac))
		{
		snps$macfilter		<<- snps$minorcount >= mac
		}else{
		snps$macfilter		<<- TRUE
		}
	if(snpdepth_filter)
		{
		snps$depthfilter	<<- snps$depthfilter
		}else{
		snps$depthfilter	<<- TRUE
		}
	if(!is.null(TsTv_filter))
		{
		if(TsTv_filter!="Ts"&TsTv_filter!="Tv")
			{
			return(cat("ERROR: input to TsTv_filter flag should be either 'Ts' (to keep transitions only) and 'Tv' (to keep transversions only).",sep="\n")) 
			}
		if(TsTv_filter=="Ts")
			{
			snps$tstvfilter	<<- snps$transit
			}else{
			snps$tstvfilter	<<- !snps$transit
			}
		}else{
		snps$tstvfilter		<<- TRUE
		}
	if(!"polyfilter" %in% colnames(snps))
		{
		cat("WARNING: column snps$polyfilter absent. Creating now...",sep="\n")
		snps$polyfilter		<<- glMean(mygenlight)>0
		}
	if(!silent){cat("Setting overall filter.",sep="\n")}
	# Set overall filters:
	snps$filter2		<<- snps$missfilter&snps$hefilter&snps$macfilter&snps$uniqpos&snps$depthfilter&snps$tstvfilter&snps$polyfilter
	snps$filter			<<- snps$filter2&snps$distfilter
	if(!silent){cat("Overall filters set.",sep="\n")}
	# The following lines are necessary to present the error: Error in if (!any(snps$filter)) { : missing value where TRUE/FALSE needed
	# Although probably if there is a NA, the problem was earlier.
	snps$filter[is.na(snps$filter)]		<<- FALSE	
	snps$filter2[is.na(snps$filter2)]	<<- FALSE	
	# remove duplicate columns:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	#
	mysambar$populations	<<- mysambar$populations2
	mysambar$mycolours		<<- mysambar$mycolours2
	}

plotfilters<-function(export=NULL,plotdiscarded=TRUE)
	{
	filterdf<-snps[,c("polyfilter","missfilter","hefilter","distfilter","macfilter","tstvfilter","filter","filter2")]
	#
	if(plotdiscarded)
		{
		plottitle		<- "Number of discarded SNPs"
		}else{
		plottitle		<- "Number of retained SNPs"
		}
	mymatrix			<- matrix(NA,nrow=8,ncol=8)
	colnames(mymatrix)	<- c("poly","miss","he","dist","mac","tstv","all","all2")
	rownames(mymatrix)	<- c("poly","miss","he","dist","mac","tstv","all","all2")
	for(i in c(1:8))		# per row
		{
		for(j in c(1:8))	# per column
			{
			filter1			<- filterdf[,i]
			filter2			<- filterdf[,j]
			if(i<j)			# above diagonal
				{
				if(plotdiscarded)
					{
					mymatrix[i,j]	<- length(which((!filter1)|(!filter2)))	
					}else{
					mymatrix[i,j]	<- length(which(filter1&filter2))
					}
				}
			if(i==j)
				{
				if(plotdiscarded)
					{
					mymatrix[i,j]	<- length(which(!filter1))
					}else{
					mymatrix[i,j]	<- length(which(filter1))
					}
				}
			}
		}
	mymatrix	<<- mymatrix
	#
	# create heatmap showing number of filter data:
	if(!is.null(export))
		{
		plotname	<- ifelse(plotdiscarded,"Filterclasses_discarded","Filterclasses_retained")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=12,height=11)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=12,height=11)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=1200,height=1100)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=12,height=11)}
		}
	# define colours:
	mymax		<- max(mymatrix,na.rm=TRUE)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- seq(0,1000,100)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	# create heatmap:
	heatmap.2(lwid=c(0.5,4),lhei=c(0.5,4),mymatrix,cellnote=ifelse(!is.na(mymatrix),mymatrix,""),notecol="black",adjRow = c(0.5,0.5),adjCol=c(NA,0.5),notecex=2.5,cex.lab=2,cexRow=2.5,cexCol=2.5,Colv=FALSE,Rowv=FALSE,scale="none",dendrogram="none",key=FALSE,col=myColours,keysize=1,trace="none",ylab = "",xlab = "",srtCol=45,srtRow=45)
	mtext(plottitle, side = 3, line = 0.5, cex = 3)
	if(!is.null(export)){dev.off()}
	}

ind_maf<-function(popnames=mysambar$populations,allsites=FALSE,popcorrect=TRUE,silent=TRUE)	
	{
	# This function calculates the average number of minor alleles (relative to metapopulation) per locus.
	# For each locus (2 alleles) the outcome can be: 
	# 0/2 = 0
	# 1/2 = 0.5
	# 2/2 = 1
	# This is averaged over all loci. Say for example we have the following genotype score for 10 loci:
	# 1 0 0 1 
	# Then we: (1 + 1)/8 = 0.25. 
	# So each locus 25 percent of observing a minor allele, according to calculations. 
	# This is correct, because the probabilities per locus are 0.5, 0, 0, 0.5. 
	# As a side note: we observe 50 percent heterozygous loci. This is a slight he-excess, because expected heterozygosity is: 2*0.25*0.75 = 0.375.  
	#   	
	# If allsites = TRUE, maf is calculated for all sites, including sites which are not segregating within the population to which the individual belongs
	# If allsites = TRUE, results will be stored in column inds_maf_all
	# If allsites = FALSE (default), maf is calculated for segregating sites only
	# If allsites = FALSE (default), results will be stored in column inds_maf
	indmaf					<- rep(NA,nrow(inds))
	nsegsites1				<- rep(NA,nrow(inds))
	nsegsites2				<- rep(NA,nrow(inds))
	nsegsites3				<- rep(NA,nrow(inds))
	nsegsites4				<- rep(NA,nrow(inds))
	n0_meta					<- rep(NA,nrow(inds))
	n1_meta					<- rep(NA,nrow(inds))
	n2_meta					<- rep(NA,nrow(inds))
	ntotal					<- rep(NA,nrow(inds))
	#
	n0_pop					<- rep(NA,nrow(inds))
	n1_pop					<- rep(NA,nrow(inds))
	n2_pop					<- rep(NA,nrow(inds))
	#
	for (i in (1:(nrow(inds))))
		{
		if(!silent){cat(i,sep="\n")}
		if(!silent){cat(as.vector(inds$name[i]),sep="\n")}
		mypop				<- as.vector(inds$pop[i])
		if(allsites)
			{
			temp			<- as.matrix(mygenlight[i,snps$filter])
			mymaf1			<- snps[snps$filter,names(snps)==paste("maf",mypop,sep="_")]
			mymaf2			<- snps[snps$filter,names(snps)==paste("maf2",mypop,sep="_")]
			}else{
			mypop			<- inds$pop[i]
			mypopmaf		<- snps[,names(snps) == paste("maf",mypop,sep="_")] 	
			mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
			temp			<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0])
			mymaf1			<- snps[snps$filter&mypopmaf>0,names(snps)==paste("maf",mypop,sep="_")]
			mymaf2			<- snps[snps$filter&mypopmaf>0,names(snps)==paste("maf2",mypop,sep="_")]
			nsegsites1[i]	<- ncol(temp)
			nsegsites2[i]	<- length(temp[!is.na(temp)])
			temp2			<- as.matrix(mygenlight[i,snps$hefilter&mypopmaf>0])
			nsegsites3[i]	<- ncol(temp2)
			nsegsites4[i]	<- length(temp2[!is.na(temp2)])
			}
		temp2	<- as.data.frame(table(temp))
		# number of 1's (heterozygous sites): 	(length(z[z==1])-(length(z)-length(z[!is.na(z)]))
		# indmaf[i]			<- apply(temp,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)]))+2*(length(z[z==2])-(length(z)-length(z[!is.na(z)]))))/(2*length(z[!is.na(z)])))
		# the apply-function works fine, but this one is easier to understand:
		#
		# 22-02-2021: calculate n0, n1 and n2 using estimate of minor allele based on metapopulation:
		temp3					<- temp[!is.na(temp)]
		n0_meta[i]				<- length(temp3[temp3==0])
		n1_meta[i]				<- length(temp3[temp3==1])
		n2_meta[i]				<- length(temp3[temp3==2])
		if(!silent){cat(paste("n2_meta: ", n2_meta[i],sep=""),sep="\n")}
		#
		# calculate n0, n1 and n2 after correction for minor alleles which flipped over in subpopulation to becoming major allele:
		# Note: if sample sizes are small, this can result in biased estimates
		temp4					<- temp
		temp5					<- temp
		temp5[(mymaf1!=mymaf2)&temp4==2]<- 0
		temp5[(mymaf1!=mymaf2)&temp4==0]<- 2
		temp3					<- temp5[!is.na(temp5)]
		n0_pop[i]				<- length(temp3[temp3==0])
		n1_pop[i]				<- length(temp3[temp3==1])
		n2_pop[i]				<- length(temp3[temp3==2])
		if(!silent){cat(paste("n2_pop: ", n2_pop[i],sep=""),sep="\n")}
		# calculate average proportion of minor alleles (based on correction of minor allele):
		ntotal[i]			<- length(temp3)
		indmaf[i]			<- sum(temp3)/(2*length(temp3))		# 2 alleles per locus, so hence times 2
		}
	if(allsites)
		{
		inds$maf_all		<<- indmaf
		inds$n0_meta		<<- n0_meta
		inds$n1_meta		<<- n1_meta
		inds$n2_meta		<<- n2_meta
		inds$ndata			<<- ntotal
		inds$n0_pop			<<- n0_pop
		inds$n1_pop			<<- n1_pop
		inds$n2_pop			<<- n2_pop
		inds$allgeno		<<- inds$n0_pop>0&inds$n1_pop>0&inds$n2_pop>0
		inds$allgeno2		<<- inds$n0_pop>0&inds$n2_pop>0
		}else{
		inds$n0_meta_seg	<<- n0_meta
		inds$n1_meta_seg	<<- n1_meta
		inds$n2_meta_seg	<<- n2_meta
		inds$maf			<<- indmaf
		inds$nsegsites1		<<- nsegsites1
		inds$nsegsites2		<<- nsegsites2
		inds$nsegsites3		<<- nsegsites3
		inds$nsegsites4		<<- nsegsites4
		}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}

# This function is executed by the importdata() function in order to create a preliminary He_vs_miss plot which can be consulted by users before running the filterdata() function:  
# It calculates temporary inds$hetero values
indhetero_allsnps<-function()
	{
	# Calculates individual heterozygosities:
	indhet			<- rep(NA,nrow(inds))
	indnsites2		<- rep(NA,nrow(inds))
	for (i in (1:(nrow(inds))))
		{
		mymatrix 		<- as.matrix(mygenlight[i,])
		# the next seemingly complicated formula is necessary because NA are counted as 1's.
		indhet[i]		<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		indnsites2[i]	<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
		}
	inds$hetero_all		<<- indhet
	inds$hetero			<<- indhet
	inds$nsites2		<<- indnsites2
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}	

ind_hetero<-function(popnames=mysambar$populations,chrominfo=FALSE,allsites=FALSE)
	{
	# Calculates individual heterozygosities:
	indhet		<- rep(NA,nrow(inds))
	indhet2		<- rep(NA,nrow(inds))
	indhetX		<- rep(NA,nrow(inds))
	indnsites1	<- rep(NA,nrow(inds))
	indnsites2	<- rep(NA,nrow(inds))
	indnsites_nofilter	<- rep(NA,nrow(inds))
	indnsites_filter2	<- rep(NA,nrow(inds))
	for (i in (1:(nrow(inds))))
		{
		if(chrominfo)
			{
			if(allsites)
				{
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&snps$chr!="X"])
				Xmatrix		<- as.matrix(mygenlight[i,snps$filter&snps$chr=="X"])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2&snps$chr!="X"])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter&snps$chr!="X"])
				}else{
				mypop		<- inds$pop[i]
				mypopmaf	<- snps[,names(snps) == paste("maf",mypop,sep="_")]
				mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&snps$chr!="X"&mypopmaf>0])
				Xmatrix		<- as.matrix(mygenlight[i,snps$filter&snps$chr=="X"&mypopmaf>0])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2&snps$chr!="X"&mypopmaf>0])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter&snps$chr!="X"&mypopmaf>0])
				}
			# the next seemingly complicated formula is necessary because NA are counted as 1's.
			# the formula has the following structure:
			# ((number of He-sites) - (number of sites with missing data))/(number of sites without missing data) 
			# For example, the following vector: 2 0 NA 1 1 NA
			# would result in:
			# 4 - (4 - 2))/4				
			indnsites1[i]			<- apply(mymatrix,1,function(z) length(z))
			indnsites2[i]			<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
			indhet[i]				<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indhetX[i]				<- apply(Xmatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indnsites_filter2[i]	<- apply(mymatrix2,1,function(z) length(z[!is.na(z)]))
			indnsites_nofilter[i]	<- apply(mymatrix3,1,function(z) length(z[!is.na(z)]))
			}else{
			if(allsites)
				{
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter])
				}else{
				mypop		<- inds$pop[i]
				mypopmaf	<- snps[,names(snps) == paste("maf",mypop,sep="_")]
				mypopmaf[is.na(mypopmaf)]	<- 0		# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2&mypopmaf>0])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter&mypopmaf>0])
				}
			# the next seemingly complicated formula is necessary because NA are counted as 1's.
			indnsites1[i]	<- apply(mymatrix,1,function(z) length(z))
			indnsites2[i]	<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
			indhet[i]		<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indnsites_filter2[i]	<- apply(mymatrix2,1,function(z) length(z[!is.na(z)]))
			indnsites_nofilter[i]	<- apply(mymatrix3,1,function(z) length(z[!is.na(z)]))
			}
		}
	if(!allsites)	{inds$hetero				<<- indhet}
	if(!allsites)	{inds$hetero[inds$popmaf==0]<<- 0}		# necessary because of line: mymatrix 	<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0]) 
	if(allsites)	{inds$nsites1				<<- indnsites1}
	if(allsites)	{inds$nsites2				<<- indnsites2}
	if(allsites)	{inds$hetero_all			<<- indhet}
	if(allsites)	{inds$nsites_filter2		<<- indnsites_filter2}
	if(allsites)	{inds$nsites_nofilter		<<- indnsites_nofilter}
	if(!allsites)	{inds$nsegsites_filter2		<<- indnsites_filter2}
	if(!allsites)	{inds$nsegsites_nofilter	<<- indnsites_nofilter}
	if(chrominfo)	{inds$heteroX				<<- indhetX}
	if(allsites&&chrominfo)	{inds$heteroX_all	<<- indhetX}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}	

plotlocusdepth<-function(export=FALSE)
	{
	myscores	<- snps$meandepth[!is.na(snps$meandepth)]
	temp		<- myscores[myscores<quantile(myscores,0.995)]
	mythreshold	<- qnorm((1-0.05/length(myscores)), mean = mean(temp,na.rm=TRUE), sd = sd(temp,na.rm=TRUE), lower.tail = TRUE, log.p = FALSE)
	hs			<- hist(log(myscores),breaks=1000)
	if(export){pdf("Locusdepth.pdf")}
	par(layout(matrix(c(1,1,1,1,1,1,1,1,2),1,9)),mar=c(2,0,2,0),oma=c(3,7,2,2))
	plot(myscores,log="y",cex=0.75,pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(c(1:length(myscores))[myscores>mythreshold],myscores[myscores>mythreshold],cex=0.75,pch=16,col="red")
	abline(h=mythreshold,lty=2)
	mtext("Mean read depth",side=2,line=4,cex=2)
	mtext("SNP index",side=1,line=4,cex=2)
	# add histogram on the side
	plot(NA, type='n', axes=FALSE, yaxt='n',xlab='',ylab=NA,main=NA,xlim=c(0,max(hs$counts)),ylim=c(1,length(hs$counts)))
	arrows(rep(0,length(hs$counts)),1:length(hs$counts),hs$counts,1:length(hs$counts),length=0,angle=0,lwd=2,col="grey")
	if(export){dev.off()}
	}

plotHe_perind<-function(export=NULL,genomehe=FALSE)
	{
	ninds	<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		plotname	<- ifelse(genomehe,"Genomehe_per_ind","He_per_ind")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=ninds*0.25,width=15)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=ninds*0.25,width=15)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=ninds*25,width=1500)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=ninds*0.25,width=15)}
		}
	indstemp	<- inds[order(inds$pop),]
	if(!genomehe)
		{
		myhe	<- indstemp$hetero_all
		}else{
		myhe	<- indstemp$genomehe
		}
	barplot(myhe[indstemp$filter],col=indstemp$popcol[indstemp$filter],border=indstemp$popcol[indstemp$filter],horiz=TRUE,names.arg=indstemp$nr[indstemp$filter],las=1)	
	if(!genomehe)
		{
		mtext(side=1,"Heterozygosity",line=3,cex=3)
		}else{
		mtext(side=1,"Genome wide heterozygosity",line=3,cex=3)
		}
	if(!is.null(export)){dev.off()}
	}

barplotF_perind<-function(export=NULL)
	{
	ninds	<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		plotname	<- "Inbreeding_per_ind"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=ninds*0.25,width=15)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=ninds*0.25,width=15)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=ninds*25,width=1500)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=ninds*0.25,width=15)}
		}
	indstemp	<- inds[order(inds$pop),]
	barplot(indstemp$obshomo[indstemp$filter],col=indstemp$popcol[indstemp$filter],border=indstemp$popcol[indstemp$filter],horiz=TRUE,names.arg=indstemp$nr[indstemp$filter],las=1)
	myauto	<- indstemp$F[indstemp$filter]*indstemp$nsites5[indstemp$filter]
	myauto	<- ifelse(myauto<0,0,myauto)
	barplot(myauto,add=TRUE,col="grey90",border=indstemp$popcol[indstemp$filter],horiz=TRUE)
	mtext(side=1,"Number of autozygous (light grey) and non-autozygous (colour) homozygous sites",line=2.5,cex=2)
	if(!is.null(export)){dev.off()}
	}
	
retainedsites_perpop<-function(export=NULL)
	{
	npops	<- length(mysambar$populations)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Retainedsites.perpop.eps",family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="pdf"){pdf("Retainedsites.perpop.pdf",family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="png"){png("Retainedsites.perpop.png",family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile("Retainedsites.perpop.wmf",family=mysambar$myfont,width=npops*2.5,height=6)}
		}
	par(mar=c(4,8,0.5,0.5))
	boxplot(inds$nsites2[inds$filter]~inds$pop[inds$filter],col=mysambar$mycolours[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,pch=16)
	mtext(side=2,"Number of retained sites",line=5,cex=2)
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

retainedinds_perpop<-function(export=NULL,popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	nindsperpop	<- vector()
	for(k in c(1:npops))
		{
		nindsperpop[k]	<- nrow(inds[as.character(inds$pop)==as.character(popnames[k])&inds$filter,])
		}
	if(length(nindsperpop)!=length(mysambar$mycolours))
		{
		return(cat("ERROR: number of populations does not correspond with number of colours.",sep="\n"))
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Retainedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Retainedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Retainedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Retainedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nindsperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,main="Retained individuals",names.arg=popnames,las=1)
	if(!is.null(export)){dev.off()}
	}	

discardedinds_perpop<-function(export=NULL,popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	nindsperpop	<- vector()
	for(k in c(1:npops))
		{
		nindsperpop[k]	<- nrow(inds[as.character(inds$pop)==as.character(popnames[k])&(!inds$filter),])
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Discardedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Discardedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Discardedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Discardedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nindsperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,main="Discarded individuals",names.arg=popnames,las=1)
	if(!is.null(export)){dev.off()}
	}

indsfilter_perpop<-function(export=NULL,popnames=mysambar$populations)
	{
	npops					<- length(popnames)
	nretainedperpop			<- vector()
	for(k in c(1:npops))
		{
		nretainedperpop[k]	<- nrow(inds[as.character(inds$pop)==as.character(popnames[k])&(inds$filter),])
		}
	ndiscardedperpop		<- vector()
	for(k in c(1:npops))
		{
		ndiscardedperpop[k]	<- -(nrow(inds[as.character(inds$pop)==as.character(popnames[k])&(!inds$filter),]))
		}	
	mymin	<- min(ndiscardedperpop)-1
	mymax	<- max(nretainedperpop)+1
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Discardedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Discardedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Discardedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Discardedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nretainedperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,main="Discarded (-) and retained (+) individuals",names.arg=popnames,las=1,xlim=c(mymin,mymax))
	barplot(ndiscardedperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,add=TRUE)
	abline(v=0)
	if(!is.null(export)){dev.off()}
	}
	
plot_number_segregating_sites<-function(popnames=mysambar$populations,export=NULL,dofilter=FALSE)
	{
	if(dofilter)
		{
		mysegsites	<- inds$nsegsites2
		mytotalsites<- inds$nsites2
		}else{
		mysegsites	<- inds$nsegsites_nofilter
		mytotalsites<- inds$nsites_nofilter
		}
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		mystring	<- ifelse(dofilter,"retained","all")
		if(export=="eps"){postscript(paste("Segregatingsites",mystring,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("Segregatingsites",mystring,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("Segregatingsites",mystring,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("Segregatingsites",mystring,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	mymin					<- (min(c(min(mytotalsites),min(mysegsites))))/1000
	mymax					<- (max(c(max(mytotalsites),max(mysegsites))))/1000
	if(!dofilter)
		{
		plot(mytotalsites[inds$filter]/1000,mysegsites[inds$filter]/1000,xlim=c(mymin,mymax),ylim=c(mymin,mymax),main="Proportion segregating sites",xlab="# All sites (x 1000)",ylab="# Segregating sites (x 1000)",cex=2.5)
		}else{
		plot(mytotalsites[inds$filter]/1000,mysegsites[inds$filter]/1000,xlim=c(mymin,mymax),ylim=c(mymin,mymax),main="Proportion segregating sites",xlab="# Retained sites (x 1000)",ylab="# Retained segregating sites (x 1000)",cex=2.5)
		}
	for (j in c(1:length(popnames)))
		{
		mypop				<- popnames[j]
		points(mytotalsites[inds$pop==mypop&inds$filter]/1000,mysegsites[inds$pop==mypop&inds$filter]/1000,col=mysambar$mycolours[j],pch=16,cex=2.5)
		points(mytotalsites[inds$pop==mypop&!inds$filter]/1000,mysegsites[inds$pop==mypop&!inds$filter]/1000,col=mysambar$mycolours[j],cex=2.5)
		}
	lines(c(-1000,nrow(snps)),c(-1000,nrow(snps)))
	legend("topleft",legend=popnames,bty='n',fill=unique(inds$popcol),cex=2)
	if(!is.null(export)){dev.off()}
	}
	
mysummarytable<-function()
	{
	options(scipen=999)	# no scientific notation
	if("dist" %in% colnames(snps))
		{
		mydf				<- as.data.frame(matrix(NA,nrow=8,ncol=3))
		rownames(mydf)		<- c("Number of individuals","Number of SNPs","Percentage of SNPs with maf >= 0.05","Mean spacing between SNPs","Median spacing between SNPs","Mean proportion of missing data per individual","GC content","Transition vs transversion ratio")
		colnames(mydf)		<- c("Before filtering","After filtering","After thinning")
		for(i in (c(1:3)))
			{
			if(i==1){snpstemp<-snps;indstemp<-inds}
			if(i==2){snpstemp<-snps[snps$filter2,];indstemp<-inds[inds$filter,]}
			if(i==3){snpstemp<-snps[snps$filter,];indstemp<-inds[inds$filter,]}
			mydf[1,i]		<- nrow(indstemp)
			mydf[2,i]		<- nrow(snpstemp)
			mydf[3,i]		<- 100*nrow(snpstemp[snpstemp$maf>=0.05,])/nrow(snpstemp)
			mydf[4,i]		<- mean(snpstemp$dist,na.rm=TRUE)
			mydf[5,i]		<- median(snpstemp$dist,na.rm=TRUE)
			mydf[6,i]		<- mean(indstemp$miss,na.rm=TRUE)
			mydf[7,i]		<- nrow(snpstemp[snpstemp$GC,])/(nrow(snpstemp))
			mydf[8,i]		<- nrow(snpstemp[snpstemp$transit,])/(nrow(snpstemp[!snpstemp$transit,]))
			}
		}else{
		mydf				<- as.data.frame(matrix(NA,nrow=6,ncol=2))
		rownames(mydf)		<- c("Number of individuals","Number of SNPs","Percentage of SNPs with maf >= 0.05","Mean proportion of missing data per individual","GC content","Transition vs transversion ratio")
		colnames(mydf)		<- c("Before filtering","After filtering")
		for(i in (c(1:2)))
			{
			if(i==1){snpstemp<-snps;indstemp<-inds}
			if(i==2){snpstemp<-snps[snps$filter2,];indstemp<-inds[inds$filter,]}
			if(i==3){snpstemp<-snps[snps$filter,];indstemp<-inds[inds$filter,]}
			mydf[1,i]		<- nrow(indstemp)
			mydf[2,i]		<- nrow(snpstemp)
			mydf[3,i]		<- 100*nrow(snpstemp[snpstemp$maf>=0.05,])/nrow(snpstemp)	
			mydf[4,i]		<- mean(indstemp$miss,na.rm=TRUE)
			mydf[5,i]		<- nrow(snpstemp[snpstemp$GC,])/(nrow(snpstemp))
			mydf[6,i]		<- nrow(snpstemp[snpstemp$transit,])/(nrow(snpstemp[!snpstemp$transit,]))
			}
		}
	mydf				<- round(mydf,2)
	write.table(mydf,"SambaR.summarystats.txt",row.names=TRUE,col.names=TRUE,quote=FALSE,sep="\t")
	}	

plotminor<-function(export=NULL)
	{	
	if(!"filter"%in%colnames(snps))
		{
		return(cat("ERROR: column 'snps$filter' missing. First run filterdata() function.",sep="\n"))
		}
	if(length(table(snps$minor[snps$minor!=0&!is.na(snps$minor)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor column. Omitting minor allele histogram.",sep="\n"))
		}
	if(length(table(snps$major[snps$major!=0&!is.na(snps$major)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major column. Omitting minor allele histogram.",sep="\n"))
		}
	if(length(table(snps$minor2[snps$minor2!=0&!is.na(snps$minor2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor2 column. Omitting minor allele histogram.",sep="\n"))
		}
	if(length(table(snps$major2[snps$major2!=0&!is.na(snps$major2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major2 column. Omitting minor allele histogram.",sep="\n"))
		}
	graphics.off()
	myminor		<- as.character(snps$minor2)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Minoralleles.pdf",width=16,height=6)}	
		if(export=="pdf"){pdf("Minoralleles.pdf",width=16,height=6)}
		if(export=="png"){png("Minoralleles.png",width=1260,height=600)}
		if(export=="wmf"){win.metafile("Minoralleles.wmf",width=16,height=6)}
		}
	par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	mytable	<-table(myminor)
	mytable	<- round(mytable/1000,1)
	mymax<-(max(mytable)+5)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),xlab="",ylab="",las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("Before filtering",side=3,cex=2,line=-1.5)
	mtext("Number of SNPs (x 1000)",side=2,line=3.5,cex=2)
	mytable<-table(myminor[snps$filter2])
	mytable<- round(mytable/1000,1)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("After filtering",side=3,cex=2,line=-1.5)
	mtext("Nucleotide",side=1,cex=2,line=3.5)
	mytable<-table(myminor[snps$filter])
	mytable<- round(mytable/1000,1)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),xlab="",las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("After filtering and thinning",side=3,cex=2,line=-1.5)
	mtext("Distribution of minor alleles",side=3,outer=TRUE,cex=2,line=-3.5)
	if(!is.null(export)){dev.off()}
	}

plottransits<-function(filter=FALSE,thin=FALSE,export=NULL)
	{
	if(length(table(snps$minor[snps$minor!=0&!is.na(snps$minor)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(length(table(snps$major[snps$major!=0&!is.na(snps$major)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(length(table(snps$minor2[snps$minor2!=0&!is.na(snps$minor2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor2 column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(length(table(snps$major2[snps$major2!=0&!is.na(snps$major2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major2 column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(filter)			{mytable	<- table(as.vector(snps$major2[snps$filter2&!is.na(snps$minor2)]),as.vector(snps$minor2[snps$filter2&!is.na(snps$minor2)]))}
	if(thin)			{mytable	<- table(as.vector(snps$major2[snps$filter&!is.na(snps$minor2)]),as.vector(snps$minor2[snps$filter&!is.na(snps$minor2)]))}
	if(!(filter|thin))	{mytable	<- table(as.vector(snps$major2[!is.na(snps$minor2)]),as.vector(snps$minor2[!is.na(snps$minor2)]))}
	if(nrow(mytable)<2|ncol(mytable)<2)
		{
		return()			#return(cat("Only 1 allele type (A,C,G or T) as minor or major allele. Skipping transition/transversion plots.",sep="\n"))
		}
	mymax		<- max(mytable)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- seq(0,mymax,(mymax/10))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		if(filter)
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.filtered.wmf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.filtered.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.filtered.wmf",width=10,height=10)}
			# png returns blank file
			}
		if(thin)
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.thinned.wmf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.thinned.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.thinned.wmf",width=10,height=10)}
			# png returns blank file
			}
		if(!(filter|thin))
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.nofilter.pdf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.nofilter.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.nofilter.wmf",width=10,height=10)}
			# png returns blank file
			}
		}
	heatmap.2(lwid=c(0.5,4),lhei=c(0.5,4),mytable,cellnote=ifelse(mytable>0,mytable,""),notecol="black",adjRow = c(0.5,NA),adjCol=c(NA,0.5),notecex=3,cex.lab=2,cexRow=3,cexCol=3,Colv=FALSE,Rowv=FALSE,scale="none",dendrogram="none",key=FALSE,col=myColours,keysize=1.5,trace="none",ylab = "",xlab = "",srtCol=0)
	mtext("Minor allele", side = 1, cex = 3, line = 3.75)
	mtext("Major allele", side = 4, cex = 3, line = 0.75)
	mtext("Transitions vs transversions", side = 3, line = 2, cex = 3)
	if(filter){mtext("After filtering", side = 3, line = -0.5, cex = 2.5)}
	if(thin){mtext("After thinning", side = 3, line = -0.5, cex = 2.5)}
	if(!(filter|thin)){mtext("Before filtering", side = 3, line = -0.5, cex = 2.5)}
	if(!is.null(export)){dev.off()}
	}
	
plotfiltermaf<-function(popnames=mysambar$populations,yrange=NULL,export=NULL)
	{
	popnames	<- as.vector(popnames)
	npops		<- length(popnames)
	mycolours	<- as.vector(unique(inds$popcol))
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("MAFperpop.pdf",width=(npops)+1*8+1,height=9)}	
		if(export=="pdf"){pdf("MAFperpop.pdf",width=(npops)+1*8+1,height=9)}
		if(export=="png"){png("MAFperpop.png",width=(npops+1)*800+100,height=900)}
		if(export=="wmf"){win.metafile("MAFperpop.wmf",width=(npops+1)*8+1,height=9)}
		}
	if(is.null(yrange))
		{
		c(0,(nrow(snps[snps$filter,])/3))
		}
	par(mfrow=c(1,length(popnames)+1),mar=c(5,6,5,2),cex.axis=1.75,cex.lab=2,cex.main=2.25)
	hist(snps$maf[snps$filter],40,main = "",ylim=yrange,xlab=NULL)
	mtext("MAF",side=1,line=3.5,cex=2)	
	title("Metapop",line=-3,cex=2.5)
	for (i in (1:length(popnames)))
		{
		#cat(popnames[i],sep="\n")
		maftemp <- glMean(mygenlight[inds$filter&inds$pop==popnames[i],snps$filter])
		hist(maftemp,40,main ="",ylim=yrange,xlab=NULL,col=mycolours[i],xlim=c(0,1))
		mtext("MAF",side=1,line=3.5,cex=2)	
		title(popnames[i],line=-3,cex=2.5)
		}
	#mtext("Locus specific minor allele frequencies", side = 1, outer = TRUE,line=-2,cex=2)		# not handy if user wants to subselect tiles from the plot
	#mtext("MAF per population", side = 3, outer = TRUE,line=-4.5,cex=3.5)						# not handy if user wants to subselect tiles from the plot
	if(!is.null(export)){dev.off()}
	}	

histo_locusHe<-function(popnames=mysambar$populations,yrange=NULL,mysubtitle=NULL,export=NULL)
	{
	popnames	<- as.vector(popnames)
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Heperpop.pdf",width=npops*6,height=7)}	
		if(export=="pdf"){pdf("Heperpop.pdf",width=npops*6,height=7)}
		if(export=="png"){png("Heperpop.png",width=npops*600,height=720)}
		if(export=="wmf"){win.metafile("Heperpop.wmf",width=npops*6,height=7)}
		}
	par(mfrow=c(1,length(popnames)+1),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(is.null(yrange))
		{
		yrange	<- c(0,(nrow(snps[snps$filter,])/3))
		}
	hist(snps$hetero[snps$filter],40,main = "",ylim=yrange,xlab=NULL,xlim=c(0,1))
	mtext("He",side=1,line=3.5,cex=2)
	title("Metapop",line=-3,cex=2.5)
	for (i in (1:length(popnames)))
		{
		snps 		<<- snps[, !duplicated(colnames(snps))]
		heterotemp	<- snps[names(snps) == paste("hetero",as.vector(popnames[i]),sep = "_")]	# 16-03-2021: added underscore
		heterotemp	<- as.vector(heterotemp[,1])
		heterotemp	<- heterotemp[snps$filter]
		hist(heterotemp,40,main ="",ylim=yrange,xlab=NULL,col=mycolours[i],xlim=c(0,1))
		mtext("He",side=1,line=3.5,cex=2)	
		title(popnames[i],line=-3,cex=2.5)
		}
	#mtext("Locus specific heterozygosity", side = 1, outer = TRUE, line=-2, cex=2)			# not handy if user wants to subselect tiles from the plot
	#mtext("Heterozygosity per population", side = 3, outer = TRUE, line=-4.5, cex=3.5)		# not handy if user wants to subselect tiles from the plot
	if(!is.null(mysubtitle))
		{
		mtext(mysubtitle, side = 3, outer = TRUE,line=-3.5)
		}
	if(!is.null(export)){dev.off()}
	}

boxplot_locusHe<-function(export=NULL,popnames=mysambar$populations)
	{
	npops	<- length(popnames)
	if(npops==1)
		{
		return(cat("Only 1 population. Sambar will not generate boxplot with heterozygosity per population.",sep="\n"))
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("LocusHe.perpop.boxplot.eps",family=mysambar$myfont,width=npops*2,height=6)}
		if(export=="pdf"){pdf("LocusHe.perpop.boxplot.pdf",family=mysambar$myfont,width=npops*2,height=6)}
		if(export=="png"){png("LocusHe.perpop.boxplot.png",family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile("LocusHe.perpop.boxplot.wmf",family=mysambar$myfont,width=npops*2,height=6)}
		}
	par(mar=c(4,5,0.5,0.5))
	# 
	# create new dataframe, with one column popname, and other column He-estimates:
	temp	<- snps[snps$filter,names(snps)!="hetero"]
	temp	<- temp[, grep("hetero", names(temp))]
	# 11-06-2021: included next lines to removed imputed_He columns, which otherwise cause an error:
	imputecolumns			<- grep("imputed_hetero",colnames(temp))
	if(length(imputecolumns)>0)
		{
		temp					<- temp[,-imputecolumns]
		}
	myhe	<- as.vector(unlist(temp))
	mypops	<- rep(popnames,each=nrow(temp))
	mydf	<- data.frame(pop=mypops,hetero=myhe)
	boxplot(mydf$hetero~mydf$pop,col=mysambar$mycolours[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,pch=16)
	# add means:
	mymeans <- aggregate(hetero ~ pop, mydf, mean)
	points(c(1:npops),mymeans$hetero,pch=16,col="white",cex=1)
	mtext(side=2,"Locus heterozygosity",line=3.5,cex=2)
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}	

# not used by filter wrapper function:
plotHe<-function(popnames=mysambar$populations)
	{
	npops	<- length(popnames)
	par(mfrow=c(1,4))
	mydf	<- snps[snps$filter,c("maf","hetero")]
	mydf	<- unique(mydf)
	x		<- seq(0,1,0.01)
	y		<- 2*x*(1-x)
	plot(mydf,ylim=c(0,1),xlim=c(0,1))
	lines(x,y,col="red",lwd=2)
	for(i in c(1:npops))
		{
		mypop	<- popnames[i]
		mydf	<- snps[snps$filter,c(paste("maf",mypop,sep="_"),paste("hetero",mypop,sep=""))]
		mydf	<- unique(mydf)
		plot(mydf,ylim=c(0,1),xlim=c(0,1))
		lines(x,y,col="red",lwd=2)
		}
	}

plotbatcheffects<-function(export=NULL,dothin=TRUE,mydf=mysambar$missdf)
	{
	graphics.off()
	if(dothin)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf2		<- mydf[,c("pairmiss_exp","pairmiss_obs","outlier")]
		mydf		<- unique(mydf2)
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Pairwise_miss_deviation.scatter.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Pairwise_miss_deviation.scatter.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Pairwise_miss_deviation.scatter.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Pairwise_miss_deviation.scatter.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	mymax	<- max(c(mydf$pairmiss_exp,mydf$pairmiss_obs),na.rm=TRUE)
	plot(mydf$pairmiss_exp,mydf$pairmiss_obs,pch=16,cex=1,xlab="Expected missingness per sample pair",ylab="Observed missingness per sample pair",ylim=c(0,mymax),xlim=c(0,mymax),main="Identification of batch effects")
	points(mydf$pairmiss_exp[mydf$outlier],mydf$pairmiss_obs[mydf$outlier],pch=16,cex=1,col="red")
	legend("topleft",legend=c("TRUE","FALSE"),title="Batch effect",bty='n',fill=c("red","black"),cex=3)
	if(!is.null(export)){dev.off()}
	}

plotparalogs<-function(export=NULL,removeduplicates=TRUE,dothin=FALSE,silent=TRUE)
	{
	if(removeduplicates)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf		<- snps[,c("maf","hetero","hefilter")]
		mydf		<- unique(mydf)
		mymaf		<- mydf$maf
		myhe		<- mydf$hetero
		hefilter	<- mydf$hefilter
		}else{
		mymaf		<- snps$maf
		myhe		<- snps$hetero
		hefilter	<- snps$hefilter
		}
	create_plot		<- TRUE
	if(dothin)
		{
		if(length(mymaf)>5000)
			{
			mydata		<- data.frame(mymaf,myhe,hefilter)
			mydata2		<- mydata[sample(nrow(mydata),5000),]
			mymaf		<- mydata2$mymaf
			myhe		<- mydata2$myhe
			hefilter	<- mydata2$hefilter
			}else{
			if(!silent)
				{
				cat("Less than 5000 SNPs with unique maf-He scores. No need to thin He_vs_maf plot.",sep="\n")
				}
			create_plot	<- FALSE
			}
		}
	#
	if(create_plot)
		{
		graphics.off()
		if(!is.null(export))
			{
			plotname	<- ifelse(dothin,"He_vs_maf.thinned","He_vs_maf")
			if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		plot(mymaf[hefilter],myhe[hefilter],pch=16,cex=1,xlab="Locus specific minor allele frequency",ylab="Locus specific heterozygosity",ylim=c(0,1),main="Identification of paralogs")
		points(mymaf[!hefilter],myhe[!hefilter],pch=16,cex=1,col="red",xlab="Locus specific minor allele frequency",ylab="Locus specific heterozygosity",ylim=c(0,1))
		legend("topleft",legend=c("FALSE","TRUE"),title="Pass He filter",bty='n',fill=c("red","black"),cex=3)
		if(!is.null(export)){dev.off()}
		}
	}

He_vs_readdepth<-function(export=NULL,mindepth=NULL,popnames=mysambar$populations,allsites=TRUE,legendcex=3)
	{
	graphics.off()
	if(allsites)
		{
		myhetero	<- inds$hetero_all
		}else{
		myhetero	<- inds$hetero
		}
	for(i in c(1:2))
		{
		if(!is.null(export))
			{
			mylabel	<- ifelse(i==1,"filter","pop")
			mylabel2<- ifelse(allsites,"allsites","segregatingsites")
			if(export=="eps"){postscript(paste("He_vs_readdepth_ind",mylabel2,mylabel,"eps",sep="."),family=mysambar$myfont,width=11,height=10)}
			if(export=="pdf"){pdf(paste("He_vs_readdepth_ind",mylabel2,mylabel,"pdf",sep="."),family=mysambar$myfont,width=11,height=10)}
			if(export=="png"){png(paste("He_vs_readdepth_ind",mylabel2,mylabel,"png",sep="."),family=mysambar$myfont,width=800,height=720)}
			if(export=="wmf"){win.metafile(paste("He_vs_readdepth_ind",mylabel2,mylabel,"wmf",sep="."),family=mysambar$myfont,width=11,height=10)}
			}
		par(mar=c(5,8,5,1.5),cex.axis=2.5,cex.lab=3)
		if(i==1)
			{
			plot(inds$meandepth[inds$hetero<0.5],myhetero[inds$hetero<0.5],pch=16,cex=3,log="x",xlab="Mean read depth",ylab="",las=1)
			points(inds$meandepth[(!inds$filter)&inds$hetero<0.5],myhetero[(!inds$filter)&inds$hetero<0.5],pch=16,cex=3,col="red")
			legend("topleft",legend=c("FALSE","TRUE"),title="Retained:",bty='n',fill=c("red","black"),cex=legendcex)
			}else{
			plot(inds$meandepth[inds$hetero<0.5],myhetero[inds$hetero<0.5],pch=16,cex=3,log="x",xlab="Mean read depth",ylab="",las=1,col=inds$popcol[inds$hetero<0.5])
			legend("topleft",legend=popnames,bty='n',fill=mysambar$mycolours,cex=legendcex)
			}
		if(!is.null(mindepth))
			{
			abline(v=mindepth,lty=2,lwd=2,col="grey50")
			}
		if(allsites)
			{	
			mtext("He_allsites",side=2,line=5.5,cex=3.25)
			}else{
			mtext("He_segregating",side=2,line=5.5,cex=3.25)
			}
		if(!is.null(export)){dev.off()}
		}
	}

plotgenotri<-function(export=NULL,allsites=FALSE)
	{
	# package: ade4
	if(allsites)
		{
		mydf			<-inds[,c("n0_meta","n1_meta","n2_meta")]
		}else{
		mydf			<-inds[,c("n0_meta_seg","n1_meta_seg","n2_meta_seg")]
		#plot((inds$n0_meta_seg+inds$n1_meta_seg+inds$n2_meta_seg),inds$n0_meta_seg,col=inds$popcol,pch=16,cex=2)
		#plot((inds$n0_meta_seg+inds$n1_meta_seg+inds$n2_meta_seg),inds$n1_meta_seg/(inds$n0_meta_seg+inds$n1_meta_seg+inds$n2_meta_seg),col=inds$popcol,pch=16,cex=2)
		}
	mydf			<-mydf/rowSums(mydf)
	mydf			<<- mydf
	colnames(mydf)	<- c("AA","Aa","aa")
	#
	if(!is.null(export))
		{
		mylabel	<- ifelse(allsites,"allsites","segsites")
		if(export=="eps"){postscript(paste("Genocounts_triangle",mylabel,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10)}
		if(export=="pdf"){pdf(paste("Genocounts_triangle",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
		if(export=="png"){png(paste("Genocounts_triangle",mylabel,"png",sep="."),family=mysambar$myfont,width=750,height=720)}
		if(export=="wmf"){win.metafile(paste("Genocounts_triangle",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
		}
	par(cex=2.5)
	mybool			<- apply(mydf,1,function(x){any(is.na(x))})
	wtriangleplot 	<- triangle.plot(mydf[!mybool,],sub=TRUE,show.position=FALSE)
	points(wtriangleplot,col=inds$popcol[!mybool],cex=2.5,pch=16)
	if(!is.null(export)){dev.off()}
	}

He_vs_miss<-function(export=NULL,popnames=mysambar$populations,allsites=TRUE,maxmiss=NULL,minsites=250,legendpos="topright",do_curve=TRUE,symbolsize=3,legendcex=3)
	{
	npops	<- length(popnames)
	graphics.off()
	if(!"miss"%in%colnames(inds))
		{
		mat 		<- as.matrix(mygenlight)
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		}
	if(length(inds$miss[inds$nsites2>=minsites])==0)
		{
		return(cat("Zero individuals with more retained datapoints than defined by minsites flag. Omitting He_vs_miss plot.",sep="\n"))
		}
	if(max(inds$miss[inds$nsites2>=minsites],na.rm=TRUE)==0)
		{
		return(cat("No missing datapoints. Omitting He_vs_miss plot.",sep="\n"))
		}
	if(allsites)
		{
		myhetero	<- inds$hetero_all
		myhetero	<- ifelse(!is.finite(myhetero),0,myhetero)
		}else{
		myhetero	<- inds$hetero
		myhetero	<- ifelse(!is.finite(myhetero),0,myhetero)
		}
	for(i in c(1:2))
		{
		ndata	<- length(which(inds$nsites2>=minsites))
		if(ndata<=(npops*3))
			{
			return(cat("Insufficient number of individuals with required number of SNPs (defined by 'minsites'-flag). Omitting 'He_vs_miss' plot.",sep="\n"))  
			}
		if(!is.null(export))
			{
			mylabel	<- ifelse(i==1,"filter","pop")
			mylabel2<- ifelse(allsites,"allSNPs","segregatingsites")
			if(export=="eps"){postscript(paste("He_vs_miss_ind",mylabel2,mylabel,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10)}
			if(export=="pdf"){pdf(paste("He_vs_miss_ind",mylabel2,mylabel,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
			if(export=="png"){png(paste("He_vs_miss_ind",mylabel2,mylabel,"png",sep="."),family=mysambar$myfont,width=750,height=720)}
			if(export=="wmf"){win.metafile(paste("He_vs_miss_ind",mylabel2,mylabel,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
			}
		par(mar=c(5,8,5,1.5),cex.axis=2.5,cex.lab=3)
		if(i==1)
			{
			plot(inds$miss[inds$nsites2>=minsites],myhetero[inds$nsites2>=minsites],pch=16,cex=symbolsize,log="x",xlab="indmiss (proportion missing data)",ylab="",las=1)
			if("filter"%in%colnames(inds))
				{
				points(inds$miss[(!inds$filter)&inds$nsites2>=minsites],myhetero[(!inds$filter)&inds$nsites2>=minsites],pch=16,cex=symbolsize,col="red")
				legend("bottomleft",legend=c("FALSE","TRUE"),title="Retained:",bty='n',fill=c("red","black"),cex=legendcex)
				}
			}else{
			plot(inds$miss[inds$nsites2>=minsites],myhetero[inds$nsites2>=minsites],pch=16,cex=symbolsize,log="x",xlab="Proportion missing data",ylab="",las=1,col=inds$popcol[inds$nsites2>=minsites])
			}
		if(!is.null(maxmiss))
			{
			abline(v=maxmiss,lty=2,lwd=2,col="grey50")
			}
		if(allsites)
			{	
			mtext("He (over all sites in SNP data)",side=2,line=5.5,cex=3.25)
			}else{
			mtext("He (over segregating sites)",side=2,line=5.5,cex=3.25)
			}
		if(i==2)
			{
			for(j in c(1:npops))
				{
				mypop	<- popnames[j]
				mycol	<- mysambar$mycolours[j]
				#if("filter"%in%colnames(inds))
				#	{
				#	myselection	<- inds$nsites2>=minsites&is.finite(myhetero)&inds$pop==mypop&inds$filter
				#	}else{
					myselection	<- inds$nsites2>=minsites&is.finite(myhetero)&inds$pop==mypop
				#	}
				ndata	<- length(which(myselection))
				if(ndata>2)
					{
					x		<- inds$miss[myselection]
					y		<- myhetero[myselection]
					y		<- y[is.finite(x)]
					x		<- x[is.finite(x)]		
					n_xvalues<- length(unique(inds$miss[inds$pop==mypop]))
					if(n_xvalues>2&do_curve)
						{
						lm.out 	<- lm(y ~ x)
						mymissvec<-inds$miss[inds$pop==mypop]
						missmin	<-min(mymissvec,na.rm=TRUE)
						mystepsize<-ifelse(missmin>0.005,0.01,ifelse(missmin<0.001,0.00005,0.001))
						newx 	<- seq(min(x),max(x),by = mystepsize)
						conf_int<- predict(lm.out,newdata=data.frame(x=newx),interval="confidence",level = 0.95)
						colfunc <- colorRampPalette(c("grey",mycol))
						mycol2	<- colfunc(3)[2]
						polygon(c(newx,rev(newx)),c(conf_int[,2],rev(conf_int[,3])),col=mycol2,border=NA)
						lines(newx,conf_int[,1],col=mycol,lwd=1)
						}
					}
				}
			points(inds$miss[inds$nsites2>=minsites],myhetero[inds$nsites2>=minsites],pch=16,cex=symbolsize,col=inds$popcol[inds$nsites2>minsites])
			legend(legendpos,legend=popnames,bty='n',fill=mysambar$mycolours,cex=legendcex)
			}
		mtext("Sample heterozygosity",side=3,line=0.5,cex=3.25)
		if(!is.null(export)){dev.off()}
		}
	}

plotperpool<-function(popnames=mysambar$populations)
	{
	if("pool"%in%colnames(inds))
		{
		npops		<- length(popnames)
		mycolours	<- mysambar$mycolours[1:npops]
		# heterozygosity:
		mymax		<- max(inds$hetero,na.rm=TRUE)
		pdf("He_perpool.pdf",width=5,height=npops*1.25)
		par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			boxplot(inds$hetero[inds$pop==mypop]~inds$pool[inds$pop==mypop],col=mycolours[j],ylim=c(0,mymax),las=1,border=mycolours[j])
			}
		mtext("Sequencing pool",side=1,outer=TRUE,line=0.5)
		mtext("Sample heterozygosity",side=2,outer=TRUE,line=-0.75)
		dev.off()
		# missingness:
		mymax		<- max(inds$miss,na.rm=TRUE)
		pdf("Missingness_perpool.pdf",width=5,height=npops*1.25)
		par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			boxplot(inds$miss[inds$pop==mypop]~inds$pool[inds$pop==mypop],col=mycolours[j],ylim=c(0,mymax),las=1,border=mycolours[j])
			}
		mtext("Sequencing pool",side=1,outer=TRUE,line=0.5)
		mtext("Proportion missing data",side=2,outer=TRUE,line=-0.75)
		dev.off()
		}
	}

plotplinkF<-function(export=NULL,plotname="Plink_inbreeding",addlabels=TRUE)
	{
	setwd(mysambar$inputfilesdir)
	if(file.exists("plink.het"))
		{
		plinkf		<- read.table("plink.het",header=TRUE)
		}else{
		cat("ERROR: file called 'plink.het' missing from directory:",sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Did you run the command: 'plink --file metapop.filter2.miss0.letter --het'? See the SambaR manual for more instructions.",sep="\n"))
		}
	plinkf$FID		<- NULL
	colnames(plinkf)<- c("name","O.HOM","E.HOM","N.NM","plinkF")
	indstemp 		<- merge(x = inds, y = plinkf, by = "name", all = TRUE)
	if(any(rownames(as.matrix(mygenlight))!=indstemp$name))
		{
		return(cat("ERROR: after merging the row names of the genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	inds	<<- indstemp
	#
	# PLOT:
	npops		<- length(mysambar$populations)
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,sep="."),family=mysambar$myfont,width=npops*mywidth+3,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+3,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+300,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+3,height=8)}
		}
	par(oma=c(9,8,1,4),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	y_lim	<- c(min(indstemp$plinkF,na.rm=TRUE),1.025*max(indstemp$plinkF,na.rm=TRUE))
	boxplot(indstemp$plinkF~indstemp$poporder,border=mysambar$colorder2,log=mylog,col="grey90",las=2,xlab="",ylab="",cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim)
	stripchart(plinkF~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=3,col=mysambar$colorder2,bg="bisque",add=TRUE)
	if(addylabel)
		{	
		mtext(side=2,"Inbreeding coefficient",line=4,cex=2.75,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(addlabels)
		{
		mtext("He-deficit",side=4,at=0.01,adj=0,line=0.5,cex=1.5)
		mtext("He-excess",side=4,at=-0.01,adj=1,line=0.5,cex=1.5)
		abline(h=0,lty=3)
		}
	if(!is.null(export)){dev.off()}
	}
	
plot_F<-function(export=FALSE,popnames=mysambar$populations,addlabels=TRUE,myfvalues=NULL)
	{
	npops		<- length(popnames)
	if(is.null(myfvalues))
		{
		myfvalues	<- snps[snps$filter,paste("F",mysambar$populations,sep="_")]
		}
	if(export){pdf("Fixationindex_perlocus.pdf",width=npops*2.5,height=6)}
	par(cex.axis=1.5,mar=c(3,6,1,2))
	boxplot(myfvalues, use.cols = TRUE,col=mysambar$mycolours,names=mysambar$populations,outline=FALSE,las=1)
	mtext("Locus specific FIS",side=2,line=3.75,cex=1.75)
	if(addlabels)
		{
		mtext("He-deficit",side=4,at=0.01,adj=0,line=0.5,cex=1.5)
		mtext("He-excess",side=4,at=-0.01,adj=1,line=0.5,cex=1.5)
		abline(h=0,lty=3)
		}
	if(export){dev.off()}
	}

calc_indF<-function(popnames=mysambar$populations,correctmaf=FALSE,silent=TRUE)
	{
	# Correctmaf: calculate F based on minor allele frequency over the population excluding the individual under investigation
	#
	# The individual inbreeding coefficient F is the probability that the two alleles at a locus are identical by descent (IBD).
	# 15-4-2020: Here I use the formula: F = (obshomo - exphomo)/(nsites - exphomo)
	# as described in: Kardos et al, 2015 Measuring individual inbreeding in the age of genomics: marker-based measures are better than pedigrees
	# why does this formula work?
	# it works because F can also be defined as the proportion of expected heterozygous sites (in case of no inbreeding) which are homozygous due to inbreeding.
	# let's consider this example:
	# say diploid individual A consists of 10 sites, of which 6 are heterozygous (so heterozygosity = 0.6)
	# by selfing individual A produces individual B
	# individual B wil most likely have 4 + 0.5*6 = 7 homozygous sites
	# furthermore, assuming all sites of individual A are not identical by descent (just identical by state (IBS) in case of homozygous sites), then:
	# individual B will most likely have 0.5*10 = 5 autozygous sites
	# of these 5 autozygous sites, 3 were heterozygous in individual A, and 2 were homozygous.
	# of all other individuals in the population are not inbred, and on average have the same genotype as individual A, then:
	# according to the formula we get:
	# individual A: F = (4 - 4)/(10 - 4) = 0/6 = 0.0
	# individual B: F = (7 - 4)/(10 - 4) = 3/6 = 0.5
	# From the pedigree we know indeed that F should be 0.5. (And it also makes sense in the sense that 50 percent of expected heterozygous sites are homozygous due to inbreeding).
	#
	# Note that with 10 sites only, small stochastic deviations can lead to high F values.
	# So we also need to calculate whether the deviation from expected values is significant using a chi-squared test.
	#
	# Also note that if we calculate expected homozygosity based on input which includes the individual we examine, the outcome will be biased.
	# so say that in the example above, the population consists of two individuals only, namely A and B, then the expected homozygosity (when defined as the average of the population) would be: 5.5 sites (i.e mean of 7 and 4).
	# In that case the formula would become:
	# individual A: F = (4 - 5.5)/(10 - 5.5) = -1.5/4.5 = -0.33
	# individual B: F = (7 - 5.5)/(10 - 5.5) = 1.5/4.5 = 0.33
	# So the inclusion of inbred individuals in the calculation of expected H, leads to an underestimate of F, and can make other individuals look outbred
	# If you have big sample sizes, then a few inbred individuals will not change the expected homozygosity massively.
	# But especially with small sample sizes, inbred individuals can biased exphomo upwards, and therefore F downwards.
	#
	# Note: plink --het gives slightly different outcomes (at least when SambaR does not exclude examined individuals when calculated expected homo).  
	#
	# This is not part of it but used by other functions (?)
	inds$expHe		<<- 2*(inds$popmaf*(1-inds$popmaf))				# all sites
	inds$expHe_all	<<- 2*(inds$popmaf_all*(1-inds$popmaf_all))		# include only sites which are segregating in the population to which the individual belongs
	#
	npops			<- length(popnames)
	ninds			<- nrow(inds)
	mymatrix		<- as.matrix(mygenlight[,snps$filter])
	snpstemp		<- snps[snps$filter,]
	obshomo			<- vector()
	exphomo			<- vector()
	nsitesvec		<- vector()
	fvector			<- vector()
	pvaluevec		<- vector()
	fchi2vec		<- vector()
	fpvec			<- vector()
	for(j in c(1:ninds))
		{
		if(!silent){cat(j,sep="\n")}
		mygeno		<- as.vector(mymatrix[j,])
		indpop		<- as.vector(inds$pop[j])
		if(!silent){cat(as.vector(inds$name[j]),sep="\n")}
		if(!silent){cat(indpop,sep="\n")}
		if(!correctmaf)
			{
			indpopmaf			<- as.vector(snpstemp[,paste("maf",indpop,sep="_")])
			}else{
			if(!inds$filter[j])
				{
				# if set to FALSE, individual is not included in analyses, so it's genotype has not been considered when calculating population allele frequency
				# no need to correct
				indpopmaf			<- as.vector(snpstemp[,paste("maf",indpop,sep="_")])
				}else{
				# 05-04-2020: correct population allele frequency estimate by excluding examined individual:
				indpopmafs			<- as.vector(snpstemp[,paste("maf",indpop,sep="_")])
				indpopnr			<- which(popnames==indpop)
				indpopsize			<- nrow(inds[inds$pop==indpop&inds$filter,])
				indpopmacs			<- round(indpopmafs*indpopsize*2)		# 07-05-2020: if I do not round, I get strange values for new mafs, like -0.00000000000000005551115 instead of 0 
				indgeno2			<- as.vector(mygeno)
				indgeno2[is.na(indgeno2)]	<- 3	# because NA-values can be interpreted as 1			
				if(length(indgeno2)!=length(indpopmacs))
					{
					return(cat("ERROR: length indgeno2 does not equal length indpopmacs. Please contact developer of SambaR.",sep="\n"))
					}
				newnralleles		<- 2*(indpopsize-1)
				indpopmaf			<- ifelse(indgeno2==3,indpopmafs,ifelse(indgeno2==2,(indpopmacs-2)/newnralleles,ifelse(indgeno2==1,(indpopmacs-1)/newnralleles,indpopmacs/newnralleles)))
				if(any(indpopmaf[!is.na(indpopmaf)]<0))
					{
					testpopmacs		<<- indpopmacs
					testnrnewalleles<<- newnralleles
					testgeno		<<- mygeno	
					oldmafs			<<- indpopmafs
					newmafs			<<- indpopmaf
					return(cat("ERROR: corrected minor allele frequency below 0. Please contact developer of SambaR.",sep="\n"))
					}
				if(any(indpopmaf[!is.na(indpopmaf)]>1))
					{
					testgeno		<<- mygeno
					oldmafs			<<- indpopmafs
					newmafs			<<- indpopmaf
					return(cat("ERROR: corrected minor allele frequency above 1. Please contact developer of SambaR.",sep="\n"))
					}
				}
			}
		# expected number of homozygous sites:
		indpopmaf	<- indpopmaf[!is.na(mygeno)]
		exphomo[j]	<- sum((indpopmaf^2+(1-indpopmaf)^2))		
		# observed number of homozygous sites:
		mygeno		<- mygeno[!is.na(mygeno)]
		nsitesvec[j]<- length(mygeno)
		obshomo[j]	<- length(mygeno[mygeno!=1])
		fvector[j]	<- (obshomo[j]-exphomo[j])/(nsitesvec[j]-exphomo[j])
		fchi2vec[j] <- ((obshomo[j]-exphomo[j])^2)/exphomo[j]
		fpvec[j]	<- pchisq(fchi2vec[j],df=1,lower.tail=FALSE)
		}
	if(!correctmaf)
		{
		inds$obshomo	<<- obshomo
		inds$exphomo	<<- exphomo
		inds$nsites5	<<- nsitesvec
		inds$F			<<- fvector
		inds$F_chi2		<<- fchi2vec
		inds$F_pvalue	<<- round(fpvec,6)
		}else{
		inds$obshomo2	<<- obshomo
		inds$exphomo2	<<- exphomo
		inds$nsites5	<<- nsitesvec
		inds$F2			<<- fvector
		inds$F_chi2_2	<<- fchi2vec
		inds$F_pvalue2	<<- round(fpvec,6)
		}
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}

plot_indF<-function(export=NULL,addylabel=TRUE,logy=FALSE,plotname="Inbreeding",silent=TRUE,Fcorrect=FALSE)
	{
	indstemp	<- droplevels(inds[inds$filter,])
	npops		<- length(mysambar$populations)
	if(!silent){cat("Opening device...",sep="\n")}
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=800)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		}
	if(!silent){cat("Setting parameters...",sep="\n")}
	par(oma=c(9,7,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	if(!Fcorrect)
		{
		if(!silent){cat("boxplot...",sep="\n")}
		ymin		<- min(indstemp$F,na.rm=TRUE)
		ymin		<- ifelse(ymin<(-1),ymin,-1)
		ymax		<- max(indstemp$F,na.rm=TRUE)
		ymax		<- ifelse(ymax>1,ymax,1)
		boxplot(indstemp$F~indstemp$poporder,border="white",col="white",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=TRUE,ylim=c(ymin,ymax))
		if(!silent){cat("boxplot2...",sep="\n")}
		boxplot(indstemp$F~indstemp$poporder,border=mysambar$colorder,xlab="",ylab="",xaxt='n',yaxt='n',col="grey90",add=TRUE,outline=FALSE)
		if(!silent){cat("stripchart...",sep="\n")}
		indstemp1	<- indstemp[indstemp$F_pvalue<=0.05,]
		indstemp2	<- indstemp[indstemp$F_pvalue>0.05,]
		stripchart(F~poporder,data=indstemp1,vertical=TRUE,method="jitter",pch=16,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		stripchart(F~poporder,data=indstemp2,vertical=TRUE,method="jitter",pch=1,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		#axis(side=1,mysambar$populations,at=seq(1:npops),las=2,cex=1.5)
		}else{
		if(!silent){cat("boxplot...",sep="\n")}
		ymin		<- min(indstemp$F2,na.rm=TRUE)
		ymin		<- ifelse(ymin<(-1),ymin,-1)
		ymax		<- max(indstemp$F2,na.rm=TRUE)
		ymax		<- ifelse(ymax>1,ymax,1)
		boxplot(indstemp$F2~indstemp$poporder,border="white",col="white",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=TRUE,ylim=c(ymin,ymax))
		if(!silent){cat("boxplot2...",sep="\n")}
		boxplot(indstemp$F2~indstemp$poporder,border=mysambar$colorder,xlab="",ylab="",xaxt='n',yaxt='n',col="grey90",add=TRUE,outline=FALSE)
		if(!silent){cat("stripchart...",sep="\n")}
		indstemp1	<- indstemp[indstemp$F_pvalue2<=0.05,]
		indstemp2	<- indstemp[indstemp$F_pvalue2>0.05,]
		stripchart(F2~poporder,data=indstemp1,vertical=TRUE,method="jitter",pch=16,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		stripchart(F2~poporder,data=indstemp2,vertical=TRUE,method="jitter",pch=1,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		#axis(side=1,mysambar$populations,at=seq(1:npops),las=2,cex=1.5)
		}
	legend("topleft",legend=c("p(X^2)<0.05","p(X^2)>0.05"),pch=c(16,1),cex=2,bty='n')
	if(addylabel)
		{	
		mtext(side=2,"Inbreeding coefficient",line=4.5,cex=2.75,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}	

plotscatter_indF<-function(export=NULL,popnames=mysambar$populations,dolabels=FALSE,Fcorrect=FALSE)
	{
	npops	<- length(popnames)
	graphics.off()
	if(!is.null(export))
		{
		plotname	<- ifelse(dolabels,"Inbreeding.scatter.indnr","Inbreeding.scatter")
		correctlabel<- ifelse(Fcorrect,"corrected_maf","not_corrected_maf")
		if(export=="eps"){postscript(paste(plotname,correctlabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,correctlabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,correctlabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,correctlabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	if(!Fcorrect)
		{
		exphomo		<- inds$exphomo
		obshomo		<- inds$obshomo
		exphetero	<- inds$exphetero
		}else{
		exphomo		<- inds$exphomo2
		obshomo		<- inds$obshomo2
		exphetero	<- inds$exphetero2
		}
	mymin	<- min(c(exphomo[inds$filter],obshomo[inds$filter]),na.rm=TRUE)
	mymax	<- max(c(exphomo[inds$filter],obshomo[inds$filter]),na.rm=TRUE)
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(exphomo[inds$filter],obshomo[inds$filter],col="white",xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="Expected homozygous sites",ylab="Observed homozygous sites")
	if(!dolabels)
		{
		lines(c(0.5*mymin,2*mymax),c(0.5*mymin,2*mymax),col="grey")
		points(exphomo[inds$filter],obshomo[inds$filter],col=inds$popcol[inds$filter],pch=16,cex=3)
		}else{
		lines(c(0.5*mymin,2*mymax),c(0.5*mymin,2*mymax),col="grey")
		text(exphomo[inds$filter],obshomo[inds$filter],inds$nr[inds$filter],cex=1.5,col=inds$popcol[inds$filter])
		}
	legend("bottomright",legend=popnames,fill=mysambar$mycolours[1:npops],cex=2.5,bty='n')
	if(!is.null(export)){dev.off()}
	}

heall_vs_he<-function(export=NULL,showlabels=FALSE,popnames=mysambar$populations,legendcex=2)
	{
	mymax	<- max(c(inds$hetero_all[inds$filter],inds$hetero[inds$filter]),na.rm=TRUE)
	mymin	<- min(c(inds$hetero_all[inds$filter],inds$hetero[inds$filter]),na.rm=TRUE)
	#
	if(!is.null(export))
		{
		plotname		<- "He.all_vs_He.segregating"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(showlabels)
		{
		plot(inds$hetero_all[inds$filter],inds$hetero[inds$filter],pch=16,col="white",pch=16,cex=2.5,xlab="He (all sites)",ylab="He (segregating sites)")
		text(inds$hetero_all[inds$filter],inds$hetero[inds$filter],inds$nr[inds$filter],col=inds$popcol[inds$filter],cex=2.5)
		}else{
		plot(inds$hetero_all[inds$filter],inds$hetero[inds$filter],pch=16,col=inds$popcol[inds$filter],cex=3,xlab="He (all sites)",ylab="He (segregating sites)")
		}
	legend("topleft",legend=popnames,fill=mysambar$mycolours,cex=legendcex,bty='n')
	if(!is.null(export)){dev.off()}
	}

FvsHe<-function(export=NULL,showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=2)
	{
	graphics.off()
	if(Fcorrect)
		{
		myF	<- inds$F2
		}else{
		myF	<- inds$F
		}
	mymax	<- max(myF,na.rm=TRUE)
	mymax	<- ifelse(mymax<1,1,mymax)
	mymin	<- min(myF,na.rm=TRUE)
	mymin	<- ifelse(mymin>-1,-1,mymin)
	#
	myxmax	<- max(inds$hetero[inds$filter],na.rm=TRUE)
	if(!is.null(export))
		{
		plotname		<- ifelse(Fcorrect,"Inbreeding_FcorrectedvsHe","Inbreeding_FvsHe")
		symbollabel		<- ifelse(showlabels,"labels","points")
		if(export=="eps"){postscript(paste(plotname,symbollabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,symbollabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,symbollabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,symbollabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(showlabels)
		{
		plot(inds$hetero[inds$filter],myF[inds$filter],col="white",pch=16,cex=2.5,xlab="He (segregating sites only)",ylab="Inbreeding coefficient",ylim=c(mymin,mymax),xlim=c(0,myxmax),main="F vs He")
		text(inds$hetero[inds$filter],myF[inds$filter],inds$nr[inds$filter],col=inds$popcol[inds$filter],cex=2.5)
		}else{
		plot(inds$hetero[inds$filter],myF[inds$filter],col=inds$popcol[inds$filter],pch=16,cex=2.5,xlab="He (segregating sites only)",ylab="Inbreeding coefficient",ylim=c(mymin,mymax),xlim=c(0,myxmax),main="F vs He")
		}
	legend("topright",legend=popnames,fill=mysambar$mycolours,cex=legendcex,bty='n')
	if(!is.null(export)){dev.off()}
	}

testF<-function()
	{
	# create an inbred individual artificially by crossing an individual with itself:
	indstemp			<- inds
	newindnr			<- nrow(inds)+1
	indstemp[newindnr,]	<- inds[1,]
	indstemp$nr[newindnr]	<- newindnr 
	adultgeno				<- as.vector(as.matrix(mygenlight[1,]))
	#
	# create inbred individual:
	adultgeno[is.na(adultgeno)]	<- 3
	meiosevec			<- sample(c(0,1,1,2),length(adultgeno),replace=TRUE)
	navec				<- rep(NA,length(adultgeno))
	newgeno				<- ifelse(adultgeno==3,navec,ifelse(adultgeno==1,meiosevec,adultgeno))
	#
	# add to genlight:
	mymatrix			<- as.matrix(mygenlight)
	mymatrix			<- rbind(mymatrix,newgeno)
	mygenlight			<<- as.genlight(mymatrix)
	inds				<<- indstemp
	#
	# calculate true inbreeding coefficient (true proportion of autozygosity) and homozygosity:
	# Proportion of homozygous sites for a given individual consists of two components:
	# - sites which are homozygous due to being autozygous (Identical By Descent)
	# - sites which are not autozygous but still homozygous by chance
	# The proportion of IBD sites is estimated by the inbreeding coefficient F.
	# The proportion of sites which are not IBD is therefore 1-F.
	# And therefore, the total proportion of homozygous sites for an individual are given by:
	# Prop_homo = Pr_IBD + (1 - Pr_IBD)*(p2+q2)
	# Prop_homo = F + (1-F)(p2+q2)
	nauto				<<- length(adultgeno[adultgeno==0|adultgeno==2])
	phomo_auto			<<- nauto/length((adultgeno[adultgeno!=3]))		# This is the true inbreeding coefficient F (i.e. proportion of autozygosity). Run calc_indF to compare with estimated F. 
	nhomo_not_auto		<<- length(newgeno[(newgeno==0|newgeno==2)&adultgeno==1])
	phomo_not_auto		<<- nhomo_not_auto/length((adultgeno[adultgeno!=3])) 
	phomo_exp			<<- phomo_auto+phomo_not_auto
	newgeno2			<- newgeno
	newgeno2[is.na(newgeno2)]	<- 3			
	phomo_obs			<<- length(newgeno[newgeno!=1&newgeno!=3])/length(newgeno[newgeno!=3])
	# For one test run I found:
	# True autozygosity (phomo_auto): 0.62
	# Estimated autozygosity (by calc_indF): 0.46
	# So the inbreeding coefficient seems to underestimate 
	}

# 16-4-2020: depreciated:	
plot_indF_old<-function(popnames=mysambar$populations,export=NULL)
	{
	# plot:
	mycolours		<- mycolours[1:npops]
	graphics.off()
	if(!is.null(export)&("vioplot" %in% (.packages())))
		{
		if(export=="eps"){postscript("Inbreeding.pdf",width=npops*2.5,height=7)}	
		if(export=="pdf"){pdf("Inbreeding.pdf",width=npops*2.5,height=7)}
		if(export=="png"){png("Inbreeding.png",width=npops*250,height=720)}
		if(export=="wmf"){win.metafile("Inbreeding.wmf",width=npops*2.5,height=7)}
		}
	par(mar=c(5,7,5,2),cex.axis=2,cex.lab=2.5,cex.main=3,las=1)
	if(allsites)
		{
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(inds$F_all[is.finite(inds$F)&inds$filter]),max(inds$F_all[is.finite(inds$F)&inds$filter])),xaxt="n",xlab="",ylab="")	
		}else{
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(inds$F[is.finite(inds$F)&inds$filter]),max(inds$F[is.finite(inds$F)&inds$filter])),xaxt="n",xlab="",ylab="")	
		}
	for (i in c(1:npops))
		{
		mypop			<- popnames[i]
		if(allsites)
			{
			vioplot(inds$F_all[inds$filter&inds$pop==mypop&is.finite(inds$F_all)&!is.na(inds$F_all)],at=i,add=TRUE,col=mycolours[i])
			}else{
			vioplot(inds$F[inds$filter&inds$pop==mypop&is.finite(inds$F)&!is.na(inds$F)],at=i,add=TRUE,col=mycolours[i])
			}
		}
	axis(side=1,at=seq(1,npops),labels=popnames,lty=1,las=1,cex.axis=1.75)
	mtext("Population",1,line=3,cex=2.25)
	mtext("Inbreeding coefficient",3,line=1.5,cex=2.5)
	mtext("F (1 - Hobs/Hexp)",2,line=4.5,cex=2.5,las=0)
	if(!is.null(export)&("vioplot" %in% (.packages()))){dev.off()}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

expHe_vs_He<-function(popnames=mysambar$populations,export=NULL,allsites=FALSE)
	{
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		exportname	<- ifelse(allsites,"expHe_vs_He.allsites","expHe_vs_He.segregatingsites")
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	if(allsites)
		{
		mymaf	<- inds$popmaf_all
		myhetero<- inds$hetero_all
		}else{
		mymaf	<- inds$popmaf
		myhetero<- inds$hetero
		}
	plot(mymaf[inds$filter],myhetero[inds$filter],xlab="Observed sample maf",ylab="Observed sample He",cex=2,ylim=c(0,0.5))
	for (j in c(1:length(popnames)))
		{
		mypop				<- popnames[j]
		points(mymaf[inds$pop==mypop&inds$filter],myhetero[inds$pop==mypop&inds$filter],col=mysambar$mycolours[j],pch=16,cex=2)
		points(mymaf[inds$pop==mypop&!inds$filter],myhetero[inds$pop==mypop&!inds$filter],col=mysambar$mycolours[j],cex=2)
		}
	# add line showing expected values:
	temp	<- seq(0,1,0.01)
	temp2	<- 2*temp*(1-temp)
	lines(temp,temp2,col="black",lwd=2)
	# add legend:
	legend("topleft",legend=popnames,bty='n',fill=mysambar$mycolours,cex=2)
	if(!is.null(export)){dev.off()}
	}

missingness_perpop<-function(export=NULL,addylabel=TRUE,logy=FALSE)
	{
	npops		<- length(mysambar$populations)
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		mylabel	<- ifelse(addylabel,ifelse(logy,"perpop.log","perpop"),ifelse(logy,"perpop.log.no_ylabel","perpop.no_ylabel"))
		if(export=="eps"){postscript(paste("Missingdata",mylabel,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste("Missingdata",mylabel,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste("Missingdata",mylabel,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste("Missingdata",mylabel,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		}
	par(oma=c(9,8,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	mylog	<- ifelse(logy,"y","")
	y_lim	<- c(min(inds$miss,na.rm=TRUE),1.025*max(inds$miss,na.rm=TRUE))
	boxplot(inds$miss~inds$poporder,border=mysambar$colorder2,log=mylog,col="grey90",las=2,xlab="",ylab="",cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim)
	stripchart(miss~poporder,data=inds,vertical=TRUE,method="jitter",pch=16,cex=3,col=mysambar$colorder2,bg="bisque",add=TRUE)
	if(addylabel)
		{	
		#mtext(side=2,"Proportion missing data",line=3.75,cex=2)
		yline	<- ifelse(logy,5.5,4)
		mtext(side=2,"Proportion missing data",line=yline,cex=2.75,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}


groupplot<-function(export=NULL,plotlabel="poptype",ylabel=NULL,indscore=NULL,groupvector=NULL,grouplevels=NULL,indfilter=NULL)
	{
	if(is.null(indscore)|is.null(groupvector)|is.null(grouplevels)|is.null(indfilter))
		{
		return(cat("ERROR: Please define input values to the flags indscore, groupvector, grouplevels, and indfilter.",sep="\n"))
		}
	if(!groupvector%in%colnames(inds))
		{
		return(cat("ERROR: groupvector column name not present in inds dataframe.",sep="\n"))
		}
	if(!indscore%in%colnames(inds))
		{
		return(cat("ERROR: indscore column name not present in inds dataframe.",sep="\n"))
		}
	indstemp				<- droplevels(inds[indfilter,c("pop","popcol",indscore,groupvector)])
	colnames(indstemp)		<- c("pop","popcol","indscore","group")
	indstemp$groupfactor	<- factor(as.character(indstemp$group),levels=grouplevels) 
	#
	ngroups					<- length(grouplevels)
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		plotname		<- "Group_boxplot"
		if(export=="eps"){postscript(paste(plotname,plotlabel,"eps",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,plotlabel,"pdf",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,plotlabel,"png",sep="."),family=mysambar$myfont,width=ngroups*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,plotlabel,"wmf",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		}
	par(oma=c(9,8,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	yrange		<- c(min(indstemp$indscore,na.rm=TRUE),max(indstemp$indscore,na.rm=TRUE))
	boxplot(indstemp$indscore~indstemp$groupfactor,las=2,border="grey50",outline=FALSE,ylim=yrange,col="grey90",xlab="",ylab="",cex.axis=2.5,pch=16)
	for(i in c(1:length(mysambar$populations)))
		{
		mypop		<- mysambar$populations[i]
		mycolour	<- mysambar$mycolours[i] 
		indstemp2	<- indstemp[as.character(indstemp$pop)==mypop,]
		stripchart(indscore~groupfactor,data=indstemp2,vertical=TRUE,method="jitter",pch=16,cex=3,xlab="",ylab="",col=mycolour,bg="bisque",add=TRUE)
		}
	if(!is.null(ylabel))
		{	
		mtext(side=2,ylabel,line=5.5,cex=3,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}
	
indheboxplot<-function(export=NULL,plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="He-sites in SNP data",yline=4.5)
	{
	indstemp			<- droplevels(inds[inds$filter,c("poporder",heteroscore)])
	colnames(indstemp)	<- c("poporder","heteroscore")
	#indstemp$pop2		<- as.character(indstemp$pop)
	npops				<- length(mysambar$populations)
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=npops*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=npops*mywidth+2,height=8)}
		}
	par(oma=c(9,7,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	boxplot(indstemp$heteroscore~indstemp$poporder,border=mysambar$colorder,col="grey90",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=FALSE,ylim=c(0,max(indstemp$heteroscore,na.rm=TRUE)))
	stripchart(heteroscore~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2.5,col=mysambar$colorder,bg="bisque",add=TRUE)
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	#mtext(side=1,"Sample",line=6.5,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

thindata<-function(mindistance=500)
	{
	for (i in (1:nrow(snps)))
		{
		snps$distfilter[i]	<<- ifelse(snps$dist[i]>=mindistance,TRUE,FALSE) 
		}
	snps$distfilter			<<- ifelse(is.na(distfilter),FALSE,distfilter)
	}	

stacks_demultiplex<-function(plotretained=TRUE,QC=FALSE)
	{
	x		<- read.table("I:/PhD/Reindeer/Processradtagsoutput_nosums.txt",header=TRUE)
	x$Pool2	<- gsub("Pool","",x$Pool)
	mylanes	<- as.vector(unique(x$Sequencing_Lane))
	x$Sequencing_Lane2	<- NA
	for(j in c(1:length(mylanes)))
		{
		mylane		<- mylanes[j]
		x$Sequencing_Lane2[x$Sequencing_Lane==mylane]<-j
		}
	x$Pool3<-paste(x$Sequencing_Lane2,x$Pool2,sep=".")
	# retained reads:
	if(plotretained)
		{
		if(QC)
			{
			pdf("Retainedreads.QC.pdf",width=12,height=12)
			par(mfrow=c(2,2),oma=c(0,2,0,1))
			boxplot((x$LowQuality/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion low quality reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot((x$NoRadTag/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion reads with no barcode",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(((x$Unpaired_forward+x$Unpaired_reverse)/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion reads with no barcode",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(((x$Read_pairs*2)/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion retained reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			dev.off()
			}else{
			pdf("Retainedreads.overall2.pdf",width=12,height=6)
			par(mfrow=c(1,2),oma=c(0,2,0,0))
			boxplot(((x$Read_pairs*2)/x$Total_Reads)~(x$Pool3),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion retained reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(x$Read_pairs/1000000~x$Pool3,ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Retained read pairs (x 1M)",side=2,line=2.5,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			dev.off()
			}
		}
	# Read depth per locus vs total read depth:
	y				<- x[order(x$ID),]
	inds$pool		<- y$Pool3
	inds$nreadpairs	<- y$Read_pairs
	pdf("Mean.vs.total.readdepth.pdf",height=6,width=12)
	par(mfrow=c(1,2),oma=c(0,2,0,0))
	plot(inds$nreadpairs/1000000,inds$meandepth,ylab="",xlab="",pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(inds$nreadpairs[!inds$filter]/1000000,inds$meandepth[!inds$filter],pch=16,col="red")
	mtext("Mean read depth",side=2,line=3,cex=2)	
	mtext("Number of read pairs (x 1M)",side=1,line=3,cex=2)
	plot(inds$meandepth,inds$miss,ylab="",xlab="",pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(inds$meandepth[!inds$filter],inds$miss[!inds$filter],pch=16,col="red")
	mtext("Proportion missing data",side=2,line=3,cex=2)	
	mtext("Mean read depth",side=1,line=3,cex=2)
	dev.off()
	}


plotn2<-function(export=NULL)
	{
	if(!is.null(export))
		{
		plotname	<- "Genocounts_n2meta_vs_n2pop"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	mylim	<- c(0,max(c(inds$n2_meta,inds$n2_pop)))
	plot(inds$n2_meta,inds$n2_pop,col=inds$popcol,pch=16,cex=2.5,xlab="relative to metapopulation",ylab="relative to subpopulation",ylim=mylim,xlim=mylim,main="# minor homozygous genotypes")
	lines(c(0,1000000),c(0,1000000),lty=2)
	legend("topright",legend=mysambar$populations2,bty='n',fill=mysambar$mycolours2,cex=2)
	if(!is.null(export)){dev.off()}
	}

plotgenocounts<-function(popnames=mysambar$populations,export=FALSE,myout=NULL,addlabels=TRUE,make_global=FALSE)
	{
	npops			<- length(popnames)
	if(is.null(myout))
		{
		myout			<- matrix(NA,ncol=4,nrow=npops)
		rownames(myout)	<- popnames
		for (j in c(1:npops))
			{
			mypop		<- popnames[j]
			# cat(mypop,sep="\n")
			mymaf		<- snps[,paste("maf",mypop,sep="_")]
			mymaf[is.na(mymaf)]	<- 0
			mymat		<- as.matrix(mygenlight[inds$filter&inds$pop==mypop,mymaf>0&snps$filter,])
			n0			<- length(mymat[mymat==0&!is.na(mymat)])
			n1			<- length(mymat[mymat==1&!is.na(mymat)])
			n2			<- length(mymat[mymat==2&!is.na(mymat)])
			nall		<- length(mymat[!is.na(mymat)])
			myout[j,1]	<- n0/nall
			myout[j,2]	<- n1/nall
			myout[j,3]	<- n2/nall
			myout[j,4]	<- (n1+2*n2)/(2*nall)
			}
		myout			<- as.data.frame(myout)
		colnames(myout)	<- c("n0","n1","n2","maf") 
		myout$prop		<- myout$n2/myout$n1
		}else{
		myout	<- myout
		}
	# plot:
	myout2			<- t(myout[,c(1:3)])
	if(make_global)
		{
		myout			<<- myout
		myout2			<<- myout2
		}
	npops			<- length(popnames)
	if(npops>1)
		{
		x			<- matrix(0,ncol=npops,nrow=npops*3)
		for(j in c(1:npops))
			{
			mydata	<- myout2[,j]
			x[(j*3-2):(j*3),j]	<- mydata
			}
		}else{
		x			<- myout2
		}
	mycolours		<- mysambar$mycolours[1:npops]
	mycols			<- vector()
	for(j in c(1:npops))
		{
		mycol	<- mycolours[j]
		colfunc <- colorRampPalette(c("grey",mycol))
		mycol2	<- colfunc(3)
		mycols	<- c(mycols,mycol2)
		}
	if(export)
		{
		if(addlabels)
			{
			pdf("Genocounts.withlabels.pdf")
			}else{
			pdf("Genocounts.pdf")
			}
		}
	testx		<<- x
	par(mar=c(4,10,2.5,2.5))
	xx<-barplot(x,col=mycols,border=NA,space=0.1,horiz=TRUE,names.arg=popnames,las=1,cex.names=1.5)
	if(addlabels)
		{
		for(j in c(1:npops))
			{
			poppoints	<- x[,j]
			poppoints	<- poppoints[poppoints!=0]
			poppoints	<- cumsum(poppoints)
			barmid		<- xx[j]
			text(poppoints,barmid,labels = c(0,1,2),adj=1,cex=1.5)
			}
		mtext("Genotype proportions",side=3,line=0.5,cex=2)
		mtext("0: homozygous major; 1: heterozygous; 2: homozygous minor",side=3,line=-0.75,cex=1)
		}
	if(export){dev.off()}
	}

plotgenocounts_inds<-function(export=FALSE,addlabels=TRUE,make_global=FALSE,metapop=TRUE)
	{
	indstemp		<- inds[inds$filter,]
	indstemp		<- indstemp[order(indstemp$pop),]
	if(metapop)
		{
		myout			<- indstemp[indstemp$filter,c("n0_meta","n1_meta","n2_meta")]
		}else{
		myout			<- indstemp[indstemp$filter,c("n0_pop","n1_pop","n2_pop")]
		}
	myout			<- myout/(indstemp$nsites2)
	myout2			<- t(myout)
	if(make_global)
		{
		myout			<<- myout
		myout2			<<- myout2
		}
	ninds			<- nrow(myout)
	#indnames		<- indstemp$nr[indstemp$filter]
	indnames		<- indstemp$name[indstemp$filter]
	if(ninds>1)
		{
		x			<- matrix(0,ncol=ninds,nrow=ninds*3)
		for(j in c(1:ninds))
			{
			mydata	<- myout2[,j]
			x[(j*3-2):(j*3),j]	<- mydata
			}
		}else{
		x			<- myout2
		}
	mycolours		<- indstemp$popcol
	mycols			<- vector()
	for(j in c(1:ninds))
		{
		mycol	<- mycolours[j]
		colfunc <- colorRampPalette(c("grey",mycol))
		mycol2	<- colfunc(3)
		mycols	<- c(mycols,mycol2)
		}
	# plot:
	if(export)
		{
		plotlabel1	<- ifelse(addlabels,"withlabels","nolabels")
		plotlabel2	<- ifelse(metapop,"metapop","subpop")
		pdf(paste("Genocounts_inds",plotlabel1,plotlabel2,"pdf",sep="."),height=ninds*0.25,width=15)
		}
	par(mar=c(4,10,2.5,2.5))
	xx<-barplot(x,col=mycols,border=NA,space=0.1,horiz=TRUE,names.arg=indnames,las=1,cex.names=0.75)
	if(addlabels)
		{
		for(j in c(1:ninds))
			{
			poppoints	<- x[,j]
			poppoints	<- poppoints[poppoints!=0]
			poppoints	<- cumsum(poppoints)
			barmid		<- xx[j]
			text(poppoints,barmid,labels = c(0,1,2),adj=1,cex=1.5)
			}
		mtext("Genotype proportions",side=3,line=-0.5,cex=3.5)
		mtext("0: homozygous major; 1: heterozygous; 2: homozygous minor",side=3,line=-3,cex=2.5)
		}
	if(export){dev.off()}
	}

plotmapping<-function(export=FALSE,input1="alignmentscores.reinasref.txt",input2="alignmentscores.cowasref.txt",myrefs=c("reindeer","cow"),plotcols=c("grey","black"))
	{
	if(export){pdf("Mapping_scores.pdf")}
	x<-read.table(input1)
	colnames(x)	<- c("sample","mapped","concordant")
	y<-read.table(input2)
	colnames(y)	<- c("sample","mapped","concordant")
	plot(inds$nreadpairs/1000000,x$mapped,las=1,pch=16,xlab="",ylab="",col=plotcols[1])
	mtext("Mapped reads (%)",side=2,line=2.5,cex=2)	
	mtext("Number of read pairs (x 1M)",side=1,line=3,cex=2)
	points(inds$nreadpairs/1000000,x$concordant,col=plotcols[1])
	points(inds$nreadpairs/1000000,y$mapped,pch=16,col=plotcols[2])
	points(inds$nreadpairs/1000000,y$concordant,col=plotcols[2])
	legend("bottomright",fill=plotcols,legend=myrefs,bty='n',cex=1.5)
	if(export){dev.off()}
	mymeans	<<- c(mean(x$mapped), mean(x$concordant), mean(y$mapped), mean(y$concordant))
	mysd	<<- c(sd(x$mapped), sd(x$concordant), sd(y$mapped), sd(y$concordant))
	# The inputfiles were generated on Linux using the commands:
	# cat ./*mapped.txt > allsamples.reinasref.mappedcounts.txt
	# cat ./*paired.txt > allsamples.reinasref.pairedcounts.txt
	# ls -1 ./*verysensitive.bam > samfiles.txt
	# sed -i 's/bam/sam/g' samfiles.txt 
	# sed 's/.reinasref.verysensitive.sam//g' samfiles.txt > mysamples.txt
	# sed -i 's/\.\///g' mysamples.txt
	# paste mysamples.txt allsamples.reinasref.mappedcounts.txt allsamples.reinasref.pairedcounts.txt > allsamples.alignmentscores.txt
	# cat ./*mapped.txt > allsamples.cowgenome.mappedcounts.txt
	# cat ./*paired.txt > allsamples.cowgenome.pairedcounts.txt
	# ls -1 ./*verysensitive.bam > samfiles.txt
	# sed -i 's/bam/sam/g' samfiles.txt 
	# sed 's/.cowgenome.verysensitive.sam//g' samfiles.txt > mysamples.txt
	# sed -i 's/\.\///g' mysamples.txt
	# paste mysamples.txt allsamples.cowgenome.mappedcounts.txt allsamples.cowgenome.pairedcounts.txt > allsamples.alignmentscores.txt
	}
	
# End of data preparation	
############################################################################################################	




############################################################################################################
# Population structure analyses

# This function executes all population structure analyses at once:
# I still want to include phylogenetic analyses.
# This webpage has tips:
# https://www.molecularecologist.com/2016/02/quick-and-dirty-tree-building-in-r/

findstructure<-function(add_legend=TRUE,legend_pos="bottomright",legend_cex=3,Kmin=2,Kmax=6,pop_order=NULL,short_pop=NULL,do_nei=TRUE,do_tree=TRUE,do_perpop=FALSE,do_pi=TRUE,do_dapc=TRUE,do_subsets=FALSE,doBAPT=TRUE,do_indca=TRUE,do_popca=TRUE,do_pca=TRUE,do_mds=TRUE,onlyLEA=FALSE,do_genind=FALSE,symbol_size=3,colour_vector=NULL,silent=TRUE,do_tess=TRUE,do_network=FALSE,do_continue=FALSE,LEAperpop=FALSE,LEAheightfactor=0.75,LEAwidthfactor=0.1,LEAaxiscex=1.5,LEAlabelcex=1.75,LEAyaxiscex=1.25,do_dc=TRUE,marine_dataset=FALSE,dapc_heatmap=TRUE)
	{
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		# This would lead to error message: Error in 1:nLoc(x) : NA/NaN argument.
		# a quick and dirty way of working around this would be to type:
		# inds$filter[is.na(inds$filter)]	<- FALSE
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	my_packages	<- c("adegenet","ape","poppr","LEA","StAMPP")
	for (i in c(1:length(my_packages)))
		{
		my_package	<- my_packages[i]
		if(my_package %in% (.packages()) == FALSE)
			{
			if(do_continue)
				{
				cat(paste("WARNING: essential package ",my_package," not installed or loaded. Continuing anyway, to see how far we get before running into an error.",sep=""),sep="\n")
				}else{
				return(cat(paste("ERROR: essential package ",my_package," not installed or loaded. Please rerun the getpackages function or try to install/load this package yourself. Alternatively run findstructure(do_continue=TRUE) to see how far you can get before running into an error.",sep=""),sep="\n"))
				}
			}
		}
	nsnps	<- nrow(snps[snps$filter,])
	if(nsnps<500)
		{
		if(do_continue)
			{
			cat(paste("WARNING: only ",nsnps," SNPs retained after filtering. This might give low resolution, or even lead to errors when running pcoa analyses. Continue anyway...",sep=""),sep="\n")
			}else{
			return(cat(paste("WARNING: only ",nsnps," SNPs retained after filtering. This might give low resolution, or even lead to errors when running pcoa analyses. Consider using less strict filter settings. Alternatively run findstructure(do_continue=TRUE) to continue anyway.",sep=""),sep="\n"))
			}	
		}
	#
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	popnames	<- mysambar$populations
	# pop_order should be a vector with all population names.
	if(!is.null(pop_order))
		{
		cat("Redefining order of populations as specified by pop_order flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(pop_order)!=length(popnames))
			{
			return(cat("ERROR: vector input to pop_order argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(pop_order)!=length(popnames))
			{
			return(cat("ERROR: vector input to pop_order argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!pop_order%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in pop_order vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%pop_order))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in pop_order argument.",sep="\n"))
			}
		npops			<- length(pop_order)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- pop_order[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<<- k  
			}
		}
	# legend_pos can be either topleft, top, topright, left, center, right, bottomleft, bottom, or bottomright
	setwd(mysambar$structuredir)
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	cat("If you receive the error 'Error in file(file, ifelse(append,'a','w')): cannot open the connection', this might be because a txt.file with dc-scores is open in a file viewer.",sep="\n")
	cat("Close this file, or else run the findstructure function with the flag do_dc set to FALSE.",sep="\n")
	#
	# do analyses:
	if(!onlyLEA)
		{
		if(do_pi)
			{
			cat("Creating pcoa plot based on pairwise sequence similarity using Sambar functions and Ape...",sep="\n")
			if(!silent){cat("calcpi",sep="\n")}
			calcpi(pi_per_pop=FALSE)
			calcpi(pi_per_pop=TRUE)
			if(!silent){cat("ape_pcoa",sep="\n")}
			cat("If you receive an error after this line, rerun findstructure with the flag 'do_pi' set to FALSE (i.e., findstructure(do_pi=FALSE)).",sep="\n")  
			ape_pcoa(labels=FALSE,method="pi",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,method="pi",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,method="pi",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=FALSE,method="pi",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			ape_pcoa(labels=TRUE,method="pi",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,method="pi",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,method="pi",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,method="pi",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)}
			ape_pcoa(labels=TRUE,missvector=inds$miss,method="pi",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,missvector=inds$miss,method="pi",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,missvector=inds$miss,method="pi",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,missvector=inds$miss,method="pi",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			#
			#multiplot_pcoa_axes(exporttype="eps",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			#multiplot_pcoa_axes(exporttype="pdf",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			#multiplot_pcoa_axes(exporttype="png",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			#if(mysambar$os=="Windows"){multiplot_pcoa_axes(exporttype="wmf",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))}
			}
		if(do_nei)
			{
			cat("Creating Nei's genetic distance matrix...",sep="\n")
			ind_neimatrix(export=NULL)
			if(!silent){cat("plot_ind_neimatrix",sep="\n")}
			plot_ind_neimatrix(export="eps")
			plot_ind_neimatrix(export="pdf")
			plot_ind_neimatrix(export="png")
			if(mysambar$os=="Windows"){plot_ind_neimatrix(export="wmf")}
			cat("Creating pcoa plot based on Nei's genetic distance using StAMPP and Ape...",sep="\n")
			cat("If you receive an error after this line, rerun findstructure with the flag 'do_nei' set to FALSE (i.e., findstructure(do_nei=FALSE)).",sep="\n")  
			ape_pcoa(labels=FALSE,method="nei",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,method="nei",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,method="nei",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=FALSE,method="nei",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			ape_pcoa(labels=TRUE,method="nei",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,method="nei",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,method="nei",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,method="nei",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			ape_pcoa(labels=TRUE,method="nei",missvector=inds$miss,export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,method="nei",missvector=inds$miss,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,method="nei",missvector=inds$miss,export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,method="nei",missvector=inds$miss,export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			#
			multiplot_pcoa_axes(exporttype="eps",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			multiplot_pcoa_axes(exporttype="pdf",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			multiplot_pcoa_axes(exporttype="png",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			if(mysambar$os=="Windows"){multiplot_pcoa_axes(exporttype="wmf",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))}
			if(do_subsets)
				{
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				if(nrow(snps[snps$filter,])>500)
					{
					cat("Creating pcoa plots based on Nei's genetic distance using small subsets of loci...",sep="\n")
					if(length(mysambar$populations)>1)
						{
						# subsets containing SNPs with highest standard deviation of MAF:
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=TRUE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=TRUE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						}
					# random subset:
					plotmulti_pcoa(mymethod="nei",export="pdf",do_legend=TRUE)
					plotmulti_pcoa(mymethod="nei",export="pdf",do_legend=FALSE)
					}
				if(nrow(snps[snps$filter,])>100)
					{	
					cat("Creating pcoa plots based on Hamming's genetic distance using even smaller subsets of loci...",sep="\n")
					cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
					# for even smaller subsets:
					if(length(mysambar$populations)>1)
						{
						# subsets containing SNPs with highest standard deviation of MAF:
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						}
					# random subset:
					plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),do_legend=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),do_legend=FALSE,dodc=do_dc)
					}
				}
			}
		cat("Creating pcoa plot based on Hamming's genetic distance using poppr and Ape...",sep="\n")
		ape_pcoa(labels=FALSE,method="hamming",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=FALSE,method="hamming",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=FALSE,method="hamming",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		if(mysambar$os=="Windows"){ape_pcoa(labels=FALSE,method="hamming",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
		ape_pcoa(labels=TRUE,method="hamming",export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,method="hamming",export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,method="hamming",export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,method="hamming",export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
		ape_pcoa(labels=TRUE,method="hamming",missvector=inds$miss,export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,method="hamming",missvector=inds$miss,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,method="hamming",missvector=inds$miss,export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,method="hamming",missvector=inds$miss,export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
		#
		multiplot_pcoa_axes(exporttype="eps",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
		multiplot_pcoa_axes(exporttype="pdf",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
		multiplot_pcoa_axes(exporttype="png",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
		if(mysambar$os=="Windows"){multiplot_pcoa_axes(exporttype="wmf",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))}
		if(length(mysambar$populations)>1&do_perpop)
			{
			cat("Creating pcoa plots based on Hamming's genetic distance for each population separately...",sep="\n")
			cat("If you receive an error after this line, rerun the findstructure function with the flag do_perpop set to FALSE (i.e: findstructure(do_perpop=FALSE)).",sep="\n")
			ape_pcoa_pop(popnames=mysambar$populations,exporttype="pdf",my_method="hamming")
			}
		if(do_subsets)
			{
			if(max(snps$miss,na.rm=TRUE)>0.03)
				{
				cat("Creating pcoa plots based on Hamming's genetic distance using various SNP filter settings...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				# 14-04-2020: Thomas received here the error (which I still need to fix): 'Error in min(D.eig$values): invalid 'type' (complex) of argument 
				multiplot_pcoa(mymethod="hamming",exporttype="pdf")
				multiplot_pcoa(mymethod="hamming",dolabels=TRUE,exporttype="pdf")
				multiplot_pcoa(mymethod="hamming",dolabels=TRUE,print_miss=TRUE,exporttype="pdf")
				plotmiss_vs_p(mymethod="hamming",exporttype="pdf")
				#
				cat("Creating pcoa plots based on Hamming's genetic distance for all individuals (also non_retained individuals) using various SNP filter settings...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				pcoa_allinds(mymethod="hamming",exporttype="pdf")
				pcoa_allinds(mymethod="hamming",exporttype="pdf",dolabels=TRUE)
				pcoa_allinds(mymethod="hamming",exporttype="pdf",dolabels=TRUE,print_miss=TRUE)
				}
			if(nrow(snps[snps$filter,])>500)
				{
				cat("Creating pcoa plots based on Hamming's genetic distance using small subsets of loci...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				if(length(mysambar$populations)>1)
					{
					# subsets containing SNPs with highest standard deviation of MAF:
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					}
				# random subsets:
				plotmulti_pcoa(mymethod="hamming",export="pdf",do_legend=TRUE,dodc=do_dc)
				plotmulti_pcoa(mymethod="hamming",export="pdf",do_legend=FALSE,dodc=do_dc)
				}
			if(nrow(snps[snps$filter,])>100)
				{	
				cat("Creating pcoa plots based on Hamming's genetic distance using even smaller subsets of loci...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				if(length(mysambar$populations)>1)
					{
					# subsets containing SNPs with highest standard deviation of MAF:
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					}
				# random subsets:
				plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),do_legend=TRUE,dodc=do_dc)
				plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),do_legend=FALSE,dodc=do_dc)
				}
			}
		if(do_tree)
			{
			cat("Creating NJ tree based on Hamming's genetic distance (i.e. using bitwise.dist function of poppr package)...",sep="\n")
			cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'do_tree' flag set to false (i.e. findstructure(do_tree=FALSE)).",sep="\n")
			#cat("A second option is to rerun the filterdata() function with different filter options (include more SNPs) and then try the findstructure function again.",sep="\n")
			#08-03-2020: above lines are redundant after including inds$allgeno filter.
			popprtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			cat("Creating UPGMA tree based on Hamming's genetic distance (i.e. using bitwise.dis function of poppr package)...",sep="\n")
			popprtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			popprtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			#
			cat("Calculating Nei's genetic distance using stamppNeisD function of the package 'StAMPP'...",sep="\n")
			pop_neimatrix(export=NULL)
			if(length(mysambar$populations)>3)
				{
				# 22-09-2021:
				getpoptree(exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
				getpoptree(exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
				getpoptree(exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
				getpoptree(exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
				}
			}
		if(do_popca)
			{
			if(length(mysambar$populations)>=3)
				{
				cat("Executing correspondence analysis for populations...",sep="\n")
				cat("If you run into an error shortly after this line, rerun the findstructure function with the flag do_popca set to FALSE.",sep="\n")
				if(nrow(snps[snps$filter,])<100000)
					{
					if(!silent){cat("makeinputfca",sep="\n")}
					makeinputfca()
					if(!silent){cat("run_ca for populations",sep="\n")}
					run_ca(mydf=mysambar$fca_input,perpop=TRUE,doall=FALSE,dodc=do_dc)
					if(!silent){cat("plot_ca for populations",sep="\n")}
					plot_ca(addlegend=FALSE,export="eps",symbolsize=symbol_size)
					plot_ca(addlegend=FALSE,export="pdf",symbolsize=symbol_size)
					plot_ca(addlegend=FALSE,export="png",symbolsize=symbol_size)
					if(mysambar$os=="Windows"){plot_ca(addlegend=FALSE,export="wmf",symbolsize=symbol_size)}
					plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="eps",symbolsize=symbol_size)
					plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="pdf",symbolsize=symbol_size)
					plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="png",symbolsize=symbol_size)
					if(mysambar$os=="Windows"){plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="wmf",symbolsize=symbol_size)}
					}else{
					cat("More than 100.000 SNPs present in retained dataset. For sake of computation time, skipping correspondence analyses for populations.",sep="\n")
					}
				}else{
				cat("Currently less than 3 population defined. Skipping correspondence analysis for populations.",sep="\n")
				}
			}
		if(do_indca)
			{
			cat("Executing correspondence analysis for individuals...",sep="\n")
			cat("If you run into an error shortly after this line, rerun the findstructure function with the flag do_indca set to FALSE.",sep="\n")
			if(!silent){cat("makeinputfca_ind",sep="\n")}
			makeinputfca_ind()
			if(!silent){cat("run_ca for individuals",sep="\n")}
			run_ca(mydf=mysambar$fca_input_ind,perpop=FALSE,doall=FALSE)
			if(!silent){cat("plot_ca for individuals",sep="\n")}
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="eps",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="pdf",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="png",symbolsize=symbol_size)
			if(mysambar$os=="Windows"){plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="wmf",symbolsize=symbol_size)}
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="eps",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="pdf",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="png",symbolsize=symbol_size)
			if(mysambar$os=="Windows"){plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="wmf",symbolsize=symbol_size)}
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="eps",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="pdf",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="png",symbolsize=symbol_size)
			if(mysambar$os=="Windows"){plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="wmf",symbolsize=symbol_size)}
			}
		if("SNPRelate"%in%(.packages())&do_pca)
			{
			cat("Creating pca plot using snprelate...",sep="\n")
			cat("If you receive an error shortly after this line, rerun the findstructure function with the flag do_pca set to FALSE.",sep="\n")
			snprelate_pca(export="eps",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)	
			snprelate_pca(export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			snprelate_pca(export="png",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){snprelate_pca(export="wmf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			snprelate_pca(export="eps",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)	
			snprelate_pca(export="pdf",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			snprelate_pca(export="png",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){snprelate_pca(export="wmf",addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			if(do_subsets)
				{
				cat("Creating pca plot using snprelate using various SNP filter settings...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				multisnprelate_pca(dolabels=FALSE,exporttype="pdf",dolegend=add_legend,poslegend=legend_pos,cex_legend=4,size_symbol=4,maxmiss=0.01)
				}
			file.remove("my.gds")
			}else{
			cat("Package 'SNPrelate' not installed and/or loaded. Not creating snprelate based PCA plots.",sep="\n")
			}
		if(do_mds)
			{
			cat("Creating multidimensional scaling (MDS) plots...",sep="\n")
			if(!silent){cat("bothMDS",sep="\n")}
			bothMDS(exporttype="pdf",rundc=FALSE)
			if(!silent){cat("doMDS",sep="\n")}
			doMDS(labels=TRUE,nonmetric=TRUE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			doMDS(labels=TRUE,nonmetric=FALSE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			doMDS(labels=FALSE,nonmetric=TRUE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			doMDS(labels=FALSE,nonmetric=FALSE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			}
		if(do_dapc)
			{
			cat("Creating dapc plots...",sep="\n")	
			cat("If you receive an error soon after thin line, set the flag 'do_dapc' to FALSE.",sep="\n")
			if(do_genind)
				{
				genlight2genind()
				if(!silent){cat("adegenet_dapc",sep="\n")}
				}
			multi_adegenet_dapc(export="pdf",thresvector=c(20,50,80,95),max_clusters=Kmax,legendadd=add_legend,poslegend=legend_pos,cexlegend=legend_cex,symsize=symbol_size,rundc=do_dc,plot_heatmap=dapc_heatmap)
			}
		if(length(mysambar$populations)>1&doBAPT)
			{
			popnind	<- as.vector(table(inds$pop[inds$filter]))
			if(all(popnind>1))
				{
				cat("Calculating Bayesian assignment probabilities...",sep="\n")
				cat("If the calculation takes too long, or produces errors, rerun the findstructure function with the flag 'doBAPT' set to FALSE.",sep="\n")
				assign2pop()
				if(mysambar$ndata_popassign>1)
					{
					if(!silent){cat("plotassign2pop",sep="\n")}
					plotassign2pop(export="eps",addsamplenr=TRUE)
					plotassign2pop(export="pdf",addsamplenr=TRUE)
					plotassign2pop(export="png",addsamplenr=TRUE)
					if(mysambar$os=="Windows"){plotassign2pop(export="wmf",addsamplenr=TRUE)}
					plotassign2pop(export="eps",addsamplenr=FALSE)
					plotassign2pop(export="pdf",addsamplenr=FALSE)
					plotassign2pop(export="png",addsamplenr=FALSE)
					if(mysambar$os=="Windows"){plotassign2pop(export="wmf",addsamplenr=FALSE)}
					if(!silent){cat("plotassign2pop_hetero",sep="\n")}
					# 28-05-2021: replaced by triangle plot:
					#plotassign2pop_hetero()
					if(!silent){cat("multi_assign2pop",sep="\n")}
					if(mysambar$ndata_popassign>50&mysambar$ndata_popassign<=250)
						{
						multi_assign2pop(nsnp_vector=c(10,20,30,40,50),exporttype="pdf")
						multi_assign2pop(nsnp_vector=c(10,20,30,40,50),exporttype="pdf",top_popmaf_sd=TRUE)
						}
					if(mysambar$ndata_popassign>250)
						{
						multi_assign2pop(nsnp_vector=c(50,100,150,200,250),exporttype="pdf")
						multi_assign2pop(nsnp_vector=c(50,100,150,200,250),exporttype="pdf",top_popmaf_sd=TRUE)
						}
					multi_assign2pop(exporttype="pdf")
					multi_assign2pop(exporttype="pdf",top_popmaf_sd=TRUE)
					}
				}else{
				cat("Skipping Bayesian population assignment test because one or more populations contain 1 individual only.",sep="\n")
				}
			}else{
			cat("Skipping Bayesian population assignment test either only 1 populations defined or because the flag doBAPT is set to FALSE.",sep="\n")
			}
		if(do_network)
			{
			# 01-10-2019: not insightful, therefore by default not included
			cat("Generating genotype network...",sep="\n")	
			cat("If you receive whilst an error after this line, set the flag 'do_network' to FALSE.",sep="\n")
			if(nrow(snps[snps$filter,])>1000)	# if less than 1000 loci, no need to sample, and therefore no stochastic element, so no need to run analysis multiple times to see general behaviour
				{
				makenetworks(nplots=5)
				}else{
				makenetworks(nplots=1)
				}
			}else{
			cat("Skipping genotype networks because the flag do_network is set to FALSE.",sep="\n")
			}
		}
	if("LEA" %in% (.packages()) == FALSE)
		{
		cat("Package LEA not installed or loaded. Skipping LEA admixture analyses.",sep="\n")
		}else{
		cat("Creating admixture barplot using LEA...",sep="\n")
		runLEA(mindemes=Kmin,maxdemes=Kmax,poporder=pop_order)
		if(!silent){cat("eps",sep="\n")}
		LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="eps",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
		LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="eps",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
		if(!silent){cat("pdf",sep="\n")}
		LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
		LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
		#if(!silent){cat("png",sep="\n")}
		#LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="png",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
		#LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="png",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
		if(!silent){cat("wmf",sep="\n")}
		if(mysambar$os=="Windows"){LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="wmf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)}
		if(mysambar$os=="Windows"){LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="wmf",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)}
		# optionally order by longitude:
		if(("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
			{
			if(any(is.na(inds$longitude))|any(is.na(inds$latitude)))
				{
				cat("No missing values allowed in longitude and latitude column.",sep="\n")
				cat("SambaR will not order LEA structure plots by longitude.",sep="\n")
				}else{
				if(!silent){cat("LEAstructureplot by longitude",sep="\n")}
				runLEA(mindemes=Kmin,maxdemes=Kmax,order_on_longitude=TRUE)
				LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
				LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=FALSE,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)	
				if(mysambar$os=="Windows"){LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="wmf",addindnr=TRUE,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)}
				if(mysambar$os=="Windows"){LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="wmf",addindnr=FALSE,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)}
				}
			}
		if(any(as.vector(inds$pop)!=as.vector(inds$pop2))&LEAperpop)
			{
			cat("Running LEA per population.",sep="\n")
			for (my_pop in mysambar$populations)
				{
				cat(my_pop,sep="\n")
				nrinds	<- nrow(inds[inds$pop==my_pop&inds$filter,])
				if(nrinds<3)
					{
					cat("Less than 3 individuals. Skipping LEA admixture plot.",sep="\n")
					}else{
					runLEA(mindemes=Kmin,maxdemes=6,popnames=mysambar$populations,order_on_longitude=FALSE,focuspop=my_pop)
					indspop		<- inds[inds$pop==my_pop&inds$filter,]
					mysubpops	<- unique(as.vector(indspop$pop2))
					mysubpops	<- mysubpops[order(mysubpops)]
					LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,order_on_longitude=FALSE,poporder=pop_order,shortpop=short_pop,colourvector=colour_vector,focuspop=my_pop,popnames=mysubpops,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex)
					}
				}
			}
		if(!onlyLEA)
			{
			# optionally create geographical maps:
			if(!silent){cat("create_sambarmaps",sep="\n")}
			create_sambarmaps(K_max=Kmax,radius_ratio=30,dotess=do_tess,marine_data=marine_dataset)
			}
		}
	# reset working directory to default:
	setwd(mysambar$inputdatadir)
	cat("Finished structure analyses.",sep="\n")
	}

create_sambarmaps<-function(K_max=6,radius_ratio=30,dotess=TRUE,dolea=TRUE,dodapc=TRUE,domantel=TRUE,plot_per_pop=FALSE,marine_data=FALSE)
	{
	# radius_ratio is the ratio between radius of piechart and the range of either longitude or latitude (i.e. smallest of the two)
	# e.g.: 30 means 1/30th.
	if((!"latitude"%in%colnames(inds))|(!"longitude" %in% colnames(inds)))
		{
		cat("Longitude and/or latitude column are absent in inds dataframe.",sep="\n")
		cat("SambaR will not generate geographical maps.",sep="\n")
		}else{
		if(any(is.na(inds$longitude[inds$filter]))|any(is.na(inds$latitude[inds$filter])))
			{
			cat("No missing values allowed in longitude and latitude column.",sep="\n")
			return(cat("SambaR will not create geographical maps. If wanted, you can use the addgeofile() function to update the inds$latitude and inds$longitude column.",sep="\n"))
			}
		if(!"longitude2"%in%colnames(inds))
			{
			# pacific or atlantic centred map?
			inds$longitude2			<<- ifelse(inds$longitude>=0,inds$longitude,abs(inds$longitude)+180)
			}
		if(!"longitude3"%in%colnames(inds))
			{
			# pacific or atlantic centred map?
			inds$longitude3			<<- ifelse(inds$longitude>=-15,inds$longitude,180+(180-abs(inds$longitude)))
			}
		if(!"geomapsdir" %in% (names(mysambar)))
			{
			geomapsdir				<- paste(mysambar$structuredir,"Maps",sep="/")
			nelements				<- length(mysambar)
			mysambar$geomapsdir		<<- geomapsdir
			}else{
			if(is.null(mysambar$geomapsdir))
				{
				geomapsdir			<- paste(mysambar$structuredir,"Maps",sep="/")
				nelements			<- length(mysambar)
				mysambar$geomapsdir	<<- geomapsdir
				}
			}
		my_devices	<- dev.list()
		n_devices	<- length(my_devices)
		if(n_devices!=0)
			{
			cat("Closing open devices...",sep="\n")
			my_devices	<- dev.list()
			for(k in rev(my_devices))
				{
				dev.off(k)
				}
			}
		cat("Setting directory to:",sep="\n")
		cat(mysambar$geomapsdir,sep="\n")
		setwd(mysambar$geomapsdir)
		if(!is.null(mysambar$leaqmatrixlist)&dolea)
			{
			cat("Creating geographical maps with admixture piecharts using LEA output...",sep="\n")
			cat("If you receive an error shortly after this line, set the flag dolea to FALSE.",sep="\n")
			mymaxK	<- length(mysambar$leaqmatrixlist)+1
			if(mymaxK<K_max)
				{
				cat(paste("Warning: K_max is set to",K_max,"but currently data available for a maximum K of",mymaxK,sep=" "),sep="\n")
				cat("If desired, rerun the findstructure() function with a higher Kmax value.",sep="\n")
				cat(paste("Creating plots now for K = 2 to K =",mymaxK,sep=" "),sep="\n")
				maplea(maxdemes=mymaxK,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
				maplea(maxdemes=mymaxK,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
				}else{
				maplea(maxdemes=K_max,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
				maplea(maxdemes=K_max,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
				}
			}else{
			cat("Could not find object called mysambar$leaqmatrixlist. Run the findstructure() function and try again.",sep="\n")
			}
		if(!is.null(mysambar$dapcqmatrixlist)&dodapc)
			{
			cat("Creating geographical maps with admixture piecharts using DAPC output...",sep="\n")
			cat("If you receive an error shortly after this line, set the flag dodapc to FALSE.",sep="\n")
			mymaxK	<- length(mysambar$dapcqmatrixlist)+1
			if(mymaxK<K_max)
				{
				cat(paste("Warning: K_max is set to",K_max,"but currently data for available for a maximum K of",mymaxK,sep=" "),sep="\n")
				cat("If desired, rerun the findstructure() function with a higher Kmax value.",sep="\n")
				cat(paste("Creating plots now for K = 2 to K =",mymaxK,sep=" "),sep="\n")
				mapdapc(maxdemes=mymaxK,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
				mapdapc(maxdemes=mymaxK,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
				}else{
				mapdapc(maxdemes=K_max,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
				mapdapc(maxdemes=K_max,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
				}
			}else{
			cat("Object 'dapcqmatrixlist' not present in mysambar list. Run the findstructure() function and try again.",sep="\n")
			}
		if(dotess)
			{
			cat("Creating Tessellation plots...",sep="\n")
			cat("If you receive an error shortly after this line, set the flag dotess to FALSE.",sep="\n")
			# map tess qmatrix:
			runtess3(export="pdf",myrepos='http://cran.us.r-project.org',maxK=K_max)
			maptess(use_lea=FALSE,mydemes=c(2:K_max),export="pdf",multiplot=FALSE,marine=marine_data)
			maptess(use_lea=FALSE,mydemes=c(2:5),export="pdf",multiplot=TRUE,marine=marine_data)
			# barplot tess:
			tesslist<-list()
			for(ndemes in c(2:(K_max)))	
				{
				tesslist[[ndemes-1]] 	<- qmatrix(tessout,K=ndemes)
				}
			plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=TRUE,order_on_longitude=FALSE)
			plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=TRUE,order_on_longitude=TRUE)
			plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=FALSE,order_on_longitude=FALSE)
			plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=FALSE,order_on_longitude=TRUE)
			# map LEA qmatrix
			maptess(use_lea=TRUE,mydemes=c(2:K_max),export="pdf",multiplot=FALSE,marine=marine_data)
			maptess(use_lea=TRUE,mydemes=c(2:5),export="pdf",multiplot=TRUE,marine=marine_data)
			}
		if(domantel)
			{
			cat("If you receive an error shortly after this line, set the flag domantel to FALSE.",sep="\n")
			cat("Creating mantel plot...",sep="\n")
			multi_mantel_plot(popnames=mysambar$populations,doexport=TRUE)
			}
		cat("Plotting location of samples using R package Rworldmap...",sep="\n")
		plotlocations(export="pdf",addaxislabels=FALSE)
		plotlocations(export="pdf",addaxislabels=TRUE)
		plotlocations(export="pdf",addaxislabels=TRUE,adjustratio=0.5,mycex=3)
		plotlocations(export="pdf",addaxislabels=FALSE,adjustratio=0.5,mycex=3)
		plotlocations(export="pdf",addaxislabels=TRUE,adjustratio=0.5,mycex=3,mydeviation=1)
		plotlocations(export="pdf",addaxislabels=FALSE,adjustratio=0.5,mycex=3,mydeviation=1)
		cat("Plotting location of samples using R package maps...",sep="\n")
		plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1.25,dolabels=FALSE,showborders=FALSE)
		plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1.25,dolabels=FALSE,showborders=TRUE)
		plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1.25,dolabels=TRUE,showborders=FALSE)
		plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1.25,dolabels=TRUE,showborders=TRUE)
		cat("Files have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		setwd(mysambar$structuredir)
		}	
	}

# make input for correspondence analysis (I called it factorial correspondence analysis, but actually not sure whether it is factorial indeed)	
makeinputfca<-function(popnames=mysambar$populations,remove0=FALSE)
	{
	if(length(popnames)==1)
		{
		return(cat("Currently only 1 population defined. SambaR can not execute correspondence analysis (CA).",sep="\n"))
		}else{
		temp	<- snps[snps$filter,c(paste("maf",mysambar$populations,sep="_"))]
		nsites	<- snps$nonmissallelecount[snps$filter]
		for (j in c(1:nrow(temp)))
			{
			myrow			<- as.vector(temp[j,]*nsites[j])
			if(remove0)
				{
				myrow[myrow==0]	<- 1
				}
			temp[j,]		<- myrow
			}
		temp			<- round(temp)
		colnames(temp)	<- mysambar$populations
		mysambar$fca_input	<<- temp[complete.cases(temp), ]
		}
	}

makeinputfca_ind<-function(popnames=mysambar$populations,doall=FALSE,impute_persnp=TRUE)
	{
	if(impute_persnp)
		{
		if(is.null(mysambar$imputedmatrix_persnp))
			{
			sambarimpute(per_snp=TRUE)
			}
		if(doall)
			{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix_persnp[,snps$filter])
			}else{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix_persnp[inds$filter,snps$filter])
			}
		}else{
		if(is.null(mysambar$imputedmatrix))
			{
			sambarimpute(per_snp=FALSE)
			}
		if(doall)
			{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix[,snps$filter])
			}else{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix[inds$filter,snps$filter])
			}
		
		}
	}
	
# input dataset:
sambarimpute<-function(doall=FALSE,per_snp=TRUE,silent=TRUE,calc_he=TRUE,popnames=mysambar$populations,do_overwrite=FALSE)
	{
	# impute data (because no missing values allowed):
	mymatrix				<- as.matrix(mygenlight)
	# impute data (because no missing values allowed):
	if(!per_snp)
		{
		cat("Imputing data using using genotype information per sample...",sep="\n")
		do_analysis			<- ifelse(is.null(mysambar$imputedmatrix_persnp),TRUE,ifelse(do_overwrite,TRUE,FALSE))
		if(!do_analysis)
			{
			cat("Obtaining imputed dataset from mysambar$imputedmatrix_persnp.",sep="\n")
			mymatrix		<- mysambar$imputedmatrix_persnp
			}
		}else{
		cat("Imputing data using using genotype information per SNP...",sep="\n")
		do_analysis			<- ifelse(is.null(mysambar$imputedmatrix),TRUE,ifelse(do_overwrite,TRUE,FALSE))
		if(!do_analysis)
			{
			cat("Obtaining imputed dataset from mysambar$imputedmatrix.",sep="\n")
			mymatrix		<- mysambar$imputedmatrix
			}
		}
	#
	if(do_analysis)
		{
		for (i in c(1:nrow(inds)))
			{
			myind				<- as.vector(inds$name)[i]
			mypop				<- as.vector(as.character(inds$pop))[i]
			if(!silent){cat(i,sep="\n")}
			if(!silent){cat(myind,sep="\n")}
			if(!silent){cat(mypop,sep="\n")}
			#
			myrow				<- mymatrix[i,]
			myrow_data			<- myrow[!is.na(myrow)]
			myrow_na			<- myrow[is.na(myrow)]
			nmiss				<- length(myrow_na)
			#
			columnname			<- paste("maf",mypop,sep="_")
			if(per_snp&!(columnname%in%colnames(snps)))
				{
				return(cat("ERROR: column with population specific minor allele frequencies missing from snps dataframe. First run the snp_maf() function.",sep="\n"))
				}
			if(nmiss<nrow(snps))
				{
				if(per_snp)
					{
					mymafcolumn			<- as.vector(snps[,columnname])
					if(any(is.na(mymafcolumn)))
						{
						# 26-04-2021: Quick and dirty solution to avoid the error:
						# Error in apply(popmatrix, 2, function(z) { : dim(X) must have a positive length
						if(!silent){cat(paste("WARNING: no maf-estimate for one or more SNPs of population ",mypop,". Using instead maf estimate of meta population.",sep=""),sep="\n")}  
						mymafcolumn		<-ifelse(is.na(mymafcolumn),snps$maf,mymafcolumn)
						}
					AAthres				<- (1-mymafcolumn)*(1-mymafcolumn)
					aathres				<- 1-(mymafcolumn*mymafcolumn)
					randomvec			<- runif(length(mymafcolumn))
					randomgeno			<- ifelse(randomvec<=AAthres,0,ifelse(randomvec<=aathres,1,2)) 
					myrow_all			<- ifelse(is.na(myrow),randomgeno,myrow)  
					#myrow_all			<- ifelse(is.na(myrow),9,myrow)		# test to check if replacing NAs only
					}else{
					myrow_na[1:nmiss]	<- sample(as.vector(myrow[!is.na(myrow)]),nmiss,replace=TRUE)
					myrow_all			<- c(myrow_data,myrow_na)
					myrow_all			<- myrow_all[order(names(myrow_all))]
					}
				mymatrix[i,]			<- myrow_all
				}else{
				if(inds$filter[i]&doall)
					{
					return(cat(paste("ERROR: Sample ",myind, "contains missing data only. Set doall flag to FALSE.")),sep="\n")
					}
				}
			}
		}		
	if(per_snp)
		{
		mysambar$imputedmatrix_persnp	<<- mymatrix
		cat("Imputed data stored at mysambar$imputedmatrix_persnp.",sep="\n")
		}else{
		mysambar$imputedmatrix			<<- mymatrix
		cat("Imputed data stored at mysambar$imputedmatrix.",sep="\n")
		}
	#
	if(calc_he)
		{
		cat("Calculating snp-specific maf, mac and He-scores for imputed dataset...",sep="\n")
		ninds						<- nrow(inds[inds$filter,])
		inputgenlight				<- as.genlight(mymatrix)
		snps$imputed_minorcount		<<- as.vector(glSum(inputgenlight[inds$filter,]))
		snps$imputed_majorcount		<<- 2*ninds-snps$imputed_minorcount	
		snps$imputed_maf			<<- round(snps$imputed_minorcount/(2*ninds),3)
		#
		popmatrix 					<- mymatrix[inds$filter,]
		popmatrix[is.na(popmatrix)]	<- 3
		snps$imputed_Aa				<<- apply(popmatrix,2,function(z){(length(z[z==1]))})
		snps$imputed_hetero			<<- apply(popmatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		#
		# Per population:
		for (i in (1:length(popnames)))
			{
			if(any(inds$filter&inds$pop==popnames[i]))
				{
				snps$maftemp 		<<- glMean(inputgenlight[inds$filter&inds$pop==popnames[i],])
				snps$maftemp[!is.finite(snps$maftemp)]	<<- NA 
				if(any(is.na(snps$maftemp)))
					{
					cat(paste("WARNING: No data for 1 or more snps in population:",popnames[i],sep=" "),sep="\n")
					}
				snps$mactemp		<<- as.vector(glSum(inputgenlight[inds$filter&inds$pop==popnames[i],]))
				#
				popmatrix					<- mymatrix[inds$filter&inds$pop==popnames[i],,drop=FALSE]
				popmatrix[is.na(popmatrix)]	<- 3		# because otherwise NA's are counted as 1.
				snps$Aatemp					<<- apply(popmatrix,2,function(z){length(which(z==1))})
				snps$heterotemp				<<- apply(popmatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
				}else{
				cat(paste("No individuals retained in population:",popnames[i],sep=" "),sep="\n")
				snps$maftemp 		<<- NA
				snps$mactemp		<<- NA
				snps$Aatemp			<<- NA
				snps$heterotemp		<<- NA
				}
			names(snps)[names(snps) == "maftemp"] 	<<- paste("imputed_maf",popnames[i],sep = "_")
			names(snps)[names(snps) == "mactemp"] 	<<- paste("imputed_mac",popnames[i],sep = "_")
			names(snps)[names(snps) == "Aatemp"] 	<<- paste("imputed_Aa",popnames[i],sep = "_")
			names(snps)[names(snps) == "heterotemp"]<<- paste("imputed_hetero",popnames[i],sep = "_")
			}
		# if this function has been executed before, remove columns produced during previous execution:
		snps 						<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
		}
	}

run_ca<-function(mydf=mysambar$fca_input,perpop=TRUE,mymethod="dudi",doall=FALSE,popnames=mysambar$populations,doinstall=FALSE,dodc=TRUE)
	{
	if(perpop&length(popnames)<3)
		{
		return(cat("Currently less than 2 population defined. SambaR can not execute fca analysis when perpop is set is TRUE.",sep="\n"))
		}
	if(!(mymethod=="dudi"|mymethod=="factominer"))
		{
		return(cat("ERROR: mymethod should be 'dudi' or 'factominer'.",sep="\n"))
		}
	# correspondence analysis is principal components analysis for categorical data (rather than for numerical data?)
	# mymethod can be be 'factominer' (FactoMineR package) or 'dudi' (ade4 package).
	# Other options for correspondence analysis, at present not incorporated, would be:
	# library(ca)
	# res.ca <- ca(housetasks)
	# library(MASS)
	# res.ca <- corresp(housetasks, nf = 3)
	# No matter which method, factominer is used for plotting.
 	#
	if(doinstall)
		{
		install.packages("FactoMineR")
		install.packages("factoextra")
		library("FactoMineR")
		library("factoextra")
		}
	npops	<- length(popnames)
	if(is.null(mydf))
		{
		return(cat("Error: provide a dataframe with minor allele counts per population to mydf flag.",sep="\n"))
		}
	if(!perpop)
		{
		if(doall)
			{
			ninds	<- nrow(inds)
			}else{
			ninds	<- nrow(inds[inds$filter,])
			}
		if(ncol(mydf)!=ninds)
			{
			return(cat("ERROR: number of columns in input file does not correspond with expected number of individuals.",sep="\n"))
			}
		}else{
		if(ncol(mydf)!=npops)
			{
			return(cat("ERROR: number of columns in input file does not correspond with expected number of populations.",sep="\n"))
			}
		}
	# mydf	<- unique(mydf)							# remove duplicates rows
	if(mymethod=="factominer")
		{
		# sambarfunction_findstructure:
		##### FINDSTRUCTURE #####
		# sambarfunction_findstructure:
		### correspondence analyses:
		# sambarfunction_findstructure:
		mysambar$res.ca 	<<- CA(mydf,ncp=5,graph=FALSE)
		# this gives sometimes the error: Error in eigen(crossprod(X, X), symmetric = TRUE) : infinite or missing values in 'x'
		}
	if(mymethod=="dudi")
		{
		#sambarfunction_findstructure:
		mysambar$res.ca 	<<- dudi.coa(mydf,scannf=FALSE,nf=5)		
		}
	#
	if(mymethod=="factominer")
		{
		mysambar$ca_eig.val <<- as.data.frame(get_eigenvalue(mysambar$res.ca))
		mysambar$ca_coord	<<- mysambar$res.ca$col$coord
		mysambar$ca_perc1	<<- round(res.ca$eig[1,2],1)
		mysambar$ca_perc2	<<- round(res.ca$eig[2,2],1)
		}
	if(mymethod=="dudi")
		{
		mysambar$ca_out 	<<- get_ca_col(mysambar$res.ca)
		mysambar$ca_coord	<<- mysambar$ca_out$coord
		mysambar$ca_eig.val <<- get_eigenvalue(mysambar$res.ca)
		mysambar$ca_perc1	<<- round(mysambar$ca_eig.val$variance.percent[1],1)
		mysambar$ca_perc2	<<- round(mysambar$ca_eig.val$variance.percent[2],1)
		}
	mytablename	<- "CA.ind.axis1vs2.dc_score.txt"
	if(dodc)
		{
		calc_dc(popnames=mysambar$populations,pscores=mysambar$ca_coord,axis_1=1,axis_2=2,tablename=mytablename)
		}
	}

plot_ca<-function(do_scree=FALSE,export=NULL,doall=FALSE,perpop=TRUE,popnames=mysambar$populations,dolabels=FALSE,addlegend=TRUE,symboltype=16,symbolsize=2.5,legendpos="topleft",legendcex=1.5,resetgraphics=TRUE)
	{
	npops	<- length(popnames)
	# screeplot:
	if(do_scree)
		{
		if(!is.null(export))
			{
			if(perpop)
				{
				if(export=="eps"){postscript("CA.pop.screeplot.eps",family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf("CA.pop.screeplot.pdf",family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png("CA.pop.screeplot.png",family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile("CA.pop.screeplot.wmf",family=mysambar$myfont,width=10,height=10)}
				}else{
				if(export=="eps"){postscript("CA.ind.screeplot.eps",family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf("CA.ind.screeplot.pdf",family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png("CA.ind.screeplot.png",family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile("CA.ind.screeplot.wmf",family=mysambar$myfont,width=10,height=10)}
				}
			}
		barplot(mysambar$ca_eig.val$variance.percent,ylab="Percentage explained variance",names.arg=c(1:nrow(eig.val)))
		if(!is.null(export)){dev.off()}
		}
	#
	# ordination plot:
	if(resetgraphics){graphics.off()}
	if(!is.null(export))
		{
		mylegend	<- ifelse(addlegend,ifelse(perpop,"pop.withlegend","ind.withlegend"),ifelse(perpop,"pop.nolegend",ifelse(dolabels,"ind.nolegend.labels","ind.nolegend")))
		if(export=="eps"){postscript(paste("CA",mylegend,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("CA",mylegend,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("CA",mylegend,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("CA",mylegend,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,5,2,2),cex.lab=2.5,cex.axis=2.5)
	plot(mysambar$ca_coord[,1],mysambar$ca_coord[,2],col="white",cex=symbolsize,pch=16,xlab=paste("Dim 1 (",mysambar$ca_perc1," %)",sep=""),ylab=paste("Dim 2 (",mysambar$ca_perc2," %)",sep=""))
	abline(h=0,col="grey")
	abline(v=0,col="grey")
	if(perpop)
		{
		mycolours	<- mysambar$mycolours
		}else{
		if(doall)
			{
			mycolours	<- inds$popcol
			}else{
			mycolours	<- inds$popcol[inds$filter]
			}
		}
	if(dolabels)
		{
		if(doall)
			{
			mynumbers	<- inds$nr
			}else{
			mynumbers	<- inds$nr[inds$filter]
			}
		text(x=mysambar$ca_coord[,1],y=mysambar$ca_coord[,2],mynumbers,col=mycolours,cex=0.5)
		}else{
		points(mysambar$ca_coord[,1],mysambar$ca_coord[,2],col=mycolours,cex=symbolsize,pch=16)
		}
	if(addlegend==TRUE&npops>1)
		{
		if(length(symboltype)>1)
			{
			legend(legendpos,legend=popnames,fill=mysambar$mycolours,pch=symboltype,bty="n",cex=legendcex)
			}else{
			legend(legendpos,legend=popnames,fill=mysambar$mycolours,bty="n",cex=legendcex)
			}
		}
	if(!is.null(export)){dev.off()}
	}
	
hwe<-function(popnames=mysambar$populations,indselection=inds$filter,mycolours=mysambar$mycolours,export=NULL,addlabels=TRUE,silent=TRUE)
	{
	popnames		<- as.vector(popnames)
	npops			<- length(popnames)
	### For metapop:
	snps$Hexp_meta	<<- 2*snps$maf*(1-snps$maf)
	snps$F_meta		<<- (snps$Hexp_meta-snps$hetero)/snps$Hexp_meta
	# alternatively:
	# snps$F_meta	<<- (snps$expAa-snps$Aa)/snps$expAa
	snps$HWEchi2	<<- ((snps$expAA-snps$AA)^2/(snps$expAA+1))+((snps$Aa-snps$expAa)^2/(snps$expAa+1))+((snps$aa-snps$expaa)^2/(snps$expaa+1))
	# Degrees of freedom (df) = N_genotypes - N_alleles. For biallelic snps: 3-2=1.
	# This is the reason: once we decided on a value for p, everything else was decided for us. Whatever p was, q had to be 1-p, and p2, 2pq, and q2 were set as well. 
	# So, to make columns for p-values and for significance (TRUE or FALSE), we can type:
	snps$HWEp		<<- round(pchisq(snps$HWEchi2,df=1,lower.tail=FALSE),6)
	snps$HWE		<<- snps$HWEchi2 < (qchisq(.95,df=1))
	# He deficit or excess?
	snps$Hdeficit	<<- ifelse(snps$expAa-snps$Aa>0,TRUE,FALSE) 
	# I noticed that deficit is often caused by high maf. Maybe to correct for it:
	# snps$Hdeficit <<- ifelse(snps$HWE=="TRUE"&snps$maf<0.45,snps$Hdeficit,NA)
	### Plot:
	graphics.off()
	ntiles			<- npops+1
	if(!is.null(export))
		{
		mywidth1	<- ntiles*6+1
		mywidth2	<- ntiles*400+200
		if(export=="eps"){postscript("HWE.eps",family=mysambar$myfont,width=mywidth1,height=10)}
		if(export=="pdf"){pdf("HWE.pdf",family=mysambar$myfont,width=mywidth1,height=10)}
		if(export=="png"){png("HWE.png",family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile("HWE.wmf",family=mysambar$myfont,width=mywidth1,height=10)}
		}
	par(mfrow=c(1,ntiles),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	hist(snps$HWEchi2[snps$filter],breaks=seq(0,max(snps$HWEchi2[snps$filter]+10,0.5)),xlim=c(0,20),ylim=c(0,nrow(snps[snps$filter,])),main="",xlab="",ylab="Number of loci")
	mtext("Metapop",side=3,line=-2,cex=2)
	abline(v=qchisq(.95,df=1),lty=2)
	mtext("Locus specific HWE chi squared scores",side=1,line=-1.5,cex=2,outer=TRUE)
	mtext("HWE test scores",side=3,line=-3.5,cex=2.5,outer=TRUE)
	# For individuals populations:
	### For individual pops:
	for (i in (1:length(popnames)))
		{
		if(!silent){cat(popnames[i],sep="\n")}
		# Expected genotypes per population:
		# misscount			<- glNA(mygenlight[indselection&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		# npopind				<- nrow(inds[indselection&inds$pop==popnames[i],])
		# nonmisscount 		<- 2*npopind-misscount
		# snps$nonmisstemp	<<- nonmisscount
		# Observed genotypes per population:
		# mymatrix 			<- as.matrix(mygenlight[indselection&inds$pop==popnames[i],])
		# mymatrix[is.na(mymatrix)]	<- 3
		# obsAA				<- apply(mymatrix,2,function(z){length(z[z==0])})
		# obsAa				<- apply(mymatrix,2,function(z){length(z[z==1])})
		# obsaa				<- apply(mymatrix,2,function(z){length(z[z==2])})
		# expAA				<- round((1-mymaf)*(1-mymaf)*nonmisscount/2)
		# expAa				<- round(2*mymaf*(1-mymaf)*nonmisscount/2)
		# expaa				<- round(mymaf*mymaf*nonmisscount/2)
		# 16-03-2021: masked 14 lines above
		obsAA				<- snps[,paste("AA",popnames[i],sep="_")]		# 16-03-2021
		obsAa				<- snps[,paste("Aa",popnames[i],sep="_")]		# 16-03-2021
		obsaa				<- snps[,paste("aa",popnames[i],sep="_")]		# 16-03-2021
		# misscount			<- snps[,paste("miss",popnames[i],sep="_")]		# 16-03-2021
		nonmisscount		<- snps[,paste("n",popnames[i],sep="_")]		# 16-03-2021
		mymaf				<- snps[,paste("maf",popnames[i],sep="_")]
		expAA				<- round((1-mymaf)*(1-mymaf)*nonmisscount)		# 16-03-2021
		expAa				<- round(2*mymaf*(1-mymaf)*nonmisscount)		# 16-03-2021
		expaa				<- round(mymaf*mymaf*nonmisscount)				# 16-03-2021
		# Do the HWE-test:
		snps$Ftemp			<<- (expAa-obsAa)/expAa
		snps$HWEchi2temp	<<- ((expAA-obsAA)^2/(expAA+1))+((obsAa-expAa)^2/(expAa+1))+((obsaa-expaa)^2/(expaa+1))
		snps$HWEptemp		<<- round(pchisq(snps$HWEchi2temp,df=1,lower.tail=FALSE),6)
		snps$HWEtemp		<<- snps$HWEchi2temp < (qchisq(.95,df=1))
		snps$Hdeficittemp	<<- ifelse(expAa-obsAa>0,TRUE,FALSE) 
		snps$expAatemp		<<- expAa
		#snps$obsAatemp		<<- obsAa		# 16-03-2021: masked
		# Plot:
		hist(snps$HWEchi2temp[snps$filter],breaks=seq(0,max(snps$HWEchi2temp[snps$filter],na.rm=TRUE)+10,0.5),xlim=c(0,20),ylim=c(0,nrow(snps[snps$filter,])),main="",xlab="",ylab="",col=mycolours[i])
		mtext(popnames[i],side=3,line=-2,cex=2)
		abline(v=qchisq(.95,df=1),lty=2)
		# Rename:
		# names(snps)[names(snps) == "nonmisstemp"]	<<- paste("n",popnames[i],sep = "_")
		# names(snps)[names(snps) == "obsAatemp"]	<<- paste("Aa",popnames[i],sep = "_")
		# 16-03-2021: masked two lines above
		names(snps)[names(snps) == "expAatemp"]		<<- paste("expAa",popnames[i],sep = "_")
		names(snps)[names(snps) == "Ftemp"] 		<<- paste("F",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEchi2temp"] 	<<- paste("HWEchi2",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEptemp"] 		<<- paste("HWEp",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEtemp"] 		<<- paste("HWE",popnames[i],sep = "_")
		names(snps)[names(snps) == "Hdeficittemp"]	<<- paste("Hdeficit",popnames[i],sep = "_")
		} 
	if(!is.null(export)){dev.off()}
	# results per population:
	nsnps		<- nrow(snps[snps$filter,])
	results		<- matrix(, nrow = (length(popnames)+1), ncol = 4)
	colnames(results)<- c("Equilibrium","Disequilibrium","He_deficit","He_surplus")
	rownames(results)<- c("metapop",as.vector(popnames))
	results[1,1]	<- nrow(snps[snps$HWE==TRUE&snps$filter,])/nsnps*100
	results[1,2]	<- nrow(snps[snps$HWE==FALSE&snps$filter,])/nsnps*100
	results[1,3]	<- nrow(snps[snps$HWE==FALSE&snps$filter&snps$Hdeficit==TRUE,])/nsnps*100
	results[1,4]	<- nrow(snps[snps$HWE==FALSE&snps$filter&snps$Hdeficit==FALSE,])/nsnps*100
	for (i in (1:length(popnames)))
		{
		myHWE		<- snps[,paste("HWE",popnames[i],sep="_")]
		myHdeficit	<- snps[,paste("Hdeficit",popnames[i],sep="_")]
		results[i+1,1]	<- nrow(snps[myHWE==TRUE&snps$filter,])/nsnps*100
		results[i+1,2]	<- nrow(snps[myHWE==FALSE&snps$filter,])/nsnps*100
		results[i+1,3]	<- nrow(snps[myHWE==FALSE&snps$filter&myHdeficit==TRUE,])/nsnps*100
		results[i+1,4]	<- nrow(snps[myHWE==FALSE&snps$filter&myHdeficit==FALSE,])/nsnps*100
		}
	mysambar$hwetable	<<- round(results,2)
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}   	

wahlundplot<-function(export=NULL,popnames=mysambar$poporder,addlabels=TRUE,silent=TRUE,plotname="Wahlund_effect",addylabel=TRUE)
	{
	fdf				<- snps[snps$filter,c("morgan","F_meta","HWE")]
	colnames(fdf)	<- c("pop","F","HWE")
	fdf$pop			<- "0_meta"
	npops			<- length(popnames)+1
	for (j in c(1:(npops-1)))
		{
		mypop			<- popnames[j]
		if(!silent){cat(mypop,sep="\n")}
		fdfpop			<- snps[snps$filter,c("morgan",paste("F",mypop,sep="_"),paste("HWE",mypop,sep="_"))]
		colnames(fdfpop)<- c("pop","F","HWE")
		fdfpop$pop		<- paste(j,mypop,sep="_")
		fdf				<- as.data.frame(rbind(fdf,fdfpop))
		}
	fdf				<- fdf[!is.na(fdf$HWE)&is.finite(fdf$F),]
	fdfout			<- fdf[!fdf$HWE,]
	retainedpops	<- unique(fdf$pop)
	retainedpops	<- sapply(strsplit(retainedpops, "_"),"[",2)
	popbool			<- popnames%in%retainedpops
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=6)}
		}
	par(oma=c(5,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
	boxplot(fdf$F~fdf$pop,border="white",col="white",las=2,xlab="",ylab="",cex.axis=1.5,pch=16,outline=TRUE,ylim=c(-1,1),names=c("metapop",popnames[popbool]))
	boxplot(fdf$F~fdf$pop,border=c("black",mysambar$colorder[popbool]),xlab="",ylab="",xaxt='n',yaxt='n',col="grey90",add=TRUE,outline=FALSE)
	if(length(as.vector(unique(fdfout$pop)))<(npops+1))
		{
		mypch	<- 1
		mycex	<- 0.25
		stripchart(F~pop,data=fdf,vertical=TRUE,method="jitter",pch=mypch,cex=mycex,xlab="",ylab="",col=c("black",mysambar$colorder[popbool]),bg="bisque",add=TRUE) 
		}else{
		# if possible show only loci significantly out of HWE
		mypch	<- 16
		mycex	<- 0.5
		stripchart(F~pop,data=fdfout,vertical=TRUE,method="jitter",pch=mypch,cex=mycex,xlab="",ylab="",col=c("black",mysambar$colorder[popbool]),bg="bisque",add=TRUE) 
		}
	if(addylabel)
		{	
		mtext(side=2,"F per SNP",line=3.25,cex=2,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

wahlundplot_old<-function(mysteps=0.05,export=NULL,popnames=mysambar$populations,addlabels=TRUE,silent=TRUE)
	{
	fislist			<- list()
	fislist2		<- list()
	ndatalist		<- list()
	npops			<- length(popnames)
	# for populations:
	for (j in c(1:npops))
		{
		mypop		<- popnames[j]
		if(!silent){cat(mypop,sep="\n")}
		myfis		<- snps[,paste("F",mypop,sep="_")]
		mymaf		<- snps[,paste("maf",mypop,sep="_")]
		myselection	<- is.finite(myfis)&snps$filter2
		if(any(myselection))
			{
			mybreaks	<- seq(0,1,mysteps)
			myhalf		<- mysteps/2
			mylabels	<- seq(myhalf,1-myhalf,mysteps)
			mafbins		<- cut(mymaf[myselection],mybreaks)
			# boxplot(myfis[myselection]~mafbins)
			fisperbin	<- aggregate(myfis[myselection],by=list(mafbins),FUN=mean) 
			nperbin		<- aggregate(myfis[myselection],by=list(mafbins),FUN=length)
			nbins		<- nrow(fisperbin)
			mylabels2	<- mylabels[1:nbins]
			fislist[[j]]	<- cbind(mylabels2,fisperbin$x) 
			fislist2[[j]]	<- fisperbin$x
			ndatalist[[j]]	<- nperbin$x
			}else{
			emptybins		<- seq(0,0.5,mysteps)
			zerodata		<- rep(0,length(emptybins))
			fislist[[j]]	<- cbind(emptybins,zerodata)
			fislist2[[j]]	<- zerodata
			ndatalist[[j]]	<- zerodata
			}
		}
	# for metapop:
	myfis		<- snps$F_meta
	mymaf		<- snps$maf
	myselection	<- is.finite(myfis)&snps$filter2
	mybreaks	<- seq(0,1,mysteps)
	myhalf		<- mysteps/2
	mylabels	<- seq(myhalf,1-myhalf,mysteps)
	mafbins		<- cut(mymaf[myselection],mybreaks)
	fisperbin	<- aggregate(myfis[myselection], by=list(mafbins),FUN=mean) 
	nperbin		<- aggregate(myfis[myselection], by=list(mafbins),FUN=length)
	nbins		<- nrow(fisperbin)
	mylabels2	<- mylabels[1:nbins]
	fislist[[npops+1]]	<- cbind(mylabels2,fisperbin$x) 
	ndatalist[[npops+1]]<- nperbin$x
	fislist2[[npops+1]]	<- fisperbin$x
	# define limit:
	myylim	<- c(-0.05,max(unlist(fislist2)))
	if(myylim[2]<=0)
		{
		myylim	<- c(min(unlist(fislist2)),0.03)
		}
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Wahlund.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Wahlund.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Wahlund.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Wahlund.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	for (j in c(1:(npops+1)))
		{	
		if(j==4)
			{
			mycol		<- "black"
			myfis		<- fislist[[npops+1]]
			ndata		<- ndatalist[[npops+1]]
			}else{
			mycol		<- mysambar$mycolours[j]
			myfis		<- fislist[[j]]
			ndata		<- ndatalist[[j]]
			}
		if(j==1)
			{
			plot(myfis[ndata>100,],xlab="Locus specific maf",ylab="Locus specific Fis",xlim=c(0,1),ylim=myylim,col=mycol,type='b',lwd=3,pch=16)
			}else{
			points(myfis[ndata>100,],col=mycol,lwd=3,type='b',pch=16)
			}
		}
	abline(h=0,lty=2,lwd=1.5)
	if(addlabels)
		{
		mtext("He deficit",side=4,at=0.005,adj=0,line=0.5,cex=2)
		mtext("He excess",side=4,at=-0.005,adj=1,line=0.5,cex=2)
		}
	legend("topright",legend=c("metapop",popnames),fill=c("black",mysambar$mycolours),cex=2,bty="n")
	if(!is.null(export)){dev.off()}
	fislist<<-fislist
	}	

# Depends on StAMPP. Requires function do_heatmap. 
ind_neimatrix<-function(bin_size=0.025,export=NULL)
		{
		# First create indstemp file with all samples clustered together per population:
		mymatrixtemp		<- as.matrix(mygenlight)
		mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		indstemp			<- inds[order(inds$pop),]
		pop(mygenlighttemp)	<- as.factor(indstemp$pop)
		if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
			{
			return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
			}
		# Now do the calculation:
		# sambarfunction_findstructure:
		### PCOA analyses:
		# sambarfunction_findstructure:
		neimatrix 			<- stamppNeisD(mygenlighttemp[indstemp$filter,snps$filter],pop=FALSE)
		neimatrix[!is.finite(neimatrix)]<-NA
		mysambar$indneimatrix<<- neimatrix
		do_heatmap(export_type=export,nbins=5,mymatrix=mysambar$indneimatrix,my_inds=indstemp,my_snps=snps,my_col="orange",exportname="Neimatrix.ind",addlab=TRUE,mytitle="Nei's genetic distance")		
		do_heatmap(export_type=export,nbins=5,mymatrix=mysambar$indneimatrix,my_inds=indstemp,my_snps=snps,my_col="orange",exportname="Neimatrix.ind.withlegend",addlab=FALSE,mytitle="Nei's genetic distance")		
		}

plot_ind_neimatrix<-function(bin_size=0.025,export=NULL,add_lab=FALSE)
		{
		# First create indstemp file with all samples clustered together per population:
		if(is.null(mysambar$indneimatrix))
			{
			cat("ERROR: mysambar$indneimatrix not present. Please first run the ind_neimatrix function.",sep="\n")
			}
		indstemp			<- inds[order(inds$pop),]			
		do_heatmap(export_type=export,nbins=5,mymatrix=mysambar$indneimatrix,my_inds=indstemp,my_snps=snps,addlab=add_lab,my_col="orange",exportname="Neimatrix.ind",mytitle="Nei's genetic distance")		
		}

# phylogenetic tree
# requires the package 'Ape'
# Still need to find out how to assign the right colour codes to the tips
# Tree does not reflect population structure accurately, so decided not to use it. 
apetree<-function(mymatrix=mysambar$indneimatrix,my_inds=inds)
	{
	colnames(mymatrix)	<- my_inds$pop[my_inds$filter]
	colnames(mymatrix)	<- my_inds$pop[my_inds$filter]
	mytree				<- nj(mymatrix)
	plot(mytree,edge.color=my_inds$popcol[my_inds$filter],cex=0.5)
	}		

popprtree<-function(export=NULL,do_analysis=TRUE,mymethod="upgma",mydistance="bitwise.dist",mycolours=NULL,genofilter=FALSE,plotname="Tree",plottitle=NULL,titlecex=3,titleline=-11,labelcex=1,nodelabelcex=1,myadj=0,myfont=3,mylwd=1,mytype="phylogram",labelangle="horizontal",tiplabels=TRUE,addnodelabels=TRUE,edgecolors=TRUE,maxnodelabel=NULL,showpop=FALSE,tree_angle=0,mydirection="rightwards",silent=TRUE)
	{
	# if only one node per population:
	# mypopcolours	<- vector()
	# for(k in c(1:length(mytree$tip.label))){mypopcolours[k]<-mysambar$mycolours2[which(mysambar$populations2==mytree$tip.label[k])]}
	# Note: can be done only for heterozygous individuals. So if running for X chromosome or MT, males will be excluded. 
	#
	# type can be: "phylogram" (the default), "cladogram", "fan", "unrooted", "radial"
	if(!"poppr" %in% rownames(installed.packages()))
		{
		return(cat("ERROR: package 'poppr' not installed. Functions of these package are needed to create phylogenetic trees.",sep="\n"))
		}else{
		if("poppr" %in% (.packages()) == FALSE)
			{
			cat("Loading package 'poppr'...",sep="\n")
			library("poppr")
			}
		}
	if(!"ape" %in% rownames(installed.packages()))
		{
		return(cat("ERROR: package 'ape' not installed. Functions of these package are needed to create phylogenetic trees.",sep="\n"))
		}else{
		if("ape" %in% (.packages()) == FALSE)
			{
			cat("Loading package 'ape'...",sep="\n")
			library("ape")
			}
		}
	#
	if(!(mymethod=="upgma"|mymethod=="NJ"))
		{
		return(cat("ERROR: mymethod has to be either 'upgma' or 'NJ'.",sep="\n"))
		}
	# method can be: 'upgma' and 'NJ'
	if(!"allgeno"%in%colnames(inds))
		{
		return(cat("ERROR: columns 'inds$allgeno' missing.",sep="\n"))
		}
	if(!"allgeno2"%in%colnames(inds))
		{
		return(cat("ERROR: columns 'inds$allgeno2' missing.",sep="\n"))
		}
	if(genofilter)
		{
		cat("Not including individuals which do not possess al three genotypes (0, 1, 2).",sep="/n") 
		# We use an additional filter 'inds$allgeno'.
		# To prevent the error:
		# Error in (function (x, percent = TRUE, mat = FALSE, missing_match = TRUE,  : min(ploidy(x)) == max(ploidy(x)) is not TRUE
		# as a reminder, inds$allgeno and inds$allgeno2 are defined as follows:
		# inds$allgeno		<- inds$n0_pop>0&inds$n1_pop>0&inds$n2_pop>0
		# inds$allgeno2		<- inds$n0_pop>0&inds$n2_pop>0
		# allgeno2 is used to enable the use of haploid data or haplodiploid data (such as MT-DNA and sex chromosomal data).
		# However, in case allgeno2 returns the ploidy error, one could also try if the allgeno filter prevents the error
		myindsfilter		<- inds$filter&inds$allgeno2
		}else{
		cat("Using all individuals, also the ones which do not possess al three genotypes (0, 1, 2).",sep="\n")
		cat("If you run into an error stating 'min(ploidy(x)) == max(ploidy(x)) is not TRUE', try rerunning the popprtree function which the flag genofilter set to TRUE.",sep="\n") 
		myindsfilter	<- inds$filter
		}
	if(nrow(inds[inds$allgeno,])<3)
		{
		if(nrow(inds[inds$allgeno2,])<3)
			{
			return(cat("Less than 3 individuals which have all 3 genotypes (0,1,2) or even all only both homozygous (0,2) genotypes. Skipping tree.",sep="\n"))
			}else{
			cat("WARNING: Less than 3 individuals which have all 3 genotypes (0,1,2), but 3 or more individuals do have both homozygous (0,2) genotypes. Why are heterozygous individuals absent? Continuing anyway.",sep="\n")
			my_gl		<- mygenlight[myindsfilter,snps$filter]
			my_colours	<- inds$popcol[myindsfilter]
			}
		}else{
		my_gl			<- mygenlight[myindsfilter,snps$filter]
		my_colours		<- inds$popcol[myindsfilter]
		}
	if(!is.null(mycolours))
		{
		my_colours		<- mycolours
		}
	mypops		<- pop(my_gl)
	mypops		<- mypops
	ninds		<- length(mypops)
	mygeno		<- my_gl
	# Note: alternatively mygeno can be a distance matrix, such as neimatrix, and then mydistance should be set to 'nei.dist'
	# Other options are rogers.dist, edwards.dist, reynolds.dist
	if(do_analysis)
		{
		if(!silent){cat("Running aboot function of poppr package...",sep="\n")}
		mytree 			<- poppr::aboot(mygeno,tree=mymethod,distance=mydistance,sample=100,showtree=F,cutoff=50,quiet=F)
		mysambar$mytree	<<- mytree
		}else{
		cat("The flag 'do_analysis' is set to FALSE. Plotting tree stored at mysambar$mytree.",sep="\n")
		if(is.null(mysambar$mytree))
			{
			return(cat("ERROR: mysambar$mytree is NULL.",sep="\n"))
			}
		mytree			<- mysambar$mytree
		}
	#
	mycolors2 				<- rep("black",Nedge(mytree))
	if(edgecolors)
		{
		if(!silent){cat("Defining edge colours...",sep="\n")}
		tipindex				<- which(mytree$edge[,2]%in%c(1:ninds))
		indorder				<- mytree$edge[tipindex,2]
		mycolors2[tipindex]		<- my_colours[indorder]
		}
	#
	if(showpop)
		{
		# 16-07-2021: to plot one pop name per population rather than all sample names
		# 16-07-2021: Because plot.phylo function does not accepted duplicated sample names nor NA-values, I use this workaround:
		# not perfect, but comes close
		if(!silent){cat("Editing edge labels (because flag showpop is set to TRUE)...",sep="\n")}
		coldf			<- data.frame("pop"=mypops,"popcol"=my_colours)
		coldf$nr		<- c(1:nrow(coldf))
		coldf$bool		<- !duplicated(coldf$pop,fromLast=TRUE)
		coldf$pop2		<- ifelse(coldf$bool,as.character(coldf$pop),paste(coldf$pop,coldf$nr,sep="_"))
		coldf$popcol2	<- ifelse(coldf$bool,as.character(coldf$popcol),"white")
		mycoldf			<<- coldf
		mytree$tip.label<- coldf$pop2
		my_colours		<- coldf$popcol2
		}
	#
	# plot:
	mydistance	<- ifelse(mydistance=="bitwise.dist","Hammingdist",mydistance)
	labelstr	<- ifelse(tiplabels,"tiplabels","notiplabels")
	labelstr2	<- ifelse(addnodelabels,"nodelabels","nonodelabels")
	colorstr	<- ifelse(edgecolors,"colortips","blacktips")
	plotname	<- paste(plotname,mydistance,mymethod,mytype,labelstr,labelstr2,colorstr,sep=".")
	#cat(plotname,sep="\n")
	if(!is.null(export))
		{
		myheight	<- ifelse(mytype=="phylogram",ninds*0.15+2,14)
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=14,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=14,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=14,height=myheight)}
		}
	par(cex.axis=2)
	if(!silent){cat("Running plot.phylo function of the ape package...",sep="\n")}
	ape::plot.phylo(mytree,cex=labelcex,font=myfont,adj=0,show.tip.label=tiplabels,tip.color=my_colours,type=mytype,lab4ut=labelangle,edge.width=mylwd,node.pos=1,edge.color=mycolors2,rotate.tree=tree_angle,direction=mydirection)
	if(!is.null(mytree$node.label)&addnodelabels)
		# this are node labels (e.g. support values), not tip labels (e.g. sample names, stored at mytree$label)
		{
		if(!silent){cat("Adding node labels...",sep="\n")}
		if(!is.null(maxnodelabel))
			{
			mytree$node.label	<- ifelse(mytree$node.label>=maxnodelabel,NA,mytree$node.label)
			}
		nodelabels(mytree$node.label,adj=c(1.3,-0.5),frame="n",cex=nodelabelcex,font=3,xpd=TRUE,col="grey50")
		}
	#nodelabels(mytree$node.label,adj=c(1.3,-0.5),frame="n",cex=1,font=3,xpd=TRUE)
	#legend('topleft',legend=mysambar$populations,fill=mysambar$mycolours,bty="n",cex = 2.5)
	axis(side = 1,cex=2)
	mtext("Genetic distance",side=1,line=3,cex=2.5)
	if(!is.null(plottitle)){mtext(plottitle,side=3,line=titleline,cex=titlecex)}
	if(!is.null(export))
		{
		dev.off()
		cat("Phylogenetic plot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	#
	# export in Nexus format:
	nexusname	<- paste("Tree",mydistance,mymethod,"numbers.txt",sep=".")
	write.nexus(mytree,file=nexusname,translate=TRUE)
	nexusname	<- paste("Tree",mydistance,mymethod,"labels.txt",sep=".")
	write.nexus(mytree,file=nexusname,translate=FALSE)
	}

# 18-02-20: The function 'calc_dc' calculates what I call the the dc-score, the 'distinct clustering'-score.
# I developed this measure to enhance objective interpretation of coordination analyses (such as PCA, PCOA and CA).
# It is not uncommon to read that PCA-analyses 'clearly' reveal distinct clusters.
# The dc-score quantifies to what extent clusters overlap based on first 2 axes of PCA plot.
# The measure is very intuitive: it is the ratio between 'mean distance of samples from population mean' and the 'mean distance between populations'.
# If the dc-score is close to 0, populations cluster away from each other, and for each population sample dots are laying atop of each other.
# If the dc-score is equal or greater than 1, populations overlap.   
# The input to the function should be a matrix with sample loadings on pc-axes, for example created with the function ape_pcoa.
# Note: the dc-score does not consider consider explained variance by each ordination axis. 
calc_dc<-function(popnames=mysambar$populations,pscores=NULL,tablename=NULL,make_global=FALSE,axis_1=1,axis_2=2)
	{
	if(is.null(pscores))
		{
		return(cat("ERROR: provide matrix or dataframe with p-scores to pscore flag.",sep="\n"))
		}
	mypops			<- inds$pop[inds$filter]
	npops			<- length(popnames)
	if(npops==1)
		{
		return(cat("Only 1 population defined. Omitting calculation of dc-score.",sep="\n"))
		}
	nsamples		<- length(mypops)
	n_pcs			<- ncol(pscores)
	meanp			<- matrix(NA,nrow=n_pcs,ncol=npops)
	colnames(meanp)	<- popnames
	devp			<- matrix(NA,nrow=n_pcs,ncol=nsamples)
	meandev			<- matrix(NA,nrow=n_pcs,ncol=npops)
	colnames(meandev)<- popnames
	#
	for (pcol in c(1:n_pcs))
		{
		myp			<-	pscores[,pcol]
		# calculate mean p-scores per population:
		for (k in c(1:npops))
			{
			my_pop			<- popnames[k]
			meanp[pcol,k]	<- mean(myp[mypops==my_pop])
			}
		# calculate deviation from mean p-score per sample:
		for (m in c(1:nsamples))
			{
			my_pop		<- mypops[m]
			popnr		<- which(popnames==my_pop)
			devp[pcol,m]<- abs(myp[m]-meanp[pcol,popnr])  
			}
		# calculate mean deviation for each population:
		for (k in c(1:npops))
			{
			my_pop			<- popnames[k]
			mydev			<- devp[pcol,]			
			meandev[pcol,k]	<- mean(mydev[mypops==my_pop])
			}
		}
	if(make_global)
		{
		meanp		<<- meanp
		devp		<<- devp
		meandev		<<- meandev
		}
	#
	# calculate distance between populations for two axes:
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	pdist			<- vector()
	for (k in c(1:ncombi))
		{
		my_pop1		<- combitable[1,k]
		my_pop2		<- combitable[2,k]
		pvec1		<- meanp[c(axis_1,axis_2),which(popnames==my_pop1)] 
		pvec2		<- meanp[c(axis_1,axis_2),which(popnames==my_pop2)]
		dist1		<- abs(pvec2[1]-pvec1[1])
		dist2		<- abs(pvec2[2]-pvec1[2])
		pdist[k]	<- round(sqrt(dist1^2+dist2^2),4)
		}
	# calculate the mean distance between samples and population meanspacing
	sampledist		<- round(sqrt(devp[axis_1,]^2+devp[axis_2,]^2),4)
	sampledistmean	<- vector()
	for (k in c(1:npops))
		{
		my_pop			<- popnames[k]
		sampledistmean[k]<- mean(sampledist[mypops==my_pop])
		}
	#
	# lastly, calculate the ratio between 'sample deviation from population mean' and 'mean differentiation between populations':
	# 'distinct cluster'-score:
	dcscore		<- data.frame("pop1"=combitable[1,],"pop2"=combitable[2,],"popdist"=pdist)		
	for (k in c(1:ncombi))
		{
		my_pop1				<- as.character(dcscore$pop1[k])
		my_pop2				<- as.character(dcscore$pop2[k])
		dcscore$within1[k]	<- round(sampledistmean[which(popnames==my_pop1)],4)
		dcscore$within2[k]	<- round(sampledistmean[which(popnames==my_pop2)],4)
		dcscore$n_pop1[k]	<- length(which(mypops==my_pop1)) 
		dcscore$n_pop2[k]	<- length(which(mypops==my_pop2))
		}
	dcscore$dc1				<- round(dcscore$within1/dcscore$popdist,4) 
	dcscore$dc2				<- round(dcscore$within2/dcscore$popdist,4)
	#
	# mean dc-score:
	dcscore$meandc			<- round(mean(c(dcscore$dc1,dcscore$dc2)),4)
	dcscore$weigted_meandc	<- round(sum(dcscore$dc1*dcscore$n_pop1+dcscore$dc2*dcscore$n_pop2)/(sum(dcscore$n_pop1)+sum(dcscore$n_pop2)),4)	
	mysambar$dcscore		<<- dcscore 
	if(!is.null(tablename))
		{
		#cat(paste("Writing file '",tablename,"'. If you receive the error 'Error in file(file, ifelse(append,'a','w')): cannot open the connection', is the file perhaps open in a file viewer?",sep=""),sep="\n")
		#cat("Else, run the findstructure function with the flag do_dc set to FALSE.",sep="\n")
		write.table(dcscore,tablename,row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		}
	}

dcplot<-function(exporttype=NULL,mycex=6)
	{
	z		<- data.frame("p1"=as.numeric(as.character(c("-0.02","0.02","0.03","0.02","-0.03","-0.01"))),"p2"=as.numeric(as.character(c("-0.03","-0.03","0.03","0.02","0.03","0.01"))),"mean_p1"=as.numeric(as.character(c("0","0","0.025","0.025","-0.02","-0.02"))),"mean_p2"=as.numeric(as.character(c("-0.03","-0.03","0.025","0.025","0.02","0.02"))))
	z$col	<- c("blue","blue","darkred","darkred","darkgreen","darkgreen")
	if(!is.null(exporttype))
		{
		mywid		<- 27.5
		myhei		<- 9.5
		mywid2		<- 2000
		myhei2		<- 720
		plotname	<- "dcscore_example"
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(6,4,3,1),cex.axis=3.75)
	plot(z$p1,z$p2,xlim=c(-0.035,0.035),ylim=c(-0.035,0.035),col=z$col,xlab="",cex=mycex,ylab="",xaxt='n',pch=16)
	legend("right",legend=c("popA","popB","popC"),cex=4,bty='n',fill=c("blue","darkred","darkgreen"))
	mtext("1. ordination analysis",cex=2.5,side=3,line=0.5)
	axis(side=1,mgp=c(0,2.5,0))
	#
	plot(z$p1,z$p2,xlim=c(-0.035,0.035),ylim=c(-0.035,0.035),col=z$col,xlab="",cex=mycex,ylab="",xaxt='n',pch=16)
	points(z$mean_p1,z$mean_p2,pch=1,col=z$col,cex=mycex)
	legend("right",legend=c("popA","popB","popC"),cex=4,bty='n',fill=c("blue","darkred","darkgreen"))
	mtext("2. mean loadings per population",cex=2.5,side=3,line=0.5)
	axis(side=1,mgp=c(0,2.5,0))
	#
	plot(z$p1,z$p2,xlim=c(-0.035,0.035),ylim=c(-0.035,0.035),col=z$col,xlab="",cex=mycex,ylab="",xaxt='n',pch=16)
	points(z$mean_p1,z$mean_p2,pch=1,col=z$col,cex=mycex)
	legend("right",legend=c("popA","popB","popC"),cex=4,bty='n',fill=c("blue","darkred","darkgreen"))
	mtext("3. distances between (mean) loadings",cex=2.5,side=3,line=0.5)
	axis(side=1,mgp=c(0,2.5,0))
	arrows(x0=z$p1,y0=z$p2,x1=z$mean_p1,y1=z$mean_p2,col=z$col,length=0.25)
	arrows(x1=z$p1,y1=z$p2,x0=z$mean_p1,y0=z$mean_p2,col=z$col,length=0.25)
	#
	arrows(x0=z$mean_p1[1],y0=z$mean_p2[1],x1=z$mean_p1[3],y1=z$mean_p2[3],length=0.25)
	arrows(x0=z$mean_p1[3],y0=z$mean_p2[3],x1=z$mean_p1[1],y1=z$mean_p2[1],length=0.25)
	arrows(x0=z$mean_p1[1],y0=z$mean_p2[1],x1=z$mean_p1[5],y1=z$mean_p2[5],length=0.25)
	arrows(x0=z$mean_p1[5],y0=z$mean_p2[5],x1=z$mean_p1[1],y1=z$mean_p2[1],length=0.25)
	arrows(x0=z$mean_p1[3],y0=z$mean_p2[3],x1=z$mean_p1[5],y1=z$mean_p2[5],length=0.25)
	arrows(x0=z$mean_p1[5],y0=z$mean_p2[5],x1=z$mean_p1[3],y1=z$mean_p2[3],length=0.25)
	mtext("axis1",side=1,line=3.5,cex=3,outer=TRUE)
	mtext("axis2",side=2,line=0.5,cex=3,outer=TRUE)
	if(!is.null(exporttype)){dev.off()}
	}

ape_pcoa_pop<-function(popnames=mysambar$populations,exporttype="pdf",my_method="hamming",silent=TRUE)
	{
	if(length(popnames)>1)
		{
		for (my_pop in popnames)
			{
			if(!silent){cat(my_pop,sep="\n")}
			npopind	<- nrow(inds[inds$pop==my_pop&inds$filter,])
			if(npopind<3)
				{
				if(!silent){cat("Less than 3 retained individuals. Omitting population specific pcoa plot.",sep="\n")}
				}else{
				ape_pcoa(indselection=inds$filter&inds$pop==my_pop,method=my_method,printname=inds$name,export=exporttype,label_size=1,labels=TRUE,addlegend=FALSE,exportname=my_pop,dodc=FALSE)
				if(any(as.vector(inds$pop2)!=as.vector(inds$pop)))
					{
					ape_pcoa(indselection=inds$filter&inds$pop==my_pop,use_symboltype2=TRUE,symbolsize=3,method=my_method,printname=inds$name,export=exporttype,labels=FALSE,addlegend=TRUE,exportname=my_pop,dodc=FALSE)
					}else{
					ape_pcoa(indselection=inds$filter&inds$pop==my_pop,use_symboltype2=FALSE,symbolsize=3,method=my_method,printname=inds$name,export=exporttype,labels=TRUE,addlegend=TRUE,exportname=my_pop,dodc=FALSE)
					}
				}
			}
		cat("Population specific pcoa plots have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}else{
		cat("Currently only 1 population defined. Omitting population specific pcoa plots.",sep="\n")
		}
	}

# PCoA: Principal Coordinates Analysis (NOTE: this is different from principal component analysis or PCA). Depends on StAMPP (Nei's genetic distance) and Ape (pcoa):
# ape_pcoa(method="hamming",symbolkey="sex",legendpos="topleft")
ape_pcoa<-function(pscores=NULL,axis1=1,axis2=2,doplot=TRUE,dodc=TRUE,do_mirror=c(FALSE,FALSE),indselection=inds$filter,snpselection=snps$filter,colourcode=inds$popcol,popcolours=mysambar$mycolours,labcex=3,axiscex=2,axisdistance=NULL,labeldistance=3.75,ylabeldistance=3.75,method="nei",export=NULL,exportname=NULL,popnames=mysambar$populations,symbolkey=NULL,use_symboltype2=FALSE,mar1=5,mar2=6.5,mar3=3.5,symbolsize=2.5,addlegend=TRUE,legendpos="bottomright",legendcex=3,mylegend=NULL,mylegendcol=NULL,mylegendtitle=NULL,addtitle=NULL,title_cex=NULL,titledistance=1,labels=FALSE,label_size=0.75,printname=NULL,printpop2=FALSE,missvector=NULL,resetgraphics=TRUE,silent=TRUE,makeglobal=FALSE,return_object=FALSE,addbox=TRUE,shuffle_par=NULL,addxy=FALSE)
	{
	# method can be "nei" (Nei's genetic distance D), "hamming" (Hamming's genetic distance), "euclidean", or "pi".
	# Note: snpselection and indselection can not be applied when running method 'pi'. You should use calcpi() function to recalculate pi on different snp dataset.
	# Note: symbol size will be 0.75 for labels (irrespective of settings), to avoid overlap. 
	# Note: legend will not be displayed when only one population is defined, irrespective of settings.
	#
	if(!is.null(symbolkey))
		{
		if(any(symbolkey%in%colnames(inds)))
			{
			symbolkeyvec	<- inds[,symbolkey]
			}else{
			return(cat("ERROR: Symbolkey not present as column name in inds dataframe.",sep="\n"))
			}
		if(length(unique(symbolkeyvec[indselection]))>13)
			{
			return(cat("ERROR: Symbolkey contains more than 13 levels. Currently not supported by SambaR.",sep="\n"))
			}
		}
	npops			<- length(popnames)
	#
	if(is.null(pscores))
		{
		if(!silent){cat("Running pcoa analyses...",sep="\n")}
		if(method=="nei")
			{
			if(!silent){cat("Generating distance matrix based on Nei's D...",sep="\n")}
			# sambarfunction_findstructure:
			neimatrix 		<- StAMPP::stamppNeisD(mygenlight[indselection,snpselection],pop=FALSE)
			if(!silent){neimatrix	<<- neimatrix}
			if(any(is.na(neimatrix)))
				{
				mysambar$pcoa_error	<<- TRUE
				return(cat("ERROR: Pcoa plot can not be generated due to missing data in neimatrix.",sep="\n"))
				}else{
				mysambar$pcoa_error	<<- FALSE
				}
			if(any(is.infinite(neimatrix)))
				{
				return(cat("ERROR: Pcoa plot can not be generated due to infinite values in neimatrix.",sep="\n"))
				}
			# sambarfunction_findstructure:
			p 				<- ape::pcoa(neimatrix, correction="none", rn=NULL)
			if(makeglobal)
				{
				mymatrix	<<- neimatrix
				p			<<- p
				}
			}
		if(method=="hamming")
			{
			ploidy(mygenlight)<-2
			if(!silent){cat("Generating distance matrix based on Hammings genetic distance...",sep="\n")}
			# sambarfunction_findstructure:
			hammingmatrix	<- poppr::bitwise.dist(mygenlight[indselection,snpselection],mat=TRUE,euclidean=FALSE)
			if(any(is.na(hammingmatrix)))
				{
				mysambar$pcoa_error	<<- TRUE
				return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
				}else{
				mysambar$pcoa_error	<<- FALSE
				}
			# sambarfunction_findstructure:
			p 				<- ape::pcoa(hammingmatrix, correction="none", rn=NULL)
			if(makeglobal)
				{
				mymatrix	<<- hammingmatrix
				p			<<- p
				}
			}
		if(method=="euclidean")
			{
			eucmatrix		<- poppr::bitwise.dist(mygenlight[indselection,snpselection],mat=TRUE,euclidean=TRUE)
			if(any(is.na(eucmatrix)))
				{
				mysambar$pcoa_error	<<- TRUE
				return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
				}else{
				mysambar$pcoa_error	<<- FALSE
				}
			# sambarfunction_findstructure:
			p 				<- ape::pcoa(eucmatrix, correction="none", rn=NULL)
			if(makeglobal)
				{
				mymatrix	<<- eucmatrix
				p			<<- p
				}
			}
		if(method=="pi")
			{
			# pimatrix is generated with calcpi
			if(is.null(mysambar$tajdlist_meta[[1]]))
				{
				cat("Pairwise distances list not present. Generating now...",sep="\n")
				#sambarfunction_findstructure
				calcpi(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE)
				}
			#sambarfunction_findstructure
			pidf			<- mysambar$tajdlist_meta[[1]]
			if(!silent){cat("Converting from dataframe to matrix...",sep="\n")}
			#sambarfunction_findstructure
			pimatrix		<- pidf2matrix(pidf=mysambar$tajdlist_meta[[1]],myinds=inds$nr[inds$filter])
			if(any(is.na(pimatrix)))
				{
				mysambar$pcoa_error	<<- TRUE
				return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
				}else{
				mysambar$pcoa_error	<<- FALSE
				}
			if(!silent){cat("Executing pcoa analyses...",sep="\n")}
			# sambarfunction_findstructure:
			if(!silent){pimatrix	<<- pimatrix}
			p 				<- ape::pcoa(pimatrix, correction="none", rn=NULL)	
			if(makeglobal)
				{
				mymatrix	<<- pimatrix
				p			<<- p
				}
			# 15-11-2019: untraceable error when running the function above: Error in array(STATS, dims[perm]) : 'dims' cannot be of length 0
			# 26-01-2020: another untraceable error when running the function above: 
			# Error in data.frame(eig[1:k], rel.eig, rel.eig.cor, bs, cum.eig.cor, cum.bs) : 
			# arguments imply differing number of rows: 90, 92
			# In addition: Warning message:
			# In sqrt(eig[1:k2]) : NaNs produced
			}
		}else{
		cat("Plotting p-scores provided to pscores flag...",sep="\n")
		p	<- pscores
		}
	#
	if(doplot)
		{
		myp1	<- p$vectors[,axis1]
		myp2	<- p$vectors[,axis2]
		if(!is.null(shuffle_par))
			{
			myp1	<- myp1+shuffle_par*runif(length(myp1))
			myp2	<- myp2+shuffle_par*runif(length(myp2))
			}
		if(do_mirror[1])
			{
			cat("Mirror image of axis1.",sep="\n")
			myp1	<- -myp1
			}
		if(do_mirror[2])
			{
			cat("Mirror image of axis2.",sep="\n")
			myp2	<- -myp2
			}	
		if(!silent){cat("Finished pcoa analyses. Plotting...",sep="\n")}
		if(!is.null(export))
			{
			if(resetgraphics){graphics.off()}
			setwd(mysambar$structuredir)
			my_symbol	<- ifelse(labels,ifelse(is.null(missvector),"labels","missingness"),ifelse(is.null(symbolkey),ifelse(use_symboltype2,"symboltype2","dots"),symbolkey))
			if(is.null(exportname))
				{
				myplotname	<- paste("pcoa",method,paste("PC",axis1,"vs",axis2,sep=""),my_symbol,sep=".")
				}else{
				myplotname	<- paste("pcoa",exportname,method,paste("PC",axis1,"vs",axis2,sep=""),my_symbol,sep=".")
				}
			if(export=="eps"){postscript(paste(myplotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf(paste(myplotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png(paste(myplotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(myplotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
			}
		# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
		par(mar=c(mar1,mar2,mar3,1),cex.axis=axiscex,cex.main=3.5)
		#plot(myp1,myp2,xlab=paste("PC",axis1," (",round(p$values$Relative_eig[axis1]*100,1),"%)",sep=""),ylab=paste("PC",axis2," (",round(p$values$Relative_eig[axis2]*100,1),"%)",sep=""),col="white",frame=FALSE)
		if(is.null(axisdistance))
			{
			plot(myp1,myp2,xlab="",ylab="",col="white",frame=FALSE)
			}else{
			if(axisdistance>=0)
				{
				plot(myp1,myp2,xlab="",ylab="",col="white",frame=FALSE,xaxt='n')
				axis(side=1,mgp=c(0,axisdistance,0),cex=axiscex)
				}else{
				plot(myp1,myp2,xlab="",ylab="",col="white",frame=FALSE,xaxt='n',yaxt='n')
				box(which="plot")
				}
			}
		myxlab	<- paste("PC",axis1," (",round(p$values$Relative_eig[axis1]*100,1),"%)",sep="")
		myylab	<- paste("PC",axis2," (",round(p$values$Relative_eig[axis2]*100,1),"%)",sep="")
		mtext(myxlab,side=1,line=labeldistance,cex=labcex)
		mtext(myylab,side=2,line=ylabeldistance,cex=labcex)
		if(addxy)
			{
			abline(h=0,col="grey95")
			abline(v=0,col="grey95")
			}
		if(labels==TRUE)
			{
			if(!is.null(missvector))
				{
				text(myp1,myp2,round(missvector[indselection],4),col=colourcode[indselection],cex=label_size)
				}else{
				if(!is.null(printname))
					{
					text(myp1,myp2,printname[indselection],col=colourcode[indselection],cex=label_size)
					}else{
					text(myp1,myp2,inds$nr[indselection],col=colourcode[indselection],cex=0.75)
					}
				}
			}else{
			if(use_symboltype2)
				{
				points(myp1,myp2,col=colourcode[indselection],pch=as.vector(inds$symboltype2[indselection]),cex=symbolsize)
				}else{
				if(is.null(symbolkey))
					{
					points(myp1,myp2,col=colourcode[indselection],pch=16,cex=symbolsize)
					}else{
					symbolvector	<- c(16,17,18,20,15,0,1,2,6,3,4,5,8)
					mypch			<<- symbolvector[as.factor(symbolkeyvec)]
					points(myp1,myp2,col=colourcode[indselection],pch=mypch[indselection],cex=symbolsize)
					}
				}
			}
		if(!is.null(mylegend)&!is.null(mylegendcol))
			{
			legend(legendpos,mylegend,fill=mylegendcol,bty="n",border=mylegendcol,cex=legendcex,title=mylegendtitle)
			}
		if(addlegend==TRUE&npops>1)
			{
			mypopcols	<- popcolours[1:npops]
			if(!is.null(symbolkey))
				{
				symbolvector	<- c(16,17,18,20,15,0,1,2,6,3,4,5,8)
				mypch			<<- symbolvector[as.factor(symbolkeyvec)]
				legendpch		<- unique(mypch[!is.na(mypch)])
				legendkey		<- unique(symbolkeyvec[!is.na(symbolkeyvec)])
				legend(legendpos,legend=legendkey,pch=legendpch,bty="n",cex=legendcex)
				}else{
				if(use_symboltype2)
					{
					#legendpch		<- unique(as.vector(inds$symboltype2[indselection]))
					#legendkey		<- unique(as.vector(inds$pop2[indselection]))
					#legendpch		<- legendpch[order(legendkey)]
					#legendkey		<- legendkey[order(legendkey)]
					#pop_col		<- unique(as.vector(inds$popcol[indselection]))
					#legend(legendpos,legend=legendkey,pch=legendpch,bty="n",cex=legendcex,col=pop_col)
					legend(legendpos,popnames,fill=mypopcols,bty="n",cex=legendcex,border=mypopcols)
					}else{
					legend(legendpos,popnames,fill=mypopcols,bty="n",cex=legendcex,border=mypopcols)
					}
				}
			}
		if(!is.null(addtitle))
			{
			if(is.null(title_cex))
				{
				#cat("No titlecex.",sep="\n")
				title(main=addtitle,line=titledistance)
				}else{
				#cat("Title cex specified.")
				title(main=addtitle,line=titledistance,cex.main=title_cex)
				#mtext(addtitle,side=3,line=titledistance,cex=title_cex)
				}
			}
		if(addbox)
			{
			box(which="plot")
			}
		if(!is.null(export))
			{
			dev.off()
			if(!is.null(symbolkey))
				{
				path1<- paste(getwd())
				cat(paste("PCoA-plot has been written to: ", paste(path1,(paste("pcoa",method,my_symbol,sep=".")),sep="/"), sep =""),sep="\n")
				}
			}
		}
	if(dodc)
		{
		# calculate 'distinct clustering' score
		if(!is.null(export))
			{
			if(npops>1)
				{
				calc_dc(popnames=mysambar$populations,pscores=p$vectors,axis_1=axis1,axis_2=axis2,tablename=paste(myplotname,paste("axis",axis1,"vs",axis2,sep=""),"dc_score.txt",sep="."))
				}
			}
		}
	if(return_object)
		{
		return(p)
		}
	}
	

# This function is to create pcoa plots with different small subsets.
# The function is different from 'multiplot_pcoa' (see below)
plotmulti_pcoa<-function(export=NULL,mymethod="nei",nloci=c(500,375,250,125),randomsubset=TRUE,do_legend=TRUE,poslegend="bottomright",cex_legend=4,silent=TRUE,size_symbol=4,no_fixed=TRUE,no_miss=TRUE,dodc=TRUE)
	{
	if(!silent&randomsubset){cat("Creating PCoA plots using subsets of randomly selected SNPs...",sep="\n")}
	if(!silent&!randomsubset){cat("Creating PCoA plots using subsets of SNPs with highest standard deviation of minor allele frequencies...",sep="\n")}
	setwd(mysambar$structuredir)
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	nsnps		<- nrow(snps[snps$filter,])
	if(any(nloci>nsnps))
		{
		return(cat(paste("ERROR: Number of retained SNPs (",nsnps,") is below specified subset size.",sep=""),sep="\n")) 
		}
	mynumbers	<- c(1:nrow(snps))
	if(!randomsubset)
		{
		if(!"sd_popmaf"%in%colnames(snps))
			{
			return(cat("ERROR: SambaR couldn't find column called 'sd_popmaf' in snps dataframe. Rerun the filterdata function, or set the flag randomsubset to TRUE.",sep="\n"))
			}
		if(length(mysambar$populations)==1)
			{
			return(cat("Currently 1 population defined. Impossible to selection loci with highest variation in MAF among populations. Omitting 'multi_pcoa.highest_sd_maf' plot.",sep="\n"))
			}
		if(!silent){cat("Setting filter...",sep="\n")}
		popmafs 				<- snps[,grep("maf_",colnames(snps))]
		mafmin					<- apply(popmafs,1,min)
		nodatavec				<- !is.na(rowSums(popmafs))
		mysd					<- snps$sd_popmaf
		if(no_fixed)
			{
			fixedfilter			<- mafmin>0
			}else{
			fixedfilter			<- rep(TRUE,nrow(snps))
			}
		if(no_miss)
			{
			missfilter			<- nodatavec
			}else{
			missfilter			<- rep(TRUE,nrow(snps))
			}
		myfilter			<- snps$filter&fixedfilter&missfilter&is.finite(mysd)&!is.na(mysd)
		if(!silent){cat("Applying filter...",sep="\n")}
		mysd					<- mysd[myfilter]
		snpsfiltered			<- snps[myfilter,]
		snpstemp				<- snpsfiltered[order(-mysd),]
		if(length(mysd)<max(nloci))
			{
			return(cat("Low number of retained SNPs with minor allele present in all populations. Omitting 'multi_pcoa.highest_sd_maf' plot.",sep="\n")) 
			}
		}
	myselectionlist	<- list()
	if(!is.null(export))
		{
		mylabel		<- ifelse(randomsubset,paste(mymethod,"randomsubset",sep="."),paste(mymethod,"highest_sd_maf",sep="."))
		mylabel2	<- paste(max(nloci),"snps",sep="")
		mylabel3	<- ifelse(randomsubset,"with_fixed",ifelse(no_fixed,"no_fixed","with_fixed"))
		mylabel4	<- ifelse(randomsubset,"with_miss",ifelse(no_miss,"no_miss","with_miss"))
		legendlabel	<- ifelse(do_legend,"withlegend","nolegend")
		if(export=="pdf"){pdf(paste("multi_pcoa",mylabel,mylabel2,mylabel3,mylabel4,legendlabel,"pdf",sep="."),height=18,width=18)}
		}
	par(mfrow=c(2,2))
	for(n_subset in nloci)
		{
		if(!silent){cat(n_subset,sep="\n")}
		if(randomsubset)
			{
			mydraw		<- sample(mynumbers[snps$filter],n_subset)
			myselection	<- mynumbers%in%mydraw
			}else{
			snpsubset	<- head(snpstemp,n_subset)
			thres		<- min(snpsubset$sd_popmaf,na.rm=TRUE)
			myselection	<- snps$sd_popmaf>=thres&myfilter
			myselection	<<- myselection
			# add to SNPs dataframe:
			myselectionlist[[n_subset]]	<- myselection
			snps$mafSDtop				<<- myselection
			names(snps)[which(names(snps)=="mafSDtop")]	<<- paste("mafSDtop",n_subset,sep="")
			snps 						<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
			}
		# create plot:
		add_legend		<- ifelse(n_subset==nloci[1],ifelse(do_legend,TRUE,FALSE),FALSE)
		ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=add_legend,legendpos=poslegend,makeglobal=TRUE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
		if(!mysambar$pcoa_error&dodc)
			{
			mtext(paste(n_subset," snps",sep=""),cex=3)
			#cat("Calculating dc_scores...",sep="\n")
			calc_dc(popnames=mysambar$populations,pscores=p$vectors,axis_1=1,axis_2=2,tablename=NULL)
			if(length(mysambar$populations)>1)
				{
				mtext(text=paste("dc = ",round(mysambar$dcscore$meandc[1],2),sep=""),side=3,cex=2.75,line=-2.5)
				}
			}
		}
	if(!is.null(export)){dev.off()}
	#
	if(mymethod=="hamming"&!randomsubset)
		{
		setwd(mysambar$inputfilesdir)
		for(n_subset in nloci)
			{
			plot_name	<- paste("metapop.highest_popmafsd",paste(n_subset,"SNPS",sep=""),mymethod,mylabel3,mylabel4,"number",sep=".")
			genlight2ped(snpsfilter=myselection,indsfilter=inds$filter,exportname=plot_name,quiet=TRUE) 		
			plot_name	<- paste("metapop.highest_popmafsd",paste(n_subset,"SNPS",sep=""),mymethod,mylabel3,mylabel4,"letter",sep=".")
			genlight2ped(snpsfilter=myselection,indsfilter=inds$filter,exportname=plot_name,quiet=TRUE,genonumber=FALSE) 
			}
		setwd(mysambar$structuredir)
		}
	}

# This script is to create pcoa plots with different filter settings.
# The function is different from 'plotmulti_pcoa' (see above)
multiplot_pcoa<-function(exporttype=NULL,mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=FALSE,poslegend="center",cex_legend=4,size_symbol=4,maxmiss=0.01)
	{
	my_plist	<- list()
	mypnames	<- vector()
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(dolabels)
			{
			plotname	<- ifelse(print_miss,paste("pcoa_multi",mymethod,"proportion.missingdata",sep="."),paste("pcoa_multi",mymethod,"label",sep="."))
			}else{
			plotname	<- paste("pcoa_multi",mymethod,sep=".")
			}
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(4,4,3,1),cex.axis=3.75)
	nsnps		<- nrow(snps[snps$filter,])
	mynumbers	<- c(1:nrow(snps))
	# no filter:
	if(print_miss)
		{
		indsmissingness(max_miss=maxmiss)	# calculate inds$miss3
		miss_vector1	<- inds$miss
		miss_vector2	<- inds$miss2
		miss_vector3	<- inds$miss3
		}else{
		miss_vector1	<- NULL
		miss_vector2	<- NULL
		miss_vector3	<- NULL
		}
	# all snps:
	p_apepcoa			<- ape_pcoa(return_object=TRUE,snpselection=rep(TRUE,nsnps),labcex=2.75,labels=dolabels,missvector=miss_vector1,axiscex=3,axisdistance=2,labeldistance=5.5,method=mymethod,resetgraphics=FALSE,addlegend=dolegend,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	my_plist[[1]]		<- p_apepcoa
	mymax				<- round(max(snps$miss,na.rm=TRUE),2)
	nretained			<- nrow(snps) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mypnames[1]			<- paste("miss",mymax,sep="")
	# current filter settings:
	p_apepcoa			<- ape_pcoa(return_object=TRUE,snpselection=snps$filter,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector2,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	my_plist[[2]]		<- p_apepcoa
	mymax				<- round(max(snps$miss[snps$filter],na.rm=TRUE),2)
	nretained			<- nrow(snps[snps$filter,]) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mypnames[2]			<- paste("miss",mymax,sep="")
	# 
	p_apepcoa			<- ape_pcoa(return_object=TRUE,snpselection=snps$miss<=maxmiss,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector3,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	my_plist[[3]]		<- p_apepcoa
	nretained			<- nrow(snps[snps$miss<=maxmiss,])
	mtext(paste(nretained," SNPs, max ", maxmiss, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mypnames[3]			<- paste("miss",maxmiss,sep="")
	if(!is.null(exporttype)){dev.off()}
	mysambar$plist		<<- my_plist
	mysambar$pnames		<<- mypnames
	}

# This script is to create combined pcoa plots for different axis combinations
# The function is different from 'plotmulti_pcoa' (see above)
multiplot_pcoa_axes<-function(exporttype=NULL,my_legend=NULL,my_legendcol=NULL,exportname=NULL,mymethod="hamming",cex_lab=2.75,dolabels=FALSE,print_miss=FALSE,print_name=NULL,dolegend=TRUE,poslegend="bottom",cex_legend=3,size_symbol=4,size_label=2.5,maxmiss=0.01,myaxes=c(1,2,1,3,2,3),mirroraxis=c(rep(FALSE,6)),use_symbol2=FALSE)
	{
	setwd(mysambar$structuredir)
	#my_plist	<<- list()
	#mypnames	<<- vector()
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(is.null(exportname))
			{
			exportname		<- "pcoa_multi_axes"
			}else{
			exportname		<- paste(exportname,"pcoa_multi_axes",sep=".")
			}
		if(dolabels)
			{
			plotname	<- ifelse(print_miss,paste(exportname,mymethod,"proportion.missingdata",sep="."),paste(exportname,mymethod,"label",sep="."))
			}else{
			plotname	<- paste(exportname,mymethod,sep=".")
			}
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(4,4,3,1),cex.axis=3.75)
	boolmirror1	<- mirroraxis[1:2]
	boolmirror2 <- mirroraxis[3:4]
	boolmirror3 <- mirroraxis[5:6]
	if(!print_miss)
		{
		mymissvector	<- NULL
		}else{
		mymissvector	<- inds$miss
		}
	if(is.null(my_legend)&is.null(my_legendcol))
		{
		ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[1],axis2=myaxes[2],do_mirror=boolmirror1,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,addlegend=dolegend,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
		}else{
		ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[1],axis2=myaxes[2],do_mirror=boolmirror1,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=FALSE,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
		}
	mtext("PC1 vs PC2",side=3,cex=2.75,line=0.5)
	ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[3],axis2=myaxes[4],do_mirror=boolmirror2,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	mtext("PC1 vs PC3",side=3,cex=2.75,line=0.5)
	ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[5],axis2=myaxes[6],do_mirror=boolmirror3,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	mtext("PC2 vs PC3",side=3,cex=2.75,line=0.5)
	if(!is.null(exporttype)){dev.off()}
	}

# This script is to create pcoa plots with all individuals, and as many SNPs as possible.
# The function is different from 'plotmulti_pcoa' (see above)
pcoa_allinds<-function(exporttype=NULL,mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=FALSE,poslegend="center",cex_legend=4,size_symbol=4)
	{
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(dolabels)
			{
			plotname	<- ifelse(print_miss,paste("pcoa_multi_allinds",mymethod,"missingdata",sep="."),paste("pcoa_multi_allinds",mymethod,"label",sep="."))
			}else{
			plotname	<- paste("pcoa_multi_allinds",mymethod,sep=".")
			}
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(4,4,3,1),cex.axis=3.75)
	nr_inds		<- nrow(inds)
	nsnps		<- nrow(snps[snps$filter,])
	mynumbers	<- c(1:nrow(snps))
	# no filter:
	if(print_miss)
		{
		miss_vector1	<- inds$miss
		miss_vector2	<- inds$miss2
		}else{
		miss_vector1	<- NULL
		miss_vector2	<- NULL
		miss_vector3	<- NULL
		}
	#
	# all snps:
	my_selection		<- rep(TRUE,nrow(snps))
	ape_pcoa(indselection=rep(TRUE,nr_inds),snpselection=my_selection,labcex=2.75,labels=dolabels,missvector=miss_vector1,axiscex=3,axisdistance=2,labeldistance=5.5,method=mymethod,resetgraphics=FALSE,addlegend=dolegend,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	nretained			<- nrow(snps) 
	mtext(paste("all ",nretained," SNPs",sep=""),side=3,cex=2.75,line=0.5)
	#
	# current filter settings:
	ape_pcoa(indselection=rep(TRUE,nr_inds),snpselection=snps$filter,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector2,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	nretained			<- nrow(snps[snps$filter,]) 
	mtext(paste("retained ",nretained," SNPs",sep=""),side=3,cex=2.75,line=0.5)
	#
	# ~1000 SNPs with least missing data:
	if(nrow(snps[snps$hefilter,])>1000)
		{
		snpprop		<- 1000/nrow(snps[snps$hefilter,])
		}else{
		snpprop		<- 1
		}
	mythres		<- quantile(snps$miss2[snps$hefilter],snpprop)
	my_selection<- snps$miss2<=mythres&snps$hefilter
	#
	if(print_miss)
		{
		mat 		<- as.matrix(mygenlight[,my_selection])
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		miss_vector3<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		}
	nretained			<- length(my_selection[my_selection])		
	ape_pcoa(indselection=rep(TRUE,nr_inds),snpselection=my_selection,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector3,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	mtext(paste(nretained," highest quality SNPs",sep=""),side=3,cex=2.75,line=0.5)
	if(!is.null(exporttype)){dev.off()}
	}

plotmiss_vs_p<-function(mymethod="hamming",exporttype="pdf")
	{
	for(j in c(1:3))
		{
		if(!is.null(exporttype))
			{
			mywid		<- 27.5
			myhei		<- 9.5
			mywid2		<- 2000
			myhei2		<- 720
			mydataset	<- ifelse(j==1,mysambar$pnames[1],ifelse(j==2,mysambar$pnames[2],mysambar$pnames[3])) 
			plotname	<- paste("pcoa",mymethod,"miss_pcscore",mydataset,sep=".")
			if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
			if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
			if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
			}
		par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(6,4,3,1),cex.axis=3.75)
		xx	<- inds$miss[inds$filter]
		plot(xx,mysambar$plist[[j]]$vectors[,1],col=inds$popcol[inds$filter],xlab="",ylab="",pch=16,cex=4,xaxt='n')
		mtext("PC 1",cex=2.5,side=3,line=0.5)
		axis(side=1,mgp=c(0,2.5,0))
		plot(xx,mysambar$plist[[j]]$vectors[,2],col=inds$popcol[inds$filter],xlab="",ylab="",pch=16,cex=4,xaxt='n')
		mtext("PC 2",cex=2.5,side=3,line=0.5)
		axis(side=1,mgp=c(0,2.5,0))
		plot(xx,mysambar$plist[[j]]$vectors[,3],col=inds$popcol[inds$filter],xlab="",ylab="",pch=16,cex=4,xaxt='n')
		mtext("PC 3",cex=2.5,side=3,line=0.5)
		axis(side=1,mgp=c(0,2.5,0))
		mtext("Proportion missing data",side=1,line=4,cex=3,outer=TRUE)
		mtext("PC score",side=2,line=0.5,cex=3,outer=TRUE)
		if(!is.null(exporttype)){dev.off()}
		}
	}

# Depends on package SNPRelate
# Note, if you didn't close the genofile before calling it again, you will get this ERROR: ERROR in file(filename, "wb") : cannot open the connection
# In addition: Warning message: # In file(filename, "wb") : cannot open file 'my.gds': Permission denied
multisnprelate_pca<-function(dolabels=FALSE,exporttype=NULL,dolegend=TRUE,poslegend="right",cex_legend=4,size_symbol=2.75,maxmiss=0.01)
	{
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(dolabels)
			{
			if(exporttype=="eps"){postscript("pca.snprelate_multi.labels.eps",family=mysambar$myfont,width=mywid,height=myhei)}	# 10.5 instead of 10 because otherwise some labels are missing
			if(exporttype=="pdf"){pdf("pca.snprelate_multi.labels.pdf",family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="png"){png("pca.snprelate_multi.labels.png",family=mysambar$myfont,width=mywid2,height=myhei2)}
			if(exporttype=="wmf"){win.metafile("pca.snprelate_multi.labels.wmf",family=mysambar$myfont,width=mywid,height=myhei)}
			}else{
			if(exporttype=="eps"){postscript("pca.snprelate_multi.eps",family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="pdf"){pdf("pca.snprelate_multi.pdf",family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="png"){png("pca.snprelate_multi.png",family=mysambar$myfont,width=mywid2,height=myhei)}
			if(exporttype=="wmf"){win.metafile("pca.snprelate_multi.wmf",family=mysambar$myfont,width=mywid,height=myhei)}
			}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(6,4,3,1),cex.axis=3.75)
	# no filter:
	snprelate_pca(export=NULL,resetgraphics=FALSE,addaxislabel=FALSE,snpsfilter=rep(TRUE,nrow(snps)),addlegend=dolegend,labels=dolabels,legendpos=poslegend,legendcex=cex_legend,symbolsize=size_symbol,dodc=FALSE)	
	mymax			<- round(max(snps$miss,na.rm=TRUE),2)
	nretained		<- nrow(snps) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	# current filter settings:
	snprelate_pca(export=NULL,resetgraphics=FALSE,addaxislabel=FALSE,snpsfilter=snps$filter,addlegend=FALSE,labels=dolabels,legendpos=poslegend,legendcex=cex_legend,symbolsize=size_symbol,dodc=FALSE)	
	mymax			<- round(max(snps$miss[snps$filter],na.rm=TRUE),2)
	nretained		<- nrow(snps[snps$miss<=mymax,]) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	# strict filter (max %1 missing data): 
	snprelate_pca(export=NULL,resetgraphics=FALSE,addaxislabel=FALSE,snpsfilter=(snps$miss<=0.01),addlegend=FALSE,labels=dolabels,legendpos=poslegend,legendcex=cex_legend,symbolsize=size_symbol,dodc=FALSE)	
	nretained		<- nrow(snps[snps$miss<=maxmiss,])
	mtext(paste(nretained," SNPs, max ", maxmiss, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mtext("Eigenvector 1",side=1,line=4,cex=3,outer=TRUE)
	mtext("Eigenvector 2",side=2,line=0.5,cex=3,outer=TRUE)
	if(!is.null(exporttype)){dev.off()}
	}

snprelate_pca<-function(chrom=FALSE,resetgraphics=TRUE,axis1=1,axis2=2,indsfilter=inds$filter,snpsfilter=snps$filter,export=NULL,exportname="pca.snprelate",plottitle=NULL,symbolsize=5,labels=FALSE,addaxislabel=TRUE,addlegend=TRUE,legendpos="right",popnames=mysambar$populations,popcolours=mysambar$colorder,symboltype=16,legendcex=3,dodc=TRUE)
	{
	mymatrix	<- as.matrix(mygenlight[indsfilter,snpsfilter])
	mypops		<- as.factor(inds$pop[indsfilter]) 
	mypopcolours<- inds$popcol[indsfilter]
	if(chrom)
		{
		# sambarfunction_findstructure:
		### PCA analyses (SNPrelate):
		# sambarfunction_findstructure:
		snpgdsCreateGeno("my.gds",snpfirstdim=FALSE,genmat=mymatrix,sample.id=inds$name[indsfilter],snp.id=snps$name[snpsfilter],snp.chromosome=snps$chr[snpsfilter],snp.position = snps$position[snpsfilter])
		}else{
		snpgdsCreateGeno("my.gds",snpfirstdim=FALSE,genmat=mymatrix,sample.id=inds$name[indsfilter],snp.id=snps$name[snpsfilter],snp.chromosome=rep(1,length(snps$name[snpsfilter])),snp.position = snps$position[snpsfilter])
		}
	# sambarfunction_findstructure:
	genofile 	<- snpgdsOpen("my.gds")
	# sambarfunction_findstructure:
	pca 		<- snpgdsPCA(genofile)
	# sambarfunction_findstructure:
	sample.id 	<- read.gdsn(index.gdsn(genofile, "sample.id"))
	npops		<- length(popnames)
	pcadata 	<- data.frame(sample.id = pca$sample.id,pop=factor(mypops)[match(pca$sample.id,sample.id)],EV1 = pca$eigenvect[,axis1],EV2 = pca$eigenvect[,axis2],stringsAsFactors = FALSE)
	pcadata$col	<- mypopcolours
	# sambarfunction_findstructure:
	snpgdsClose(genofile)
	if(resetgraphics)
		{
		graphics.off()
		if(!is.null(export))
			{
			exportname		<- paste(exportname,paste(axis1,"vs",axis2,sep=""),sep=".")
			if(labels)
				{
				exportname	<- paste(exportname,"labels",sep=".")
				if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}	# 10.5 instead of 10 because otherwise some labels are missing
				if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				}else{
				if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				}
			}
		par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
		}
	# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
	# 28-09-2021: replaced following line:
	# mycols		<- mysambar$mycolours[1:npops]
	mycols			<- popcolours
	if(addaxislabel)
		{
		plot(pcadata$EV1,pcadata$EV2,pch=16,col="white",xlab="",ylab="",cex=symbolsize)
		#mtext("eigenvector 1",side=1,line=3.5,cex=3.5)
		#mtext("eigenvector 2",side=2,line=3.5,cex=3.5)
		mtext(paste("Dim ",axis1," (",round(100*pca$varprop[axis1],1)," %)",sep=""),side=1,line=3.5,cex=3.5)
		mtext(paste("Dim ",axis2," (",round(100*pca$varprop[axis2],1)," %)",sep=""),side=2,line=3.5,cex=3.5)
		}else{
		plot(pcadata$EV1,pcadata$EV2,pch=16,col="white",xlab="",ylab="",cex=symbolsize,xaxt='n')
		axis(side=1,mgp=c(0,2.5,0))
		}
	if(labels)
		{
		text(pcadata$EV1,pcadata$EV2,inds$nr[inds$filter],pch=16,col=pcadata$col,cex=0.75)
		}else{
		if(length(symboltype)>1)
			{
			mysymbols	<<- vector()
			for (j in c(1:npops))
				{
				nrsamples	<- length(inds$name[inds$pop==popnames[j]&indsfilter])
				symboltemp	<- rep(symboltype[j],nrsamples)
				mysymbols	<- c(mysymbols,symboltemp)		
				}
			rm(symboltemp)
			points(pcadata$EV1,pcadata$EV2,col=pcadata$col,pch=mysymbols,cex=symbolsize)
			}else{
			points(pcadata$EV1,pcadata$EV2,col=pcadata$col,pch=16,cex=symbolsize)
			}
		}
	if(addlegend==TRUE&npops>1)
		{
		if(length(symboltype)>1)
			{
			legend(legendpos,legend=popnames,fill=mycols,border=mycols,pch=symboltype,bty="n",cex=legendcex)
			}else{
			legend(legendpos,legend=popnames,fill=mycols,border=mycols,bty="n",cex=legendcex)
			}
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,line=0.5,cex=3.5)
		}
	if(!is.null(export)){dev.off()}	
	mypcascores	<- cbind(pcadata$EV1,pcadata$EV2)
	mytablename	<- "pca.snprelate.axis1vs2.dc_score.txt"
	if(dodc)
		{
		calc_dc(popnames=mysambar$populations,pscores=mypcascores,axis_1=1,axis_2=2,tablename=mytablename)
		}
	}

bothMDS<-function(exporttype=NULL,rundc=TRUE)
	{
	if(!is.null(exporttype))
		{
		if(exporttype=="eps"){postscript("MDS.metric_vs_nonmetric.eps",family=mysambar$myfont,width=20,height=10)}
		if(exporttype=="pdf"){pdf("MDS.metric_vs_nonmetric.pdf",family=mysambar$myfont,width=20,height=10)}
		if(exporttype=="png"){png("MDS.metric_vs_nonmetric.png",family=mysambar$myfont,width=1440,height=720)}
		if(exporttype=="wmf"){win.metafile("MDS.metric_vs_nonmetric.wmf",family=mysambar$myfont,width=20,height=10)}
		}
	par(mfrow=c(1,2))
	doMDS(export=NULL,nonmetric=FALSE,labels=TRUE,addlegend=TRUE,addtitle=TRUE,dodc=rundc)	# export should be NULL
	doMDS(export=NULL,nonmetric=TRUE,labels=TRUE,addlegend=FALSE,addtitle=TRUE,dodc=rundc) 	# export should be NULL
	if(!is.null(exporttype)){dev.off()}
	}
	
doMDS<-function(export=NULL,ndim=2,nonmetric=FALSE,labels=FALSE,addlegend=TRUE,legendpos="right",popnames=mysambar$populations,symboltype=16,symbolsize=2,addtitle=FALSE,legendcex=2,dodc=TRUE)
	{
	mydata	<- as.matrix(mygenlight)[inds$filter,snps$filter]
	mylabels<- inds$nr[inds$filter]
	npops	<- length(popnames)
	mycols	<- inds$popcol[inds$filter]
	mypopcols<- mysambar$mycolours[1:npops]
	# calculation:
	d 		<- dist(mydata) 						# euclidean distances between the rows
	mymin	<- min(d,na.rm=TRUE)
	if(mymin<=0)
		{
		cat("Zero or negative distance in distance matrix, meaning some individuals have identical genotype scores. Skipping MDS plot.",sep="\n")
		}else{
		if(nonmetric)
			{
			#sambarfunction_findstructure:
			### Multi-dimensional scaling (MDS) analyses:
			#sambarfunction_findstructure:
			myfit 	<- isoMDS(d,k=ndim)
			x 		<- myfit$points[,1]
			y 		<- myfit$points[,2]
			}else{
			#sambarfunction_findstructure:
			myfit 	<- cmdscale(d,eig=FALSE,k=ndim) 	
			x 		<- myfit[,1]
			y 		<- myfit[,2]
			}
		# plot:
		mdstype	<- ifelse(nonmetric,"MDS.nonmetric","MDS.metric")
		if(!is.null(export))
			{
			if(labels)
				{
				if(export=="eps"){postscript((paste(mdstype,"labels.eps",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf((paste(mdstype,"labels.pdf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png((paste(mdstype,"labels.png",sep=".")),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile((paste(mdstype,"labels.wmf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				}else{
				if(export=="eps"){postscript((paste(mdstype,"eps",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf((paste(mdstype,"pdf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png((paste(mdstype,"png",sep=".")),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile((paste(mdstype,"wmf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				}
			}	
		#par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
		par(mar=c(5,6,3,1),cex.axis=2)
		plot(x,y,xlab="",ylab="",main="",type="n",las=1)
		mtext("Coordinate 1",side=1,line=3.5,cex=3)
		mtext("Coordinate 2",side=2,line=3.5,cex=3)
		if(labels)
			{
			text(x,y,labels=mylabels,cex=.75,col=mycols)
			}else{
			points(x,y,cex=symbolsize,col=mycols,pch=symboltype)
			}	
		if(addtitle)
			{
			mytitle	<- ifelse(nonmetric,"Non-metric MDS","Metric MDS")
			mtext(mytitle,side=3,line=0.5,cex=3)
			}
		if(addlegend&npops>1)
			{
			if(length(symboltype)>1)
				{
				legend(legendpos,legend=popnames,fill=mypopcols,pch=symboltype,bty="n",cex=legendcex)
				}else{
				legend(legendpos,legend=popnames,fill=mypopcols,bty="n",cex=legendcex)
				}
			}
		if(!is.null(export)){dev.off()}
		mds_scores	<- cbind(x,y)	
		mytablename	<- paste(mdstype,"axis1vs2.dc_score.txt",sep=".")
		if(dodc)
			{
			calc_dc(popnames=mysambar$populations,pscores=mds_scores,axis_1=1,axis_2=2,tablename=mytablename)
			}
		}
	}
	
# DAPC (and PCA) with Adegenet
genlight2genind<-function(input=mygenlight,add2sambar=TRUE)
	{
	# When trying to run dapc analysis with genlight, I got an ERROR stating that on a Windows computer mc.cores is not possible.
	# I decided to work around this problem by converting genlight object to genind object. 
	# 27-01-2020: for big datasets (e.g 350,000 SNPs for 90 individuals) genind conversion is not feasible.
	# 27-01-2020: the error I got before I don't get now, so it seems that conversion is not necessary anyway.
	#
	# The conversion does take time, so first check whether it is needed or whether you already did it:
	if(add2sambar)
		{
		if(!is.null(mysambar$genind))
			{
			n_inds	<- dim(mysambar$genind$tab)[1]
			n_snps	<- (dim(mysambar$genind$tab)[2])/2
			if((n_inds==nrow(inds[inds$filter,]))&(n_snps==nrow(snps[snps$filter,])))
				{
				return(cat("Genind object already stored in mysambar$genind. No conversion needed.",sep="\n"))	
				}
			}
		}
	cat("Converting genlight object to genind object...",sep="\n")
	cat("This might take a while.",sep="\n")
	#
	# First line is in case the user (you) changed inds$popcol column and populations vector but forgot to change genlight$pop correspondingly:
	if(add2sambar)
		{
		mygenlight@pop	<- as.factor(inds$pop)
		x.mat 			<- as.matrix(input[inds$filter,snps$filter]) # input is a genlight object
		}else{
		x.mat			<- as.matrix(input)
		}
	x.mat[x.mat == 0] 	<- "1/1" # homozygote reference
	x.mat[x.mat == 1] 	<- "1/2" # heterozygote
	x.mat[x.mat == 2] 	<- "2/2" # homozygote alternate
	mycolnames			<- colnames(x.mat)
	mycolnames			<- gsub(":","_",mycolnames)			# 09-07-19: to avoid ERROR: ERROR in .local(.Object, ...) : more than one '.' in column names; please name column as [LOCUS].[ALLELE]
	mycolnames			<- gsub("\\.","_",mycolnames)		# 09-07-19: to avoid ERROR: ERROR in .local(.Object, ...) : more than one '.' in column names; please name column as [LOCUS].[ALLELE]
	colnames(x.mat)		<- mycolnames
	#x.mat				<<- x.mat
	mygenind 	  		<- df2genind(x.mat,sep="/",ploidy = 2)
	if(add2sambar)
		{
		pop(mygenind)	  	<- as.vector(mygenlight@pop[inds$filter])
		mysambar$genind		<<- mygenind
		cat("Conversion finished. Genind object is stored at mysambar$genind.",sep="\n")
		}else{
		mygenind		<<- mygenind
		cat("Conversion finished. Genind object is stored at mygenind.",sep="\n")
		}
	}

# dudi.pca does not accept missing data (ERROR: na entries in table) so impute data first
# 13-02-2020: I tried to plot(pca1$co$Comp1,pca1$co$Comp2,col=col), but results 
# therefore, I don't use the following function:	
adegenet_pca<-function(export=NULL,nfactor=10)
	{
	setwd(mysambar$structuredir)
	if(is.null(mysambar$imputedmatrix))
		{
		sambarimpute()
		}
	mygeno			<- as.data.frame(t(mysambar$imputedmatrix[inds$filter,snps$filter]))		# it seems I have to transpose to give eigenvalues for samples rather than for snps	
	nind			<- nrow(inds[inds$filter,])
	nloc			<- nrow(snps[snps$filter,])
	mypops			<- inds$pop[inds$filter]
	mypoplabels		<- as.vector(unique(mypops))
	col				<- as.vector(unique(inds$popcol[inds$filter]))
	pca1 			<- dudi.pca(mygeno,cent=FALSE,scale=FALSE,scannf=FALSE,nf=10)
	# plot(pca1$co$Comp1,pca1$co$Comp2,col=col)		# unfortunately output doesn't seem to make sense
	#
	# PCA eigenvalues (can also be inset in graph):
	if(!is.null(export)){pdf(paste("adegenet.pca.eigenvalues",nloc,"loci",nind,"samples.pca.pdf",sep="."),width=6,height=6)}
	barplot(pca1$eig[1:50],main="PCA eigenvalues", col=heat.colors(50))
	if(!is.null(export)){dev.off()}
	#
	# PCA plot:
	if(!is.null(export)){pdf(paste("adegenet.pca",nloc,"loci",nind,"samples.pca.pdf",sep="."),width=12,height=12)}
	par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
	s.class(pca1$li, pop(mygeno),xax=1,yax=2,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-2"))
	s.class(pca1$li, pop(mygeno),xax=1,yax=3,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-3"))
	s.class(pca1$li, pop(mygeno),xax=2,yax=3,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 2-3"))
	s.class(pca1$li, pop(mygeno),xax=1,yax=4,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-4"))
	if(!is.null(export)){dev.off()}
	# unused:
	# s.label(pca1$li,xax=1,yax=2)														# to plot sample labels
	# add.scatter.eig(pca1$eig[1:20],nf=nfactor,xax=1,yax=2, posi = "bottomright")		# to add inset of PCA eigenvalues
	}


overlapdapc<-function(popnames=mysambar$populations,observedmat=NULL)
	{
	# if mysambar$dapcoverlaplist does not correspond with current mysambar$populations, the following error:  
	# Error in dimnames(x) <- dn : length of 'dimnames' [1] not equal to array extent
	if(is.null(observedmat))
		{
		return(cat("ERROR: Provide input to observedmat flag.",sep="\n"))
		}
	mymatrix			<- observedmat
	npops				<- length(popnames)
	rownames(mymatrix)	<- popnames
	colnames(mymatrix)	<- paste("cluster",c(1:npops))
	# reorder matrix:
	mymatlist	<- list()
	myperms		<- permutations(n=npops,r=npops)	# depends on gtools
	nperms		<- nrow(myperms)
	diagsum		<- rep(NA,nperms)
	for(j in c(1:nperms))
		{
		myperm		<- myperms[j,]
		myoptions	<- c(1:npops)
		taken		<- 0
		myorder		<- rep(NA,npops)
		for (k in myperm)
			{
			myrow		<- mymatrix[k,]
			myoptions	<- myoptions[!myoptions==taken]
			myremrow	<- myrow[myoptions]
			myhigh		<- max(myremrow)
			taken		<- which(myrow==myhigh)[1] 
			myorder[k]	<- taken
			}
		mynewmat		<- mymatrix[,myorder]
		diagsum[j]		<- sum(diag(mynewmat))
		mymatlist[[j]]	<- mynewmat
		}
	mywinner	<- which(diagsum==max(diagsum))[1]
	bestmat		<- mymatlist[[mywinner]]
	#
	# observed vector:
	myobs		<- c(diag(bestmat),bestmat[upper.tri(bestmat)],bestmat[lower.tri(bestmat)])
	# expected vector:
	npopinds	<- as.vector(table(inds$pop[inds$filter]))
	myexp		<- c(npopinds,rep(0,npops*(npops-1)))
	# now calculate deviation:
	mytable		<- cbind(myobs,myexp)
	mytable		<- mytable[rowSums(mytable)!=0,]
	options(warn=-1)
	mychiout	<- chisq.test(mytable)
	options(warn=0)
	mychi		<- mychiout[[1]]
	mydf		<- mychiout[[2]]
	myp			<- mychiout[[3]]
	mychidf		<- data.frame("chi2"=mychi,"df"=mydf,"pvalue"=myp)  
	write.table(mychidf,"dapc.inferred.vs.expected.chisquared-score.txt",row.names=FALSE,col.names=TRUE,quote=FALSE)
	cat("File 'dapc.inferred.vs.expected.chisquared-score.txt' with chi-squared value written to directory:",sep="\n")
	cat(getwd(),sep="\n")
	}
	
# 09-01-2018: are the following lines regarding the dapc function still true?
#If the length of your populations vector is one (so all individuals are assigned to the same population), the dapc plot will be created interactively, which means that at a certain point you are prompted to input numbers on the screen. Because the plot is generated two times (different formats), and because you get 4 questions per plot, this will be a bit repetitive. 
#The prompts are (and rough guidelines to what the input should be):
#Choose the number PCs to retain (>= 1): 			1/3*nind
#Choose the number of clusters (>=2: 				your a priori guess
#Choose the number PCs to retain (>=1): 			1/3*nind
#Choose the number discriminant functions to retain (>=1):	 3
#If you have your samples assigned to more than one population, this will be done automatically for you, so you won’t be prompted.  

multi_adegenet_dapc<-function(export=NULL,xvalonly=FALSE,nrep=50,thresvector=c(20,50,80,95),max_clusters=6,legendadd=TRUE,poslegend="right",cexlegend=2.5,symsize=2,silent=FALSE,rundc=TRUE,plot_heatmap=TRUE)
	{
	npops	<- length(mysambar$populations)
	if(!xvalonly)
		{
		# for explained variance based analysis:
		for(mythres in thresvector)
			{
			setwd(mysambar$structuredir)
			dapcfolder	<- paste("dapc_explainedvariance",mythres,sep="")
			if(file.exists(dapcfolder))
				{
				setwd(file.path(mysambar$structuredir,dapcfolder))
				}else{
				dir.create(file.path(mysambar$structuredir,dapcfolder))
				setwd(file.path(mysambar$structuredir,dapcfolder))
				}
			cat(paste("Starting DAPC analyses with number of PC's based on an explained variance of ",mythres,"%.",sep=""),sep="\n")
			adegenet_dapc(maxclusters=max_clusters,export="pdf",min_explainedvariance=mythres,use_genind=FALSE,addlegend=legendadd,legendpos=poslegend,legendcex=cexlegend,symbolsize=symsize,use_current_dir=TRUE,dodc=rundc,plotheatmap=plot_heatmap)
			if(length(mysambar$dapcoverlaplist)>=(npops-1)&npops!=1)
				{
				if(!silent){cat("Calculating overlap between inferred and expected clusters...",sep="\n")}
				# calculate chi-squared value for overlap between inferred and expected clusters:
				overlapdapc(observedmat=mysambar$dapcoverlaplist[[npops-1]])
				}
			setwd(mysambar$structuredir)
			}
		# for a score based analysis:
		setwd(mysambar$structuredir)
		dapcfolder	<- paste("dapc_ascore")
		if(file.exists(dapcfolder))
			{
			setwd(file.path(mysambar$structuredir,dapcfolder,sep=""))
			}else{
			dir.create(file.path(mysambar$structuredir,dapcfolder))
			setwd(file.path(mysambar$structuredir,dapcfolder))
			}
		cat("Starting DAPC analyses with number of PC's based on an the a-score.",sep="\n")
		adegenet_dapc(maxclusters=max_clusters,export="pdf",use_genind=FALSE,addlegend=legendadd,legendpos=poslegend,legendcex=cexlegend,symbolsize=symsize,use_current_dir=TRUE,dodc=rundc,plotheatmap=plot_heatmap)
		if(length(mysambar$dapcoverlaplist)>=(npops-1)&npops!=1)
			{
			# calculate chi-squared value for overlap between inferred and expected clusters:
			overlapdapc(observedmat=mysambar$dapcoverlaplist[[npops-1]])
			}
		setwd(mysambar$structuredir)
		}
	# To prevent overfitting, we want to know the maximum number of principal components to retain.
	# Above we use the a-score or the arbitrary threshold 80% explained variance.
	# Another way to investigate the number of PC's to retain is to use the function xvalDapc().
	# This function calculates the proportion of succesful outcome prediction 
	# I have no clue what is predicted, and when it is successful.
	# The important point is however that you should select the number of PCs at which the curves starts to plateau.
	# First impute data, because the function uses dadi.pca, and dadi.pca does not accept NA values.
	n_snps	<- nrow(snps[snps$filter,])
	if(!file.exists("dapc_xval.cross.validation.20.pdf"))
		{
		if(n_snps>25000)
			{
			cat("The dataset contains more than 50K SNPs. Skipping xvalDapc() function in order to save time.",sep="\n")
			cat("To execute this function, run: 'runxval(nrep=20)'. With big datasets, high number of repetitions will cause long calculation times.",sep="\n")
			}else{
			if(npops>1)
				{
				cat("Running the function xvalDapc() to determine minimum number of principal components to retain.",sep="\n")
				runxval(nrep=50)
				}else{
				cat("Currently only 1 population defined. Skipping the function xvalDapc().",sep="\n")
				}
			}
		}else{
		cat("File called 'dapc_xval.cross.validation.20.pdf' already present. Skipping the function xvalDapc().",sep="\n")
		}
	setwd(mysambar$structuredir)
	}
	
runxval<-function(nrep=20,exporttype="pdf")
	{
	setwd(mysambar$structuredir)
	if(is.null(mysambar$imputedmatrix))
		{
		sambarimpute()
		}
	for (mymax in c(20,100))
		{
		xval	<- xvalDapc(mysambar$imputedmatrix[inds$filter,snps$filter],grp=as.factor(inds$pop[inds$filter]),n.pca.max=mymax,n.rep=nrep,xval.plot=FALSE)
		if(!is.null(exporttype))
			{
			plotname	<- paste("dapc_xval.cross.validation",mymax,sep=".")
			if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=6,height=6)}
			if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=6,height=6)}
			if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=6,height=6)}
			}
		par(mar=c(4,6,0.5,0.5))
		boxplot(xval[[1]]$success~xval[[1]]$n.pca,col="orange",las=2,xlab="",ylab="",cex.axis=1.5,pch=16)
		#points(rep(seq(mymax/10,mymax-mymax/10,mymax/10),each=nrep)/2,xval[[1]]$success,col="grey50",cex=1,pch=16)	# overlaying points, not insightful
		mtext(side=2,"Proportion successful predictions",line=4.25,cex=2)
		mtext(side=1,"Number of PCs",line=3,cex=2)
		if(!is.null(exporttype)){dev.off()}
		}
	}

adegenet_dapc<-function(export=NULL,use_genind=FALSE,min_explainedvariance=NULL,sumstatsplot=TRUE,maxclusters=5,transparent=0.6,symbolsize=2,addlegend=TRUE,legendpos="right",legendcex=2.5,use_current_dir=FALSE,silent=TRUE,dodc=TRUE,plotheatmap=TRUE)
	{	
	# if min_explainedvariance is not NULL, this function will use min_explainedvariance threshold (any value between 0 and 100) to define number of PC's to incorporate
	# otherwise, the function will use the a-score to define the number of PC's. 
	#
	if(is.null(mysambar$genind)&use_genind)
		{
		return(cat("ERROR: No genind object stored at mysambar$genind. Did you run the genlight2genind()-function?",sep="\n"))
		}
	if(!use_current_dir){setwd(mysambar$structuredir)}
	# First create indstemp file with all samples clustered together per population:
	if(!silent){cat("Selecting and ordering samples...",sep="\n")}
	if(use_genind)
		{
		mygeno		<- mysambar$genind
		}else{
		# sambarfunction_findstructure:
		### DAPC analyses:
		# sambarfunction_findstructure:
		mygeno		<- mygenlight[inds$filter,snps$filter]
		}
	mymatrixtemp	<- as.matrix(mygeno)
	mypopnames		<- inds$pop[inds$filter]
	# sambarfunction_findstructure:
	mymatrixtemp	<- mymatrixtemp[order(mypopnames),]
	# sambarfunction_findstructure:
	mygeno			<- as.genind(mymatrixtemp)
	if(is.null(mygeno@all.names))
		{
		# This is to avoid the error:
		# invalid length in all.names: Error in validObject(x) : invalid class "genind" object: FALSE
		cat("WARNING: all.names missing from genind object. Adding now...",sep="\n")
		mygeno@loc.fac		<- as.factor(snps$name[snps$filter])
		mygeno@loc.n.all	<- rep(2,nrow(snps[snps$filter,]))
		mygeno@all.names	<- as.list(snps$name[snps$filter])
		}else{
		if(length(mygeno@all.names)!=nrow(snps[snps$filter,]))
			{
			cat("WARNING: all.names vector in genind object does not have expected length. Replacing...",sep="\n")
			mygeno@loc.fac		<- as.factor(snps$name[snps$filter])
			mygeno@loc.n.all	<- rep(2,nrow(snps[snps$filter,]))
			mygeno@all.names	<- as.list(snps$name[snps$filter])
			}
		}
	indstemp		<- inds[order(inds$pop),]
	pop(mygeno)		<- as.factor(indstemp$pop[inds$filter])
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name[indstemp$filter])))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Defining population colours..",sep="\n")}
	# Now start analysis:	
	nind			<- nrow(indstemp[indstemp$filter,])
	nloc			<- nrow(snps[snps$filter,])
	mypops			<- indstemp$pop[indstemp$filter]
	mypoplabels		<- as.vector(unique(mypops))
	mycols			<- as.vector(unique(indstemp$popcol[indstemp$filter]))	# used for barplot
	mycols			<- mycols[order(mypoplabels)]							# how to double check if colours are assigned to clusters correctly?
	npops			<- length(mypoplabels)
	if(npops==1)
		{
		cat("At present only 1 population defined.",sep="\n")
		cat("To run without ERRORs, DAPC needs at least 2 populations as input.",sep="\n")		# ERROR message: ERROR in svd(X, nu = 0L) : infinite or missing values in 'x'
		cat("Therefore, Sambar randomly assigned the samples to 2 populations.",sep="\n")
		myhalf			<- floor(nind/2)
		myrandomlabels	<- c(rep("random_pop1",myhalf),rep("random_pop2",(nind-myhalf)))
		pop(mygeno)		<- myrandomlabels
		mypopulations	<- c("random_pop1","random_pop2")
		npops			<- 2
		}else{
		mypopulations	<- mysambar$populations
		}
	if(sumstatsplot)
		{
		## create plot with dapc summary statistics:
		graphics.off()
		if(!is.null(export))
			{
			if(!silent){cat("Opening device...",sep="\n")}
			if(export=="eps"){postscript("dapc.summarystatistics.eps",family=mysambar$myfont,width=19,height=7)}
			if(export=="pdf"){pdf("dapc.summarystatistics.pdf",family=mysambar$myfont,width=19,height=7)}
			if(export=="png"){png("dapc.summarystatistics.png",family=mysambar$myfont,width=1300,height=500)}
			if(export=="wmf"){win.metafile("dapc.summarystatistics.wmf",family=mysambar$myfont,width=19,height=7)}
			# wmf only works if solid = 1 (Otherwise ERROR about blank input)
			}
		par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
		#
		## plot pca eigenvalues:
		if(!silent){cat("Starting DAPC analyses...",sep="\n")}
		dapc.out 		<- dapc(mygeno,n.pca=100,n.da=100)	# we set n.pca and n.da for now really high so pc's cover 100 of explained variance (and for nda no choice is made yet(?))
		if(!silent){cat("Selecting number of PCs to retain...",sep="\n")}
		mypcaeigen 		<- dapc.out$pca.eig
		mypcaeigensum 	<- 100*cumsum(mypcaeigen)/sum(mypcaeigen)
		mytotalpca		<- length(mypcaeigensum)
		# Retaining too many components with respect to the number of individuals can lead to over-fitting and unstability in the membership probabilities returned by the method 
		# The bottomline is therefore retaining a few PCs without sacrificing too much information.
		# Different ways to determine optimal number:
		# mynpca		<- which(mypcaeigensum>80)[1]			# when 80% explained?
		# mynpca		<- which((diff(mypcaeigensum)<0.5))[1]	# alternative method: when added explained variance below a certain threshold (e.g 0.5%)? 
		# accepted way is using built-in function of dapc, which calculates a so called a score, and outputs a plot at the same time:
		my_ascore 		<- optim.a.score(dapc.out)			
		if(is.null(min_explainedvariance))
			{
			mynpca		<- my_ascore$best
			cat(paste("Based on the a-score statistic,",mynpca,"is the optimal number of PCs. DAPC-analyses will be executed using this value.",sep=" "),sep="\n")
			}else{
			mynpca		<- which(mypcaeigensum>min_explainedvariance)[1]
			cat(paste("Number of PCs to retain given the prespecified amount of explained variance is: ",mynpca,". DAPC-analyses will be executed using this value.",sep=""),sep="\n")
			}
		cat(paste("Number of PC's included in analysis: ",mynpca,sep=""),sep="\n") 
		plot(mypcaeigensum,col=rep(c("orange","grey20"),c(mynpca,1000)),ylim=c(0,100),xlim=c(0,mytotalpca),main="Variance explained by PCA", xlab="PCA axis", ylab="Cumulated variance (%)",cex=1, pch=20, type="h", lwd=2)
		legend("topleft",legend=c("Not retained","Retained"),fill=c("grey20","orange"),bty='n',cex=1.5)
		#
		## create bic plot:
		# I set max.n.clust to 10, unless datasets contain no more than 10 (sub)populations, or less individuals): 
		mymaxcluster	<- 10
		mymaxcluster	<- ifelse(npops>10,npops,mymaxcluster)
		mymaxcluster	<- ifelse(nind<10,nind-1,mymaxcluster)
		mygrp 			<- find.clusters(mygeno,max.n.clust=mymaxcluster,n.pca=mynpca,choose.n.clust=FALSE)	
		#
		# When I try to run the following function:
		# xvalDapc(as.matrix(mygeno),mygrp,n.pca.max=nrow(mygeno),n.da=20,n.pca=mynpca,n.rep=30,xval.plot=TRUE)
		# I get the error:
		# Error in order(y) : unimplemented type 'list' in 'orderVector1'
		# Or:
		# xval<-xvalDapc(mygeno,grp=as.factor(inds$pop[inds$filter]),n.pca.max=100,n.rep=3)
		# Error in dudi.pca(x, nf = n.pca.max, scannf = FALSE, center = center,  :  na entries in table
		#
		#
		plot(mygrp$Kstat,main="Bic value",xlab="Number of clusters",ylab="BIC",type='b',col="grey20")
		if(!is.null(export)){dev.off()}
		#
		# plot reassignment of samples:
		# this plot is difficult to assign population colours, because I am not sure whether clusters defined by dapc are the same as population clusters
		# graphics.off()
		# if(!is.null(export))
		#	{
		#	if(export=="eps"){postscript("dapc.barplot.eps",family=mysambar$myfont,width=13,height=7)}
		#	if(export=="pdf"){pdf("dapc.barplot.pdf",family=mysambar$myfont,width=13,height=7)}
		#	if(export=="png"){png("dapc.barplot.png",family=mysambar$myfont,width=720,height=500)}
		#	if(export=="wmf"){win.metafile("dapc.barplot.wmf",family=mysambar$myfont,width=13,height=7)}
		#	# wmf only works if solid = 1 (Otherwise ERROR about blank input)
		#	}
		# if(npops==1)
		#	{
		#	tempcols<-mysambar$mycolours[1:2]
		#	}else{
		#	tempcols=mycols1
		#	}
		# par(mar=c(4.5,15,1,2.5),cex.axis=2,cex.lab=2.5,cex.main=2.5)
		# sumtemp <- summary(dapc(mygeno, n.da=20, n.pca=mynpca))$assign.per.pop*100
		# barplot(sumtemp, xlab="% of reassignment to actual cluster",horiz=TRUE,las=1,col=tempcols,xlim=c(0,100))
		# if(!is.null(export)){dev.off()}
		#
		# not sure what this plot is doing:
		# barplot(dapc.out$eig,main="Discriminant analysis eigenvalues",ylab="F-statistic",xlab="Linear Discriminants",col="orange",names.arg=c(1:length(dapc.out$eig)))
		#
		}
	myclusters	<- c(2:maxclusters)
	cat("Running DAPC analyses for various number of expected clusters (K).",sep="\n")
	cat("Observe the screeplot in the 'dapc.summarystatistics'-plot to find the optimal K value (lowest point or flattening of decline).",sep="\n")
	myoverlap		<- list()
	dapcqmatrixlist	<- list()
	for (i in myclusters)
		{
		cat(paste("K =",i,sep=" "),sep="\n")
		#
		# sambarfunction_findstructure:
		mygrp 	<- find.clusters(mygeno,max.n.clust=20,n.pca=mynpca,n.clust=i)
		# From the adegenet manual: For small number of clusters (less than tens), all DA eigenvalues can be saved. 
		# I set n.da to upper limit of 20, but only 'ncluster - 1' are saved when running dapc function   
		#
		for (myindex in c(1:2))
			{
			# we are going to create scatter plots both for simulated and for real data.
			showsimulated	<- ifelse(myindex==1,TRUE,FALSE)
			if(showsimulated)
				{
				# 18-01-2020: note: if you exclude mygrp$grp then you get very nice structured plots, but that doesn't mean it is meaningful. 
				# Without grp$grp you dapc will use a priori defined population assignment as input.
				# 13-02-2020: I include the option within grp$grp now, so users can compare the output.
				dapc.out 			<- dapc(mygeno,pop=NULL,n.pca=mynpca,n.da=20)
				datatype			<- "WITH_prior_popinfo"
				}else{
				# sambarfunction_findstructure:
				dapc.out 			<- dapc(mygeno,pop=mygrp$grp,n.pca=mynpca,n.da=20)	 
				datatype			<- "WITHOUT_prior_popinfo"
				}
			mydapc					<- as.data.frame(dapc.out$ind.coord)
			mysambar$mydapc			<<- mydapc
			#
			# matrix with population membership probabilities:
			myqmatrix				<- round(dapc.out$posterior,3)
			myqmatrix				<- myqmatrix[order(rownames(myqmatrix)),]
			if(!showsimulated)
				{
				dapcqmatrixlist[[i-1]]	<- myqmatrix
				mytable					<- as.matrix(table(pop(mygeno),mygrp$grp))	
				colnames(mytable)		<- paste("cluster",levels(mygrp$grp),sep="_")
				myoverlap[[i-1]]		<- mytable
				}
			mysambar$dapcoverlaplist	<<- myoverlap
			#
			# Scatter plots:
			graphics.off()
			# to add DAPC eigenvalues: scree.da=TRUE; to add PCA eigenvalues: scree.pca=TRUE
			# as mentioned above, number of discriminant functions is nclusters (i) - 1.
			# if i = 2, there is only one option: xax = 1 and yax = 1.
			# if i = 3, there are 3 options: xax = 1 and yax=1; xax = 1 and yax = 2, xax = 2 and yax = 2. However, we are only interested in the second option.
			# if i = 4 or more, this are the options we are interested in: xax = 1 and yax = 2, xax = 1 and yax = 3, xax = 2 and yax = 3.
			# so:
			#				
			# if (i == 2)
			#	{
			#	if(!is.null(export))
			#		{
			#		if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc.eps",sep="."),height=6,width=6)}
			#		if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc.pdf",sep="."),height=6,width=6)}
			#		if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc.png",sep="."),height=720,width=720)}
			#		if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc.wmf",sep="."),height=6,width=6)}
			#		}
			#	add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
			#	scatter(dapc.out, grp=mypops, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=transparent,cex.lab=2.5,clabel=2.5,label=NULL,legend=add_leg)
			#	if(!is.null(export)){dev.off()}
			#	}
			#
			if (i == 3)
				{
				for(myrun in c(1:4))
					{
					if(!is.null(export))
						{
						mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
						if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"eps",sep="."),height=10,width=10)}
						if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=10,width=10)}
						if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"png",sep="."),height=720,width=720)}
						if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=10,width=10)}
						}
					par(cex.axis=2,cex.lab=2.5,cex.main=2.5)
					#scatter(dapc.out, grp=mypops, col=mycols, xax=1, yax=2, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=transparent,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
					if(myrun<3)
						{
						plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
						}else{
						plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
						text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
						}
					abline(v=0,col="grey")
					abline(h=0,col="grey")
					if(myrun%%2!=0)
						{
						add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
						if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
						}
					mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
					if(!is.null(export)){dev.off()}
					}
				}
			# 13-02-2020: It is a mystery to me why it is possible to run plot(mydapc$LD1,mydapc$LD2) even if npca=1 (meaning that the column mydapc$L2 is absent).
			# it results in samples clustered together in discs shaped agglomerations.
			#if(mynpca<4)	# 20-02-2020: because I experienced that mynpca can be 4 or higher, and only one column in mydapc.
			if (ncol(mydapc)<3)
				{
				cat("Number of retained PC's is below 4. Skipping dapc plot's for K=4 and higher.",sep="\n")
				}else{
				if (i == 4)
					{
					for(myrun in c(1:4))
						{
						if(!is.null(export))
							{
							mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
							if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"eps",sep="."),height=12,width=12)}
							if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=12,width=12)}
							if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"png",sep="."),height=1200,width=1200)}
							if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=12,width=12)}
							}
						#par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						par(mfrow=c(2,2),mar=c(1,2,2,1),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=2, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=4)
							text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						if(myrun%%2!=0)
							{
							add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
							if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=3)}
							}
						mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD1,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD1,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						mtext("DAs: 1 vs 3",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=2, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD2,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD2,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD2,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						mtext("DAs: 2 vs 3",side=3,line=0,cex=2.5)
						if(!is.null(export)){dev.off()}
						}
					}
				#
				if (i > 4)
					{
					for(myrun in c(1:4))
						{
						if(!is.null(export))
							{
							mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
							if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"eps",sep="."),height=12,width=12)}
							if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=12,width=12)}
							if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"png",sep="."),height=1200,width=1200)}
							if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=12,width=12)}
							}
						#par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						par(mfrow=c(2,2),mar=c(1,2,2,1),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=2, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						if(myrun%%2!=0)
							{
							add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
							if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=3)}
							}
						mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD1,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD1,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						mtext("DAs: 1 vs 3",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=2, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD2,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD2,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD2,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						mtext("DAs: 2 vs 3",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=4, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD4,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							}else{
							plot(mydapc$LD1,mydapc$LD4,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD1,mydapc$LD4,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						mtext("DAs: 1 vs 4",side=3,line=0,cex=2.5)
						if(!is.null(export)){dev.off()}
						}
					}
				}
			if(ncol(mydapc)>1&dodc)
				{
				mytablename	<- paste("dapc.K",i,mynpca,"scatter.dapc",datatype,"axis1vs2.dc_score.txt",sep=".")
				calc_dc(popnames=mysambar$populations,pscores=mydapc,axis_1=1,axis_2=2,tablename=mytablename)
				}
			}
		}
	if(!showsimulated)
		{
		names(dapcqmatrixlist)	<- paste("K",myclusters,sep="")
		mysambar$dapcqmatrixlist<<- dapcqmatrixlist
		#
		# lastly, create heatmaps showing overlap between dapc inferred clusters and your a priori defined populations:
		if(plotheatmap)
			{
			cat("Plotting correspondence between expected and inferred clusters...",sep="\n")
			cat("If you receive an error after this line, rerun the findstructure function with the flag 'dapc_heatmap' set to FALSE.",sep="\n") 
			dapc_heatmap(export_type=export,myoverlap=mysambar$dapcoverlaplist)
			}else{
			cat("Not plotting correspondence between expected and inferred clusters because the flag 'plotheatmap' is set to FALSE.",sep="\n")
			}
		}
	}

dapc_heatmap<-function(export_type=NULL,myoverlap=mysambar$dapcoverlaplist)
	{
	graphics.off()
	ntables			<- length(myoverlap)
	mymax			<- max(unlist(myoverlap))
	mymin			<- min(unlist(myoverlap))
	mycolfunc 		<- colorRampPalette(c("white","orange"))
	myBreaks		<- seq(mymin,mymax,(mymax/10))
	myColours		<- c(mycolfunc(length(myBreaks)-1))		
	gl 				<- lapply(1:length(myoverlap), function(i){
	mymatrix		<- data.matrix(myoverlap[[i]])
	heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
	notecol="black",notecex=2.5,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
	ylab="",xlab="",srtRow=45,srtCol=45,key=FALSE,margins=c(8,8))
	grid.echo()
	grid.grab()})
	graphics.off()
	if(!is.null(export_type))
		{
		myheight	<- ceiling(ntables/2)*6.5
		mywidth		<- ifelse(ntables==1,7.5,15)
		myheight2	<- ceiling(ntables/2)*650
		mywidth2	<- ifelse(ntables==1,750,1500)
		if(export_type=="eps"){postscript("dapc.inferred.vs.expectedclusters.eps",height=myheight,width=mywidth)}
		if(export_type=="pdf"){pdf("dapc.inferred.vs.expectedclusters.pdf",height=myheight,width=mywidth,onefile=FALSE)}
		if(export_type=="png"){png("dapc.inferred.vs.expectedclusters.png",height=myheight2,width=mywidth2)}
		if(export_type=="wmf"){win.metafile("dapc.inferred.vs.expectedclusters.wmf",height=myheight,width=mywidth)}
		}	
	grid.newpage()
	grid.arrange(grobs=gl,ncol=2,clip=TRUE)	
	if(!is.null(export_type)){dev.off()}
	}

# 02-05-2020: to create stand alone plot
dapc_scatter<-function(addlegend=TRUE,export=NULL,symbolsize=2,legendpos="topright",legendcex=2.5,popnames=mysambar$populations,titlesize=2.5)
	{
	# first run adegenet_dapc (with desired settings) to create dapc output (mydapc matrix).
	# First create indstemp file with all samples clustered together per population:
	if(is.null(mysambar$mydapc))
		{
		cat("ERROR: could not find object 'mydapc'.",sep="\n") 	
		}else{
		cat("Plotting DAPC output...",sep="\n")
		mydapc		<- mysambar$mydapc
		}
	npops			<- length(popnames)
	mygeno			<- mygenlight[inds$filter,snps$filter]
	mymatrixtemp	<- as.matrix(mygeno)
	mypopnames		<- inds$pop[inds$filter]
	mymatrixtemp	<- mymatrixtemp[order(mypopnames),]
	mygeno			<- as.genind(mymatrixtemp)
	indstemp		<- inds[order(inds$pop),]
	pop(mygeno)		<- as.factor(indstemp$pop[inds$filter])
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste("scatter.dapc",datatype,mysymbol,"eps",sep="."),height=10,width=10)}
		if(export=="pdf"){pdf(paste("scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=10,width=10)}
		if(export=="png"){png(paste("scatter.dapc",datatype,mysymbol,"png",sep="."),height=720,width=720)}
		if(export=="wmf"){win.metafile(paste("scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=10,width=10)}
		}
	par(cex.axis=2,cex.lab=2.5,cex.main=2.5)
	plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
	abline(v=0,col="grey")
	abline(h=0,col="grey")
	if(addlegend){legend(legendpos,legend=popnames,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
	mtext("DAs: 1 vs 2",side=3,line=0,cex=titlesize)
	if(!is.null(export)){dev.off()}
	}

makenetworks<-function(nplots=3,do_silent=TRUE,show_mut=2,do_randomsubset=TRUE,noderatio=0.1,do_overwrite=TRUE,legend_cex=1.5,legend_pos="topleft",nrloci=1000,bin_factor=NULL,export_name="Genotype_network",alt_threshold=0)
	{
	if("raster" %in% (.packages()) == TRUE)
		{
		return(cat("ERROR: can not generate network if package 'raster' is loaded, because it masks a function of the package spDep. Please load a new R session and run the getpackages() function with within mypackageslist.txt the column value of the row 'raster' set to FALSE (default).",sep="\n"))  
		}
	# To prevent error:
	# Error in h(simpleError(msg, call)) : 
	# error in evaluating the argument 'data' in selecting a method for function 'with': unable to find an inherited method for function 'raster' for signature '"integer"'
	if(is.null(mysambar$mydnabin)|do_overwrite)
		{
		genlight2DNAbin(export=TRUE,input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="filtereddata.diploid.fa") 
		}
	for(plotnr in c(1:nplots))
		{
		if(!do_silent){cat(plotnr,sep="\n")}
		binlabel	<- ifelse(is.null(bin_factor),"nobinning",paste("binwidth",bin_factor,sep=""))
		makenetwork(silent=do_silent,export=TRUE,showmut=show_mut,exportname=paste(export_name,binlabel,plotnr,sep="_"),legendcex=legend_cex,randomsubset=do_randomsubset,myratio=noderatio,nloci=nrloci,legendpos=legend_pos,binfactor=bin_factor,altthreshold=alt_threshold)
		}
	}

makenetwork<-function(myinput=mysambar$mydnabin,showmut=2,nloci=1000,randomsubset=FALSE,popnames=mysambar$populations,legendpos="topleft",legendcex=1.5,myratio=0.1,export=FALSE,exportname="Genotype_network",silent=TRUE,binfactor=NULL,altthreshold=0)
	{
	# too many loci results in overlapping circles.
	# 1000 randomly sampled loci with a ratio of 0.1 works best 
	# or: 2000 loci with a ratio of 0.05
	#
	# 20-05-2021: not clear to me what causes this error:
	# Error in integrate(L_jm, 0, 1, j = i, m = M) : non-finite function value
	#
	if("raster" %in% (.packages()) == TRUE)
		{
		return(cat("ERROR: can not generate network if package 'raster' is loaded, because it masks a function of the package spDep. Please load a new R session and run the getpackages() function with within mypackageslist.txt the column value of the row 'raster' set to FALSE (default).",sep="\n"))  
		}
	if(is.null(myinput))
		{
		return(cat("ERROR: specified input file does not exist. Did you run the genlight2DNAbin() function?",sep="\n"))
		}
	if(length(altthreshold)==1)
		{
		if(altthreshold!=0)
			{
			return(cat("ERROR: altthreshold should be either 0 or contain two elements: c(minimum,maximum).",sep="\n"))
			}
		}
	# define pops and colours:
	indstemp	<- droplevels(inds[inds$filter,])
	myorder		<- order(indstemp$pop)
	indstemp	<- indstemp[myorder,]
	mypops		<- indstemp$pop
	#
	mypops2		<- popnames[order(popnames)]
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	# mycolours	<- mycolours[order(popnames)]
	#
	# select data:
	if(!silent){cat("Selecting data...",sep="\n")}
	bigdataset	<- ncol(myinput)>nloci
	if(bigdataset)
		{
		if(randomsubset)
			{
			cat(paste("Using random subset of ",nloci," SNPs...",sep=""),sep="\n")
			myinput		<- myinput[myorder,sample(c(1:ncol(myinput)),nloci,replace=FALSE)]
			}else{
			cat(paste("Using ",nloci," SNPs with highest deviation in population minor allele frequencies...",sep=""),sep="\n")
			snpstemp	<- snps[snps$filter,]
			sdthres		<- head(tail(sort(snpstemp$sd_popmaf),nloci),1)
			myinput		<- myinput[myorder,snpstemp$sd_popmaf>=sdthres]
			}
		}else{
		cat("Using all SNPs...",sep="\n")
		myinput		<- myinput[myorder,]
		}
	ndata		<- ncol(myinput)
	#
	# create network: 
	cat("Creating network...",sep="\n")
	cat("This make take a while...",sep="\n")
	e 			<- dist.dna(myinput)
	if(!silent){cat("pegas::haplotype...",sep="\n")}
	h 			<- pegas::haplotype(myinput)
	h 			<<- sort(h, what = "label")
	if(!silent){cat("pegas::haploNet...",sep="\n")}
	net 		<- pegas::haploNet(h)
	if(!is.null(binfactor))
		{
		cat("Binning number of substitutions as defined by binfactor flag.",sep="\n")
		net[,3]		<- ceiling(net[,3]/binfactor)
		altthreshold<- ceiling(altthreshold/binfactor)
		}
	#
	if(!silent){cat("Indexing...",sep="\n")}
	ind.hap		<- with(stack(setNames(attr(h,"index"),rownames(h))),table(hap=ind,pop=mypops[values]))
	#
	# without legend:
	cat("Plot without legend...",sep="\n")
	datatype	<- ifelse(randomsubset,"randomsubset","highest_sdmaf")
	exportname	<- paste(exportname,datatype,sep="_")
	if(export){pdf(paste(exportname,ndata,"snps.pdf",sep="."))}
	plot(net,show.mutation=showmut,bg=mycolours,size=attr(net,"freq"),scale.ratio=myratio,pie=ind.hap,label=FALSE,fast = FALSE,threshold=altthreshold)
	dev.off()
	# with legend:
	cat("Plot with legend...",sep="\n")
	exportname	<- paste(exportname,"legend",sep=".")
	if(export){pdf(paste(exportname,ndata,"snps.pdf",sep="."))}
	plot(net,show.mutation=showmut,bg=mycolours,size=attr(net,"freq"),scale.ratio=myratio,pie=ind.hap,label=FALSE,fast = FALSE,threshold=altthreshold)
	legend(legendpos,mypops2,col=mycolours,pch=19,ncol=1,bty='n',cex=legendcex)
	if(export){dev.off()}
	}	

# Bayesian population assignment probabilities:
assign2pop<-function(popnames=mysambar$populations,mindata=200,n_subset=NULL,silent=TRUE,top_popmafsd=TRUE,docount=FALSE,slowmethod=FALSE)
	{
	# I developed this method myself, but it turns out to be roughly similar to methods described in:
	# Peatkau et al, 1995, Microsatellite analysis of population structure in Canadian polar bears; 
	# Cornuet JM, Piry S, Luikart G, Estoup A, Solignac M, 1999. New methods employing multilocus genotypes to select or exclude populations as origins of individuals;
	# Baudouin & Cornuet, 2004, Analytical Bayesian Approach for Assigning Individuals to Populations
	# The last paper uses a Dirichlet distribution. Different?
	# 
	# The software Structure is also based on Bayes Rule likelihood of population assignment given a sample's genotype. 
	# It is however more complex (it derives population division itself, rather than using a predefined set of populations:
	# Pritchard et al, 2000, Inference of population structure using multilocus genotype data;
	#
	# The question is:
	# among populations of a reference set, which of these populations is most likely to be the origin of a particular individual?
	if(is.null(n_subset))
		{
		fileConn	<- file("popassign.bayesian.explained.txt")
		writeLines(c("The 'popassign.bayesian'-plots depict the probability that a certain individual belongs to a predefined populations given it's observed genotype and given the minor allele frequencies of the predefined populations.",
		"This can be denoted as Pr(hypothesis|observation) or in short Pr(H|O).",
		"The hypothesis H is the population assignment and the observation O is the genotype score. The genotype score is either 0 (homozygous major), 1 (heterozygous), or 2 (homozygous minor).",
		"To calculate these probabilities SambaR use the following Bayesian formula:",
		"Pr(H|O) 	= (Pr(O|H)*Pr(H))/Pr(O)",
		"in which:",
		"Pr(H) 		= 1/npops # flat prior distribution",
		"Pr(O|H) 	= probability of observed genotypes given the population minor allele frequencies",
		"Pr(O)		= sum of product of Pr(H) and Pr(O|H) for all populations",
		"Because the prior distribution is flat, the formula can be simplified to:",
		"Pr(H1|O) 	= Pr(O|H1)/(Pr(O|H1)+Pr(O|H2)+ ... + Pr(O|Hn))	# in which n denotes number of populations",
		"For example: say we have two bottles, one (A) with 10 red and 90 white balls, and the other (B) with 1 red and 99 red balls.",
		"A ball is drawn from either bottle (you don't know which), and it happens to be red. From which bottle is the ball drawn?",
		"Pr(A|red) = Pr(red|A)/(Pr(red|A)+Pr(red|B)) = 0.1/(0.1+0.01) = 0.91",
		"Pr(B|red) = Pr(red|B)/(Pr(red|A)+Pr(red|B)) = 0.01/(0.1+0.01) = 0.09",
		"Similarly, we are going to calculate the probabilities that a sample has been drawn from any of our populations:",
		"Pr(popA|genotype) = Pr(genotype|popA)/(Pr(genotype|popA)+Pr(genotype|popB))",
		"Pr(popB|genotype) = Pr(genotype|popB)/(Pr(genotype|popA)+Pr(genotype|popB))", 
		"For example, say we have 2 populations, and for a particular locus one population (A) has a minor allele frequency (MAF) of 10 percent, and the other a MAF of 1 percent.",
		"What is the probability that an individual which is homozygous for both major alleles (i.e. genotype 0) belongs to either popA or popB?",
		"Pr(popA|0) = Pr(0|popA)/(Pr(0|popA)+Pr(0|popB)) = (0.9*0.9)/(0.9*0.9+0.99*0.99) = 0.45", 
		"Pr(popB|0) = Pr(0|popB)/(Pr(0|popA)+Pr(0|popB)) = (0.99*0.99)/(0.9*0.9+0.99*0.99) = 0.55",
		"This example only shows one locus. When having multiple loci, we calculate the probabilities Pr(geno|popA) and Pr(geno|popB) by multiplying each locus specific probability (assuming they are independent):",
		"Pr(geno|popA) = Pr(locus_1|popA)*Pr(locus_2|popA)*...*Pr(locus_k|popA)							# in which k denotes total number of loci",
		"Pr(geno|popB) = Pr(locus_1|popB)*Pr(locus_2|popB)*...*Pr(locus_k|popB)							# in which k denotes total number of loci",
		"In the script this is (roughly) written as: Pr_geno[j] <- (j-1)*Pr_geno[j-1]*Pr_locus[j]		# in which j denotes each jth locus",
		"Excluded from the calculation are all snps for which one of either alleles are not represented in all populations. Those loci would make the probability converge to 0 or 1, and hence they are omitted.", 
		"To avoid circularity, population allele frequencies are based on sample sets excluding the sample of interest.", 
		"",
		"If you use this Bayesian population assignment probability test for publication, please cite SambaR.", 
		"Similar methods have previously been published by:",
		"Peatkau et al, 1995, Microsatellite analysis of population structure in Canadian polar bears", 
		"Baudouin & Cornuet, 2004, Analytical Bayesian Approach for Assigning Individuals to Populations",
		""),fileConn)
		close(fileConn)
		}
	#
	popmafs 				<- snps[,grep("maf_",colnames(snps))]
	# 28-05-2021: included next lines to removed imputed_maf columns, which otherwise cause an error:
	imputecolumns			<- grep("imputed_maf_",colnames(popmafs))
	if(length(imputecolumns)>0)
		{
		popmafs					<- popmafs[,-imputecolumns]
		}
	#
	mafmin					<- apply(popmafs,1,min)
	colnames(popmafs)		<- popnames
	nodatavec				<- !is.na(rowSums(popmafs))
	mysd					<- snps$sd_popmaf
	myfilter				<- (snps$filter)&(mafmin>0)&(nodatavec)&is.finite(mysd)&!is.na(mysd)
	mysd					<- mysd[myfilter]
	mymafs					<- popmafs[myfilter,]
	# mymafs[is.na(mymafs)]	<- 0.0000001		# 09-07-19: quick and dirty solution for ERROR: ERROR in if (any(mymafs[j, ] == 0) | any(mymafs[j, ] == 1)) { : missing value where TRUE/FALSE needed
	# 18-02-2020: this can massively influence the results, I suppose, so this is NOT a good solution!!! I solved it by filtering out any rows with NA.
	ndata		<- nrow(mymafs)
	ndataperpop	<- vector()
	for(j in c(1:ncol(popmafs)))
		{
		mycolumn		<- popmafs[snps$filter,j]
		ndataperpop[j]	<- length(mycolumn[mycolumn>0&(!is.na(mycolumn))])
		}
	ndatadf		<- data.frame("population"=popnames,"nsnps_minorallele_present"=ndataperpop)
	if(ndata<mindata&is.null(n_subset))
		{
		cat("WARNING: a relatively low number of SNPs has the minor allele present in all populations. As a result, the power of the Bayesian assignment test might be low.",sep="\n")
		write.table(ndatadf,"popassign.bayesian.WARNING.data_per_population.txt",col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")
		fileConn	<- file("popassign.bayesian.WARNING.txt")
		writeLines(c("WARNING: with the current filter settings, a relatively low number of SNPs has the minor allele present in all populations. As a result, the power of the Bayesian assignment test might be low.",
		"Observe the 'popassign.bayesian.data_per_population.txt' to see which populations you might consider to merge or remove in order to up this number and improve the power.",
		""),fileConn)
		close(fileConn)
		}
	mysambar$ndata_popassign		<<- ndata
	if(ndata<2)
		{
		return(cat("Less than 2 SNPs retained. Aborting assign2pop().",sep="\n"))
		}
	nsnps				<- nrow(snps[myfilter,])
	ninds				<- nrow(inds)
	npops				<- length(popnames)
	popassigncol		<- rep(NA,npops)
	for (k in c(1:npops))
		{
		if(!(paste("maf",popnames[k],sep="_")) %in% colnames(snps))
			{
			return(cat("Missing column with maf values. Execute 'maffunction()' followed by 'correctmaf()' and then try running 'assign2pop()' again",sep="\n"))
			} 
		popassigncol[k]	<- inds$popcol[inds$pop==popnames[k]][1]
		}
	mysambar$popassigncol	<<- popassigncol
	#
	if(!is.null(n_subset))
		{
		nsnps			<- n_subset
		if(top_popmafsd)
			{
			mymafs		<- mymafs[order(-mysd),] 
			mymafs		<- head(mymafs,n_subset)
			}else{
			myselection	<- sample(nrow(mymafs),n_subset)
			mymafs		<- mymafs[myselection, ]
			}
		}
	# mymafs		<<- mymafs
	# create empty dataframes:
	myhomomaj	<- matrix(NA,ncol=ncol(mymafs),nrow=nrow(mymafs))
	myhetero	<- myhomomaj
	myhomomin	<- myhomomaj
	myprop		<- myhomomaj
	# start the calculation:
	myassign			<- matrix(NA,ninds,npops)
	myassignalt			<- matrix(NA,ninds,npops)	# new/temp
	for (i in c(1:nrow(inds)))
		{		
		if(!silent)
			{
			cat(i,sep="\n")
			cat(as.vector(inds$name[i]),sep="\n")
			}
		myprmat			<- matrix(NA,nsnps,npops)
		mycountmat		<- matrix(NA,nsnps,npops)		### new
		indgeno			<- as.matrix(mygenlight[i,myfilter])
		indpop			<- inds$pop[i]
		if(!is.null(n_subset))
			{
			if(top_popmafsd)
				{
				indgeno	<- as.vector(indgeno)
				indgeno	<- indgeno[order(-mysd)]
				indgeno	<- head(indgeno,n_subset)
				}else{
				indgeno	<- indgeno[,myselection]
				}
			}
		if(slowmethod)
			{
			# pr based on first locus:
			mygeno			<- indgeno[1]
			mypr			<- rep(NA,npops)
			for (k in c(1:npops))
				{
				mypr[k]		<- ifelse(mygeno==2,mymafs[1,k]*mymafs[1,k],ifelse(mygeno==1,2*mymafs[1,k]*(1-mymafs[1,k]),(1-mymafs[1,k])*(1-mymafs[1,k])))
				}
			if(any(is.na(mypr)))
				{
				mypr		<-rep(1/npops,npops)
				mycountmat[1,]	<- rep(NA,npops)
				}else{
				mycountmat[1,]	<- mypr==max(mypr)	
				}
			mypr			<- mypr/sum(mypr)	 
			myprmat[1,] 		<- mypr
			# 
			# now update probability with info from all loci:
			for (j in c(2:nsnps))
				{
				# cat(j,sep="\n")
				mygeno		<- indgeno[j]
				mynewpr		<- rep(NA,npops)
				if(is.na(mygeno))
					{
					myprmat[j,]	<- myprmat[j-1,]
					mycountmat[j,]	<- rep(NA,npops)	
					}else{
					for (k in c(1:npops))
						{
						mynewpr[k]<- ifelse(mygeno==2,mymafs[j,k]*mymafs[j,k],ifelse(mygeno==1,2*mymafs[j,k]*(1-mymafs[j,k]),(1-mymafs[j,k])*(1-mymafs[j,k])))
						}
					mycountmat[j,]	<- mynewpr==max(mynewpr)
					if(any(mymafs[j,]==0)|any(mymafs[j,]==1))
						{
						myprmat[j,]	<- myprmat[j-1,]				# I am excluding from the calculation all snps with at least one population without the minor alleles. Otherwise the probability converges immediately to 0 or 1.   
						}else{
						mynewpr		<- mynewpr/sum(mynewpr)
						for (k in c(1:npops))
							{
							mypr[k] <- (j-1)*mypr[k]*mynewpr[k]
							}
						mypr		<- mypr/sum(mypr)
						myprmat[j,]	<- mypr
						}
					}
				}	
			myassign[i,]		<- myprmat[j,]
			if(docount)
				{
				# alternative way:						
				for (k in c(1:npops))
					{
					mycount		<- mycountmat[,k]
					myassignalt[i,k]<- length(mycount[mycount==TRUE&!is.na(mycount)])
					}
				}
			}else{
			# 23-3-2020: fast method:
			#
			# 05-04-2020: correct population allele frequency estimate, to avoid circularity:
			indpopnr			<- which(popnames==indpop)
			mymafsnew			<- mymafs
			if(!inds$filter[i])
				{
				# if set to FALSE, individual is not included in analyses, so it's genotype has not been considered when calculating population allele frequency
				# no need to correct
				newindpopmafs				<- as.vector(mymafs[,indpopnr])
				mymafsnew[,indpopnr]		<- newindpopmafs
				indgeno2					<- as.vector(indgeno)
				indgeno2[is.na(indgeno2)]	<- 3	# because NA-values can be interpreted as 1	
				boolmaf0					<- newindpopmafs!=0
				}else{
				indpopsize			<- nrow(inds[inds$pop==indpop&inds$filter,])
				indpopmafs			<- as.vector(mymafs[,indpopnr])
				indpopmacs			<- round(indpopmafs*indpopsize*2)		# 07-05-2020: if I do not round, I get strange values for new mafs, like -0.00000000000000005551115 instead of 0 
				indgeno2			<- as.vector(indgeno)
				indgeno2[is.na(indgeno2)]	<- 3	# because NA-values can be interpreted as 1			
				if(length(indgeno2)!=length(indpopmacs))
					{
					return(cat("ERROR: length indgeno2 does not equal length indpopmacs. Please contact developer of SambaR.",sep="\n"))
					}
				newnralleles		<- 2*(indpopsize-1)
				newindpopmafs		<- ifelse(indgeno2==3,indpopmafs,ifelse(indgeno2==2,(indpopmacs-2)/newnralleles,ifelse(indgeno2==1,(indpopmacs-1)/newnralleles,indpopmacs/newnralleles)))
				boolmaf0			<- newindpopmafs!=0
				mymafsnew			<- mymafs
				mymafsnew[,indpopnr]<- newindpopmafs
				if(any(newindpopmafs[!is.na(newindpopmafs)]<0))
					{
					testmafs		<<- mymafs
					testmafs2		<<- mymafsnew
					return(cat("ERROR: corrected minor allele frequency below 0. Please contact developer of SambaR.",sep="\n"))
					}
				if(any(newindpopmafs[!is.na(newindpopmafs)]>1))
					{
					testmafs		<<- mymafs
					testmafs2		<<- mymafsnew
					return(cat("ERROR: corrected minor allele frequency above 1. Please contact developer of SambaR.",sep="\n"))
					}
				}
			#
			for (k in c(1:npops))
				{	
				myhomomaj[,k]	<- (1-mymafsnew[,k])*(1-mymafsnew[,k])
				myhetero[,k]	<- 2*mymafsnew[,k]*(1-mymafsnew[,k])
				myhomomin[,k]	<- mymafsnew[,k]*mymafsnew[,k]
				myprop[,k]		<- ifelse(indgeno2==3,NA,ifelse(indgeno2==2,as.vector(myhomomin[,k]),ifelse(indgeno2==1,as.vector(myhetero[,k]),as.vector(myhomomaj[,k]))))
				}
			if(i==10000)		# this can be used when encountering problems. 
				{
				testboolmaf		<<- boolmaf0
				testgeno		<<- indgeno2
				testmafs		<<- mymafs
				testmafs2		<<- mymafsnew
				testprop		<<- myprop
				}
			myhomomajdf			<- myhomomaj
			myheterodf			<- myhetero
			myhomomindf			<- myhomomin
			#
			# 05-04-2020: filter out SNPs in which corrected minor allele frequency equals 0:
			mypropdf			<- myprop
			mypropdf			<- mypropdf[boolmaf0&indgeno2!=3,]
			if(any(boolmaf0&indgeno2!=3))
				{
				if(length(indgeno2[boolmaf0&indgeno2!=3])==1)
					{
					if(!silent){cat(paste("WARNING: only 1 retained data point for sample: ",as.vector(inds$name[i]),".",sep=""),sep="\n")}
					myprop3df	<- myprop
					myprop3df[nrow(myprop3df),]	<- rep(1/npops,npops)
					}else{
					nr_sites			<- nrow(mypropdf)
					if(nr_sites<mindata)
						{
						if(!silent){cat(paste("WARNING: Number of retained data points below minimum value specified by the mindata flag for sample: ",as.vector(inds$name[i]),".",sep=""),sep="\n")}
						}
					myprop2df			<- mypropdf/(rowSums(mypropdf))
					myprop3df			<- matrix(NA,nrow=nrow(myprop2df),ncol=ncol(myprop2df))
					myprop3df[1,]		<- myprop2df[1,]
					#cat(nr_sites,sep="\n")
					for(j in (2:nr_sites))
						{
						mynewpr			<- myprop2df[j,]
						if(any(is.na(mynewpr)))
							{
							mynewpr		<- rep(1/npops,npops)
							}
						mypr			<- (j-1)*myprop3df[j-1,]*mynewpr
						mypr_prop		<- mypr/sum(mypr)
						if(any(!is.finite(mypr_prop)))
							{
							myprop3df[j,]	<- round(myprop3df[j-1,])
							}else{
							myprop3df[j,]	<- mypr_prop
							}
						}
					}
				}else{
				if(!silent){cat(paste("WARNING: no retained data points for sample: ",as.vector(inds$name[i]),".",sep=""),sep="\n")}
				myprop3df	<- myprop
				myprop3df[nrow(myprop3df),]	<- rep(1/npops,npops) 
				}
			if(!silent)
				{
				myprop3df2	<<- myprop3df
				}
			myassign[i,]	<- myprop3df[nrow(myprop3df),]
			}
		myassign[myassign<0.0001]	<- 0
		myassign[myassign>0.9999]	<- 1
		if(docount)
			{
			for (i in c(1:nrow(myassignalt)))
				{
				mysum			<- sum(myassignalt[i,])
				myassignalt[i,] <- myassignalt[i,]/mysum
				}
			}
		}
	if(is.null(n_subset))
		{
		cat("Adding data to inds dataframe.",sep="\n")
		for (k in c(1:npops))
			{
			inds$prtemp		<<- myassign[,k]
			names(inds)[names(inds) == "prtemp"] <<- paste("pr",popnames[k],sep = "")
			}
		inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	# needed for plotting:
	mysambar$myassign	<<- myassign
	mysambar$myassign2	<<- t(myassign)
	if(docount)
		{
		mysambar$myassign3	<<- t(myassignalt)
		}
	if(is.null(n_subset))
		{
		mysambar$fulldata_myassign	<<- myassign
		}
	}

# depends on 'assign2pop' and 'multiplotassign'
# The structure is like this:
# multi_assign2pop calls assign2pop for each number of SNPs and saves the scores in popassignlist
# multi_assign2pop subsequently calls multiplotassign for plotting
# so the function 'plotassign2pop' is not used. This function is used for plotting one set of SNPs only (rather than for multiple subsets of SNPs) 

multi_assign2pop<-function(nsnp_vector=NULL,exporttype=NULL,top_popmaf_sd=FALSE)
	{
	if(is.null(mysambar$fulldata_myassign))
		{
		return(cat("Can not find object 'mysambar$fulldata_myassign'. First (re)run 'assign2pop(n_subset=NULL)' and try again.",sep="\n"))
		}
	fulldata_myassign	<- mysambar$fulldata_myassign
	if(nrow(fulldata_myassign)!=nrow(inds))
		{
		return("Number of rows of 'fulldata_myassign' differs from number of rows of 'inds' dataframe. Firs (re)run 'assign2pop(n_subset=NULL)' and try again.",sep="\n")
		}
	popmafs 	<- snps[,grep("maf_",colnames(snps))]
	mafmin		<- apply(popmafs,1,min)
	nodatavec	<- !is.na(rowSums(popmafs))
	myfilter	<- (snps$filter)&(mafmin>0)&(nodatavec)
	nsnps		<- nrow(snps[myfilter,])
	if(nsnps<500)
		{
		return(cat("Retained dataset contains less than 500 SNPs which have minor allele present in all populations. Skipping multi_assign2pop plot.",sep="\n"))
		}
	if(nsnps>500)
		{	
		nsnpvector=c(50,100,200,350,500)
		}
	if(nsnps>1000)
		{
		nsnpvector=c(50,100,200,500,1000)
		}
	if(nsnps>2000)
		{
		nsnpvector=c(50,100,500,1000,2000)
		}
	if(nsnps>5000)
		{
		nsnpvector=c(50,100,500,1000,5000)
		}
	if(!is.null(nsnp_vector))
		{
		nsnpvector=nsnp_vector
		}
	mysambar$nsnpallvector	<<- c(nsnpvector,nsnps)
	mysambar$popassignlist	<<-list()
	for(myrun in c(1:length(mysambar$nsnpallvector)))
		{
		nsubset	<- mysambar$nsnpallvector[myrun] 
		cat(paste(nsubset,"SNPs",sep=" "),sep="\n")
		if(myrun==length(mysambar$nsnpallvector))
			{
			if(any(!(paste("pr",mysambar$populations,sep="")%in%colnames(inds))))
				{
				assign2pop(top_popmafsd=top_popmaf_sd)
				}else{
				mysambar$myassign	<- 	inds[,paste("pr",mysambar$populations,sep="")]
				}
			}else{
			assign2pop(popnames=mysambar$populations,n_subset=nsubset,top_popmafsd=top_popmaf_sd)
			}
		mysambar$popassignlist[[myrun]]	<<- mysambar$myassign
		}
	names(mysambar$popassignlist)	<<- paste("nsnps",c(nsnpvector,nsnps),sep="_")
	# plot:
	multiplotassign(export=exporttype,top_popmafsd=top_popmaf_sd)
	}

multiplotassign<-function(mymatrixlist=mysambar$popassignlist,export=NULL,shortpop=NULL,popnames=mysambar$populations,addindnr=TRUE,mycol=mysambar$popassigncol,top_popmafsd=FALSE)
	{
	nsamples			<- nrow(inds[inds$filter,])
	nsets				<- length(mymatrixlist)
	#
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp		<- as.matrix(mygenlight)
	mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
	indstemp			<- inds[order(inds$pop),]
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	#
	if(!is.null(export))
		{
		myheight1	<- nsets*1.25+1.5
		myheight2	<- nsets*125+150
		mywidth1	<- nsamples*0.1+1.5
		mywidth2	<- nsamples*80+200
		indlabel	<- ifelse(addindnr,"indnr","noxaxis")
		maxsnps		<- names(mymatrixlist)[length(mymatrixlist)-1]
		maxsnps		<- ifelse(top_popmafsd,paste(maxsnps,"highestmafsd",sep="."),maxsnps)
		if(export=="eps"){postscript(paste("popassign.bayesian.multi",maxsnps,indlabel,"eps",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="pdf"){pdf(paste("popassign.bayesian.multi",maxsnps,indlabel,"pdf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="png"){png(paste("popassign.bayesian.multi",maxsnps,indlabel,"png",sep="."),"Structureplot.LEA.indnr.png",family=mysambar$myfont,width=560,height=myheight2)}
		if(export=="wmf"){win.metafile(paste("popassign.bayesian.multi",maxsnps,indlabel,"wmf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# get info needed for plot:
	mylocs			<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mypops		<- indstemp$pop[indstemp$filter]
		mylocs[i]	<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs2		<- mylocs
	#
	mysets		<- c(1:nsets)
	par(mfrow=c(nsets,1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	for(myset in mysets)
		{
		#cat(myset,sep="\n")	
		qmatrix		<- mymatrixlist[[myset]]
		qmatrix		<- qmatrix[order(inds$pop),]
		qmatrix		<- qmatrix[indstemp$filter,]
		if(myset==nsets&&addindnr)
			{
			mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,ifelse(nsamples>300,0.1,0.25),0.35),0.5)
			barplot(t(qmatrix),col=mycol,border=NA,space=0,xlab="",ylab="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}else{
			xpos	<- barplot(t(qmatrix),col=mycol,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			if(myset==1)
				{
				if(length(popnames)>3)
					{
					# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
					mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
					if(mylas==1)
						{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)
						}else{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)	# 14-07-2019: can't work out adjustment to the right
						}
					}else{
					if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)}
					}
				}
			}
		mtext(paste(mysambar$nsnpallvector[myset],"snps",sep=""),side=4,line=-0.75,cex=1.25)
		}
	mtext("Assignment probability",side=2,line=-1.5,outer=TRUE,cex=1.75)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=1.75)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=1.75)
		}
	if(!is.null(export)){dev.off()}
	}

plotassign2pop<-function(export=NULL,bayesian=TRUE,popnames=mysambar$populations,shortpop=NULL,addsamplenr=TRUE,myinset=-0.15,mycol=mysambar$popassigncol)
	{
	# count number of datapoints used in analysis:
	popmafs <- snps[,grep("maf_",colnames(snps))]
	mafmin	<- apply(popmafs,1,min)
	ndata	<- length(mafmin[mafmin>0&snps$filter])
	#
	# First create indstemp file with all samples clustered together per population:
	indstemp			<- inds[order(inds$pop),]
	nsamples			<- length(indstemp$name2[indstemp$filter])
	if(addsamplenr)
		{
		mylabels			<- indstemp$nr[indstemp$filter]
		}else{
		mylabels			<- rep("",nsamples)
		}
	myassign2			<- mysambar$myassign2[,order(inds$pop)]
	if(!bayesian)
		{
		myassign3		<- mysambar$myassign3[,order(inds$pop)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# get info needed for plot:
	mylocs	<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mypops		<- indstemp$pop[indstemp$filter]
		mylocs[i]	<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs		<- mylocs+1		# can not subset xpos with value 0
	npops		<- length(popnames)
	#
	# Now we are ready to plot:
	if(!is.null(export))
		{
		mywidth		<- nsamples*0.25+8
		mywidth2	<- nsamples*25+800
		myheight	<- ifelse(nsamples<80,6.5,mywidth/4)
		myheight2	<- 650
		plotname	<- ifelse(addsamplenr,paste("popassign.bayesian.withsamplenr",paste(ndata,"snps",sep=""),sep="."),paste("popassign.bayesian",paste(ndata,"snps",sep=""),sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}	
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	par(mar=c(4.5,8,5.5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(bayesian)
		{
		# plot bayesian probability:
		mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,0.75,1),1.5)
		xpos		<- barplot(myassign2[,indstemp$filter],ylab="",col=mycol,space=0,border=NA,names.arg=mylabels,cex.names=mycex,las=2)
		mtext("Bayesian probability",cex=3.5,side=2,line=5)
		if(length(popnames)>3)
			{
			mylocs		<- xpos[mylocs]
			mylocs		<- mylocs-mylocs[which(mylocs==min(mylocs))]		# because xpos gives midpoint of bars.
			abline(v=mylocs,lwd=3.5)
			mylas		<- ifelse(any(table(indstemp$pop[indstemp$filter])<3),3,1)
			if(mylas==1)
				{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=3.5,las=mylas)
				}else{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=3.5,las=mylas)
				}
			}else{
			mylocs		<- xpos[mylocs]
			mylocs		<- mylocs-mylocs[which(mylocs==min(mylocs))]		# because xpos gives midpoint of bars.
			if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=3.5)}
			if(length(popnames>1)){abline(v=mylocs,lwd=3.5)}
			}
		}else{
		# plot counts: how many times a locus most likely to be drawn from population k:
		#barplot(myassign3[,indstemp$filter],ylab="",col=mycol,border=NA,legend=popnames,args.legend=list(x="topright",bty = "n",inset=c(-0.07,0),cex=2.25),names.arg=mylabels,cex.names=1.5,las=2)
		barplot(myassign3[,indstemp$filter],ylab="",col=mycol,border=NA,names.arg=mylabels,cex.names=1.5,las=2)
		mtext("Bayesian probability",cex=3,side=2,line=5)
		}
	if(!is.null(export)){dev.off()}
	}

plotstructure<-function(qmatrixlist=NULL,colourvector=NULL,plotname="Structureplot",export=NULL,shortpop=NULL,popnames=mysambar$populations,poporder=NULL,addindnr=TRUE,order_on_longitude=FALSE)
	{
	# poporder does not work yet
	# input is either:
	# - name of list with qmatrices to qmatrixlist flag
	# - or txt files with qmatrices in inputfilesdir (if qmatrixlist is set to NULL (default) 
	if(is.null(qmatrixlist))
		{
		setwd(mysambar$inputfilesdir)
		cat("Searching for file names ending on 'qmatrix.txt' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		filenames 	<- list.files(pattern = ".*.qmatrix.txt")
		if(length(filenames)==0)
			{
			return(cat("ERROR: the directory does not contain files ending on 'qmatrix.txt'.",sep="\n"))
			}
		filenames	<- filenames[order(filenames,decreasing=F)]
		qmatrixlist <- lapply(filenames,function(x)read.table(x,header=FALSE)) 
		}
	nmatrices	<- length(qmatrixlist) 
	nsamples	<- nrow(qmatrixlist[[1]])
	maxdemes	<- ncol(qmatrixlist[[1]])
	npops		<- length(popnames)
	mydemes		<- vector()
	#
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			}
		}
	#
	for(i in 1:nmatrices)
		{
		mydemes[i]	<- ncol(qmatrixlist[[i]])
		}
	if(nsamples==nrow(inds))
		{
		cat("Number of samples in input file equals total number of individuals in inds dataframe.",sep="\n")
		cat("Sambar will assume that samples in input file have the same names are in the same order (i.e. alphabetical) as in inds$name column.",sep="\n")
		dofilter	<- FALSE		
		mysamples	<- inds$name
		}else{
		if(nsamples==nrow(inds[inds$filter,]))
			{	
			cat("Number of samples in input file equals total number of retained individuals in inds dataframe.",sep="\n")
			cat("Sambar will assume that samples in input file have the same names are in the same order as in inds$name[inds$filter] column.",sep="\n")
			dofilter	<- TRUE
			mysamples	<- inds$name[inds$filter]
			}else{
			return(cat("ERROR: Number of samples in input file does not correspond with (retained or total) number of individuals in inds dataframe.",sep="\n"))
			}
		}
	nsamples		<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		myheight1	<- nmatrices*1.25+1.5
		myheight2	<- nmatrices*125+150
		if(addindnr)
			{
			mywidth1	<- nsamples*0.15+1.5
			mywidth2	<- nsamples*20+200
			}else{
			mywidth1	<- 8
			mywidth2	<- 560
			}
		orderlabel	<- ifelse(order_on_longitude,"geo","alphabet")
		indlabel	<- ifelse(addindnr,"indnr","noxaxis")
		if(export=="eps"){postscript(paste(plotname,orderlabel,indlabel,"eps",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}	# width=8
		if(export=="pdf"){pdf(paste(plotname,orderlabel,indlabel,"pdf",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		if(export=="png"){png(paste(plotname,orderlabel,indlabel,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,orderlabel,indlabel,"wmf",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		}
	if(is.null(colourvector))
		{	
		colourvector	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	if(maxdemes>length(colourvector))
		{
		cat("ERROR: maxdemes exceeds number of colours.",sep="\n")
		return(cat("Redefine the flag maxdemes or the flag colourvector. If running the findstructure() function, redefine the flag K_max or the flag colour_vector.",sep="\n"))
		}else{
		colourvector	<- colourvector[1:length(colourvector)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp		<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		if(is.null(poporder))
			{
			mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
			indstemp			<- inds[order(inds$pop),]
			}else{
			mymatrixtemp		<- mymatrixtemp[order(inds$poporder),]
			indstemp			<- inds[order(inds$poporder),]
			popnames			<- popnames[my_order]
			}
		}else{
		if("longitude3"%in%colnames(inds))
			{
			cat("Ordering based on longitude3...",sep="\n")
			popcoorddf			<- inds[,c("pop","longitude3","latitude")]
			}else{
			cat("Ordering based on longitude...",sep="\n")
			popcoorddf			<- inds[,c("pop","longitude","latitude")]
			}
		names(popcoorddf)	<- c("pop","longitude","latitude")
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop			<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$poplat[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		shortpop			<- shortpop[order(poplong$x)]
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	mygenlighttemp		<- as.genlight(mymatrixtemp)
	pop(mygenlighttemp)	<- as.factor(indstemp$pop)
	nsamples			<- nrow(indstemp[indstemp$filter,])
	# get info needed for plot:
	mylocs				<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop			<- popnames[i]
		mypops			<- indstemp$pop[indstemp$filter]
		mylocs[i]		<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	#
	par(mfrow=c(length(mydemes),1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	for(k in c(1:nmatrices))
		{
		ndemes		<- mydemes[k] 
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		qmatrix 	<- qmatrixlist[[k]]
		if(dofilter)
			{
			filteredinds<- inds[inds$filter,]
			if(!order_on_longitude)
				{
				qmatrix		<- qmatrix[order(filteredinds$pop),]
				}else{
				qmatrix		<- qmatrix[order(filteredinds$poplong),]
				}
			}else{
			if(!order_on_longitude)
				{
				qmatrix		<- qmatrix[order(inds$pop),]
				}else{
				qmatrix		<- qmatrix[order(inds$poplong),]
				}
			}
		mycolours	<- colourvector[1:ndemes]
		if(k==nmatrices&&addindnr)
			{
			#mycex		<- ifelse(maxdemes<4,0.5,0.75)
			# mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,0.25,0.35),0.5)	# 28-01-2020
			mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,ifelse(nsamples>300,0.1,0.25),0.35),0.5)
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}else{
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}
		if(k==1)
			{
			if(length(popnames)>3)
				{
				# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
				mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
				if(mylas==1)
					{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)
					}else{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)	# 14-07-2019: can't work out adjustment to the right
					}
				}else{
				if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)}
				}
			}
		mtext(paste("K = ",ndemes,sep=""),side=4,line=-0.75,cex=1.5)
		}
	mtext("Ancestry coefficients",side=2,line=-1.5,outer=TRUE,cex=1.75)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=1.75)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=1.75)
		}
	names(qmatrixlist)	<- paste("K",mydemes,sep="_")
	qmatrixlist			<<- qmatrixlist
	if(!is.null(export))
		{
		dev.off()
		cat("Structure plot exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}	
		
plotassign2pop_hetero<-function(popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	#pdf("popassign.bayesian.vshetero.pdf",width=5,height=npops*1.25)
	pdf("popassign.bayesian.vshetero.pdf")
	par(cex.axis=1.5,cex.lab=2,mar=c(5,5,1,1))
	#par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
	#mymax		<- max(inds$hetero,na.rm=TRUE)
	#mymax		<- max(inds$maf,na.rm=TRUE)
	#mymax		<- max(inds$maf_all,na.rm=TRUE)
	#mymax		<- max(inds$n0,na.rm=TRUE)
	#mymax		<- max(inds$n1,na.rm=TRUE)
	#mymax		<- max(inds$n2,na.rm=TRUE)
	for (j in c(1:npops))
		{
		mypop	<- popnames[j]
		mypr	<- inds[,paste("pr",mypop,sep="")]
		#plot(inds$hetero[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$maf[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$maf_all[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n0[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n1[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n2[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		firstn	<- inds$n1/inds$nsites2
		secondn	<- inds$n2/inds$nsites2
		myxlim	<- c(min(firstn,na.rm=TRUE),max(firstn,na.rm=TRUE))
		myylim	<- c(0,max(secondn,na.rm=TRUE))
		if(j==1)
			{
			plot(firstn[inds$pop==mypop],secondn[inds$pop==mypop],col=mycolours[j],pch=16,cex=2,xlim=myxlim,ylim=myylim,ylab="Proportion minor homozygous sites",xlab="Proportion heterozygous sites")
			points(firstn[inds$pop==mypop&mypr<1],secondn[inds$pop==mypop&mypr<1],pch=17,cex=3,col=mycolours[j])
			}else{
			points(firstn[inds$pop==mypop],secondn[inds$pop==mypop],col=mycolours[j],pch=16,cex=2)
			points(firstn[inds$pop==mypop&mypr<1],secondn[inds$pop==mypop&mypr<1],pch=17,cex=3,col=mycolours[j])
			}
		}
	#mtext("Heterozygosity",side=1,outer=TRUE,line=0.5)
	#mtext("Bayesian probability",side=2,outer=TRUE,line=-0.75)
	legend("topright",legend=c("Pr==1","Pr<1"),pch=c(16,17),cex=2,bty='n')
	dev.off()
	}	

runLEA<-function(mindemes=2,maxdemes=6,popnames=mysambar$populations,order_on_longitude=FALSE,focuspop=NULL,poporder=NULL,dolong3=FALSE,myploidy=2)
	{
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		}
	inds	<<- inds
	#
	# Export data:
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp			<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		if(is.null(poporder))
			{
			mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
			indstemp			<- inds[order(inds$pop),]
			}else{
			mymatrixtemp		<- mymatrixtemp[order(inds$poporder),]
			indstemp			<- inds[order(inds$poporder),]
			popnames			<- popnames[my_order]
			}
		}else{
		if(any(inds$longitude<120,na.rm=TRUE)&any(inds$longitude>120,na.rm=TRUE))
			{
			cat("WARNING: whilst running runLEA function, samples observed close to -180 and 180 degrees longitude. using inds$longitude2 column to order on longitude.",sep="\n")
			if(dolong3)
				{
				popcoorddf			<- inds[,c("pop","longitude3","latitude")]		
				}else{
				popcoorddf			<- inds[,c("pop","longitude2","latitude")]
				}
			colnames(popcoorddf)<- c("pop","longitude","latitude")
			}else{
			popcoorddf			<- inds[,c("pop","longitude","latitude")]
			}
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop			<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$latlong[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		#shortpop			<- shortpop[order(poplong$x)]
		}
	#mymatrixtest		<<- mymatrixtemp
	#indstest			<<- indstemp 
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(!is.null(focuspop))
		{
		mymatrixtemp		<- mymatrixtemp[indstemp$pop==focuspop,]
		indstemp			<- indstemp[indstemp$pop==focuspop,]
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		pop(mygenlighttemp)	<- as.factor(indstemp$pop2)
		}else{
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		pop(mygenlighttemp)	<- as.factor(indstemp$pop)
		}
	genlight2ped(exportname="LEAinput",input=mygenlighttemp,in_inds=indstemp,indsfilter=indstemp$filter)
	#
	# Reading data:
	# sambarfunction_findstructure:
	### LEA admixture analyses:
	# sambarfunction_findstructure:
	LEA_input		<- LEA::ped2geno("LEAinput.ped","LEAinput.geno")
	obj.snmf		<- LEA::snmf("LEAinput.geno",K=mindemes:maxdemes,ploidy=myploidy,entropy=T,alpha=100,project="new")
	# Creating LEA matrices:
	mydemes			<- c(mindemes:maxdemes)
	totalnr			<- length(mydemes)
	#leaqmatrixlist	<- list()
	leaqmatrixlist	<- vector(mode="list",length=length(totalnr))
	#for(ndemes in mydemes)
	for(mynr in c(1:totalnr))
		{
		ndemes		<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		# sambarfunction_findstructure:
		obj.snmf	<- LEA::snmf("LEAinput.geno", K = ndemes, alpha = 100, project = "new")
		# sambarfunction_findstructure:
		qmatrix 	<- LEA::Q(obj.snmf, K = ndemes)
		#leaqmatrixlist[[ndemes-1]]	<- qmatrix
		leaqmatrixlist[[mynr]]		<- qmatrix
		}
	names(leaqmatrixlist)	<- paste("K",mydemes,sep="_")
	if(order_on_longitude)
		{
		mysambar$leaqmatrixlist_longitude	<<- leaqmatrixlist
		}else{
		mysambar$leaqmatrixlist				<<- leaqmatrixlist
		}
	#
	# to subsequently create pca:
	# mypc = pca("LEAinput.geno", scale = TRUE)
	# plot(mypc$projections,col=indstemp$popcol[indstemp$filter],pch=16)
	# remove.pcaProject("LEAinput.pcaProject")
	# sambarfunction_findstructure:
	remove.snmfProject("LEAinput.snmfProject")
	# if function above doesn't work, delete directory and files like this:
	# sambarfunction_findstructure:
	unlink("LEAinput.snmf", recursive=TRUE)
	}

# Note: input to poporder should be the same as for runLEA, otherwise output does not make sense.
LEAstructureplot<-function(mymatrixlist=NULL,mindemes=2,maxdemes=6,side4labels=NULL,heightfactor=0.75,widthfactor=0.1,focuspop=NULL,colourvector=NULL,export=NULL,exportname=NULL,shortpop=NULL,popnames=mysambar$populations,poporder=NULL,addindnr=TRUE,order_on_longitude=FALSE,dolong3=FALSE,silent=TRUE,axiscex=1.5,labelcex=1.75,yaxiscex=1.25,shortpop_nrchars=3)
	{
	if(is.null(shortpop))
		{
		if(!silent){cat("WARNING: no input vector provided to shortpop flag.",sep="\n")}
		}
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		if(any(is.na(popnames)))
			{
			return(cat("ERROR: NA-value in popnames vector.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			}
		}
	#
	if(is.null(mymatrixlist))
		{
		if(order_on_longitude)
			{
			leaqmatrixlist	<- mysambar$leaqmatrixlist_longitude
			}else{
			leaqmatrixlist	<- mysambar$leaqmatrixlist
			}
		}else{
		leaqmatrixlist		<- mymatrixlist
		}
	nsamples		<- nrow(inds[inds$filter,])
	#
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp			<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		if(is.null(poporder))
			{
			mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
			indstemp			<- inds[order(inds$pop),]
			}else{
			mymatrixtemp		<- mymatrixtemp[order(inds$poporder),]
			indstemp			<- inds[order(inds$poporder),]
			popnames			<- popnames[my_order]
			}
		}else{
		if(any(inds$longitude<120,na.rm=TRUE)&any(inds$longitude>120,na.rm=TRUE))
			{
			cat("WARNING: samples observed close to -180 and 180 degrees longitude. using inds$longitude2 column to order on longitude.",sep="\n")
			if(dolong3)
				{
				popcoorddf			<- inds[inds$filter,c("pop","longitude3","latitude")]		
				}else{
				popcoorddf			<- inds[inds$filter,c("pop","longitude2","latitude")]
				}
			colnames(popcoorddf)<- c("pop","longitude","latitude")
			}else{
			popcoorddf			<- inds[,c("pop","longitude","latitude")]
			}
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop							<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$latlong[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		#shortpop			<- shortpop[order(poplong$x)]
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(!is.null(focuspop))
		{
		mymatrixtemp		<- mymatrixtemp[indstemp$pop==focuspop,]
		indstemp			<- indstemp[indstemp$pop==focuspop,]
		myindpops			<- indstemp$pop2
		}else{
		myindpops			<- indstemp$pop		
		}
	#
	ndemes				<- maxdemes-mindemes
	if(!is.null(export))
		{
		heightfactor2	<- 100*heightfactor
		widthfactor2	<- 100*widthfactor
		myheight1		<- (ndemes+1)*heightfactor+1.5
		myheight2		<- (ndemes+1)*heightfactor2+150
		mywidth1		<- nsamples*widthfactor+1.5
		mywidth2		<- nsamples*widthfactor2+200
		orderlabel		<- ifelse(order_on_longitude,"geo","alphabet")
		indlabel		<- ifelse(addindnr,"indnr","noxaxis")
		poplabel		<- ifelse(is.null(focuspop),"metapop",focuspop)
		exportname		<- ifelse(is.null(exportname),"Structureplot.LEA",paste(exportname,"structureplot.LEA",sep="."))
		if(export=="eps"){postscript(paste(exportname,poplabel,orderlabel,indlabel,"eps",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="pdf"){pdf(paste(exportname,poplabel,orderlabel,indlabel,"pdf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="png"){png(paste(exportname,poplabel,orderlabel,indlabel,"png",sep="."),"Structureplot.LEA.indnr.png",family=mysambar$myfont,width=560,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(exportname,poplabel,orderlabel,indlabel,"wmf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		}
	if(is.null(colourvector))
		{
		colourvector	<- mysambar$mycolours
		}
	if(length(colourvector)<maxdemes)
		{
		sambarcolours	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		colourtemp		<- colourvector
		colourvector	<- c(colourtemp,sambarcolours[!sambarcolours%in%colourtemp])
		if(length(colourvector)<maxdemes){cat("WARNING: maxdemes exceeds number of colours.",sep="\n")} 
		}
	if(ndemes>length(colourvector))
		{
		cat("ERROR: maxdemes exceeds number of colours.",sep="\n")
		return(cat("Redefine the flag maxdemes or the flag colourvector. If running the findstructure() function, redefine the flag K_max or the flag colour_vector.",sep="\n"))
		}else{
		colourvector	<- colourvector[1:length(colourvector)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,shortpop_nrchars)
			}
		}
	nsamples		<- nrow(indstemp[indstemp$filter,])
	# get info needed for plot:
	mylocs			<- vector()
	mypopcols		<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		if(!silent){cat(mypop,sep="\n")}
		#mypops		<- indstemp$pop[indstemp$filter]
		mypops		<- myindpops[indstemp$filter]
		mylocs[i]	<- as.vector(which(mypops==mypop)[1]-1)
		mypopcols[i]<- mysambar$mycolours2[which(mysambar$populations2==mypop)]
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	#mylocs2	<<- mylocs
	#
	mydemes		<- c(mindemes:maxdemes)
	totalnr		<- length(mydemes)
	par(mfrow=c(length(mydemes),1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=yaxiscex,cex.lab=2.5,cex.main=2.5)
	#for(ndemes in mydemes)
	for(mynr in c(1:totalnr))
		{
		ndemes		<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		#qmatrix	<- leaqmatrixlist[[ndemes-1]]
		qmatrix		<- leaqmatrixlist[[mynr]]
		rownames(qmatrix)	<- NULL				# added on 17-08-2021 (if rownames are present, they appear in plot)
		mycolours	<- colourvector[1:ndemes]
		#if(ndemes==maxdemes&&addindnr)
		if(mynr==totalnr&&addindnr)
			{
			#mycex		<- ifelse(maxdemes<4,0.5,0.75)
			mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,ifelse(nsamples>300,0.1,0.25),0.35),0.5)
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}else{
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			#if(ndemes==mindemes)
			if(mynr==1)
				{
				if(length(popnames)>3)
					{
					# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
					#mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
					mylas	<- ifelse(any(table(myindpops[indstemp$filter])<6),3,1)
					if(mylas==1)
						{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=axiscex,las=mylas,col=mypopcols)
						}else{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=axiscex,las=mylas,col=mypopcols)	# 14-07-2019: can't work out adjustment to the right
						}
					}else{
					if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=axiscex)}
					}
				}
			}
		if(is.null(side4labels))
			{
			mtext(paste("K = ",ndemes,sep=""),side=4,line=-0.75,cex=axiscex)
			}else{
			mtext(side4labels[mynr],side=4,line=-0.75,cex=axiscex)
			}
		}
	mtext("Ancestry coefficients",side=2,line=-1.5,outer=TRUE,cex=labelcex)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=labelcex)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=labelcex)
		}
	if(!is.null(export)){dev.off()}
	}

maplea<-function(maxdemes=6,radiusratio=30,exporttype=NULL,popnames=mysambar$populations,plotperpop=FALSE,addlabels=FALSE)
	{
	npops			<- length(popnames)
	indstemp		<- inds[order(inds$pop),]
	mycoord			<- indstemp[indstemp$filter,c("longitude","latitude")]
	mypopnames		<- indstemp$pop[indstemp$filter]
	mysamplenrs		<- indstemp$nr[indstemp$filter]
	mydemes			<- c(2:maxdemes)
	totalnr			<- length(mydemes)
	#for(ndemes in mydemes)
	for(mynr in c(1:totalnr))
		{
		ndemes			<- mydemes[mynr]
		#myqmatrix		<- mysambar$leaqmatrixlist[[ndemes-1]]
		myqmatrix		<- mysambar$leaqmatrixlist[[mynr]]
		export_name		<- paste("LEA.qmatrixmap.K",ndemes,sep="")
		my_title		<- paste("K = ",ndemes,sep="")
		mapqmatrix(coord=mycoord,qmatrix=myqmatrix,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mytitle=my_title)
		if(plotperpop&npops>1)
			{
			for(my_pop	in popnames)
				{
				popqmatrix	<- myqmatrix[mypopnames==my_pop,]
				popcoord	<- mycoord[mypopnames==my_pop,]
				if(addlabels)
					{
					export_name	<- paste(paste("LEA.qmatrixmap.K",ndemes,"withlabels",sep=""),my_pop,sep=".")
					}else{
					export_name	<- paste(paste("LEA.qmatrixmap.K",ndemes,sep=""),my_pop,sep=".")
					}
				my_title	<- paste("K = ",ndemes,sep="")
				my_title2	<- my_pop
				if(addlabels)
					{
					my_labels	<- mysamplenrs[mypopnames==my_pop]
					}else{
					my_labels	<- NULL
					}
				if(nrow(unique(popcoord))==1)
					{
					cat(paste("Only one geographical position found for",my_pop,"population. Skipping.",sep=" "),sep="\n")
					}else{
					mapqmatrix(coord=popcoord,qmatrix=popqmatrix,aligncolours=FALSE,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mylabels=my_labels,mytitle=my_title,mytitle2=my_title2)
					}
				}
			}
		}
	}

mapdapc<-function(maxdemes=5,radiusratio=30,exporttype=NULL,popnames=mysambar$populations,plotperpop=FALSE,addlabels=FALSE)
	{
	mycoord			<- inds[inds$filter,c("longitude","latitude")]
	mypopnames		<- inds$pop[inds$filter]
	npops			<- length(mysambar$populations)
	mysamplenrs		<- inds$nr[inds$filter]
	mydemes			<- c(2:maxdemes)
	for(ndemes in mydemes)
		{
		myqmatrix		<- mysambar$dapcqmatrixlist[[ndemes-1]]
		export_name		<- paste("dapc.qmatrixmap.K",ndemes,sep="")
		export_name		<- paste(export_name,"meta",sep=".")
		my_title		<- paste("K = ",ndemes,sep="")
		mapqmatrix(coord=mycoord,qmatrix=myqmatrix,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mytitle=my_title)
		if(plotperpop&npops>1)
			{
			for(my_pop	in popnames)
				{
				popqmatrix	<- myqmatrix[mypopnames==my_pop,]
				popcoord	<- mycoord[mypopnames==my_pop,]
				if(addlabels)
					{
					export_name	<- paste(paste("dapc.qmatrixmap.K",ndemes,"withlabels",sep=""),my_pop,sep=".")
					}else{
					export_name	<- paste(paste("dapc.qmatrixmap.K",ndemes,sep=""),my_pop,sep=".")
					}
				my_title	<- paste("K = ",ndemes,sep="")
				my_title2	<- my_pop
				if(addlabels)
					{
					my_labels	<- mysamplenrs[mypopnames==my_pop]
					}else{
					my_labels	<- NULL
					}
				popunique	<- unique(popcoord)
				if(nrow(popunique)==1)
					{
					cat(paste("Only 1 geographical position found for",my_pop,"population. Skipping.", sep=" "),sep="\n")
					}else{
					mapqmatrix(coord=popcoord,qmatrix=popqmatrix,aligncolours=FALSE,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mylabels=my_labels,mytitle=my_title,mytitle2=my_title2)
					}
				}
			}
		}
	}
	
mapqmatrix<-function(coord=NULL,qmatrix=NULL,popnames=mysambar$populations,mycols=NULL,radius_ratio=30,doinstall=FALSE,aligncolours=TRUE,export=NULL,exportname="qmatrix.map",mylabels=NULL,mytitle=NULL,mytitle2=NULL,silent=TRUE)
	{
	# radius_ratio is the ratio between radius and either longitude or latitude span (the smaller of the two)
	# e.g: if longitude ranges from 10 to 20, and radius_ratio is set to 40, the radius of the piecharts will equal 10/40 = 0.25. 
	if(is.null(coord))
		{
		return(cat("ERROR: you should input a matrix with geographical coordinates (i.e. longitude and latitude) of your samples to coord flag",sep="\n"))
		}
	if(is.null(qmatrix))
		{
		return(cat("ERROR: you should input a qmatrix to qmatrix flag.",sep="\n"))
		}
	if(is.null(mycols))
		{
		mycols	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	if(doinstall)
		{
		myrepos='http://cran.us.r-project.org'
		# add.pie function is part of package mapplots:
		install.packages("mapplots",repos='http://cran.us.r-project.org')
		library(mapplots)
		# geographical map from rworldmap:
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos)}
		if("rworldmap" %in% (.packages()) == FALSE) 					{library(rworldmap)}
		}
	npops		<- length(popnames)
	nclusters	<- ncol(qmatrix)
	ncolours	<- ifelse(nclusters>npops,nclusters,npops)
	# attempt to get colours aligned with population colours:
	if(aligncolours&npops>1&nclusters<=npops)
		{
		mycols			<- mycols[1:ncolours]
		popcoord		<- data.frame(pop=popnames,col=mycols,long=NA,lat=NA)
		for(mypop in popnames)
			{
			popcoord$long[popcoord$pop==mypop]	<- mean(inds$longitude[inds$pop==mypop&inds$filter])
			popcoord$lat[popcoord$pop==mypop]	<- mean(inds$latitude[inds$pop==mypop&inds$filter])
			}
		myqdf				<- as.data.frame(qmatrix)
		myqdf$max			<- apply(qmatrix,1,which.max)	
		myqdf$colour		<- NA
		mycolours			<- vector()
		for(i in c(1:ncol(qmatrix)))
			{
			mylong			<- mean(coord$longitude[myqdf$max==i])
			mylat			<- mean(coord$latitude[myqdf$max==i])
			mycol			<- as.vector(popcoord$col[which.min(abs(mylong-popcoord$long)+abs(mylat-popcoord$lat))])
			myqdf$colour[myqdf$max==i]	<- mycol
			mycolours[i]	<- mycol
			}
		if(any(duplicated(mycolours)))
			{
			cat("No clear agreement between geographic locations of predefined populations and those of the inferred clusters.",sep="\n")
			cat("Defaulting to random colour assignment.",sep="\n")
			mycolours			<- mycols[1:ncolours]
			}
		}else{
		mycolours				<- mycols[1:ncolours]
		}
	# plot:
	newmap 		<- getMap(resolution = "low")
	myratio		<- (max(coord$longitude)-min(coord$longitude))/max((coord$latitude)-min(coord$latitude))
	if(!is.null(export))
		{
		if(myratio<1)
			{
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8/myratio,width=6)}
			}else{
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8,width=6*myratio)}
			}
		if(!silent){cat(paste("Writing pdf file called:", exportname,sep=" "),sep="\n")}
		}
	#testcoord	<<- coord
	plot(coord,xlab="",ylab="",type="n",las=1)
	plot(newmap,add=T,col="grey90",border="white")
	box(col="grey90")
	longrange	<- max(coord$longitude)-min(coord$longitude)
	latrange	<- max(coord$latitude)-min(coord$latitude)
	if(latrange<longrange)
		{
		myradius	<- latrange/radius_ratio
		}else{
		myradius	<- longrange/radius_ratio
		}
	for (i in 1:nrow(qmatrix))
		{
		add.pie(z=qmatrix[i,],x=coord[i,1],y=coord[i,2],labels="",radius=myradius,col=mycolours)
		}
	if(!is.null(mylabels))
		{
		text(mylabels,x=coord[,1],y=coord[,2],cex=1,col="white")
		}
	mtext("Longitude",side=1,line=2.75,cex=1.5)
	mtext("Latitude",side=2,line=2.75,cex=1.5)
	if(!is.null(mytitle)){mtext(mytitle,side=3,line=0,cex=1.5)}
	if(!is.null(mytitle2)){mtext(mytitle2,side=3,line=1.25,cex=1.5)}
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Closed pdf file.",sep="\n")}
		}
	}	

# create map using Rworldmap
plotlocations<-function(export=NULL,mygeodf=NULL,mygeofile=NULL,adjustratio=1,addlegend=FALSE,exportname="sample_locations",mytitle=NULL,mytitle2=NULL,silent=TRUE,margin=0.1,addaxislabels=FALSE,my_pch=NULL,my_col=NULL,mycex=3,mydeviation=NULL)
	{
	# mygeodf should be a dataframe with at least the columns 'longitude' and 'latitude'
	# mygeofile should be a tab separated txt file with at least the columns 'longitude' and 'latitude'
	mycols			<- NULL
	if(is.null(mygeodf)&is.null(mygeofile))
		{
		cat("Flags 'mygeodf' and 'mygeofile' set to NULL (default). Assuming to find within inds dataframe columns called 'longitude' and 'latitude'.",sep="\n")
		if(!"longitude"%in%colnames(inds)|!"latitude"%in%colnames(inds))
			{
			return(cat("Columns 'longitude' and 'latitude' not present in inds dataframe.",sep="\n"))
			}
		coord		<- inds[inds$filter,c("longitude","latitude")]
		mycols		<- inds$popcol[inds$filter]
		}else{
		if(!is.null(mygeofile))
			{
			mygeo		<- read.table(mygeofile,header=TRUE,sep="\t")
			}else{
			mygeo		<- mygeodf
			}
		coord		<- mygeo[,c("longitude","latitude")]
		}
	if(is.null(my_col))
		{
		if(is.null(mycols))
			{
			mycols		<- rep("black",nrow(coord))
			}
		}else{
		mycols		<- as.character(my_col)
		}
	if(is.null(my_pch))
		{
		mypch		<- 19
		}else{
		mypch		<- my_pch
		}
	if(is.factor(coord$latitude))
		{
		coord$latitude	<-  as.numeric(sub(",",".",as.character(coord$latitude)))
		}
	if(is.factor(coord$longitude))
		{
		coord$longitude	<-  as.numeric(sub(",",".",as.character(coord$longitude)))
		}
	cat("Matrix with geographical coordinates has been stored under the name 'mygeocoord'.",sep="\n")
	mygeocoord		<<- coord
	if(!is.null(mydeviation))
		{
		if(is.null(mygeodf)&is.null(mygeofile))
			{
			indstemp	<- inds[inds$filter,]
			if(!"do_coordshuffle"%in%colnames(inds))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent from inds dataframe. Shuffling all data points.",sep="\n")
				indstemp$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}else{
			if(!"do_coordshuffle"%in%colnames(mygeo))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent in mygeo. Shuffling all data points.",sep="\n")
				mygeo$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}
		}
	newmap 		<- getMap(resolution = "low")
	myratio		<- (max(coord$longitude,na.rm=TRUE)-min(coord$longitude,na.rm=TRUE))/(max(coord$latitude,na.rm=TRUE)-min(coord$latitude,na.rm=TRUE))
	if(!is.null(export))
		{
		plotname		<- ifelse(addaxislabels,paste(exportname,"withaxes",sep="."),paste(exportname,"no_axes",sep="."))
		adjustlabel		<- paste("ratio",adjustratio,sep="")
		deviationlabel	<- ifelse(is.null(mydeviation),"exactlocation","withdeviation")
		if(myratio<1)
			{
			if(export=="pdf"){pdf(paste(plotname,adjustlabel,deviationlabel,"Rworldmap.pdf",sep="."),height=adjustratio*8/myratio,width=6)}
			}else{
			if(export=="pdf"){pdf(paste(plotname,adjustlabel,deviationlabel,"Rworldmap.pdf",sep="."),height=8,width=adjustratio*6*myratio)}
			}
		if(!silent){cat(paste("Writing pdf file called:", exportname,sep=" "),sep="\n")}
		}
	if(addaxislabels)
		{
		par(cex.axis=1.5,oma=c(1,2,0.5,0.5))
		plot(coord,xlab="",ylab="",type="n",las=1,col="white")
		}else{
		plot(coord,xlab="",ylab="",type="n",las=1,xaxt='n',yaxt='n',col="white")
		}
	plot(newmap,add=T,col="grey70",border="white")
	points(coord,col=mycols,cex=mycex,pch=mypch)
	box(col="grey70")
	if(addaxislabels)
		{
		mtext("Longitude",side=1,line=3,cex=2)
		mtext("Latitude",side=2,line=4,cex=2)
		}
	if(!is.null(mytitle)){mtext(mytitle,side=3,line=0,cex=1.5)}
	if(!is.null(mytitle2)){mtext(mytitle2,side=3,line=1.25,cex=1.5)}
	if(addlegend){legend("bottomleft",legend=c("NCBI","sequenced","new_samples_to_be_sequenced"),pch=c(16,15,17),bty='n',cex=3.5)}
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Closed pdf file.",sep="\n")}
		}
	}		

# depends on plotlocations2
plotfossils<-function(adjustlong=TRUE)
	{
	x			<- read.table("brownbearfossil_pbdb_data.tsv",skip=17,sep="\t",header=TRUE)
	y			<- x[,c("early_interval","max_ma","min_ma","lng","lat")]
	colnames(y)	<- c("early_interval","max_ma","min_ma","longitude","latitude")
	y$col		<- ifelse(y$min_ma==0&y$max_ma==0.0117,"darkgreen",ifelse(y$min_ma==0.0117&y$max_ma==0.126,"blue",ifelse(y$min_ma==0.126&y$max_ma==0.781,"darkred",NA)))
	y$bool		<- ifelse(y$min_ma==0&y$max_ma==0.0117,TRUE,ifelse(y$min_ma==0.0117&y$max_ma==0.126,TRUE,ifelse(y$min_ma==0.126&y$max_ma==0.781,TRUE,FALSE)))
	y$period	<- ifelse(y$min_ma==0&y$max_ma==0.0117,"0-11.7 Kya",ifelse(y$min_ma==0.0117&y$max_ma==0.126,"11.7-126 Kya",ifelse(y$min_ma==0.126&y$max_ma==0.781,"126-781 Kya",NA)))
	y$pch		<- ifelse(y$min_ma==0&y$max_ma==0.0117,1,ifelse(y$min_ma==0.0117&y$max_ma==0.126,2,ifelse(y$min_ma==0.126&y$max_ma==0.781,0,NA)))
	if(adjustlong)
		{
		y$longitude	<- ifelse(y$longitude>=-15,y$longitude,180+(180-abs(y$longitude)))
		}
	fossildf	<- y[y$bool,]
	fossilcoldf	<- data.frame("period"=c("0-11.7 Kya","11.7-126 Kya","126-781 Kya"),"col"=c("darkgreen","blue","darkred"),"pch"=c(1,2,0))
	#
	plotlocations2(export="pdf",longthreshold=15,legendtxt=fossilcoldf$period,legendcol=as.character(fossilcoldf$col),exportname="fossillocations",silent=TRUE,mygeodf=fossildf,my_col=fossildf$col[fossildf$bool])
	#
	}

# Create map using package Maps. Advantage compared to Rworldmap is that this function allows to centre the map around the Pacific ocean, if needed 
plotlocations2<-function(export=NULL,longthreshold=15,xmargin=0.05,ymargin=0.15,addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,legendpos="topleft",legendtxt=NULL,legendcol=NULL,my_pch=NULL,legendcex=0.75,mycex=1,dolabels=FALSE,showborders=FALSE,textdf=NULL,textcex=1.25,boxcol="grey90")
	{
	if("maps" %in% rownames(installed.packages()) == FALSE) {install.packages("maps",repos='http://cran.us.r-project.org')}
	if("maps" %in% (.packages()) == FALSE)					{library(maps)}
	mycols			<- NULL
	if(is.null(mygeodf)&is.null(mygeofile))
		{
		cat("Flags 'mygeodf' and 'mygeofile' set to NULL (default). Assuming to find within inds dataframe columns called 'longitude' and 'latitude'.",sep="\n")
		if(!"longitude"%in%colnames(inds)|!"latitude"%in%colnames(inds))
			{
			return(cat("Columns 'longitude' and 'latitude' not present in inds dataframe.",sep="\n"))
			}
		if(any(inds$longitude<0,na.rm=TRUE))
			{
			cat("Using inds$longitude3...",sep="\n")
			coord		<- inds[inds$filter,c("longitude3","latitude")]
			colnames(coord)	<- c("longitude","latitude")
			}else{
			cat("Using inds$longitude...",sep="\n")
			coord		<- inds[inds$filter,c("longitude","latitude")]
			}
		mycols		<- inds$popcol[inds$filter]
		}else{
		if(!is.null(mygeofile))
			{
			mygeo		<- read.table(mygeofile,header=TRUE,sep="\t")
			}else{
			mygeo		<- mygeodf
			}
		coord		<- mygeo[,c("longitude","latitude")]
		}
	if(is.null(my_col))
		{
		if(is.null(mycols))
			{
			mycols		<- rep("black",nrow(coord))
			}
		}else{
		mycols		<- as.character(my_col)
		}
	if(is.null(my_pch))
		{
		mypch		<- 19
		}else{
		mypch		<- my_pch
		}
	if(is.factor(coord$latitude))
		{
		coord$latitude	<-  as.numeric(sub(",",".",as.character(coord$latitude)))
		}
	if(is.factor(coord$longitude))
		{
		coord$longitude	<-  as.numeric(sub(",",".",as.character(coord$longitude)))
		}
	mysamplenrs		<- inds$nr[inds$filter]
	if(!is.null(mydeviation))
		{
		if(is.null(mygeodf)&is.null(mygeofile))
			{
			indstemp	<- inds[inds$filter,]
			if(!"do_coordshuffle"%in%colnames(inds))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent from inds dataframe. Shuffling all data points.",sep="\n")
				indstemp$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}else{
			if(!"do_coordshuffle"%in%colnames(mygeo))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent in mygeo. Shuffling all data points.",sep="\n")
				mygeo$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}
		}else{
		cat("Flag 'mydeviation' is set to NULL. Not shuffling.",sep="\n")
		}
	mygeocoord		<<- coord
	mygeocols		<<- mycols
	#
	# PLOTTING:
	if(!is.null(export))
		{
		plotname		<- ifelse(addaxislabels,paste(exportname,"withaxes",sep="."),paste(exportname,"no_axes",sep="."))
		deviationlabel	<- ifelse(is.null(mydeviation),"exactlocation","withdeviation")
		pointslabel		<- ifelse(dolabels,"labels","points")
		borderlabel		<- ifelse(showborders,"withborders","withoutborders")
		if(export=="pdf"){pdf(paste(plotname,pointslabel,borderlabel,deviationlabel,"Rmaps.pdf",sep="."))}
		if(export=="wmf"){win.metafile(paste(plotname,pointslabel,borderlabel,deviationlabel,"Rmaps.wmf",sep="."))}
		if(!silent){cat(paste("Writing out file called:", exportname,sep=" "),sep="\n")}
		}
	ww2 <- map('world', wrap=c(0-longthreshold,360-longthreshold), plot=FALSE, fill=TRUE)
	bordercol	<- ifelse(showborders,"white",NA)
	myxlim		<- c(min(mygeocoord$longitude,na.rm=TRUE),max(mygeocoord$longitude,na.rm=TRUE))
	myylim		<- c(min(mygeocoord$latitude,na.rm=TRUE),max(mygeocoord$latitude,na.rm=TRUE))
	myxrange	<- myxlim[2]-myxlim[1]
	myyrange	<- myylim[2]-myylim[1]
	myxlim		<- c(myxlim[1]-xmargin*myxrange,myxlim[2]+xmargin*myxrange)
	myylim		<- c(myylim[1]-ymargin*myyrange,myylim[2]+ymargin*myyrange)
	map(ww2,ylim=myylim,xlim=myxlim,col="grey90",border=bordercol,fill=TRUE)
	#map(ww2,ylim=c(30,80),xlim=c(-10,280),col="grey90",border=bordercol,fill=TRUE)	# for bears
	if(dolabels)
		{
		text(coord,labels=mysamplenrs,col=mycols,cex=mycex,pch=mypch)
		}else{
		points(coord,col=mycols,bg=mycols,cex=mycex,pch=mypch)
		}
	if(!is.null(textdf))
		{
		cat("Adding text...",sep="\n")
		text(x=textdf$x,y=textdf$y,textdf$label,col=as.character(textdf$col),cex=textcex)
		}
	if(!is.null(legendtxt)&!is.null(legendcol))
		{
		cat("Adding legend...",sep="\n")
		legend(legendpos,legend=legendtxt,fill=legendcol,bty='n',cex=legendcex)
		}
	box(col=boxcol)
	if(!is.null(export)){dev.off()}
	}
	
	
multi_mantel_plot<-function(popnames=mysambar$populations,doexport=FALSE,silent=TRUE)
	{
	if(!"tajdlist_meta" %in% names(mysambar))
		{
		calcpi(pi_per_pop=FALSE)
		}
	# between all populations:
	if(!silent){cat("between and within populations...",sep="\n")}
	mantel_plot(pi_df=mysambar$tajdlist_meta[[1]],export=doexport,exportname="Mantel.meta.withlegend",addlegend=TRUE)
	mantel_plot(pi_df=mysambar$tajdlist_meta[[1]],export=doexport,exportname="Mantel.meta",addlegend=FALSE)
	# between all populations, excluding within population comparisons:
	if(!silent){cat("between populations...",sep="\n")}
	mantel_plot(pi_df=mysambar$tajdlist_meta[[1]],export=doexport,exportname="Mantel.meta.onlybetweenpops.withlegend",addlegend=TRUE,only_betweenpop=TRUE)
	mantel_plot(pi_df=mysambar$tajdlist_meta[[1]],export=doexport,exportname="Mantel.meta.onlybetweenpops",addlegend=FALSE,only_betweenpop=TRUE)
	#
	# within each population:
	nrpops	<- length(popnames)
	if(nrpops>1)
		{
		if(!"tajdlist_pop" %in% names(mysambar))
			{
			if(!silent){cat("calculating pi...",sep="\n")}
			calcpi(pi_per_pop=TRUE)
			}
		if(!silent){cat("per population...",sep="\n")}
		for(mypopname in popnames)
			{
			if(!silent){cat(mypopname,sep="\n")}
			mypopdf		<- mysambar$tajdlist_pop[[which(names(mysambar$tajdlist_pop)==mypopname)]]
			export_name	<- paste("Mantel",mypopname,"within",sep=".")
			mantel_plot(pi_df=mypopdf,export=doexport,exportname=export_name,addlegend=FALSE)
			}
		}
	}
	
# 22_05_2019: depends on output of calcpi (flag 'perpop' can be false I think) 	
seqdivplot<-function(popnames=mysambar$populations,nsites=NULL,export=FALSE)
	{
	if(!("tajdlist_meta" %in% names(mysambar)))
		{
		calcpi(pi_per_pop=FALSE)
		}
	pi_df			<- mysambar$tajdlist_meta[[1]]
	pi_df$nsegsites	<- NA
	nsnps				<- nrow(snps)
	npops				<- length(popnames)
	mycols				<- mysambar$mycolours[1:npops]
	combipoptable		<- combn(popnames,m=2)
	combicoltable		<- combn(mycols,m=2)
	combicolvector		<- vector()
	combipopvector		<- vector()
	npairwise			<- ncol(combicoltable)
	ntotal				<- npops+npairwise
	for(i in c(1:npairwise))
		{
		mycol1				<- combicoltable[1,i]
		mycol2				<- combicoltable[2,i]
		mycolfunc3 			<- colorRampPalette(c(mycol1,mycol2))
		combicolvector[i]	<- mycolfunc3(3)[2]
		combipopvector[i]	<- ifelse(combipoptable[1,i]<combipoptable[2,i],paste(combipoptable[1,i],combipoptable[2,i],sep="_"),paste(combipoptable[2,i],combipoptable[1,i],sep="_"))
		}
	for(i in c(1:nrow(pi_df)))
		{
		mypop1				<- pi_df$pop1[i]
		mypop2				<- pi_df$pop2[i]
		mymaf1				<- snps[,paste("maf",mypop1,sep="_")]
		mymaf2				<- snps[,paste("maf",mypop2,sep="_")]
		pi_df$comparison[i]<-ifelse(pi_df$pop1[i]==pi_df$pop2[i],pi_df$pop1[i],ifelse(pi_df$pop1[i]<pi_df$pop2[i],paste(pi_df$pop1[i],pi_df$pop2[i],sep="\n"),paste(pi_df$pop2[i],pi_df$pop1[i],sep="\n")))
		pi_df$comparison2[i]<-ifelse(mypop1==mypop2,"within","between")
		pi_df$nsegsites[i]	<- length(mymaf1[mymaf1>0|mymaf2>0])
		}
	# plot:
	if(!is.null(nsites))
		{
		if(!is.null(nsites))
			{
			if(length(nsites)>1)
				{
				cat("Length of vector input to nsites flag is greater than 1. This suggests that SNP datasets are derived from different genomic regions.",sep="\n")
				return(cat("Therefore, SambaR will not calculate genome wide sequence divergence.",sep="\n"))
				}
			}
		#pi_df$genomepi	<- pi_df$ndiffpersite*nsnps/nsites*100
		pi_df$genomepi	<- pi_df$ndiffpersite*pi_df$nsegsites/nsites*100
		if(export){pdf("Divergence.betweensamples.genomewide.pdf",width=ntotal*1,height=7.5)}
		layout(matrix(c(rep(1,npops),(rep(2,npairwise))),nrow=1,ncol=ntotal))
		par(oma=c(10,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
		mymin					<- min(pi_df$genomepi,na.rm=TRUE)
		mymax					<- max(pi_df$genomepi,na.rm=TRUE)
		boxplot(pi_df$genomepi[pi_df$comparison2=="within"]~pi_df$comparison[pi_df$comparison2=="within"],las=3,ylim=c(mymin,mymax),col=mycols[order(popnames)],ylab="",xlab="")
		boxplot(pi_df$genomepi[pi_df$comparison2=="between"]~pi_df$comparison[pi_df$comparison2=="between"],las=3,ylim=c(mymin,mymax),col=combicolvector[order(combipopvector)],yaxt='n',xlab="")
		mtext(side=2,"Sequence dissimilarity (%)",line=2.5,cex=1.75,outer=TRUE,las=0)
		if(export){dev.off()}
		}else{
		if(export){pdf("Divergence.betweensamples.snpsonly.pdf",width=ntotal*1,height=7.5)}
		layout(matrix(c(rep(1,npops),(rep(2,npairwise))),nrow=1,ncol=ntotal))
		par(oma=c(10,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
		mymin					<- min(pi_df$ndiffpersite,na.rm=TRUE)
		mymax					<- max(pi_df$ndiffpersite,na.rm=TRUE)
		boxplot(pi_df$ndiffpersite[pi_df$comparison2=="within"]~pi_df$comparison[pi_df$comparison2=="within"],las=3,ylim=c(mymin,mymax),col=mycols,ylab="",xlab="")
		boxplot(pi_df$ndiffpersite[pi_df$comparison2=="between"]~pi_df$comparison[pi_df$comparison2=="between"],las=3,ylim=c(mymin,mymax),col=combicolvector,yaxt='n',xlab="")
		mtext(side=2,"SNP dissimilarity",line=2.5,cex=1.75,outer=TRUE,las=0)
		if(export){dev.off()}
		}
	#pi_df<<- pi_df
	}

popmantel<-function()
	{
	# fst:
	fstmat				<- mysambar$popneimatrix
	fstmat[lower.tri(fstmat)]	<- fstmat[upper.tri(fstmat)]
	fst_distmatrix		<- as.dist(fstmat)
	#
	# geo:
	popcoorddf			<- inds[inds$filter,c("pop","longitude2","latitude")]
	poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
	poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
	colnames(poplong)	<- c("pop","longitude")
	poplong$latitude	<- poplat$x 
	npops				<- nrow(poplong)
	geo_distmatrix		<- dist(poplong[,c("longitude","latitude")])
	#
	plot(geo_distmatrix,fst_distmatrix,pch=16,cex=0.75,col="grey",ylab="",xlab="")
	geomat				<- as.matrix(geo_distmatrix)
	colnames(geo_distmatrix)	<- poplong$pop
	rownames(geo_distmatrix)	<- poplong$pop
	geodist				<<- geo_distmatrix
	fstmat				<<- fstmat
	}
	
mantel_plot<-function(gdistmat=NULL,pi_df=mysambar$tajdlist_meta[[1]],export=FALSE,addlegend=TRUE,exportname="Mantel",silent=TRUE,only_betweenpop=FALSE,only_withinpop=FALSE,my_pops=NULL)
	{
	# extract dataset info:
	if(is.null(nrow(pi_df)))
		{
		return(cat("ERROR: pi_df does not exist.",sep="\n"))
		}
	popnames			<- as.vector(unique(c(pi_df$pop1,pi_df$pop2)))
	my_inds				<- as.vector(unique(c(pi_df$ind1,pi_df$ind2)))
	npops				<- length(popnames)
	ninds				<- nrow(my_inds)
	mycols				<- mysambar$mycolours[1:npops]
	# prepare matrices:
	colour_matrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=TRUE,onlybetweenpop=only_betweenpop)
	my_cols				<- colour_matrix[lower.tri(colour_matrix)]
	if(!is.null(my_pops))
		{
		pi_distmatrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=FALSE,onlybetweenpop=only_betweenpop,onlywithinpop=only_withinpop,mypops=my_pops[inds$filter])
		}else{
		pi_distmatrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=FALSE,onlybetweenpop=only_betweenpop,onlywithinpop=only_withinpop)
		}
	pi_distmatrix		<- as.dist(pi_distmatrix)
	geo_distmatrix		<- dist(inds[my_inds,c("longitude","latitude")])
	if(!silent)
		{
		pi_distmat		<<- pi_distmatrix
		geo_distmat		<<- geo_distmatrix 
		}
	if(length(as.vector(geo_distmatrix))>2)
		{
		mantel.lm			<- lm(as.vector(pi_distmatrix)~as.vector(geo_distmatrix))
		mantel_pvalue		<- as.vector(round(summary(mantel.lm)$coefficients[,4],4)[2])
		mantel_r2			<- round(summary(mantel.lm)$r.squared,4)
		}
	#
	# plot:
	if(export){pdf(paste(exportname,"pdf",sep="."))}
	plot(geo_distmatrix,pi_distmatrix,pch=16,cex=0.75,col=my_cols,ylab="",xlab="")
	mtext("Geographical distance (degrees)",side=1,line=2.5,cex=2)
	mtext("Genetic distance (pi)",side=2,line=2.5,cex=2)
	if(addlegend&npops>1)
		{
		combipoptable		<- combn(popnames,m=2)
		combipopvector		<- paste(combipoptable[1,],combipoptable[2,],sep="_")	
		combicoltable		<- combn(mycols,m=2)
		combicolvector		<- vector()
		for(i in c(1:ncol(combicoltable)))
			{
			mycol1				<- combicoltable[1,i]
			mycol2				<- combicoltable[2,i]
			mycolfunc3 			<- colorRampPalette(c(mycol1,mycol2))
			combicolvector[i]	<- mycolfunc3(3)[2]
			}
		mycex	<- ifelse(ncol(combipoptable)<10,1.25,ifelse(ncol(combipoptable)>30,ifelse(ncol(combipoptable)>40,0.4,0.5),0.75))	
		if(only_betweenpop)
			{
			legend("bottomright",legend=combipopvector,fill=combicolvector,cex=mycex,bty='n')
			}else{
			legend("bottomright",legend=c(popnames,combipopvector),fill=c(mycols,combicolvector),cex=mycex,bty='n')
			}
		}
	# regression R2 and p-value:
	if(length(as.vector(geo_distmatrix))>2)
		{
		abline(mantel.lm,lwd=2)
		}
	legend("topright",legend=c(paste("R2 = ",mantel_r2,sep=""),paste("p-value = ",mantel_pvalue,sep="")),lty=2,col=c(NA,NA),bty='n',cex=1.5)
	#
	if(npops==1)
		{
		mtext(popnames,side=3,line=0.25,cex=2)
		}
	if(export){dev.off()}
	#
	#mytest	<- mantel.rtest(geo_distmat,pi_distmat,nrepet = 9999)
	#abline(lm(pi_distmatrix ~ geo_distmatrix),lty=2,lwd=2)
	}

runtess3<-function(export="pdf",nloci=NULL,maxK=6,myrepos='http://cran.us.r-project.org')
	{
	# get required packages:
	if("sp" %in% rownames(installed.packages()) == FALSE) {install.packages("sp",repos=myrepos)}
	if("tess3r" %in% rownames(installed.packages()) == FALSE)  {install_github("bcm-uga/TESS3_encho_sen")}
	if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages("rworldmap",repos=myrepos)}
	library(sp)
	library(tess3r)
	library(rworldmap)
	# If you can not install tess with install_github, you might try to install from binary.
	# To do so, first download as zip from: "bcm-uga/TESS3_encho_sen"
	# install.packages(mypath=...,repos=NULL,type="binary")
	#
	# create TESS3 object:
	mycoord					<- as.matrix(inds[inds$filter,c("longitude","latitude")])	# in tess3 first latitude, then longitude. Input for tess2tess: first column longitude, second column latitude. If you reverse the order, you will eventually get an ERROR when plotting
	mytess3					<- list()
	if(!is.null(nloci))
		{
		mygeno					<- as.matrix(mygenlight)[inds$filter,c(1:nloci)]
		}else{
		mygeno					<- as.matrix(mygenlight)[inds$filter,snps$filter]
		}
	mytess3$X				<- mygeno
	mytess3$coord			<- as.matrix(inds[inds$filter,c("latitude","longitude")])	
	#
	# run the analysis:
	tessout  				<<- tess3(X = mytess3$X, coord = mycoord, K = 1:maxK, ploidy = 2, openMP.core.num = 4)
	#
	# Cluster plot: the best choice for the K value is mostly (but not strictly) when the cross-validation curve exhibits a plateau or starts increasing.
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Tess.numberofclusters.pdf")}
		}
	plot(tessout,pch=19,col ="blue",xlab ="Number of ancestral populations",ylab ="Cross-Validation score",type='l')
	if(!is.null(export)){dev.off()}
	# other plots still to be incorporated
	}

maptess<-function(use_lea=FALSE,mydemes=c(2:5),export=NULL,marine=TRUE,myrepos='http://cran.us.r-project.org',mysize=10,myratio=1.75,mycex=0.75,multiplot=FALSE,myresolution=c(600,600),ncolour=20)
	{
	# by default this function expects to find in the global environment an object called 'tessout', output of tess3 function of the tess3r package.
	# tessout is generated with SambaR's runtess3 function.
	# if (use_lea is TRUE, function expects to find mysambar$leaqmatrixlist
	#
	# multiplot is designed for 4 tiles
	#
	my.colors	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1")
	my.palette 	<- CreatePalette(my.colors,(ncolour+1))
	for(i in c(1:length(my.palette)))
		{
		my.palette[i][[1]]	<- my.palette[i][[1]][1:ncolour]
		}
	# map.max: all colours
	# map.all: only one colour
	# mapmethod	<- ifelse(mapmax,"map.max","map.all")
	#
	# select data:
	mysubset   	<- as.matrix(mygenlight)[inds$filter,snps$filter]
	tesscoord	<- as.matrix(inds[inds$filter,c("longitude","latitude")])
	nsamples	<- nrow(mysubset)
	tesscoord2	<- as.data.frame(tesscoord)
	#
	if(marine)
		{
		# if needed, load required packages:
		if("sp" %in% rownames(installed.packages()) == FALSE) {install.packages("sp",repos=myrepos)}
		if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages("rworldmap",repos=myrepos)}
		if("raster" %in% rownames(installed.packages()) == FALSE) {install.packages("raster",repos=myrepos)}
		library(sp)
		library(rworldmap)
		library(raster)
		newmap 		<- getMap(resolution = "low")
		# create polygon:
		lonmin		<- min(tesscoord[,1])
		lonmax 		<- max(tesscoord[,1])
		londiff 	<- lonmax-lonmin
		latmin 		<- min(tesscoord[,2])
		latmax 		<- max(tesscoord[,2])
		latdiff 	<- latmax-latmin
		lonmin		<- lonmin-0.2*londiff		# add margin
		lonmax		<- lonmax+0.2*londiff		# add margin
		latmin		<- latmin-0.2*latdiff		# add margin
		latmax		<- latmax+0.2*latdiff		# add margin
		x_coord 	<- c(lonmin,lonmax,lonmax,lonmin) 
		y_coord 	<- c(latmin,latmin,latmax,latmax)
		xym 		<- cbind(x_coord, y_coord)
		p			<- Polygon(xym)
		ps 			<- Polygons(list(p),1)
		sps			<- SpatialPolygons(list(ps))
		myratio		<- (lonmax-lonmin)/(latmax-latmin)
		}
	graphics.off()
	if((!is.null(export))&multiplot)
		{
		if(use_lea)
			{
			exportname	<- paste("LEA.allK.map",nsamples,"samples.pdf",sep=".")
			}else{
			exportname	<- paste("Tess.allK.map",nsamples,"samples.pdf",sep=".")
			}
		if(myratio>1)
			{
			if(export=="pdf"){pdf(exportname,height=mysize,width=mysize*myratio)}
			}else{
			if(export=="pdf"){pdf(exportname,height=mysize*1/myratio,width=mysize)}
			}
		}
	if(multiplot)
		{
		layout(matrix(c(1:4),2,2,byrow = TRUE))
		par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5)
		}
	for(ndemes in mydemes)
		{
		cat(paste("Plotting map for K = ",ndemes,sep=""),sep="\n")
		if(use_lea)
			{
			mymatrix			<- mysambar$leaqmatrixlist[[ndemes-1]]
			colnames(mymatrix)	<- NULL
			# reorder:
			indstemp			<- inds[inds$filter,]
			indstemp			<- indstemp[order(indstemp$poplong),]
			mymatrix			<- mymatrix[order(indstemp$name),]
			# convert to tess qmatrix class:
			myqmatrix			<- as.qmatrix(mymatrix)
			}else{
			myqmatrix 			<- qmatrix(tessout, K = ndemes)
			}
		if(!is.null(export)&(!multiplot))
			{
			if(use_lea)
				{
				exportname	<- paste("LEA.map",ndemes,"clusters",nsamples,"samples.pdf",sep=".")
				}else{
				exportname	<- paste("Tess.map",ndemes,"clusters",nsamples,"samples.pdf",sep=".")
				}
			if(myratio>1)
				{
				if(export=="pdf"){pdf(exportname,height=mysize,width=mysize*myratio)}
				}else{
				if(export=="pdf"){pdf(exportname,height=mysize*1/myratio,width=mysize)}
				}
			}
		if(marine)
			{
			if(multiplot)
				{
				if(ndemes==2){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "",xaxt='n')}
				if(ndemes==3){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "",xaxt='n',yaxt='n')}
				if(ndemes==4){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "")}
				if(ndemes==5){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "",yaxt='n')}
				}else{
				plot(myqmatrix,tesscoord, method = "map.max", cex = .5, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "")
				points(tesscoord2$longitude,tesscoord2$latitude,pch=16,cex=mycex,col="black")
				mtext(text="Latitude",cex=1.75,side=2,line=-2,outer=TRUE)
				mtext(text="Longitude",cex=1.75,side=1,line=-2.5,outer=TRUE)
				}
			plot(newmap, xlim=xrange, ylim=yrange, add=TRUE,col="grey85",border="white")
			points(tesscoord2$longitude,tesscoord2$latitude,pch=16,cex=mycex,col="black")
			mtext(text=(paste("K = ",ndemes,sep="")),side=3,cex=1.5,line=0)
			box(lwd=0.5)
			}else{
			if(ndemes==2){colpalette	<- my.palette}
			if(ndemes==3){colpalette	<- my.palette[c(2,1,3,4,5)]}
			if(ndemes==4){colpalette 	<- my.palette[c(3,5,1,2,4)]}
			if(ndemes==5){colpalette 	<- my.palette[c(1,3,2,5,4)]}
			plot(myqmatrix, tesscoord, method ="map.max", interpol=FieldsKrigModel(10), main="Ancestry coefficients", xlab="Longitude", ylab="Latitude", resolution=c(300,300), cex=mycex, col.palette = colpalette)
			points(tesscoord2$longitude,tesscoord2$latitude,pch=16,cex=mycex,col="black")
			box(lwd=0.5)
			}
		if(!(is.null(export))&!(multiplot)){dev.off()}
		}
	if(multiplot)
		{
		mtext(text="Latitude",cex=2.25,side=2,line=1,outer=TRUE)
		mtext(text="Longitude",cex=2,side=1,line=1.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	}

# Generate dummy longitude and latitude data, needed to run tess3r:
dummycoord<-function(new_coord=TRUE,plot_coord=TRUE,indsfilter=inds$filter,range=3)
	{
	if(new_coord)
		{
		inds$longitude	<<- NA
		inds$latitude	<<- NA
		inds$longitude[inds$pop=="Busen"]	<<- 4.9+runif(nrow(inds[inds$pop=="Busen",]))*range
		inds$longitude[inds$pop=="Barff"]	<<- 6.9+runif(nrow(inds[inds$pop=="Barff",]))*range
		inds$longitude[inds$pop=="Norway"]	<<- 8.9+runif(nrow(inds[inds$pop=="Norway",]))*range
		inds$latitude[inds$pop=="Busen"]	<<- 52.3+runif(nrow(inds[inds$pop=="Busen",]))*range
		inds$latitude[inds$pop=="Barff"]	<<- 50.3+runif(nrow(inds[inds$pop=="Barff",]))*range
		inds$latitude[inds$pop=="Norway"]	<<- 48.3+runif(nrow(inds[inds$pop=="Norway",]))*range
		}
	if(plot_coord)
		{
		plot(inds$longitude[indsfilter],inds$latitude[indsfilter])
		points(inds$longitude[inds$pop=="Busen"&indsfilter],inds$latitude[inds$pop=="Busen"&indsfilter],col="blue")
		points(inds$longitude[inds$pop=="Barff"&indsfilter],inds$latitude[inds$pop=="Barff"&indsfilter],col="green")
		points(inds$longitude[inds$pop=="Norway"&indsfilter],inds$latitude[inds$pop=="Norway"&indsfilter],col="red")
		}
	}

getgeneland<-function(myrepos='http://cran.us.r-project.org',noupdates=TRUE,mylib=NULL,mypath="C:/Users/Tatiana/Menno/Programs/Geneland/Geneland_4.0.8.zip")
	{
	if(is.null(mylib))
		{
		if("devtools" %in% rownames(installed.packages()) == FALSE)		{install.packages("devtools",repos=myrepos)}
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos)}
		if("coda" %in% rownames(installed.packages()) == FALSE)			{install.packages("coda",repos=myrepos)}
		if("Geneland" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="binary")}
		}else{
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos,lib=mylib)}
		if("coda" %in% rownames(installed.packages()) == FALSE)			{install.packages("coda",repos=myrepos,lib=mylib)}
		if("Geneland" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="source",lib=mylib)}
		}
	if("rworldmap" %in% (.packages()) == FALSE) 						{library(rworldmap)}
	if("coda" %in% (.packages()) == FALSE) 								{library(coda)}
	if("Geneland" %in% (.packages()) == FALSE) 							{library(Geneland)}
	library(coda)
	library(Geneland)
	newmap <<- getMap(resolution = "low")
	# I wrote a function to convert from genlight to structure format.
	# Originally, I used dartR to do this conversion. This package depends on several other packages:
	# if("directlabels" %in% rownames(installed.packages()) == FALSE)		{install.packages("directlabels",repos=myrepos)}
	# if("PopGenReport" %in% rownames(installed.packages()) == FALSE)		{install.packages("PopGenReport",repos=myrepos)}
	# if("leaflet" %in% rownames(installed.packages()) == FALSE)			{install.packages("leaflet",repos=myrepos)}
	# if("pca3d" %in% rownames(installed.packages()) == FALSE)			{install.packages("pca3d",repos=myrepos)}
	# if("rrBLUP" %in% rownames(installed.packages()) == FALSE)			{install.packages("rrBLUP",repos=myrepos)}
	# if("dartr" %in% rownames(installed.packages()) == FALSE)			{install.packages("dartr",repos=myrepos)}
	# or from binary:
	# install.packages("C:/Users/Tatiana/Menno/Programs/dartr/dartR_1.1.11.zip",repos=NULL,type="binary")
	# library(dartR)
	}

# ADDITIONAL ANALYSIS: Geneland
# Because Geneland takes a while to run, the user has to call these functions separately. 
# SambaR expects to find within the inds dataframe columns named ‘longitude’ and ‘latitude’ (included during execution of the importdata() function).  

# Geneland needs to be installed from either a zipfile (Windows) or tarball (Unix). You can download these files from: https://i-pri.org/special/Biostatistics/Software/Geneland/distrib/
# To install on a Windows computer, type on R command line:
# getgeneland(mypath="C:/path/to/Geneland_4.0.8.zip",mylib=NULL)
# To install on a Unix computer, type on R command line:
# getgeneland(mypath="/path/to/Geneland_4.0.8.tar.gz",mylib="/path/to/your/storage/dir/")
# To run Geneland and subsequently plot the output, type:
# runandplotgeneland(my_iter=10000,burnin_fraction=0.2,my_thin=100,nloci=1000)
# The settings my_iter, burnin_fraction, and my_thin can be used the alter the MCMC chain settings. The flag nloci determines how many (randomly selected) loci will be used for the analysis. This number can, obviously, not exceed the number of retained snps in your snps dataframe. Depending on the capacities of your computer, there are limits to the combinations of my_iter, my_thin and nloci. If you set these values too high, you will encounter an error about memory allocation. Therefore you might not be able to use all your snps. 
# The output will be stored in the folder ‘Genelandoutput’ in the structure directory. 

# I don't mention Geneland anymore in the manual. Why not?
# When running Geneland, I have to subset the data because of memory allocation limits.
# You could argue to select loci with high minor allele frequencies (more informative), but I am afraid this is a biased representation of the dataset, which might affect the outcome
# So instead I sample randomly.	
# 10000 iterations for 1000 loci does not resolve population structure correctly according to my trials.
# I assigned to my Busen, Barff and Norway samples random geographical locations, clustered per population but with slight overlap
# The overlapping samples were wrongly assigned. 
# 100000 iterations with 1000 loci is not possible on my computer (memory allocation ERROR)
# 100000 iterations with 100 loci does not find the right structure (not even close)   
# 100000 iterations with 450 loci is not possible on my computer (memory allocation ERROR)
# 100000 iterations with 400 loci ... memory allocation ERROR when outputting results
# 100000 iterations with 200 loci does not resolve population structure correctly (not even closely)
# 1000 iterations with 1000 loci does not resolve population structure correctly either
# 10000 iterations with 2000 loci overclusters
# 10000 iterations with 2000 loci and correlated set to FALSE, underclusters
runandplotgeneland<-function(my_iter=10000,burnin_fraction=0.2,my_thin=100,doanalysis=TRUE,doplots=TRUE,initK=5,Kmax=8,nloci=1000,correlation=FALSE)
	{
	# mysambar$mycolours has 8 default colours, hence Kmax=8 
	if(!("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
		{
		return(cat("ERROR: No longitude and/or latitude column present in inds dataframe.",sep="\n"))
		}
	savediter	<- my_iter/my_thin
	myburn		<- savediter*burnin_fraction
	cat(paste("Number of iterations before thinning:",my_iter,sep=" "),sep="\n")
	cat(paste("Number of iterations after thinning:",savediter,sep=" "),sep="\n")	
	cat(paste("Burn-in (after thinning):",myburn,sep=" "),sep="\n")
	myfolder	<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	if(doanalysis)
		{
		rungeneland(myiter=my_iter,var_npop=TRUE,n_init=initK,popmax=Kmax,mythinning=my_thin,myburn=myburn,nloc=nloci,correlated=correlation)
		checkconvergence(myburnin=myburn,export="pdf")
		}
	if(doplots)
		{
		cat("Creating plots using Geneland functions...",sep="\n")
		genelandplotting(myburnin=myburn)
		cat("Creating additional plots using SambaR functions...",sep="\n")
		scattergeneland(myiter=my_iter,myburnin=myburn,gradient=FALSE,export="pdf",makeplots=TRUE)
		scattergeneland(myiter=my_iter,myburnin=myburn,gradient=TRUE,export="pdf",makeplots=TRUE)
		cat("Analysis finished.",sep="\n")
		myendtime	<- Sys.time()
		exportname	<- paste(myfolder,"endtime.txt",sep="")
		write.table(myendtime,exportname,quote=FALSE,col.names=FALSE)
		}
	}	

rungeneland<-function(myiter=10000,var_npop=TRUE,n_init=5,popmax=8,mythinning=100,myburnin=2,nloc=1000,correlated=FALSE)
	{
	# since we filter on maf, we can be sure that all loci have 2 alleles per loci, and so 2 columns per locus once we converted from genlight to structure.
	nind					<- nrow(inds[inds$filter,])
	genlight2structure(snpsfilter=snps$filter,indsfilter=inds$filter)
	geno					<- mysambar$mystructure[,c(3:ncol(mysambar$mystructure))]
	# subsample:
	#mysample				<- sample(c(1:(ncol(geno)-1)),nloc,replace=FALSE)
	#mysample2				<- c(mysample,(mysample+1))
	#mysample				<- mysample2[order(mysample2)]
	geno					<- geno[,c(1:(nloc*2))]
	coord					<- inds[inds$filter,c("longitude","latitude")]
	myfolder				<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	dir.create(myfolder)
	cat("Running MCMC analyses...",sep="\n")
	myfreqmodel				<- ifelse(correlated,"Correlated","Uncorrelated")
	MCMC(coordinates=coord,delta.coord=0,geno.dip.codom=geno,varnpop=var_npop,npopinit=n_init,spatial=TRUE,freq.model=myfreqmodel,nit=myiter,thinning=mythinning,rate.max=nind,npopmax=popmax,nb.nuclei.max=3*nind,path.mcmc=myfolder)
	PostProcessChain(coordinates=coord,path.mcmc=myfolder,nxdom=100,nydom=100,burnin=myburnin)
	}
		
# as of 26_03_2019 depreciated:	
rungeneland_old<-function(myiter=10000,var_npop=TRUE,n_init=6,popmax=10,mythinning=100,myburnin=2)
	{
	nind					<- nrow(inds[inds$filter,])
	cat("Converting from genlight to structure format...",sep="\n")
	# since we filter on maf, we can be sure that all loci have 2 alleles per loci.
	mymatrix				<- as.matrix(mygenlight[inds$filter,snps$filter])
	#mymatrix				<- mymatrix[,c(1:1000)]
	nloci					<- ncol(mymatrix)
	tempgl					<- as.genlight(mymatrix)
	mycoorddf				<- as.matrix(cbind(inds$latitude[1:ninds],inds$longitude[1:ninds]))
	colnames(mycoorddf)		<- c("lat","lon")
	tempgl$other$latlong	<- mycoorddf
	gl2structure(tempgl,outfile="mydata.stru",outpath=mysambar$inputfilesdir,v=0)
	mystructure				<- read.structure("mydata.stru",n.ind=nind,n.loc=nloci,onerowperind=FALSE,col.lab=0,col.pop=0,col.others=2,row.marknames=1)
	geno					<- as.matrix(mystructure)
	coord					<- inds[inds$filter,c("longitude","latitude")]
	myfolder				<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	dir.create(myfolder)
	cat("Running MCMC analyses...",sep="\n")
	MCMC(coordinates=coord,delta.coord=0,geno.dip.codom=geno,varnpop=var_npop,npopinit=n_init,spatial=TRUE,freq.model="Correlated",nit=myiter,thinning=mythinning,rate.max=nind,npopmax=popmax,nb.nuclei.max=3*nind,path.mcmc=myfolder)
	PostProcessChain(coordinates=coord,path.mcmc=myfolder,nxdom=100,nydom=100,burnin=myburnin)
	}

checkconvergence<-function(myburnin=2,export=NULL)
	{
	myfolder		<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	conver			<- read.table(paste(myfolder,"log.posterior.density.txt",sep=""),header=FALSE)
	colnames(conver)<-"posterior"
	conver$nr		<-c(1:nrow(conver))
	# plot myway:
	# plot(conver$nr,conver$posterior,type='l',ylab="Log posterior density",xlab="Iteration (x 1000)")
	# abline(v=myburnin,lty=2)
	# plot with coda:
	mychain			<- conver$posterior[c(myburnin:nrow(conver))]
	myconver		<- as.mcmc.list(lapply(as.data.frame(mychain), mcmc))	# convert to mcmc object
	if(!is.null(export))
		{
		exportname	<- paste(myfolder,"Traceplot.pdf",sep="")
		if(export=="pdf"){pdf(exportname)}
		}
	plot(myconver)
	if(!is.null(export)){dev.off()}
	# test:
	mydf			<- as.data.frame(matrix(nrow=4,ncol=4))
	colnames(mydf)	<- c("frac1","frac2","Z","p")
	mydf$frac1		<- c(0.1,0.2,0.3,0.5)
	mydf$frac2		<- c(0.5,0.6,0.7,0.1)
	for(i in c(1:4))
		{
		myfrac1			<- mydf$frac1[i]
		myfrac2			<- mydf$frac2[i]	
		gewekeout		<- geweke.diag(myconver,frac1=myfrac1,frac2=myfrac2)
		myzvalue		<- gewekeout$mychain[[1]]
		mypvalue 		<- pnorm(-abs(myzvalue))
		mydf$Z[i]		<- myzvalue
		mydf$p[i]		<- mypvalue
		}
	exportname	<- paste(myfolder,"Geweke.diag.output.txt",sep="")
	write.table(mydf,exportname,quote=FALSE,col.names=FALSE,row.names=TRUE)
	# if you have done multiple runs, you can use gelman diagnostics (which compares chains of each run)
	# gelmanout		<- gelman.diag(myconver,confidence = 0.95,transform=FALSE,autoburnin=TRUE,multivariate=TRUE)
	}

genelandplotting<-function(myburnin=2)
	{
	coord		<- inds[inds$filter,c("longitude","latitude")]
	myfolder	<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	setwd(myfolder)
	# Geneland built in plotting functions:
	# Plot number of clusters:
	Plotnpop(path.mcmc=myfolder,burnin=myburnin,printit=TRUE,file="Number_of_Clusters.pdf",format="pdf")
	# Map clusters geographically:
	PosteriorMode(coordinates=coord,path.mcmc=myfolder,printit=TRUE,file="Genelandmap.pdf",format="pdf") 
	PlotTessellation(coordinates=coord,path.mcmc=myfolder,printit=TRUE,path=myfolder)
	graphics.off()
	}	

scattergeneland<-function(myiter=1000,myburnin=2,gradient=TRUE,export=NULL,makeplots=TRUE,mapresolution="low")
	{
	myfolder	<- paste(mysambar$structure,"Genelandoutput/",sep="/")
	newmap 		<- getMap(resolution = mapresolution)
	sampledata	<- read.table(paste(myfolder,"proba.pop.membership.indiv.txt",sep=""),header=FALSE)
	nK			<- ncol(sampledata)-2
	colnames(sampledata)<-c("longitude","latitude",(paste("c",c(1:nK),sep="")))
	nbins		<- length(table(sampledata$c1,sampledata$c2))
	nsamples	<- nrow(sampledata)
	myxlim		<- c(min(sampledata$longitude),max(sampledata$longitude))
	myylim		<- c(min(sampledata$latitude),max(sampledata$latitude))
	myratio		<- (max(sampledata$longitude)-min(sampledata$longitude))/max((sampledata$latitude)-min(sampledata$latitude))
	# set mapping colours:
	sampledata$col	<- NA
	for(i in c(1:nsamples))
		{
		sampledata$col[i]	<- rgb(sampledata$c1[i],sampledata$c2[i],sampledata$c3[i])
		}
	# How many clusters identified?
	temp		<- sampledata[,c(3:9)]	
	temp2		<- sapply(temp,sum)
	nclusters	<- length(temp2[temp2>0])
	# col2 is generated kind of the same, but allowing for more colours (although difference between the other colours not very clear:)
	sampledata$col2	<- NA
	sampledata$col3	<- NA
	sampledata$blend<- NA
	colourvector	<- mysambar$mycolours
	for(i in c(1:nsamples))
		{
		myrow				<- sampledata[i,c(3:9)]
		mymax1				<- order(myrow)[length(myrow)]
		mysecond1			<- order(myrow)[length(myrow)-1]
		mymax2				<- as.vector(unlist(myrow[mymax1]))
		mysecond2			<- as.vector(unlist(myrow[mysecond1]))
		mycol1				<- colourvector[mymax1]
		mycol2				<- colourvector[mysecond1]
		#mycolfunc1 		<- colorRampPalette(c(mycol2,mycol1))
		mycolfunc1 			<- colorRampPalette(c("black",mycol1))
		mycolramp			<- mycolfunc1(nbins)
		mybin				<- mymax2*(nbins-1)+1
		sampledata$col2[i]	<- mycolramp[mybin]
		sampledata$blend[i]	<- ifelse(mymax2==1,FALSE,TRUE)
		sampledata$col3[i]	<- mycol1
		}
	if(gradient)
		{
		mycols	<- sampledata$col2
		}else{
		mycols	<- sampledata$col3	
		}
	myqmatrix2	<<- sampledata
	#
	if(makeplots)
		{
		# Plot:
		# Multitile plot:
		if(!is.null(export))
			{
			if(gradient)
				{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.multitile.gradient.scatter.pdf",sep=".")
				}else{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.multitile.scatter.pdf",sep=".")
				}
			exportname2	<- paste(myfolder,exportname,sep="")
			if(nclusters==2){pdf(exportname2,height=6,width=6*2*myratio)}
			if(nclusters==3){pdf(exportname2,height=6,width=6*3*myratio)}
			if(nclusters==4){pdf(exportname2,height=12,width=6*2*myratio)}
			if(nclusters==5){pdf(exportname2,height=12,width=6*3*myratio)}
			if(nclusters==6){pdf(exportname2,height=12,width=6*3*myratio)}
			if(nclusters==7){pdf(exportname2,height=12,width=6*4*myratio)}
			if(nclusters==8){pdf(exportname2,height=12,width=6*4*myratio)}
			}
		if(nclusters==2){layout(matrix(c(1:2),1,2,byrow = TRUE))}
		if(nclusters==3){layout(matrix(c(1:3),1,3,byrow = TRUE))}
		if(nclusters==4){layout(matrix(c(1:4),2,2,byrow = TRUE))}
		if(nclusters==5){layout(matrix(c(1:5),2,3,byrow = TRUE))}
		if(nclusters==6){layout(matrix(c(1:6),2,3,byrow = TRUE))}
		if(nclusters==7){layout(matrix(c(1:7),2,4,byrow = TRUE))}
		if(nclusters==8){layout(matrix(c(1:8),2,4,byrow = TRUE))}
		par(mar=c(1.5,1.5,1,1),oma=c(3,3,1.5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
		for(i in c(1:nclusters))	
			{
			mycluster	<- sampledata[,i+2]
			select		<- mycluster>0.5
			plot(sampledata$longitude[select],sampledata$latitude[select],col=mycols[select],pch=16,cex=1.5,ylim=myylim,xlim=myxlim)
			plot(newmap,add=T,col="grey90",border="grey")
			points(sampledata$longitude[select],sampledata$latitude[select],col=mycols[select],pch=16,cex=1.5)
			box()
			}
		mtext(text="Latitude",cex=2,side=2,line=1,outer=TRUE)
		mtext(text="Longitude",cex=2,side=1,line=1.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		#
		# Singletile plot:
		if(!is.null(export))
			{
			if(gradient)
				{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.singletile.gradient.scatter.pdf",sep=".")
				}else{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.singletile.scatter.pdf",sep=".")
				}
			exportname2	<- paste(myfolder,exportname,sep="/")
			pdf(exportname2,height=6,width=6*myratio)
			}
		par(mar=c(0.5,0.5,0.5,0.5),oma=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		plot(newmap, xlim=myxlim, ylim=myylim,col="grey85",border="grey")
		points(sampledata$longitude,sampledata$latitude,pch=16,cex=1.5,col=mycols)
		if(!is.null(export)){dev.off()}
		}
	# export results as qmatrix
	myqmatrix3            		<- cbind(inds$name[inds$filter],inds$longitude[inds$filter],inds$latitude[inds$filter],myqmatrix2)
	colnames(myqmatrix3)[1:3]	<- c("name","longitude","latitude") 
	write.table(myqmatrix3,paste(myfolder,"myqmatrix.txt",sep=""),quote=FALSE,col.names=TRUE,row.names=TRUE)
	}

	
# End of population structure analyses 
###############################################################################################################





###############################################################################################################
# Population differentiation analyses

# This function executes all genetic distance analyses at once:
calcdistance<-function(silent=TRUE,nchroms=NULL,do_hybridcheck=FALSE,do_binaryD=FALSE,do_distplot=TRUE,do_comparefst=TRUE,my_triplets=NULL,dostamppfst=TRUE,do_Dfst=FALSE,only_geneflow=FALSE,max_ntriplets=60,do_jackknife=TRUE,jk_blocksize=1000000,minjkblocks=50,dopoptree=TRUE,dodistgenpop=TRUE,do_dxy=TRUE)
	{
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(length(mysambar$populations)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate genetic distance between populations. Execution halted.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
		my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	#
	setwd(mysambar$divergencedir)
	#
	if(!only_geneflow)
		{
		# Execute analyses:
		# myamova()
		cat("Calculating Nei's genetic distance using stamppNeisD function of the package 'StAMPP'...",sep="\n")
		pop_neimatrix(export="eps")
		pop_neimatrix(export="pdf")
		pop_neimatrix(export="png")
		if(mysambar$os=="Windows"){pop_neimatrix(export="wmf")}
		if(length(mysambar$populations)>3&dopoptree)
			{
			# 22-09-2021:
			getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
			}
		cat("Calculating Pearson's correlation coefficient and variance fst values...",sep="\n")
		runWrightFst()
		cat("Plotting Pearson's correlation coefficient...",sep="\n")
		plotfst(export="eps",inputvector=mysambar$pearsonvector,exportname="MAF_corr_pop",plottitle="Pearson's correlation coefficient")
		plotfst(export="pdf",inputvector=mysambar$pearsonvector,exportname="MAF_corr_pop",plottitle="Pearson's correlation coefficient")
		plotfst(export="png",inputvector=mysambar$pearsonvector,exportname="MAF_corr_pop",plottitle="Pearson's correlation coefficient")
		if(mysambar$os=="Windows"){plotfst(export="wmf",inputvector=mysambar$pearsonvector,exportname="Maf_corr_pop",plottitle="Pearson's correlation coefficient")}
		cat("Plotting variance among population minor allele frequencies...",sep="\n")
		plotfst(export="eps",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="MAF variance")
		plotfst(export="pdf",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="MAF variance")
		plotfst(export="png",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="MAF variance")
		if(mysambar$os=="Windows"){plotfst(export="wmf",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="Variance MAF")}
		cat("Plotting Wright 1943 fst...",sep="\n")
		plotfst(export="eps",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")
		plotfst(export="pdf",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")
		plotfst(export="png",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")
		if(mysambar$os=="Windows"){plotfst(export="wmf",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")}
		if(!is.null(nchroms))
			{
			cat("Creating Manhattan fst plot...",sep="\n")
			# manhattan fst plots for each pairwise population comparison:
			multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
			multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
			multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
			multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
			}
		cat("Calculating pairwise Nei 1977 Fst...",sep="\n")
		locusNeiFst()
		cat("Calculating pairwise Cockerham & Weir 1987 Fst...",sep="\n")
		run_locusWCfst(export="pdf",silent=silent)	# histogram, depends on locusWCfst	
		if(mysambar$os=="Windows"){run_locusWCfst(export="wmf")}
		if(length(mysambar$populations)<=5&do_distplot)
			{
			if(!silent){cat("Fdist_multiplot",sep="\n")}
			cat("Generating Fdist plots. If you run into an error after this line, set the flag do_distplot to FALSE (i.e. 'calcdistance(do_distplot=FALSE)').",sep="\n")
			Fdist_multiplot(export="eps")	# He-Fst scatterplot, depends on Fdist_plot
			Fdist_multiplot(export="pdf")
			Fdist_multiplot(export="png")
			if(mysambar$os=="Windows"){Fdist_multiplot(export="wmf")}
			}
		if("mafSDtop1000"%in%colnames(snps))
			{
			if(!silent){cat("Fdist_multiplot",sep="\n")}
			Fdist_plot(my_dataset="metapop",showlabels=FALSE,exporttype="pdf",axislabels=TRUE,addsd=TRUE,dothin=TRUE,silent=TRUE)
			}
		#cat("Calculating pairwise Weir & Cockerham 1983 multilocus Fst...",sep="\n")
		#if(do_sambarFst)
		#	{
		#	multiLocusWeirFst(export="eps")
		#	multiLocusWeirFst(export="pdf")
		#	multiLocusWeirFst(export="png")
		#	if(mysambar$os=="Windows"){multiLocusWeirFst(export="wmf")}
		#	}
		# 18-05-2020: switch to accepted method, which also outputs p-value (through bootstrapping):  
		if(dostamppfst)
			{
			cat("Calculating pairwise Weir & Cockerham 1983 Fst using Stampp. If you run into an error, set the flag dostamppfst to FALSE.",sep="\n")
			runstamppFst(n_boots=100,export="eps")
			runstamppFst(n_boots=100,export="pdf")
			runstamppFst(n_boots=100,export="png")
			if(mysambar$os=="Windows"){runstamppFst(n_boots=100,export="wmf")}
			}
		#
		if(dodistgenpop)
			{
			cat("Calculating distances between populations using dist.genpop() function of the package 'adegenet'...",sep="\n")
			cat("If you run into an error, set the flag dodistgenpop to FALSE.",sep="\n")
			popdistances()	# this function also combines all distances scores into one table
			#
			# 28-10-2021:
			cat("Creating heatmaps with Reynolds genetic distance estimates calculated with the function dist.genpop()...",sep="\n")
			pop_reynoldsmatrix(export="eps")
			pop_reynoldsmatrix(export="pdf")
			pop_reynoldsmatrix(export="png")
			if(mysambar$os=="Windows"){pop_reynoldsmatrix(export="wmf")}
			cat("Creating NJ and UPGMA populations tree using as input Reynolds genetic distance matrix...",sep="\n")
			getpoptree(mymatrix=mysambar$popreynoldmatrix,exportlabel="Reynolds",donj=FALSE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popreynoldmatrix,exportlabel="Reynolds",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popreynoldmatrix,exportlabel="Reynolds",donj=FALSE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popreynoldmatrix,exportlabel="Reynolds",donj=TRUE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
			}
		cat("Plotting correlation between pairwise distance estimation methods...",sep="\n")
		cat("If you receive an error after this line, rerun the calcdistance function with the flag do_comparefst set to FALSE.",sep="\n")
		if(do_comparefst)
			{
			if(dodistgenpop)
				{
				comparefstplot(export="pdf")
				}else{
				cat("Not running the function 'comparefstplot' because the flag 'dodistgenpop' has been set to FALSE.",sep="\n")
				}
			}
		if(!silent){cat("Exporting Nei-table.",sep="\n")}
		exportneitable()
		if(!silent){cat("Exporting scatter plots showing comparisons between genetic distance estimates.",sep="\n")}
		poppairscatter(export="pdf",plotname="Poppair_NeiDvsWC1983Fst",xscore=mysambar$popneivector,yscore=mysambar$WC1983fstvector,xlabel="Nei's genetic distance (D)",ylabel="Weir & Cockerham 1983 Fst",yline=4.5)
		poppairscatter(export="pdf",plotname="Poppair_NeiDvsWright1943Fst",xscore=mysambar$popneivector,yscore=mysambar$Wrightfstvector,xlabel="Nei's genetic distance (D)",ylabel="Wright 1943 Fst")
		poppairscatter(export="pdf",plotname="Poppair_Wright1943Fst_WC1983Fst",xscore=mysambar$Wrightfstvector,yscore=mysambar$WC1983fstvector,xlabel="Wright 1943 Fst",ylabel="Weir & Cockerham 1983 Fst")
		if(!is.null(nchroms))
			{
			cat("Sliding window analyses...",sep="\n")
			# window fst:
			plotwindowfst(fst_type="Wrightfst",n_chroms=nchroms,export="pdf")	# to create windowfstdf
			}
		if(do_dxy)
			{
			cat("Calculating Dxy (mean raw distance between populations)...",sep="\n")
			cat("If you run into an error after this line, or if the calculation takes too long, rerun the calcdistance function with the flag do_dxy set to false (i.e. 'calcdistance(do_dxy=FALSE)')",sep="\n")
			popmeandxy()
			cat("Creating boxplots with between sample genetic distances...",sep="\n")  
			cat("Again, if you run into an error after this line, or if the calculation takes too long, rerun the calcdistance function with the flag do_dxy set to false (i.e. 'calcdistance(do_dxy=FALSE)')",sep="\n")
			seqdivplot(nsites=NULL,export=TRUE)
			}
		}
	#
	### GENE FLOW ANALYSES
	# many options:
	# - D calculation implemented in SAMBAR (according to algorithm of Simon H Martin)
	# - Dfst calculation implemented in SAMBAR (not validated, experimental algorithm)
	# - R package HybridCheck
	# - R package StrataG (related to HybridCheck?)
	# - R package Admixtools2 (f3 and f4 statistics)
	# - R package admixr (many statistics, mostly based on admixtools)
	#
	if(length(mysambar$populations)<3)
		{
		cat("Skipping gene flow analyses because currently less than 3 populations defined.",sep="\n")
		}else{
		if(is.null(my_triplets))
			{
			# find all possible triplets:
			mypops				<- mysambar$populations
			my_triplets			<- as.data.frame(permutations(n=length(mypops),r=3,v=mypops,repeats.allowed=F))
			colnames(my_triplets)<- c("p1","p2","p3")
			# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
			my_triplets$myorder	<- as.character(my_triplets$p2)>as.character(my_triplets$p1)
			my_triplets$ingroup	<- ifelse(my_triplets$myorder,paste(my_triplets$p1,my_triplets$p2,my_triplets$p3,sep="_"),paste(my_triplets$p2,my_triplets$p1,my_triplets$p3,sep="_"))
			my_triplets			<- my_triplets[(!duplicated(my_triplets$ingroup)),c(1:3)]
			}
		ntriplets		<- nrow(my_triplets)
		if(ntriplets>max_ntriplets)
			{
			cat(paste("More than ",max_ntriplets," population triplets. Omitting ABBA-BABA statistics.",sep=""),sep="\n")
			cat("Provide a different value to the flag 'max_ntriplets' if you want to run ABBA-BABA analyses anyway.",sep="\n")
			cat("Alternatively, and preferably, define a shorter set of triplets to the my_triplets flag.",sep="\n")
			cat("The input to the my_triplets should be a dataframe with three columns called 'p1','p2', and 'p3', listing for each triplet the ingroup1, ingroup2, and the introgressor species.",sep="\n") 
			}else{
			cat("Calculating ABBA-BABA statistics...",sep="\n")
			calcD(popnames=mysambar$populations,snpfilter=snps$filter,silent=TRUE,mytriplets=my_triplets,dojackknife=do_jackknife,minblocks=minjkblocks,jkblocksize=jk_blocksize)
			plotD(export="eps")
			plotD(export="png")
			plotD(export="pdf")
			#if(mysambar$os=="Windows"){plotD(export="wmf")}	# file too big
			plotD(export="eps",shortpop=TRUE)
			plotD(export="png",shortpop=TRUE)
			plotD(export="pdf",shortpop=TRUE)
			#if(mysambar$os=="Windows"){plotD(export="wmf",shortpop=TRUE)}	# file too big
			plotD(export="eps",doboxplot=TRUE)
			plotD(export="png",doboxplot=TRUE)
			plotD(export="pdf",doboxplot=TRUE)
			#if(mysambar$os=="Windows"){plotD(export="wmf",doboxplot=TRUE)}	# file too big
			plotD(export="eps",shortpop=TRUE,doboxplot=TRUE)
			plotD(export="png",shortpop=TRUE,doboxplot=TRUE)
			plotD(export="pdf",shortpop=TRUE,doboxplot=TRUE)
			#if(mysambar$os=="Windows"){plotD(export="wmf",shortpop=TRUE,doboxplot=TRUE)}	# file too big		
			#
			barplotD(mydf=mysambar$dscores,export="pdf",silent=TRUE,plottitle=NULL,allcombi=FALSE,addnsnps=TRUE)
			barplotD(mydf=mysambar$dscores,export="pdf",silent=TRUE,plottitle=NULL,allcombi=TRUE,addnsnps=TRUE)
			#
			if(do_Dfst)
				{
				plotD(export="eps",plotDfst=TRUE)
				plotD(export="pdf",plotDfst=TRUE)
				plotD(export="png",plotDfst=TRUE)
				#if(mysambar$os=="Windows"){plotD(export="wmf",plotDfst=TRUE)}	# file too big
				plotD(export="eps",plotDfst=TRUE,shortpop=TRUE)
				plotD(export="pdf",plotDfst=TRUE,shortpop=TRUE)
				plotD(export="png",plotDfst=TRUE,shortpop=TRUE)
				#if(mysambar$os=="Windows"){plotD(export="wmf",plotDfst=TRUE,shortpop=TRUE)}	# file too big
				}
			# 04-11-2021: still to add:
			# runadmixtools()
			# strataG package:
			# binaryD()
			}
		if(do_hybridcheck)
			{
			cat("Calculating ABBA-BABA statistics using HybridCheck...",sep="\n")	
			# p-values don't make sense yet, so therefore only 1 block (no jackknife approach included).
			# Rather than using p-values in hybridcheck output, I should use same method as used in calcD.
			runhybridcheck(use_exampledata=FALSE,myquartet=NULL,popnames=mysambar$populations,nsnpsperblock=NULL,nblocks=1)
			plotD(mydf=hbdf,export="eps",shortpop=TRUE,methodname="HybridCheck")
			plotD(mydf=hbdf,export="png",shortpop=TRUE,methodname="HybridCheck")
			plotD(mydf=hbdf,export="pdf",shortpop=TRUE,methodname="HybridCheck")
			if(mysambar$os=="Windows"){plotD(mydf=hbdf,export="wmf",shortpop=TRUE,methodname="HybridCheck")}
			}
		if(do_binaryD)
			{
			# binary D (strataG package?):
			binaryD(exampledata=FALSE,fourpops=mysambar$populations,samplesize=200)
			plotD(mydf=myhbdf,export="pdf",methodname="HybridCheck",doboxplot=TRUE,shortpop=TRUE)
			}
		if(!is.null(nchroms))
			{
			chromD(n_chroms=nchroms,silent=TRUE)
			plotD(export="eps",n_chroms=nchroms)
			plotD(export="pdf",n_chroms=nchroms)
			plotD(export="png",n_chroms=nchroms)
			#if(mysambar$os=="Windows"){plotD(export="wmf",n_chroms=nchroms)}
			cat("D statistics plots have been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		# karyotype:
		if(!is.null(nchroms))
			{
			cat("Sliding window analyses...",sep="\n")
			# window fst and Dfst:
			calcwindowDfst()													# calculate window Dfst
			multiplotkaryo(nrchroms=nchroms,exporttype="pdf",mystatdf=windowfstdf,mystat="Wrightfst")
			}
		}
	#cat("Outputting summary table...",sep="\n")
	#mypopdivergencetable()
	cat("Analysis finished.",sep="\n")
	setwd(mysambar$inputdatadir)
	}

# maf versus longitude
# only useful in case of dense sampling
plotgradient<-function(populations=mysambar$populations)
	{
	# exclu
	popmafdf			<- snps[snps$filter,grep("maf_",colnames(snps))]
	mynames				<- colnames(popmafdf)
	colnames(popmafdf)	<- gsub("maf_","",mynames)
	popmafdf			<- popmafdf[,(colnames(popmafdf)%in%populations)]
	popmafdf			<- popmafdf[,order(colnames(popmafdf))]
	#
	longdf				<- aggregate(inds$longitude3,by=list(inds$pop),FUN=mean)
	colnames(longdf)	<- c("pop","longitude")
	longdf				<- longdf[longdf$pop%in%populations,]
	longdf$nr			<- c(1:nrow(longdf))
	longdf				<- longdf[order(longdf$longitude),]
	# 
	# reorder popmafdf:
	popmafdf			<- popmafdf[,longdf$nr]
	#
	npops				<- length(populations)
	nsnps				<- nrow(popmafdf)
	plot(longdf$long,popmafdf[1,],ylim=c(0,1),col="white")
	for (k in c(1:nsnps))
		{
		lines(longdf$long,popmafdf[k,])
		}
	}

popdistances<-function(silent=TRUE,popnames=mysambar$populations,do_overwrite=TRUE)
	{
	if(is.null(mysambar$genpop)|do_overwrite)
		{
		cat("Creating genpop object...",sep="\n")
		minortemp			<- snps[,paste("mac",mysambar$populations,sep="_")]
		alltemp				<- snps[,paste("n",mysambar$populations,sep="_")]
		majortemp			<- alltemp-minortemp
		colnames(minortemp)	<- mysambar$populations
		colnames(majortemp)	<- mysambar$populations
		snpnames			<- snps$name2
		snpnames			<- paste(c(1:length(snpnames)),snpnames,sep="_")	# this is in case chrom is set to unknown, which can result in snps with same snps$name2
		rownames(majortemp)	<- paste(snpnames,"1",sep=".")
		rownames(minortemp)	<- paste(snpnames,"2",sep=".")
		mymatrix			<- rbind(majortemp,minortemp)
		mymatrix			<- t(mymatrix[order(rownames(mymatrix)),])
		mygenpop			<- as.genpop(mymatrix)
		mysambar$genpop		<<- mygenpop
		cat("Genpop object saved as mysambar$genpop.",sep="\n")
		}else{
		mygenpop			<- mysambar$genpop 
		}
	#
	if(!silent){cat("combinames",sep="\n")}
	combitable				<- combn(popnames,m=2)
	ncombi					<- ncol(combitable)
	combinames				<- paste(combitable[1,],combitable[2,],sep="_")
	npairwise				<- length(combinames)
	#
	if(!silent){cat("popdistlist",sep="\n")}
	popdistlist				<- list()
	mymethods				<- c("Nei_D_1972_adegenet","Edwards_1971_adegenet","Reynolds_Weir_Cockerham_1983_adegenet","Rodgers_1972_adegenet","Provesti_1975_adegenet")
	myshortnames			<- c("NeiD1972_ad","Edwards1971_ad","RWC1983_ad","Rodgers1972_ad","Provesti1975_ad") 
	popdistdf				<- as.data.frame(matrix(NA,ncol=length(mymethods),nrow=npairwise))
	colnames(popdistdf)		<- myshortnames
	rownames(popdistdf)		<- combinames
	if(!silent){cat("mypopdist",sep="\n")}
	for (k in c(1:5))
		{
		mymethod			<- mymethods[k]
		if(!silent){cat(mymethod,sep="\n")}
		mypopdist			<- round(adegenet::dist.genpop(mygenpop,method=k,diag=FALSE,upper=FALSE),4)
		mypopdist			<- as.matrix(mypopdist)
		tpopdist			<- t(mypopdist)
		popdistvec			<- tpopdist[lower.tri(tpopdist,diag=FALSE)]
		popdistdf[,k]		<- popdistvec 
		popdistlist[[k]]	<- mypopdist 
		write.table(as.matrix(mypopdist),paste("Distmatrix",mymethod,"txt",sep="."),quote=FALSE,sep="\t")
		}
	#
	# add other scores:
	if(!silent){cat("add scores",sep="\n")}
	if(!is.null(mysambar$popneivector))
		{
		if(!silent){cat("popneivector",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$popneivector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "NeiD1972_st"
		}else{
		if(!silent){cat("popneivector not present",sep="\n")}
		}
	if(!is.null(mysambar$WC1983fstvector))
		{	
		if(!silent){cat("WC1983fst",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$WC1983fstvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "WC1983_st"
		}else{
		if(!silent){cat("WC1983fstvector not present",sep="\n")}
		}
	if(!is.null(mysambar$WC1983pvector))
		{	
		if(!silent){cat("WC1983p",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$WC1983pvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "WC1983p_st"
		}else{
		if(!silent){cat("WC1983pvector not present",sep="\n")}
		}
	if(!is.null(mysambar$WC1983logpvector))
		{	
		if(!silent){cat("WC1983logp",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$WC1983logpvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "WC1983logp_st"
		}else{
		if(!silent){cat("WC1983pvector not present",sep="\n")}
		}
	if(!is.null(mysambar$Wrightfstvector))
		{
		if(!silent){cat("Wrightfst",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$Wrightfstvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "Wright1943_sa"
		}else{
		if(!silent){cat("Wrightfstvector not present",sep="\n")}
		}
	if(!is.null(mysambar$varfstvector))
		{
		if(!silent){cat("varfst",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$varfstvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "variance_sa"
		}else{
		if(!silent){cat("varfstvector not present",sep="\n")}
		}
	if(!is.null(mysambar$pearsonvector))
		{
		if(!silent){cat("pearson",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$pearsonvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "Pearson_r_sa"
		}else{
		if(!silent){cat("pearsonvector not present",sep="\n")}
		}
	write.table(popdistdf,"Population_distances.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
	mysambar$popdistdf		<<- popdistdf
	if(!silent)
		{
		cat("Distance scores have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

comparefstplot<-function(export=NULL)
	{
	distdf2				<- mysambar$popdistdf[,!(colnames(mysambar$popdistdf)%in%c("WC1983p_st","WC1983logp_st","variance_sa","Pearson_r_sa"))]
	if(!is.null(export))
		{
		pdf("Compare_pairwise_distmethods.pdf",height=8,width=8)
		}
	mymax		<- max(distdf2,na.rm=TRUE)+0.025
	pairs(distdf2,xlim=c(0,mymax),lower.panel=NULL,ylim=c(0,mymax),pch=16,las=2,cex=0.5)
	if(!is.null(export)){dev.off()}
	}


# AMOVA
# Depends on package StamPP'
myamova<-function(permutations=10)
	{
	nei 			<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=FALSE)
	amovaresults	<<- stamppAmova(nei,mygenlight[inds$filter,snps$filter],perm=permutations)	
	return(amovaresults)
	}

# depends on plotkaryo
multiplotkaryo<-function(nrchroms=NULL,exporttype=NULL,popnames=mysambar$populations,silent=TRUE,mystat="Wrightfst",mystatdf=NULL,mystepsize=0.2)
	{
	# mystat and mystatdf can also be 'Dfst' and 'windowfstdf' 
	if(is.null(mystatdf))
		{
		mystatdf	<- snps[,grep(mystat,colnames(snps))]
		}
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	mycolours		<- as.vector(unique(inds$popcol))
	combicoltable	<- combn(mycolours,m=2)	
	for(combinr in c(1:ncombi))
		{
		mypair		<- paste(combitable[1,combinr],combitable[2,combinr],sep="_")
		if(!silent){cat(mypair,sep="\n")}
		mystatvalues<- paste(mystat,mypair,sep="_")
		mycolfunc 	<- colorRampPalette(c(combicoltable[1,combinr],combicoltable[2,combinr]))
		my_combicol	<- mycolfunc(3)[2]
		if(!silent){cat(mystatvalues,sep="\n")}
		plotkaryo(export=exporttype,popnames=mysambar$populations,n_chroms=nrchroms,mychrom=NULL,stepsize=mystepsize,mycol="blue",mycol2="darkred",windowdf=mystatdf,inputvalues=mystatvalues)
		}
	}

plotkaryo<-function(popnames=mysambar$populations,n_chroms=NULL,mychrom=NULL,stepsize=0.2,mycol="blue",mycol2="darkred",export=NULL,windowdf=NULL,inputvalues=NULL)
	{
	# for example: windowdf=windowfstdf,inputvalues="Dfst_ABC_Eurasia_polar"
	mytest1<-(1/stepsize)
	mytest2<-round(mytest1)
	if(mytest1%%mytest2!=0)
		{
		return(cat("ERROR: 1/stepsize should be a round number.",sep="\n"))  
		}
	# BiocManager::install("karyoploteR")
	# library(karyoploteR)
	#
	# example:
	# mykaryo 		<- toGRanges(data.frame(chr=c("A","B"),start=c(1,1),end=c(100,200)))
	# kp 			<- plotKaryotype(genome=mykaryo,plot.type=6)
	# myregionsdf	<- data.frame(chr=c("A","A","B","B"),start=c(1,50,1,100),end=c(50,100,100,200),name=c("A1","A2","B1","B2"),col=c("darkred","blue","blue","darkred"))
	# myregions 	<- toGRanges(myregionsdf)
	# kpRect(kp,data=myregions,y0=0,y1=1,col=fstbins,data.panel="ideogram",border=NA)
	#
	# windowdf: a dataframe containing the columns 'chr','start','end', as well as a column as defined by inputvalues (which will be plotted).
	if(is.null(windowdf))
		{
		return(cat("ERROR: windowdf does not exist.",sep="\n"))
		}
	if(any(!c('chr','start','end')%in%colnames(windowdf)))
		{
		return(cat("ERROR: windowdf should contain columns called 'chr','start' and 'end'.",sep="\n"))
		}
	if(!inputvalues%in%colnames(windowdf))
		{
		return(cat("ERROR: column name defined by inputvalues flag not present in dataframe defined by windowdf flag.",sep="\n"))
		}
	if(!is.null(mychrom))
		{
		windowdf	<- windowdf[windowdf$chr==mychrom,]
		plottype	<- 1	# space above graph for plotting data
		}else{
		plottype	<- 6
		}
	regionvalues	<- as.vector(windowdf[,inputvalues])
	myregionsdf		<- windowdf[,c("chr","start","end")]
	myregions 		<- toGRanges(myregionsdf)
	mybreaks		<- round(seq(-1,1,stepsize),2)
	#
	if(!is.null(export))
		{
		if(is.null(mychrom))
			{
			myplotname	<- paste("Genomewide_window",inputvalues,sep="_")
			myheight	<- 8
			myheigth2	<- 800
			mywidth		<- 8
			mywidth2	<- 800
			}else{
			myplotname	<- paste("Chrom_window",mychrom,inputvalues,sep="_")
			myheight	<- 6
			myheigth2	<- 600
			mywidth		<- 12
			mywidth2	<- 1200
			}
		if(export=="eps"){postscript(paste(myplotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(myplotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(myplotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(myplotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	if(!is.null(mychrom))
		{
		snpstemp	<- snps[snps$chr2==mychrom,c("chr2","chrlength")] 
		snpstemp	<- unique(snpstemp)
		snpstemp	<- snpstemp[order(snpstemp$chr2),]
		mykaryo		<- data.frame("chr"=snpstemp$chr2,start=1,"end"=snpstemp$chrlength)
		}else{
		snpstemp	<- snps[snps$chr2<=n_chroms,c("chr2","chrlength")] 
		snpstemp	<- unique(snpstemp)
		snpstemp	<- snpstemp[order(snpstemp$chr2),]
		mykaryo		<- data.frame("chr"=snpstemp$chr2,start=rep(1,n_chroms),"end"=snpstemp$chrlength)
		}
	kp 			<- plotKaryotype(genome=mykaryo,plot.type=plottype)
	#
	## define colours:
	# positive values:
	poscolfunc 				<- colorRampPalette(c("grey90",mycol))
	negcolfunc 				<- colorRampPalette(c(mycol2,"grey90"))
	poscols					<- poscolfunc(round(1/stepsize))
	negcols					<- negcolfunc(round(1/stepsize))
	bincols					<- c(negcols,poscols)
	fstbins					<- as.vector(cut(regionvalues,mybreaks,labels=bincols))
	fstbins[regionvalues==-1]<- mycol2
	mycolfunc2 				<- colorRampPalette(c("white","grey90"))
	fstbins[is.na(regionvalues)] <- mycolfunc2(5)[2]
	kpRect(kp,data=myregions,y0=0,y1=1,col=fstbins,data.panel="ideogram",border=NA)
	# 
	if(!is.null(mychrom))
		{
		x					<- windowdf$start
		npops				<- length(popnames)
		mycolours			<- mysambar$mycolours[1:npops]	
		combitable			<- combn(popnames,m=2)
		combicoltable		<- combn(mycolours,m=2)
		npairwise			<- ncol(combitable)
		mycolvec			<- vector()
		mynamesvec			<- vector()
		for (i in (1:npairwise))
			{
			combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
			fstvalues		<- as.vector(windowdf[,names(windowdf) == paste("Wrightfst",combiname,sep = "_")])
			# as colour we are going to use a blend of the two population colours:
			mycol1			<- combicoltable[1,i]
			mycol2			<- combicoltable[2,i]
			mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
			mycol			<- mycolfunc3(3)[2]
			mynamesvec[i]	<- combiname
			mycolvec[i]		<- mycol
			kpLines(kp,chr=mychrom,x=x,y=fstvalues,col=mycol,lwd=2)
			}
		legend("topright",legend=mynamesvec,fill=mycolvec,bty='n',cex=1.5)
		}else{
		# legend:
		if(any(regionvalues[!is.na(regionvalues)]<0))
			{
			fstbinleg	<- as.vector(cut(seq(-1,1,0.01),mybreaks))
			fstbinleg	<- unique(fstbinleg)
			fstbinleg[2]<- paste("[-1,",-1+round(stepsize,2),"]",sep="")
			fstbinleg[1]<- "NA"
			fstbincol	<- as.vector(cut(seq(-1,1,stepsize),mybreaks,labels=bincols))
			fstbincol[1]<- mycolfunc2(5)[2]
			}else{
			fstbinleg	<- as.vector(cut(seq(0,1,0.01),mybreaks))
			fstbinleg	<- unique(fstbinleg)
			fstbinleg[2]<- paste("[0,",round(stepsize,2),"]",sep="")
			fstbinleg[1]<- "NA"
			fstbincol	<- as.vector(cut(seq(0,1,stepsize),mybreaks,labels=bincols))
			fstbincol[1]<- mycolfunc2(5)[2]
			}
		fstbinleg	<<- fstbinleg
		legend("bottomright",legend=fstbinleg,fill=fstbincol,bty='n',cex=1.5)
		}
	if(!is.null(export)){dev.off()}
	}

plotscatterkaryo<-function()
	{
	kp <- plotKaryotype(plot.type = 4, ideogram.plotter = NULL, labels.plotter = NULL)
	kpAddCytobandsAsLine(kp)
	kpAddChromosomeNames(kp, srt=45)
	points <- unlist(tileGenome(kp$chromosome.lengths, tilewidth = 100e3))
	points$y <- rnorm(n = length(points), mean = 0.5, sd = 0.1)
	kpPoints(kp, data = points, col=colByChr(points, colors = "rainbow"))
	#kpPoints(kp, data = points, col=colByChr(points, colors = "brewer.set1"), r1=0.45)
	#kpPoints(kp, data = points, col=colByChr(points, colors = "2blues"), r0=0.55)
	}

# Sliding window Fst:
# Depends on package 'zoo'
windowfst<-function(chrom=1,width=50,step=10,winbp=5000000,stepbp=250000,fsttype="WeirFst",popnames=mysambar$populations,selectcombi=NULL,snpselection=snps$filter2,mycolours=as.vector(unique(inds$popcol)),yrange=c(0,0.4),yby=0.1,xrange=c(0,160000000),xby=25,addlegend=FALSE,xaxislabels=TRUE,region=NULL,mylwd=1.5,addchrom=TRUE,legendcex=1,silent=TRUE)
	{
	npops	<- length(popnames)
	# if winbp and stepbp are not NULL, statistics per region are calculated as well.
	if(fsttype!="WeirFst"&fsttype!="Wrightfst")
		{
		return(cat("ERROR: fsttype should be either 'WeirFst' or 'Wrightfst'.",sep="\n"))
		}
	# region is a two element vector to highlight area in between
	xrange				<- xrange/1000000
	selection			<- snps$chr2==chrom&snpselection
	combitable			<<- combn(popnames,m=2)
	combicoltable		<<- combn(mycolours,m=2)
	if(!is.null(selectcombi))
		{	
		combitable		<<- as.matrix(combitable[,selectcombi])
		combicoltable	<<- as.matrix(combicoltable[,selectcombi])
		}
	combicolours		<<- rep(NA,ncol(combitable))
	combivector			<<- paste(combitable[1,],combitable[2,],sep="_")
	winmidpoint			<- rollapply(snps$pos[selection],width,mean,by=step,na.rm=TRUE)
	windowoutput		<<- as.data.frame(matrix(NA,nrow=length(winmidpoint),ncol=ncol(combitable)+1))
	colnames(windowoutput)<<- c(combivector,"pos")
	windowoutput$pos	<<- winmidpoint
	#
	if((!is.null(winbp))&(!is.null(stepbp)))
		{
		if(!silent){cat("Calculating fst for regions with fixed number of bp (as defined by winbp and stepbp flags)...",sep="\n")}
		# 31-3-20: alternative way: for regions of fixed length instead of for fixed number of SNPs
		chrlength		<- mean(snps$chrlength[snps$chr2==chrom],na.rm=TRUE)
		chrname			<- as.vector(unique(snps$chr[snps$chr2==chrom]))
		mystarts		<- seq(0,chrlength,stepbp)+1
		myends			<- mystarts-1+winbp
		mymid			<- (mystarts-1+myends)/2
		n_win			<- length(mystarts)
		windowdf		<<- data.frame("chr"=rep(chrom,n_win),"chrlength"=rep(chrlength,n_win),"start"=mystarts,"end"=myends,"mid"=mymid)
		windowdf$end	<<- ifelse(windowdf$end>windowdf$chrlength,windowdf$chrlength,windowdf$end)
		windowdf$nsnps	<<- NA
		windowdf$he		<<- NA
		windowdf$maf	<<- NA
		chr_snps	<- snps[snps$chr2==chrom,]
		for(j in c(1:n_win))
			{
			mystart				<- windowdf$start[j]
			myend				<- windowdf$end[j]
			regionsnps			<- chr_snps[chr_snps$pos>mystart&chr_snps$pos<=myend,]
			windowdf$nsnps[j]	<<- nrow(regionsnps)
			windowdf$he[j]		<<- mean(regionsnps$hetero,na.rm=TRUE)
			windowdf$maf[j]		<<- mean(regionsnps$maf,na.rm=TRUE)
			windowdf$HWEchi2[j]	<<- mean(regionsnps$HWEchi2,na.rm=TRUE)
			}
		}else{
		if(!silent){cat("Calculating fst for regions consisting of fixed number of SNPs (as defined by width and step flags)...",sep="\n")}
		}
	#
	# for pairwise population comparisons:
	npairwise	<- ncol(combitable)
	for (i in (1:npairwise))
		{
		combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
		fstvalues		<- snps[selection,names(snps) == paste(fsttype,combiname,sep = "_")]
		#fstvalues		<- snps[selection,names(snps) == paste("WeirFst",combiname,sep = "_")]
		# Sliding window:		
		fstmean 		<- rollapply(fstvalues,width,mean,by=step,na.rm=TRUE)
		#fstsd 			<- rollapply(fstvalues,width,sd,by=step,na.rm=TRUE)
		windowoutput[names(windowoutput) == combivector[i]] <<- fstmean
		#
		if(!is.null(winbp)&!is.null(stepbp))
			{
			# 31-3-20: alternative way: for regions of fixed length instead of for fixed number of SNPs:
			fstvalues		<- chr_snps[,names(snps) == paste(fsttype,combiname,sep = "_")]
			windowdf$meanfst<<- NA	
			for(j in c(1:n_win))
				{
				#cat(j,sep="\n")
				mystart		<- windowdf$start[j]
				myend		<- windowdf$end[j]
				mybool		<- chr_snps$pos>mystart&chr_snps$pos<=myend
				if(any(mybool))
					{
					#cat("mybool",sep="\n")
					regionfst		<- fstvalues[mybool]
					if(any(!is.na(regionfst)))
						{
						#cat("mean_fst",sep="\n")
						windowdf$meanfst[j]	<<- mean(regionfst,na.rm=TRUE)
						}else{
						windowdf$meanfst[j]	<<- NA
						}
					}else{
					windowdf$meanfst[j]		<<- NA
					}
				}
			names(windowdf)[names(windowdf)=="meanfst"] <<- paste(fsttype,combiname,sep = "_")
			}
		}
	if(!is.null(winbp)&!is.null(stepbp))
		{
		n_col			<- ncol(windowdf)
		windowoutput2	<- windowdf[,c((n_col-npairwise+1):n_col)]
		}
	# Plot:
	# plot first line:
	# as colour we are going to use a blend of the two population colours:
	mycol1			<- combicoltable[1,1]
	mycol2			<- combicoltable[2,1]
	mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
	mycol			<- mycolfunc3(3)[2]
	combicolours[1]	<<- mycol
	if(xaxislabels)
		{
		if((!is.null(winbp))&(!is.null(stepbp)))
			{
			plot(windowdf$mid/1000000,windowoutput2[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}else{
			plot(windowoutput$pos/1000000,windowoutput[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}
		axis(2, at=seq((yrange[1]+yby/2),yrange[2],by=yby),las=1)
		axis(1, at=seq((xrange[1]),xrange[2],by=xby),las=1)
		}else{
		if((!is.null(winbp))&(!is.null(stepbp)))
			{
			plot(windowdf$mid/1000000,windowoutput2[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}else{
			plot(windowoutput$pos/1000000,windowoutput[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}
		axis(2, at=seq((yrange[1]+yby/2),yrange[2],by=yby),las=1)
		}
	if(!is.null(region))
		{
		rect(xleft=region[1],ybottom=-1,xright=region[2],ytop=1,col="grey",border=NA)
		if(!is.null(winbp)&is.null(stepbp))
			{
			lines(windowdf$mid/1000000,windowoutput2[,1],col=mycol,lwd=mylwd)
			}else{
			lines(windowoutput$pos/1000000,windowoutput[,1],col=mycol,lwd=mylwd)
			}
		}else{
		if((!is.null(winbp))&(!is.null(stepbp)))
			{
			if(!silent){cat("Adding polygon...",sep="\n")}
			polygon(x=c(windowdf$mid/1000000,rev(windowdf$mid/1000000)),y=c(rep(0,nrow(windowdf)),rev(windowdf$he)),col="grey",border=NA)
			lines(windowdf$mid/1000000,windowoutput2[,1],type="l",col=mycol,lwd=mylwd)
			if(addlegend){legend("topright",y=0.2,"Heterozygosity",fill="grey",cex=legendcex,bty="n")}
			#lines(windowdf$mid/1000000,windowdf$he)
			#lines(windowdf$mid/1000000,windowdf$nsnps/max(windowdf$nsnps,na.rm=TRUE),lty=2)
			#lines(windowdf$mid/1000000,windowdf$maf,col="red")
			#lines(windowdf$mid/1000000,(windowdf$HWEchi2/max(windowdf$HWEchi2,na.rm=TRUE)),col="green")
			}
		}
	if(addchrom)
		{
		mtext(chrname,3,line=-1,cex=0.75)
		}
	# plot optional extra lines:
	if(ncol(combitable)>1)
		{
		for (z in (2:(ncol(combitable))))
			{
			# as colour we are going to use a blend of the two population colours:
			mycol1		<- combicoltable[1,z]
			mycol2		<- combicoltable[2,z]
			mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
			mycol		<- mycolfunc3(3)[2]
			combicolours[z]	<<- mycol
			if((!is.null(winbp))&(!is.null(stepbp)))
				{
				lines(windowdf$mid/1000000,windowoutput2[,z],type="l",col=mycol,lwd=mylwd)
				}else{
				lines(windowoutput$pos/1000000,windowoutput[,z],type="l",col=mycol,lwd=mylwd)
				}
			title((paste("chromosome",chrom, sep = " ")),line = 1)
			}
		}
	if(addlegend){legend("topleft",y=0.2,combivector,fill=combicolours,cex=legendcex,bty="n")}
	}

# depends on windowfst
# to plot a single chromosome
plotchromfst<-function()
	{
	pdf("Chrom11_fst.pdf",width=12,height=7)
	par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,4,2),cex.axis=1.5)
	windowfst(chrom="HiC_scaffold_11",width=20,mylwd=2.5,step=2,selectcombi=c(1,2,3,4,5,6),yrange=c(0,1),yby=0.1,xrange=c(0,110000000),xby=5,addlegend=TRUE,addchrom=TRUE)
	mtext("Position along chromosome (Mb)",side=1,line=2.5,outer=TRUE,cex=2)
	mtext("Fst",side=2,line=1.25,outer=TRUE,cex=2)
	dev.off()
	}

# depends on function windowfst()
# to plot all chromosomes	
plotwindowfst<-function(window_nsnps=50,window_step=10,window_bp=5000000,window_stepbp=250000,mycomparisons=NULL,popnames=mysambar$populations,fst_type="WeirFst",n_chroms=NULL,ntiles=18,mychroms=NULL,ystep=0.1,export=NULL,addX=TRUE,myyrange=NULL,my_lwd=1.5,silent=TRUE,mysep="_")
	{
	mycurrentdir	<- getwd()
	# window_nsnps=50,window_step=10,window_bp=5000000,window_stepbp=250000
	windowsize	<- ifelse(is.null(window_bp),paste(window_snps,"SNPs",sep=""),paste(window_bp/1000000,"Mb",sep=""))
	if(fst_type!="WeirFst"&fst_type!="Wrightfst")
		{
		return(cat("ERROR: fst_type should be either 'WeirFst' or 'Wrightfst'.",sep="\n"))
		}
	# This function calculates fst values per window for each chromosome, and stores the window specific values in a dataframe called windowfstdf. 
	# It will also create plots, but not fancy ones, so probably you would like to use the output (windowfstdf dataframe) as input for plotkaryo() function.
	setwd(mysambar$selectiondir)
	npops	<- length(popnames)
	windowfstlist	<- list()
	if(is.null(mycomparisons))
		{
		mycomparisons=seq(1:ncol(combn(popnames,m=2)))
		}
	if(is.null(mychroms))
		{
		if(is.null(n_chroms))
			{
			return(cat("Provide an input value to the n_chroms flag",sep="\n"))
			}else{
			mychroms	<- c(1:n_chroms)
			maxlength	<- max(snps$chrlength[snps$chr2<=n_chroms],na.rm=TRUE)  
			}	
		}
	nchroms		<- length(mychroms)
	ntabs		<- ceiling(nchroms/ntiles)
	#
	# get yrange:
	if(is.null(myyrange))
		{
		myfstdf 	<- snps[,grep(paste(fst_type,"_",sep=""),colnames(snps))]
		myfstdf		<- myfstdf[,colnames(myfstdf)!=paste(fst_type,"metapop",sep=mysep)] 
		fstmin		<- min(myfstdf,na.rm=TRUE)
		fstmax		<- max(myfstdf,na.rm=TRUE)
		myyrange	<- c(fstmin,fstmax)
		}
	if(is.null(maxlength))
		{
		myxrange=c(0,160000000)
		}else{
		myxrange=c(0,maxlength)
		}
	for (n in c(1:ntabs))
		{ 
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Window_Fst",windowsize,n,"eps",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="pdf"){pdf(paste("Window_Fst",windowsize,n,"pdf",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="png"){png(paste("Window_Fst",windowsize,n,"png",sep="."),family=mysambar$myfont,width=540,height=720)}
			if(export=="wmf"){win.metafile(paste("Window_Fst",windowsize,n,"wmf",sep="."),family=mysambar$myfont,width=6,height=8)}
			}
		layout(matrix(c(c(c(1:(ntiles/2)),ntiles+1),c((ntiles/2+1):(ntiles+1))),nrow=(ntiles/2+1),ncol=2,byrow=FALSE))
		#layout(matrix(c(1:ntiles),(ntiles/2),2,byrow=FALSE))
		par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))
		if(n<ntabs)
			{
			chromset	<- mychroms[((n-1)*ntiles+1):(ntiles*n)]
			}else{
			chromset	<- mychroms[((n-1)*ntiles+1):length(mychroms)]
			}
		for (chromname in chromset)
			{
			if(!silent){cat(chromname,sep="\n")}
			if(chromname%%(ntiles/2)==0)
				{
				windowfst(chrom=chromname,fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=TRUE,mylwd=my_lwd)
				}else{
				if(mychroms[nchroms]==chromname&&addX==FALSE)
					{
					windowfst(chrom=chromname,fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=TRUE,mylwd=my_lwd)
					}else{
					windowfst(chrom=chromname,fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=FALSE,mylwd=my_lwd)
					}
				}
			# add data to list:
			windowfstlist[[chromname]]	<- windowdf 	# this works because snps$chr2 consists of numbers (1 for biggest chrom, 2 for second biggest chrom, etc)
			}
		# 13-4-2020: this doesn't work anymore since using snps$chr2 instead of snps$chr 
		#if(addX&n==ntabs)
		#	{
		#	windowfst(chrom="X",fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=TRUE,mylwd=my_lwd)
		#	}
		if(fst_type=="WeirFst")
			{
			mtext("Cockerham & Weir 1987 Fst", side=2, line=1, outer=TRUE,cex=1.5)
			}
		if(fst_type=="Wrightfst")
			{	
			mtext("Wright 1943 Fst", side=2, line=1, outer=TRUE,cex=1.5)
			}
		mtext("Position along chromosome (Mb)", side=1, line=-3.5, outer=TRUE,cex=1.25)
		# addlegend:
		if(n==ntabs)
			{
			nempty	<- ifelse(addX,(ntabs*ntiles-length(mychroms)-1+1),(ntabs*ntiles-length(mychroms)+1))
			for(mycounter in c(1:(nempty)+1))
				{
				plot(1,type ="n",axes=FALSE,xlab="",ylab="")	
				}
			}else{
			plot(1,type= "n",axes=FALSE,xlab="",ylab="")
			}
		if(length(mycomparisons)<4){legend(x="bottom",legend=combivector,horiz=T,fill=combicolours,cex=1.25,bty="n")}
		if(!is.null(export)){dev.off()}
		}
	windowfstdf		<<- do.call(rbind,windowfstlist)
	cat("Window fst values have been saved in a dataframe called 'windowfstdf'.",sep="\n")
	setwd(mycurrentdir)
	}

mafsd<-function(popnames=mysambar$populations)
	{
	npops				<- length(popnames)
	if(npops>1)
		{
		popmafs 			<- snps[,grep("maf_",colnames(snps))]
		snps$sd_popmaf		<<- apply(popmafs,1,function(x) sd(x))
		}else{
		snps$sd_popmaf		<<- NA
		}
	}

# possibly have a look at 'strataG' to work with dnabin objects
# stratag: An r package for manipulating, summarizing and analysing population genetic data
# devtools::install_github('ericarcher/strataG', build_vignettes = FALSE,upgrade="never")
# library(strataG)
binaryD<-function(exampledata=FALSE,fourpops=NULL,snpselection=NULL,samplesize=200)
	{
	if(exampledata)
		{
		# data(MySequences)
		seqmat				<- as.character(as.matrix(MySequences))
		mypops				<- c("Norfolk","Lincolnshire","Cambridgeshire","Suffolk")
		pop1 				<- c("Seq1", "Seq2", "Seq3")			
		pop2 				<- c("Seq4", "Seq5", "Seq6")			
		pop3 				<- c("Seq7", "Seq8")					
		pop4 				<- c("Seq9", "Seq10")					
		poplist				<- list(pop1=c("Seq1","Seq2","Seq3"),pop2 = c("Seq4","Seq5","Seq6"),pop3 = c("Seq7","Seq8"),pop4 = c("Seq9","Seq10"))
		poplist2			<- list(pop1=rep(mypops[1],3),pop2 = rep(mypops[2],3), pop3 = rep(mypops[3],2), pop4 = rep(mypops[4],2))
		}else{
		if(is.null(fourpops))
			{
			return(cat("ERROR: Provide a vector with 4 population names to the 'fourpops' flags.",sep="\n"))
			}
		seqmat				<- as.character(as.matrix(mysambar$mydnabin))
		if(!is.null(snpselection))
			{
			seqmat				<- seqmat[,snpselection]
			}
		mypops				<- fourpops
		pop1				<- as.vector(inds$name[inds$pop==fourpops[1]&inds$filter])
		pop2				<- as.vector(inds$name[inds$pop==fourpops[2]&inds$filter])
		pop3				<- as.vector(inds$name[inds$pop==fourpops[3]&inds$filter])
		pop4				<- as.vector(inds$name[inds$pop==fourpops[4]&inds$filter])
		poplist				<- list(pop1= pop1,pop2 = pop2,pop3 = pop3,pop4 = pop4)
		poplist2			<- list(pop1=rep(mypops[1],length(pop1)),pop2 = rep(mypops[2],length(pop2)), pop3 = rep(mypops[3],length(pop3)), pop4 = rep(mypops[4],length(pop4)))
		}
	names(poplist)		<- mypops
	names(poplist2)		<- mypops
	# get all combinations: 
	myperms				<- permutations(n = 4, r = 4, v = c(1:4))
	tempquartets		<- expand.grid(poplist[[1]],poplist[[2]],poplist[[3]],poplist[[4]])
	temppopcombos		<- expand.grid(poplist2[[1]],poplist2[[2]],poplist2[[3]],poplist2[[4]])
	for (j in c(2:nrow(myperms)))
		{
		myperm			<- myperms[j,]
		permquartets	<- expand.grid(poplist[[myperm[1]]],poplist[[myperm[2]]],poplist[[myperm[3]]],poplist[[myperm[4]]])
		tempquartets	<- rbind(tempquartets,permquartets)
		permpopcombos	<- expand.grid(poplist2[[myperm[1]]],poplist2[[myperm[2]]],poplist2[[myperm[3]]],poplist2[[myperm[4]]])
		temppopcombos	<- rbind(temppopcombos,permpopcombos)
		}
	tempquartets$order			<- ifelse(as.character(tempquartets$Var3)<as.character(tempquartets$Var4),TRUE,FALSE)
	tempquartets$ingroup1		<- ifelse(tempquartets$order,as.character(tempquartets$Var3),as.character(tempquartets$Var4))
	tempquartets$ingroup2		<- ifelse(tempquartets$order,as.character(tempquartets$Var4),as.character(tempquartets$Var3))
	tempquartets$introgressor	<- as.character(tempquartets$Var2)
	tempquartets$out			<- as.character(tempquartets$Var1)
	tempquartets$quartet		<- paste(tempquartets$ingroup1,tempquartets$ingroup2,tempquartets$introgressor,tempquartets$out,sep="_")
	myquartets					<- tempquartets[!duplicated(tempquartets$quartet),c("ingroup1","ingroup2","introgressor","out")]
	#
	temppopcombos$ingroup1		<- ifelse(tempquartets$order,as.character(temppopcombos$Var3),as.character(temppopcombos$Var4))
	temppopcombos$ingroup2		<- ifelse(tempquartets$order,as.character(temppopcombos$Var4),as.character(temppopcombos$Var3))
	temppopcombos$introgressor	<- as.character(temppopcombos$Var2)
	temppopcombos$out			<- as.character(temppopcombos$Var1)
	mypopcombos					<- temppopcombos[!duplicated(tempquartets$quartet),c("ingroup1","ingroup2","introgressor","out")]
	colnames(mypopcombos)		<- c("in1_pop","in2_pop","intro_pop","out_pop")
	#
	nquartets	<- nrow(myquartets)
	if(nquartets>samplesize)
		{
		mysample	<- sample(c(1:nquartets),samplesize,replace=FALSE)
		myquartets	<- myquartets[mysample,]
		mypopcombos	<- mypopcombos[mysample,]
		nquartets	<- samplesize
		}
	#
	myhbdf			<- as.data.frame(cbind(myquartets,mypopcombos))
	myhbdf$quartet	<- paste(myhbdf$in1_pop,myhbdf$in2_pop,myhbdf$intro_pop,myhbdf$out_pop,sep="_")
	myp1			<- ifelse(nchar(as.vector(myhbdf$in1_pop))>2,substr(as.vector(myhbdf$in1_pop),1,2),as.vector(myhbdf$in1_pop))
	myp2			<- ifelse(nchar(as.vector(myhbdf$in2_pop))>2,substr(as.vector(myhbdf$in2_pop),1,2),as.vector(myhbdf$in2_pop))
	myp3			<- ifelse(nchar(as.vector(myhbdf$intro_pop))>2,substr(as.vector(myhbdf$intro_pop),1,2),as.vector(myhbdf$intro_pop))
	myp4			<- ifelse(nchar(as.vector(myhbdf$out_pop))>2,substr(as.vector(myhbdf$out_pop),1,2),as.vector(myhbdf$out_pop))
	myhbdf$mylabels	<- paste("(((",myp1,",",myp2,"),",myp3,"),",myp4,")",sep="")
	myhbdf			<<- myhbdf[order(myhbdf$quartet),]
	myhbdf$S		<<- NA
	myhbdf$ABBA		<<- NA
	myhbdf$BABA		<<- NA
	myhbdf$D		<<- NA
	for (quartetnr in c(1:nquartets))
		{
		cat(paste("Quartet ",quartetnr," out of ",nquartets,".",sep=""),sep="\n")
		mynames			<- as.vector(unlist(myquartets[quartetnr,]))	# indnames
		my_quartet		<- as.vector(unlist(mypopcombos[quartetnr,]))	# popnames: c("Norfolk","Lincolnshire","Cambridgeshire","Suffolk")
		submat			<- seqmat[rownames(seqmat)%in%mynames,]
		temp1			<<- submat
		subdnabin		<- as.DNAbin(submat)
		temp2			<<- subdnabin
		# myvs			<- variableSites(subdnabin)
		# n_vs			<<- ncol(myvs$site.freqs)
		MyAnalysis 		<- HC$new(subdnabin)
		temp3			<<- MyAnalysis
		if(nrow(as.matrix(MyAnalysis$DNA$FullSequence))!=nrow(submat))
			{
			cat("WARNING: HybridCheck removed identical sequences. ABBA-BABA calculations for this quartet halted.",sep="\n")
			}else{
			cat("Proceeding analyses...",sep="\n")
			# HCpoplist 			<- list(Norfolk = mynames[1],Lincolnshire = mynames[2],Cambridgeshire = mynames[3],Suffolk = mynames[4])
			HCpoplist 				<- list(HCpop1 = mynames[1],HCpop2 = mynames[2],HCpop3 = mynames[3], HCpop4 = mynames[4])
			names(HCpoplist)		<- my_quartet
			MyAnalysis$setPopulations(HCpoplist)
			#testquartet 			<- list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))
			testquartet 			<- list(c(P1 = my_quartet[1], P2 = my_quartet[2], P3 = my_quartet[3], A = my_quartet[4]))
			MyAnalysis$prepareFourTaxonTests(testquartet)
			MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=1L)
			# store results:
			fttdf 					<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
			myhbdf$S[quartetnr]		<<- fttdf$S[1]
			myhbdf$ABBA[quartetnr]	<<- fttdf$ABBA[1]
			myhbdf$BABA[quartetnr]	<<- fttdf$BABA[1]
			myhbdf$D[quartetnr]		<<- fttdf$D[1]
			}
		}
	cat("Results have been stored in a dataframe called 'myhbdf'.",sep="\n")
	}

testhc<-function()
	{
	site1			<- c("c","c","t","t")
	site2			<- c("c","c","c","c")
	site3			<- c("c","t","c","t")
	site4			<- c("c","t","t","c")
	site5			<- c("y","t","t","c")
	site6			<- c("y","t","t","y")
	site7			<- c("a","a","a","a")
	mymat			<- cbind(site1,site2,site3,site4,site5,site6,site7)
	mymat			<<- mymat
	mynames			<- c("Seq1","Seq2","Seq3","Seq4")
	rownames(mymat)	<- mynames
	testdnabin		<- as.DNAbin(mymat)
	MyAnalysis 		<- HC$new(testdnabin)
	if(nrow(as.matrix(MyAnalysis$DNA$FullSequence))!=nrow(mymat))
		{
		cat("WARNING: HybridCheck removed identical sequences.",sep="\n")
		}else{
		cat(paste("Number of sequences: ",nrow(mymat),sep=""),sep="\n")
		cat(paste("Number of informative sites: ",length(MyAnalysis$DNA$InformativeBp),sep=""),sep="\n")
		#HCmat		<<- as.matrix(MyAnalysis$DNA$FullSequence)
		}
	HCpoplist 		<- list(Norfolk = mynames[1],Lincolnshire = mynames[2],Cambridgeshire = mynames[3],Suffolk = mynames[4])
	MyAnalysis$setPopulations(HCpoplist)
	testquartet 	<- list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))
	MyAnalysis$prepareFourTaxonTests(testquartet)
	MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=1L)
	fttdf 		<<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
	cat("Block estimates have been exported to a dataframe called 'fttdf'.",sep="\n")
	#
	# Conclusion:
	# Ambiguous (read: heterozygosite sites) are treated as if they are separate letters.
	# e.g.: 
	# yttc is not counted as abba site
	# ytty is counted as abba site
	}

# Use R package HybridCheck to calculate D:
runhybridcheck<-function(use_exampledata=FALSE,myquartet=NULL,popnames=mysambar$populations,nsnpsperblock=NULL,nblocks=1)
	{
	if("HybridCheck" %in% rownames(installed.packages()) == FALSE) {devtools::install_github("BenJWard/HybridCheck", build_vignettes = FALSE,upgrade="never")}
	if("HybridCheck" %in% (.packages()) == FALSE){library(HybridCheck)}
	if(use_exampledata)
		{
		cat("Running HybridCheck on example data set...",sep="\n")
		data(MySequences)
		MyAnalysis 	<- HC$new(MySequences)
		#  ls(MyAnalysis, all.names = TRUE)
		HCpoplist 	<- list(Norfolk = c("Seq1", "Seq2", "Seq3"),Lincolnshire = c("Seq4", "Seq5", "Seq6"),Cambridgeshire = c("Seq7", "Seq8"),Suffolk = c("Seq9", "Seq10"))
		MyAnalysis$setPopulations(HCpoplist)
		testquartet <- list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))
		MyAnalysis$prepareFourTaxonTests(testquartet)
		MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=10L)
		fttdf 		<<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
		cat("Block estimates have been exported to a dataframe called 'fttdf'.",sep="\n")
		}else{
		genlight2DNAbin()
		MyAnalysis 	<- HC$new(mysambar$mydnabin)
		HCpoplist	<- list()
		npops		<- length(popnames)
		for(j in c(1:npops))
			{
			my_pop					<- popnames[j]
			HCpoplist[[j]]			<- as.vector(inds$name[inds$filter&inds$pop==my_pop])
			names(HCpoplist)[j]		<- my_pop
			}
		MyAnalysis$setPopulations(HCpoplist)
		if(!is.null(myquartet))
			{
			testquartet 			<- list(c(P1 = myquartet[1], P2 = myquartet[2], P3 = myquartet[3], A = myquartet[4]))
			MyAnalysis$prepareFourTaxonTests(testquartet)
			}else{
			# perform analyses for all possible quartets.
			# first find all possible quartets:
			myquartets				<- as.data.frame(permutations(n=npops,r=4,v=popnames,repeats.allowed=F))
			colnames(myquartets)	<- c("P1","P2","P3","A")
			# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
			myquartets$myorder		<- as.character(myquartets$P2)>as.character(myquartets$P1)
			myquartets$ingroup		<- ifelse(myquartets$myorder,paste(myquartets$P1,myquartets$P2,myquartets$P3,sep="_"),paste(myquartets$P2,myquartets$P1,myquartets$P3,sep="_"))
			myquartets				<- myquartets[(!duplicated(myquartets$ingroup)),c(1:4)]
			# convert to list of named vectors:
			myquartetlist			<- list()
			nquartets				<- nrow(myquartets)
			for (j in c(1:nrow(myquartets)))
				{
				myvec				<- as.vector(myquartets[j,])
				myquartetlist[[j]]	<- c(P1 = as.character(unlist(myvec[1])), P2 = as.character(unlist(myvec[2])), P3 = as.character(unlist(myvec[3])), A = as.character(unlist(myvec[4])))
				}
			MyAnalysis$prepareFourTaxonTests(myquartetlist)
			}
		if(is.null(nsnpsperblock))
			{
			cat(paste("Running FourTaxonTests on ",nblocks," block(s).",sep=""),sep="\n")
			MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=as.integer(nblocks))		# default of 1 (or 1L) means: give genome wide estimate only
			}else{
			cat(paste("Running FourTaxonTests on blocks of ",nsnpsperblock," SNPs.",sep=""),sep="\n")
			MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=nsnpsperblock,numberOfBlocks=NULL)
			}
		fttdf 		<<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
		fttdf$pvalue<<- round(fttdf$X2_P,5)
		cat("Block estimates have been exported to a dataframe called 'fttdf'.",sep="\n")
		#
		# extract final estimate per quartet:
		if(nblocks==1&is.null(nsnpsperblock))
			{
			hbdf			<- fttdf[,c("P1","P2","P3","A","ABBA","BABA","D","pvalue")]
			colnames(hbdf)	<- c("p1","p2","p3","out","ABBA","BABA","D","pvalue")
			}else{
			hbdf			<- fttdf[,c("P1","P2","P3","A","ABBA","BABA","D","D_jEstimate","D_jSD","pvalue")]
			colnames(hbdf)	<- c("p1","p2","p3","out","ABBA","BABA","blockD","D","D_sd","pvalue")
			hbdf$D_err 		<- hbdf$D_sd/sqrt(nblocks)
			hbdf$sign		<- ifelse(hbdf$pvalue>0.05,"NS",ifelse(hbdf$pvalue<=0.001,"**","*"))
			}
		hbdf$quartet		<- paste(hbdf$p1,hbdf$p2,hbdf$p3,hbdf$out,sep="_")
		hbdf				<<- hbdf[(!duplicated(hbdf$quartet)),]
		# Something is wrong with significance test. The p-values, abstracted from fttdf$X2_P column, don't seem to make sense.
		cat("Genome wide estimates have been exported to a dataframe called 'hbdf'.",sep="\n")
		}
	#
	###### EXPLANATION ######
	# PARAMETER SETTINGS:
	# Parameter settings are divided in 5 categories:
	# TripletGeneration	- Settings for Sequence Scan Combinations.
	# SSAnalysis 		- Settings for the sequence similarity scan step.
	# BlockDetection 	- Settings for detecting recombinant blocks from sequence similarity scan data generated from the sequence similarity scan step.
	# BlockDating 		- Settings for calculating the significance values and divergence time estimates, for recombinant blocks detected in the `BlockDetection` step.
	# Plotting:
	# To change parameter settings, use the setParameters method:
	# MyAnalysis$setParameters("TripletGeneration", DistanceThreshold = 0.1, PartitionStrictness = 1)
	#
	# IMPORT DATA
	# HybridCheck builds it owns environment called 'MyAnalysis'. The objects in this environment can be observed by typing: 
	# ls(MyAnalysis, all.names = TRUE) 
	# To view the functions used to import the data, type:
	# MyAnalysis$inputDNA
	# MyAnalysis$DNA$InputDNA
	# To view the data:
	# MyAnalysis$DNA$FullSequence
	# MyAnalysis$DNA$InformativeSequence
	# MyAnalysis$DNA$InformativeBp
	# Note: duplicated sequences are deleted, so you might end up with less sequences than expected.
	#
	# D-STATISTICS 4 TAXON TEST 	
	### step 1. Prepare the test: 
	# MyAnalysis$prepareFourTaxonTests(popCombos)
	# - Option 1:
	# If no arguments is provided to the method, then HybridCheck will generate every possible combination of four populations possible for your data. 
	# For every combination of four populations, HybridCheck then does a simple distance analysis to decide which population is designated as P1, P2, P3, and A for the purposes of the four taxon test. The test assumes the phylogeny: (((P1, P2), P3), A);  
	# - Option 2:
	# Alternatively you can feed in a list of named vectors (see 'testquartet' in example above). 
	# Each named vector is a combination of four populations to test, designated as P1, P2, P3 and A for the purposes of the test.
	#
	### step 2. Run the test:
	# MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=20000L,numberOfBlocks=NULL)
	# Options:
	# - selections: 	"NOT.TESTED" (default) 	tells HybridCheck to run the test for all tests not previously run. 
	#					"ALL" 					tells HybridCheck to run all tests.
	#					or: a list of population combinations to run e.g. 'list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))' 
	# - numberOfBlocks: divide data in blocks consisting of 20000 SNPs? (Didn't get this to work yet)
	# - blockLength:	divide data in 10 blocks. For example: divide a 400kb sequence in non-overlapping blocks of 40k sites (SNPs) 
	# The functions requires one of the two parameters `blockLength` or `numberOfBlocks` to be provided. It is used to calculate the number and size of Jack-knife blocks to use in the test.
	# Note: to switch between the two (either numberofBlocks or blockLength, first create MyAnalysis again (using the commands specified above) and then rerun the fourTaxonTest method. 
	# If blockLength is bigger than number of SNPs, you will get the error:
	# Error in seq.default(from = 1, to = dnaLen, by = fttRecord$blockLength) :  invalid '(to - from)/by'
	#
	### step 3. Get the results
	# fttdf <- MyAnalysis$tabulateFourTaxonTests(selections="ALL",neat=TRUE,global = TRUE)
	# Options:
	# - selections 		can be 'ALL' , 'TESTED', or a list of character vectors of length 4, each denoting a four taxon test by the names of the populations involved.
	# - neat			If TRUE, intermediate values used in calculation of the four taxon tests will be excluded. 
	# - global			If TRUE. then global statistics will be included in the tables. This returns a `data.frame` which can be assigned as a variable and manipulated, explored, and saved, using usual R commands and/or packages.
	}

calcwindowDfst<-function(popnames=mysambar$populations,mytriplets=NULL)
	{
	if(!exists("windowfstdf"))
		{
		return(cat("ERROR: No dataframe called 'windowfstdf'. First run plotwindowfst(fst_type='Wrightfst').",sep="\n"))
		}
	npops			<- length(popnames)
	if(npops<3)
		{
		return(cat("At present less than 3 population defined. ABBA-BABA tests require at least 3 populations (when not including the outgroup). Execution halted.",sep="\n"))
		}
	# find all possible quartets:
	if(is.null(mytriplets))
		{
		mytriplets				<- as.data.frame(permutations(n=npops,r=3,v=popnames,repeats.allowed=F))
		colnames(mytriplets)	<- c("p1","p2","p3")
		# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
		mytriplets$myorder		<- as.character(mytriplets$p2)>as.character(mytriplets$p1)
		mytriplets$ingroup		<- ifelse(mytriplets$myorder,paste(mytriplets$p1,mytriplets$p2,mytriplets$p3,sep="_"),paste(mytriplets$p2,mytriplets$p1,mytriplets$p3,sep="_"))
		mytriplets				<- mytriplets[(!duplicated(mytriplets$ingroup)),c(1:3)]
		}
	ntriplets				<- nrow(mytriplets)
	for(i in 1:ntriplets)
		{
		pop1		<- as.vector(mytriplets[i,1])
		pop2		<- as.vector(mytriplets[i,2])
		pop3		<- as.vector(mytriplets[i,3])
		# fst1:
		mypops		<- c(pop1,pop3)
		mypops		<- mypops[order(mypops)]
		pop_1		<- mypops[1]
		pop_3		<- mypops[2]
		if(paste("Wrightfst",pop_1,pop_3,sep="_")%in%colnames(windowfstdf))
			{
			fst1		<- as.vector(windowfstdf[,paste("Wrightfst",pop_1,pop_3,sep="_")])
			}else{
			return(cat(paste("ERROR: No Wright-fst estimates present for population pair ",pop_1," and ",pop_3,". First run plotwindowfst(fst_type='Wrightfst').",sep=""),sep="\n"))
			}
		# fst2
		mypops		<- c(pop2,pop3)
		mypops		<- mypops[order(mypops)]
		pop_2		<- mypops[1]
		pop_3		<- mypops[2]
		if(paste("Wrightfst",pop_2,pop_3,sep="_")%in%colnames(windowfstdf))
			{
			fst2	<- as.vector(windowfstdf[,paste("Wrightfst",pop_2,pop_3,sep="_")])
			}else{
			return(cat(paste("ERROR: No Wright-fst estimates present for population pair ",pop_2," and ",pop_3,". First run plotwindowfst(fst_type='Wrightfst').",sep=""),sep="\n"))
			}
		fst2		<- as.vector(windowfstdf[,paste("Wrightfst",pop_2,pop_3,sep="_")])
		#
		windowfstdf$Dfst	<<- (fst1-fst2)/(fst1+fst2)
		colnames(windowfstdf)[colnames(windowfstdf)=="Dfst"]	<<- paste("Dfst",pop_1,pop_2,pop_3,sep="_")
		}
	}

runadmixtools<-function(silent=TRUE,tripletdf=NULL,myprefix="metapop.retainedinds.filter.number",overwriteped=FALSE)
	{
	# f3 statistics as implemented in admixtools and admixtools2
	# see: 
	# Patterson et al. 2012 Ancient admixture in human history
	# Peter et al. 2016 Admixture, population structure and F-statistics
	# The most friendly introduction can be found at the github tutorial page of Admixtools2.
	#
	# Key measure is f2, which, like a Fst-statistic, quantifies the differences in allele frequencies (a and b) between population A and B:
	# f2(A,B) = (a-b)^2 
	# The measure f3 is a composite of f2.
	# Assume that you have the following phylogeny: ((A,B),C). Then f3 is defined as:
	# f3(A;B,C) = 0.5*(f2(A,B) + f2(A,C) - f2(B,C))
	#
	# How to interpret this?
	# Incorrect interpretation: 
	# If allele frequency in A is similar to C but different to B, then evidence for admixture between A and C.
	# Correct interpretation:
	# If allele frequency difference (AFD) between A and B is negatively correlated to AFD between A and C, then evidence for admixture between A and C.
	# In other words, it is about the covariance of allele frequencies.
	# A negative f3 implies that:
	# - the more similar allele frequencies are between A and B, the more different they are between A and C. 
	# - vice versa: the more dissimilar AFs are between A and B, the more similar they are between A and C.
	# 
	# The measure f4 is very similar to f3, but incorporating a fourth population.
	# Assume that you have the following phylogeny: ((A,B),C,D) (or/and (((A,B),C),D))?)
	# f4(A,B;B,C) = 0.5*(f2(A,B) + f2(A,C) - f2(B,C))
	#
	# A negative f3 indicates f2(A,C) < f2(B,C), indicating A is admixed between A and C.   
	#
	# To avoid error: File admixtools2/Baltic/Black_f2.rds not found!', you might have to delete the output of previous runs.
	# BiocManager::install("snpStats",suppressUpdates=TRUE)
	# library(snpStats)
	if("admixtools" %in% rownames(installed.packages()) == FALSE)
		{
		cat("WARNING: package 'admixtools' has not been installed yet.",sep="\n")
		cat("Trying to install the package now...",sep="\n")
		devtools::install_github("uqrmaie1/admixtools")
		cat("Finished installing admixtools.",sep="\n")
		}
	if("admixtools" %in% (.packages()) == FALSE)
		{
		library("admixtools")
		}
	if(!is.null(tripletdf))
		{
		if(!is.data.frame(tripletdf))
			{
			return(cat("ERROR: input to tripletdf should be a dataframe.",sep="\n"))
			}
		}
	setwd(mysambar$divergencedir)
	admixtools2folder	<- "admixtools2"
	if(file.exists(admixtools2folder))
		{
		if(!silent){cat("Setting working directory...",sep="\n")}
		setwd(file.path(mysambar$divergencedir,admixtools2folder))
		}else{
		if(!silent){cat("Creating and setting working directory...",sep="\n")}
		dir.create(file.path(mysambar$divergencedir,admixtools2folder))
		setwd(file.path(mysambar$divergencedir,admixtools2folder))
		}
	# creating ped file
	if(!file.exists(paste(myprefix,"ped",sep=".")))
		{
		# if(!silent){cat("Exporting ped file...",sep="\n")}
		genlight2ped(snpsfilter=snps$filter,indsfilter=inds$filter,exportname=myprefix,quiet=TRUE)
		}else{
		if(overwriteped)
			{
			cat("Overwriting existing ped file because the flag 'overwriteped' is set to TRUE.",sep="\n")
			genlight2ped(snpsfilter=snps$filter,indsfilter=inds$filter,exportname=myprefix,quiet=TRUE)
			return(cat("Now first recreate the bed-file. Use 'plink --make-bed --recode A' to convert the newly created ped-file to bed and afterwards rerun the function. Also delete existing admixtools subdirectories.",sep="\n"))
			}else{
			cat("WARNING: using existing ped file. If you want to generate a new ped file, set the flag 'overwriteped' to TRUE.",sep="\n")
			}
		}
	if(!file.exists(paste(myprefix,"bed",sep=".")))
		{	
		# still need to find out: how to write a binary bed file rather than a ped file
		# C:/Users/Menno_de_Jong/Documents/software/plink_win64_20200107/plink --noweb --cow --allow-extra-chr --file metapop.retainedinds.filter.number --recode A -out metapop.retainedinds.filter.number
		cat("ERROR: no bed file present. This is expected behaviour if you run this command for the first time for this dataset. Use 'plink --make-bed --recode A' to convert the newly created ped-file to bed and afterwards rerun the function.",sep="\n")
		cat("BED-file missing from directory:",sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	#
	if(!silent){cat("Calculating f2-statistics...",sep="\n")}
	# option 1: first write to file:
	extract_f2(pref=myprefix,admixtools2folder,maxmiss=0.1,overwrite=TRUE,auto_only=FALSE)
	f2_blocks 		<- f2_from_precomp(admixtools2folder)
	#
	# option 2: store directly as R object without saving first as file:	
	#f2_blocks		<- f2_from_geno(pref=myprefix,admixtools2folder,maxmiss=0.1)
	f2means			<- apply(f2_blocks,1:2,mean)
	#
	if(!silent){cat("Calculating f3-statistics...",sep="\n")}
	if(!is.null(tripletdf))
		{
		cat("For predefined set of populations...",sep="\n")
		f3df			<- qp3pop(f2_blocks,pop1=as.matrix(tripletdf))
		}else{
		cat("For all population triplets...",sep="\n")
		f3df			<- qp3pop(f2_blocks)
		}
	myf3df				<- as.data.frame(f3df)
	myf3df				<<- myf3df
	if(!is.null(tripletdf))
		{
		if(!silent){cat("Reorder and combining ...",sep="\n")}
		myf3df$p			<- round(myf3df$p,8)
		myf3df$label		<- paste(myf3df$pop1,myf3df$pop2,myf3df$pop3,sep="_")
		tripletdf$label		<- paste(tripletdf$target,tripletdf$source1,tripletdf$source2,sep="_")
		tripletdf$nr		<- c(1:nrow(tripletdf))
		myf3df				<- merge(tripletdf,myf3df,by="label")
		myf3df				<- myf3df[order(myf3df$nr),]
		myf3df$mylabels		<- paste("(",myf3df$pop1,"; ",myf3df$pop2,",",myf3df$pop3,")",sep="")
		mysambar$f3df		<<- myf3df
		}else{
		myf3df				<- myf3df
		myf3df$mylabels		<- paste("(",myf3df$pop1,"; ",myf3df$pop2,",",myf3df$pop3,")",sep="")
		mysambar$f3df_all	<<- myf3df
		mysambar$f3df		<<- myf3df
		}
	if(!silent){cat("Results stored in dataframe 'mysambar$f3df'.",sep="\n")}
	}

calcf3<-function(mafdf=NULL)
	{
	# e.g.:
	# mydf 				<- snps[,c("maf_Westcoast","maf_Alaska","maf_zoohybrid")]
	# colnames(mydf)	<- c("pop1","pop2","admixpop")
	# calcf3(mafdf=mydf)
	if(is.null(mafdf))
		{
		return(cat("ERROR: provide dataframe with minor allele frequencies of three populations, with column names 'pop1','pop2','admixpop'.",sep="\n"))
		}
	mafpop1			<- mafdf$pop1
	mafpop2			<- mafdf$pop2
	mafadmix		<- mafdf$admixpop
	#
	# b and c are the introgressors, a is the putatively admixed population:
	f2ab			<<- mean((mafadmix-mafpop1)^2,na.rm=TRUE)
	f2ac			<<- mean((mafadmix-mafpop2)^2,na.rm=TRUE)
	f2bc			<<- mean((mafpop1-mafpop2)^2,na.rm=TRUE)			
	# f3 statistic:
	f3_admix		<<- 0.5*(f2ab+f2ac-f2bc)
	}

# simulations:
runcalcf3sim<-function(mean_maf=0.15,t_1=30,t_2=60,n_inds=100000,n_snps=1000)
	{
	myratios	<<- vector()
	myadmixs	<<- seq(0,1,0.05)
	for(k in c(1:length(myadmixs)))
		{
		cat(k,sep="\n")
		calcf3(meanmaf=mean_maf,t1=t_1,t2=t_2,ninds=n_inds,nruns=1000,nsnps=n_snps,admix=myadmixs[k],plot_ac=FALSE)
		myratios[k]	<<- mean(f2ab_admix)/mean(f2ab)
		}
	graphics.off()
	plot(myadmixs,myratios)
	}

# simulations:
calcf3sim<-function(meanmaf=0.15,t1=20,t2=40,ninds=100,nruns=1000,nsnps=100,admix=0.5,plot_ac=FALSE,do_analysis=TRUE)
	{
	if(do_analysis)
		{
		# t1: split a and b			in ngen ago
		# t2: split (ab) and c		in ngen ago
		f3		<<- vector()
		f2ab	<<- vector()
		f2ac	<<- vector()
		f2bc	<<- vector()
		#
		f3_admix	<<- vector()
		f2ab_admix	<<- vector()
		f2ac_admix	<<- vector()
		f2bc_admix	<<- vector()
		#
		for(i in c(1:nruns))
			{
			startmaf	<<- rbinom(n=nsnps,size=2*ninds,prob=meanmaf)/(2*ninds)
			#
			# population C:
			maf3		<<- startmaf
			for (k in c(1:t2))
				{
				maf3	<<- rbinom(n=nsnps,size=2*ninds,prob=maf3)/(2*ninds)
				}
			# population A and B:
			xmaf		<<- startmaf
			for (k in c(1:(t2-t1)))
				{
				xmaf	<<- rbinom(n=nsnps,size=2*ninds,prob=xmaf)/(2*ninds)
				}
			maf1		<<- xmaf
			maf2		<<- xmaf
			for(k in c(1:t1))
				{
				maf1	<<- rbinom(n=nsnps,size=2*ninds,prob=maf1)/(2*ninds)
				maf2	<<- rbinom(n=nsnps,size=2*ninds,prob=maf2)/(2*ninds)
				}
			maf1admix	<<- (1-admix)*maf1+admix*maf3
			#
			# f2 statistics:
			f2ab[i]	<<- mean((maf1-maf2)^2)
			f2ac[i]	<<- mean((maf1-maf3)^2)
			f2bc[i]	<<- mean((maf2-maf3)^2)
			# f3 statistic:
			f3[i]		<<- 0.5*(f2ab[i] + f2ac[i] - f2bc[i])
			#
			# with admixture:
			# f2 statistics:
			f2ab_admix[i]	<<- mean((maf1admix-maf2)^2)
			f2ac_admix[i]	<<- mean((maf1admix-maf3)^2)
			f2bc_admix[i]	<<- mean((maf2-maf3)^2)			# not different from f2bc
			# f3 statistic:
			f3_admix[i]		<<- 0.5*(f2ab_admix[i] + f2ac_admix[i] - f2bc_admix[i])
			}
		}
	mymin	<- min(c(f2ab,f2ac,f2bc,f2ab_admix,f2ac_admix))
	mymax	<- max(c(f2ab,f2ac,f2bc,f2ab_admix,f2ac_admix))
	#
	par(mfrow=c(1,3),oma=c(6,2,2,2))
	plot(f2ab,f2ac,xlim=c(mymin,mymax),ylim=c(mymin,mymax),col="grey90",pch=16,xlab="f2(a,b)",ylab=c("other f2 scores"))
	points(f2ab,f2bc,col="grey30")
	points(f2ab_admix,f2ac_admix,col="lightsteelblue4")
	#points(f2ab_admix,f2bc,col="darkblue")
	lines(c(0,1),c(0,t2/t1))
	legend("bottomright",legend=c("f2(ab) f2(ac)","f2(ab) f2(ac) admix","f2(ab) f2(bc)"),fill=c("grey90","lightsteelblue4","grey30"),bty='n',cex=1.5)
	#legend("bottomright",legend=c("f2(ab) f2(ac)","f2(ab) f2(ac) admix","f2(ab) f2(bc)","f2(ab) f2(bc) admix"),fill=c("darkred","darkgreen","blue","orange"),bty='n',cex=1.5)
	#
	mydf	<- data.frame("score"=c(rep("1 f2(a,b)",nruns),rep("2 f2(a,b) A",nruns),rep("3 f2(a,c)",nruns),rep("4 f2(a,c) A",nruns),rep("5 f2(a,b) + f2(a,c)",nruns),rep("6 f2(a,b) + f2(a,c) A",nruns),rep("7 f2(b,c)",nruns)),"value"=c(f2ab,f2ab_admix,f2ac,f2ac_admix,f2ab+f2ac,f2ab_admix+f2ac_admix,f2bc))
	boxplot(mydf$value~mydf$score,las=2,col=c("grey90","lightsteelblue4","grey90","lightsteelblue4","grey90","lightsteelblue4","grey30"),ylab="",xlab="")
	mtext("f3 scores",side=3,cex=1.5)
	#
	mymin	<- min(c(f3,f3_admix))
	mymax	<- max(c(f3,f3_admix))
	hist(f3,col="grey50",xlim=c(mymin,mymax))
	hist(f3_admix,add=TRUE)
	abline(v=0,lty=2)
	#
	if(plot_ac)
		{
		# f2(a,c)_admix/f2(a,c) ratio as a function of admix proportion (irrespective of t2/t1 ratio):
		n		<- seq(1,20,1)
		admix	<- (n-1)/n 
		myratio	<- 1/(n^2)
		mypredicted	<- (1-admix)^2	
		graphics.off()
		plot(admix,myratio,type='l')
		points(admix,mypredicted,col="red")
		#
		# hence myratio is (1-admix)^2
		#
		# hence, f3 is given by the function:
		# f3 = ((t2/t1)*p^2-p+1) * f2(A,B) + (1-p)^2 * f2(A,C) - f2(B,C)
		# in which p represents the proportion of admixture from C into A
		# x = a*(p-0.25)^2+b?
		}
	}

calcD<-function(popnames=mysambar$populations,snpfilter=snps$filter,mytriplets=NULL,silent=FALSE,dojackknife=TRUE,minblocks=50,jkblocksize=1000000,storematrix=TRUE,ancestral="major")
	{
	# mytriplets should be a dataframe with three columns (ingroup1, ingroup2, and in the third column the introgressor)
	#
	npops			<- length(popnames)
	if(npops<3)
		{
		return(cat("At present less than 3 population defined. ABBA-BABA tests require at least 3 populations (when not including the outgroup). Execution halted.",sep="\n"))
		}
	#
	if(!is.null(snpfilter))
		{
		myfilter	<- snpfilter
		}else{
		myfilter	<- rep(TRUE,nrow(snps))
		}
	nsnps			<- nrow(snps[myfilter,])
	#
	# find all possible quartets:
	if(is.null(mytriplets))
		{
		if(!silent){cat("Calculating ABBA-BABA statistics for all population triplets...",sep="\n")}
		mytriplets				<- as.data.frame(permutations(n=npops,r=3,v=popnames,repeats.allowed=F))
		}else{
		if(!silent){cat("Calculating ABBA-BABA for predefined population triplets (as defined by input to mytriplets flag)...",sep="\n")}
		}
	colnames(mytriplets)	<- c("p1","p2","p3")
	# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
	mytriplets$myorder		<- as.character(mytriplets$p2)>as.character(mytriplets$p1)
	mytriplets$ingroup		<- ifelse(mytriplets$myorder,paste(mytriplets$p1,mytriplets$p2,mytriplets$p3,sep="_"),paste(mytriplets$p2,mytriplets$p1,mytriplets$p3,sep="_"))
	mytriplets				<- mytriplets[(!duplicated(mytriplets$ingroup)),c(1:3)]
	ntriplets				<- nrow(mytriplets)
	# D statistics:
	ABBA			<- vector()
	BABA			<- vector()
	BBAA			<- vector()
	#
	AAAA			<- vector()
	BAAA			<- vector()
	ABAA			<- vector()
	AABA			<- vector()
	BBBA			<- vector()				 
	#
	dvec			<- vector()
	D_nsnps			<- vector()
	D_nsnps_Dpersnp	<- vector()	# number of SNPs with finite D-score if considered on a SNP by SNP basis
	if(storematrix)
		{
		mysambar$BBAAmat			<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		mysambar$ABBAmat			<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		mysambar$BABAmat			<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		mysambar$dmat				<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		colnames(mysambar$BBAAmat)	<<- mytriplets$ingroup 
		colnames(mysambar$ABBAmat)	<<- mytriplets$ingroup 
		colnames(mysambar$BABAmat)	<<- mytriplets$ingroup 
		colnames(mysambar$dmat)		<<- mytriplets$ingroup 
		}
	# Dfst statistics:
	Dfstvec			<- vector()
	Dfst_nsnps1		<- vector()
	Dfst_nsnps2		<- vector()
	# f statistics:
	ABBAnumerator	<- vector()
	BABAnumerator	<- vector()
	ABBAdenominator	<- vector()
	BABAdenominator	<- vector() 
	fnum			<- vector()
	fden			<- vector()
	fvec			<- vector()
	mysambar$flist	<<- list()
	for(i in 1:ntriplets)
		{
		pop1		<- as.vector(mytriplets[i,1])
		pop2		<- as.vector(mytriplets[i,2])
		pop3		<- as.vector(mytriplets[i,3])
		if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
			p1	<- as.vector(snps[myfilter,paste("maf",pop1,sep="_")])
			}else{
			return(cat(paste("ERROR: No maf vector present for ",pop1,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop2,sep="_")%in%colnames(snps))
			{
			p2	<- as.vector(snps[myfilter,paste("maf",pop2,sep="_")])
			}else{
			return(cat(paste("ERROR: No maf vector present for ",pop2,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop3,sep="_")%in%colnames(snps))
			{
			p3	<- as.vector(snps[myfilter,paste("maf",pop3,sep="_")])
			}else{
			return(cat(paste("ERROR: No maf vector present for ",pop3,".",sep=""),sep="\n"))
			}
		#
		# default assumption is that the minor allele is the derived allele, and the major allele the ancestral allele
		# how much do the results change if we made the opposite assumption?
		# answer: 
		# column 1 and 8 swap
		# columns 2-4 move to 5-7, and 5-7 to 2-4 
		# minor allele is more likely to be derived allele than a major allele: the lower the allele frequency, the higher the probability it mutated recently 
		if(ancestral=="minor")
			{
			p1		<- 1-p1
			p2		<- 1-p2
			p3		<- 1-p3
			}
		# probability of drawing ABBA and BABA, with A denoting the ancestral allele with frequency '1-p':
		ABBA[i] 	<- sum((1-p1)*p2*p3,na.rm=TRUE)	
		BABA[i]		<- sum(p1*(1-p2)*p3,na.rm=TRUE)	
		# probability of combination reflecting true topology:
		BBAA[i] 	<- sum(p1*p2*(1-p3),na.rm=TRUE)	
		# probability of other combinations:
		AAAA[i]		<- sum((1-p1)*(1-p2)*(1-p3),na.rm=TRUE)
		BAAA[i]		<- sum(p1*(1-p2)*(1-p3),na.rm=TRUE)
		ABAA[i]		<- sum((1-p1)*p2*(1-p3),na.rm=TRUE)
		AABA[i]		<- sum((1-p1)*(1-p2)*p3,na.rm=TRUE)
		BBBA[i]		<- sum(p1*p2*p3,na.rm=TRUE)					 
		#
		D_nsnps[i]	<- length(which(!is.na(p1*p2*(1-p3))))
		dvec[i]		<- (ABBA[i]-BABA[i])/(ABBA[i]+BABA[i])
		# store in matrix:
		if(storematrix)
			{
			mysambar$BBAAmat[,i]	<<- p1*p2*(1-p3)
			mysambar$ABBAmat[,i] 	<<- (1-p1)*p2*p3
			mysambar$BABAmat[,i]	<<- p1*(1-p2)*p3
			my_d					<- (mysambar$ABBAmat[,i]-mysambar$BABAmat[,i])/(mysambar$ABBAmat[,i]+mysambar$BABAmat[,i])
			mysambar$dmat[,i]		<<- my_d
			D_nsnps_Dpersnp[i]		<- length(which(is.finite(my_d)))
			}
		#
		# 12-04-2020: alternative way: Dfst using Wright Fst:
		mypops		<- c(pop1,pop3)
		mypops		<- mypops[order(mypops)]
		pop_1		<- mypops[1]
		pop_3		<- mypops[2]
		if(!(paste("Wrightfst",pop_1,pop_3,sep="_")%in%colnames(snps)))
			{
			cat("Fst estimate absent from snps dataframe. Running runWrightFst() function.",sep="\n")
			runWrightFst()
			if(!(paste("Wrightfst",pop_1,pop_3,sep="_")%in%colnames(snps)))
				{
				return(cat(paste("ERROR: No fst estimates present for population pair ",pop_1," and ",pop_3,", even after running the runWrightFst() function. Contact the developer of SambaR.",sep=""),sep="\n"))
				}
			}
		fst1	<- as.vector(snps[myfilter,paste("Wrightfst",pop_1,pop_3,sep="_")])
		#
		mypops		<- c(pop2,pop3)
		mypops		<- mypops[order(mypops)]
		pop_2		<- mypops[1]
		pop_3		<- mypops[2]
		if(!(paste("Wrightfst",pop_2,pop_3,sep="_")%in%colnames(snps)))
			{
			cat("Fst estimate absent from snps dataframe. Running runWrightFst() function.",sep="\n")
			runWrightFst()
			if(!(paste("Wrightfst",pop_2,pop_3,sep="_")%in%colnames(snps)))
				{
				return(cat(paste("ERROR: No fst estimates present for population pair ",pop_2," and ",pop_3,", even after running the runWrightFst() function. Contact the developer of SambaR.",sep=""),sep="\n"))
				}
			}
		fst2		<- as.vector(snps[myfilter,paste("Wrightfst",pop_2,pop_3,sep="_")])
		#
		meanfst1	<- mean(fst1[is.finite(fst1)],na.rm=TRUE)
		meanfst2	<- mean(fst2[is.finite(fst2)],na.rm=TRUE)
		Dfst_nsnps1[i]<- length(which(is.finite(fst1)))
		Dfst_nsnps2[i]<- length(which(is.finite(fst2)))
		Dfstvec[i]	<- (meanfst1-meanfst2)/(meanfst1+meanfst2)
		#
		# 19-04-2020: f statistics:
		# first we need to split species/population 3 in half and generate minor allele frequencies for each artificial subpop:
		myinds		<- inds$nr[inds$filter&inds$pop==pop_3]
		nind_pop3	<- length(myinds)
		nsub1		<- round(nind_pop3/2)
		inds_3a		<- myinds[1:nsub1]
		inds_3b		<- myinds[(nsub1+1):(nind_pop3)]
		p3a 		<- glMean(mygenlight[inds_3a,myfilter],alleleAsUnit=TRUE)
		p3b 		<- glMean(mygenlight[inds_3b,myfilter],alleleAsUnit=TRUE)
		p3a[!is.finite(p3a)]	<- NA
		p3b[!is.finite(p3b)]	<- NA
		mysambar$flist[[i]]		<<- cbind(p3a,p3b)
		# now we are ready to calculate f:
		ABBAnumerator[i] 	<- sum((1-p1)*p2*p3a,na.rm=TRUE)
		BABAnumerator[i] 	<- sum(p1*(1-p2)*p3a,na.rm=TRUE)
		ABBAdenominator[i] 	<- sum((1-p1)*p3b*p3a,na.rm=TRUE)
		BABAdenominator[i]	<- sum(p1*(1-p3b)*p3a,na.rm=TRUE)
		# f (admixture proportion) only sensible to calculate for ABBA excess, not for BABA excess:
		fnum[i]				<- ABBAnumerator[i]-BABAnumerator[i]
		fden[i]				<- ABBAdenominator[i]-BABAdenominator[i]
		fvec[i]				<- ifelse(dvec[i]>0,(ABBAnumerator[i]-BABAnumerator[i])/(ABBAdenominator[i]-BABAdenominator[i]),NA)
		}
	mytriplets$AAAA		<- AAAA/nsnps
	#
	mytriplets$BBAA		<- BBAA/nsnps
	mytriplets$ABBA		<- ABBA/nsnps
	mytriplets$BABA		<- BABA/nsnps
	#
	mytriplets$AABA		<- AABA/nsnps
	mytriplets$BAAA		<- BAAA/nsnps
	mytriplets$ABAA		<- ABAA/nsnps
	#
	mytriplets$BBBA		<- BBBA/nsnps
	mytriplets$all		<- as.vector(rowSums(mytriplets[,4:11]))
	#
	mytriplets$BBAAnorm	<- round(mytriplets$BBAA/(mytriplets$BBAA+mytriplets$ABBA+mytriplets$BABA),3)
	mytriplets$ABBAnorm	<- round(mytriplets$ABBA/(mytriplets$BBAA+mytriplets$ABBA+mytriplets$BABA),3)
	mytriplets$BABAnorm	<- round(mytriplets$BABA/(mytriplets$BBAA+mytriplets$ABBA+mytriplets$BABA),3)
	#
	# probability of observing deviation from equal ratio between ABBA and ABBA:
	nlow				<- ifelse(mytriplets$ABBAnorm<mytriplets$BABAnorm,round(mytriplets$ABBAnorm*nsnps),round(mytriplets$BABAnorm*nsnps))
	nboth				<- round((mytriplets$ABBAnorm+mytriplets$BABAnorm)*nsnps)
	mytriplets$rbinomp	<- round(pbinom(nlow,nboth,0.5,lower.tail=TRUE),5)
	#
	mytriplets$D		<- (mytriplets$ABBA-mytriplets$BABA)/(mytriplets$ABBA+mytriplets$BABA)
	mytriplets$D_nsnps	<- D_nsnps
	mytriplets$ABBAnum	<- ABBAnumerator/nsnps
	mytriplets$BABAnum	<- BABAnumerator/nsnps
	mytriplets$ABBAden	<- ABBAdenominator/nsnps
	mytriplets$BABAden	<- BABAdenominator/nsnps
	mytriplets$fnum		<- fnum
	mytriplets$fden		<- fden
	mytriplets$f		<- fvec
	dscores				<- mytriplets
	if(storematrix)
		{
		# note: calculation of genome wide D is based on average ABBA and average BABA. 
		# ABBA and BABA are based on multiplication of minor allele frequencies, which are almost always present, unless a SNP has no data in a particular population
		# So basically almost all data is being considered
		dscores$D_nsnps_Dpersnp	<- D_nsnps_Dpersnp
		}
	dscores$Dfst		<- Dfstvec
	dscores$Dfst_nsnps1	<- Dfst_nsnps1
	dscores$Dfst_nsnps2	<- Dfst_nsnps2
	dscores$mylabels	<- paste("(((",dscores$p1,", ",dscores$p2,"), ",dscores$p3,"), out)",sep="")
	dscores$mylabels2	<- paste("(((",dscores$p1,", ",dscores$p2,"), ",dscores$p3,"), O)",sep="")
	#
	# dividing genome in blocks needed for jackknife procedure:
	cat(paste("Dividing genome in blocks of fixed length of ",jkblocksize," bp...",sep=""),sep="\n")
	mychroms		<- snps$chr[myfilter]
	mypos			<- snps$pos[myfilter]
	block_indices 	<- get_block_indices(block_size=jkblocksize,positions=mypos,chromosomes=mychroms)
	mysambar$block_indices	<<- block_indices
	n_blocks 		<- length(block_indices)
	if(n_blocks<50)
		{
		cat(paste("WARNING: Genome divided in only", n_blocks, "blocks. This number might not allow for meaningful jackknife resampling."),sep="\n")
		}else{
		cat(paste("Genome divided into", n_blocks, "blocks."),sep="\n")
		}
	if(dojackknife&n_blocks>=minblocks)
		{
		if(!silent){cat("Starting jackknife procedure...",sep="\n")}
		D_sd			<- vector()
		D_err			<- vector()
		D_Z				<- vector()
		blockDmat		<- matrix(NA,ncol=ntriplets,nrow=n_blocks)
		blockDfstmat	<- matrix(NA,ncol=ntriplets,nrow=n_blocks)
		for(k in 1:nrow(mytriplets))
			{
			pop1		<- as.vector(mytriplets[k,1])
			pop2		<- as.vector(mytriplets[k,2])
			pop3		<- as.vector(mytriplets[k,3])
			p1			<- as.vector(snps[myfilter,paste("maf",pop1,sep="_")])
			p2			<- as.vector(snps[myfilter,paste("maf",pop2,sep="_")])
			p3			<- as.vector(snps[myfilter,paste("maf",pop3,sep="_")])
			#
			mypops		<- c(pop1,pop3)
			mypops		<- mypops[order(mypops)]
			pop_1		<- mypops[1]
			pop_3		<- mypops[2]
			fst1		<- as.vector(snps[myfilter,paste("Wrightfst",pop_1,pop_3,sep="_")])
			mypops		<- c(pop2,pop3)
			mypops		<- mypops[order(mypops)]
			pop_2		<- mypops[1]
			pop_3		<- mypops[2]
			fst2		<- as.vector(snps[myfilter,paste("Wrightfst",pop_2,pop_3,sep="_")])
			#
			for(blocknr in c(1:n_blocks))
				{
				myselection	<- block_indices[[blocknr]]
				blockp1		<- p1[myselection]
				blockp2		<- p2[myselection]
				blockp3		<- p3[myselection]
				blockBBAA 	<- sum(blockp1*blockp2*(1-blockp3))
				blockABBA 	<- sum((1-blockp1)*blockp2*blockp3)
				blockBABA	<- sum(blockp1*(1-blockp2)*blockp3)	
				blockDmat[blocknr,k]	<- (blockABBA-blockBABA)/(blockABBA+blockBABA)
				#
				# 13-04-2020:
				blockfst1	<- fst1[myselection]
				blockfst2	<- fst2[myselection]
				meanfst1	<- mean(blockfst1[is.finite(blockfst1)],na.rm=TRUE)
				meanfst2	<- mean(blockfst2[is.finite(blockfst2)],na.rm=TRUE)
				blockDfstmat[blocknr,k]	<- (meanfst1-meanfst2)/(meanfst1+meanfst2)
				}
			D_sd[k] 		<- get_jackknife_sd(block_indices=block_indices,FUN=D.stat,p1,p2,p3)
			# cat(paste("D standard deviation = ", round(D_sd,4)),sep="\n")
			# From this unbiased estimate of the standard deviation of D, we can compute the standard error and the Z score to test of whether D deviates significantly from zero.
			D_err[k] 		<- D_sd[k]/sqrt(n_blocks)
			D_Z[k] 			<- abs(dscores$D[k]/D_err[k])
			}
		blockdf				<- as.data.frame(blockDmat)
		colnames(blockdf)	<- paste("triplet",c(1:ntriplets),sep="")
		blockdf$nsnps		<- sapply(block_indices,FUN=length)
		# mysambar$blockdf	<<- blockdf
		#
		blockfstdf			<- as.data.frame(blockDfstmat)
		colnames(blockfstdf)<- paste("triplet",c(1:ntriplets),sep="")
		blockfstdf$nsnps	<- sapply(block_indices,FUN=length)
		# mysambar$blockfstdf <<- blockfstdf
		#
		dscores$D_sd	<- D_sd
		dscores$nblocks	<- n_blocks
		dscores$D_err	<- D_err
		dscores$D_Z		<- D_Z
		mypvalues		<- 2*pnorm(-abs(dscores$D_Z))	# this assumes the test is 2 sided (which I think it is). If not, we should not multiply by 2.
		dscores$pvalue	<- formatC(mypvalues,format="e") 
		dscores$sign2	<- ifelse(mypvalues>0.05,"NS",ifelse(mypvalues<=0.001,"**","*"))
		dscores$sign	<- ifelse(D_Z<3,"NS",ifelse(D_Z>6,"**","*"))
		dscores$excess	<- ifelse(mypvalues>0.05,"no",ifelse(mytriplets$D>0,"ABBA","BABA"))
		#
		Dtable			<- dscores[,c("p1","p2","p3","BBAA","ABBA","BABA","D","D_nsnps","D_sd","nblocks","D_err","D_Z","pvalue","sign","excess")]
		}else{
		cat(paste("Flag dojackknife has been set to FALSE or number of genome blocks is below ",minblocks," (value defined to minblocks flag). Omitting jackknife calculations and hence no identification if obtained D-values are significant.",sep=""),sep="\n")
		Dtable			<- dscores[,c("p1","p2","p3","BBAA","ABBA","BABA","D","D_nsnps")]
		}
	mysambar$dscores	<<- dscores
	write.table(Dtable,"Dstatistics.txt",col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")	
	cat("A table with D-statistics (called 'Dstatistics.txt') has been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}

chromD<-function(n_chroms=NULL,popnames=mysambar$populations,snpfilter=snps$filter,silent=FALSE)
	{
	npops			<- length(popnames)
	if(npops<3)
		{
		return(cat("At present less than 3 population defined. ABBA-BABA tests require at least 3 populations (when not including the outgroup). Execution halted.",sep="\n"))
		}
	if(is.null(n_chroms))
		{
		return(cat("ERROR: provide a value to n_chroms flag.",sep="\n"))
		}
	if(is.null(snpfilter))
		{
		myfilter		<- rep(TRUE,nrow(snps))
		}else{
		myfilter		<- snpfilter
		}
	if(!silent){cat("Dividing genome into chromosomes...",sep="\n")}
	snpstemp			<- snps[snps$chr2<=n_chroms&myfilter,]
	chrom_names 		<- as.vector(unique(snpstemp$chr))
	chrom_indices 		<- lapply(chrom_names, function(chrom) which(snpstemp$chr == chrom))
	names(chrom_indices)<- chrom_names
	#
	# find all possible quartets:
	mytriplets				<- as.data.frame(permutations(n=npops,r=3,v=popnames,repeats.allowed=F))
	colnames(mytriplets)	<- c("p1","p2","p3")
	#
	# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
	mytriplets$myorder		<- as.character(mytriplets$p2)>as.character(mytriplets$p1)
	mytriplets$ingroup		<- ifelse(mytriplets$myorder,paste(mytriplets$p1,mytriplets$p2,mytriplets$p3,sep="_"),paste(mytriplets$p2,mytriplets$p1,mytriplets$p3,sep="_"))
	mytriplets				<- mytriplets[(!duplicated(mytriplets$ingroup)),c(1:3)]
	# calculate D per chromosome:
	if(!silent){cat("Calculating chromosome specific ABBA-BABA statistics for all population triplets...",sep="\n")}
	Dbychrom		<<- matrix(NA,ncol=nrow(mytriplets),nrow=n_chroms)
	for(k in 1:nrow(mytriplets))
		{
		if(!silent){cat(k,sep="\n")}
		pop1		<- mytriplets[k,1]
		pop2		<- mytriplets[k,2]
		pop3		<- mytriplets[k,3]
		P1			<- paste("maf",pop1,sep="_")
		P2			<- paste("maf",pop2,sep="_")
		P3			<- paste("maf",pop3,sep="_")
		Dbychrom[,k] <<- sapply(chrom_names,function(chrom) D.stat(snpstemp[chrom_indices[[chrom]],P1],snpstemp[chrom_indices[[chrom]],P2],snpstemp[chrom_indices[[chrom]], P3]))
		}
	if(!silent){cat("Results have been stored in a matrix object called 'Dbychrom'.",sep="\n")}
	#
	# dividing genome in blocks needed for jackknife procedure:
	if(!silent){cat("Dividing genome in blocks of fixed length...",sep="\n")}
	block_indices_chrom 	<- lapply(chrom_names,function(chrom) get_block_indices(block_size=1e6,positions=snpstemp$pos[snpstemp$chr==chrom]))
	n_blocks 				<- length(block_indices_chrom)
	if(!silent){cat(paste("Chromosomes divided into", n_blocks, "blocks."),sep="\n")}
	chrom_indices			<- chrom_indices
	#
	if(!silent){cat("Starting jackknife procedure...",sep="\n")}
	Dsd_bychrom		<- matrix(NA,ncol=nrow(mytriplets),nrow=n_chroms)
	for(k in 1:nrow(mytriplets))
		{
		if(!silent){cat(k,sep="\n")}
		for (m in c(1:n_chroms))
			{
			#cat(paste("chromosome ",m,sep=""),sep="\n")
			block_indices<- block_indices_chrom[[m]]
			pop1		<- mytriplets[k,1]
			pop2		<- mytriplets[k,2]
			pop3		<- mytriplets[k,3]
			p1			<- as.vector(snpstemp[,paste("maf",pop1,sep="_")])
			p2			<- as.vector(snpstemp[,paste("maf",pop2,sep="_")])
			p3			<- as.vector(snpstemp[,paste("maf",pop3,sep="_")])
			Dsd_bychrom[m,k] 	<- get_jackknife_sd(block_indices=block_indices,FUN=D.stat,p1,p2,p3)
			}
		}
	nblocks_chrom	<- sapply(block_indices_chrom,FUN=length)
	D_err_chrom 	<- Dsd_bychrom/sqrt(nblocks_chrom)
	D_Z_chrom 		<- Dbychrom/D_err_chrom
	D_pvalue_chrom	<- 2*pnorm(-abs(D_Z_chrom))
	D_pvalue2_chrom	<- formatC(D_pvalue_chrom,format="e") 
	D_sign			<- ifelse(D_pvalue_chrom>0.05,"NS",ifelse(D_pvalue_chrom<=0.001,"**","*"))
	Dchromlist		<<- list()
	Dchromlist[[1]]	<<- Dbychrom
	Dchromlist[[2]]	<<- Dsd_bychrom
	Dchromlist[[3]]	<<- nblocks_chrom
	Dchromlist[[4]]	<<- D_err_chrom
	Dchromlist[[5]]	<<- D_Z_chrom
	Dchromlist[[6]]	<<- D_pvalue_chrom
	Dchromlist[[7]]	<<- D_pvalue2_chrom
	Dchromlist[[8]]	<<- D_sign
	names(Dchromlist)<<-c("D","D_sd","nblocks","D_err","D_Z","pvalue","pvalue2","sign") 
	if(!silent){cat("Results have been stored in a list object called 'Dchromlist'.",sep="\n")}
	}

barplotD<-function(mydf=mysambar$dscores,export=NULL,silent=TRUE,plottitle=NULL,allcombi=FALSE,addnsnps=TRUE)
	{
	if(is.null(mydf))
		{
		return(cat("ERROR: provide a dataframe to the mydf flag.",sep="\n")) 
		}
	if(!silent){cat("Generating barplots...",sep="\n")}
	if(!is.null(export))
		{
		mywidth		<- 9.5
		myheight	<- 7
		plotlabel	<- ifelse(allcombi,"allcombi","3combi")
		plotname	<- ifelse(is.null(plottitle),paste("Dbarplot",plotlabel,sep="_"),paste("Dbarplot",plotlabel,plottitle,sep="_"))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		}
	layout(matrix(c(1:12),nrow=3,ncol=4,byrow=TRUE))
	par(mar=c(0.5,3.5,2,0.5),oma=c(6,1.5,1.5,2))
	ntriplets	<- nrow(mydf)
	totalsnps	<- mydf$D_nsnps
	#
	for(k in c(1:ntriplets))
		{
		if(!silent){cat(k,sep="\n")}
		if(allcombi)
			{
			myscores	<- as.vector(unlist(mydf[k,4:11]))
			nsnps		<- round(as.vector(unlist(mydf[k,4:11]*mydf$D_nsnps[k])))
			mymax		<- max(myscores)
			mymax		<- ifelse(mymax>0.77,1.1,0.77)
			if(k>=9)
				{
				myxlabel	<- c("AAAA","BBAA","ABBA","BABA","AABA","BAAA","ABAA","BBBA")
				}else{
				myxlabel	<- rep("",8)
				}
			xx<-barplot(myscores,las=2,names.arg=myxlabel,ylim=c(0,mymax),border=NA,cex.lab=1.25,col=c("grey70","lightsteelblue4","lightsteelblue4","lightsteelblue4","grey70","grey70","grey70","grey70"))
			mtext(mydf$mylabels2[k],side=3,line=0,cex=0.75)
			}else{
			myscores	<- as.vector(unlist(mydf[k,13:15]))
			myscores2	<- as.vector(unlist(mydf[k,5:7]))
			nsnps		<- round(myscores2*mydf$D_nsnps[k])
			mymax		<- max(myscores)
			mymax		<- ifelse(mymax>0.55,1.1,0.55)
			if(k>=9)
				{
				myxlabel	<- c("BBAA","ABBA","BABA")
				}else{
				myxlabel	<- rep("",3)
				}
			xx<-barplot(myscores,las=1,names.arg=myxlabel,ylim=c(0,mymax),border=NA,cex.lab=1.25,col=c("lightsteelblue4","lightsteelblue4","lightsteelblue4"))
			mtext(mydf$mylabels2[k],side=3,line=0.25,cex=0.75)
			mtext(paste("D = ",round(mydf$D[k],2),sep=""),side=3,line=-0.75,cex=0.75)
			}
		if(addnsnps)
			{
			text(x=xx,y=myscores-0.02,nsnps,cex=1,pos=3)
			}	
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,line=-0.5,cex=1.5,outer=TRUE)
		}
	myylab		<- ifelse(allcombi,"Proportion of sites","Relative proportion of sites")	
	mtext(side=2,myylab,line=-0.75,cex=1.5,outer=TRUE)
	xlabdistance<- ifelse(allcombi,4,3)
	mtext(side=1,"Presence of ancestral (A) and derived (B) allele",line=xlabdistance,cex=1.5,outer=TRUE)
	if(!is.null(export)){dev.off()}
	}

plotf3<-function(mydf=mysambar$f3df,plotname="f3stats",mycol="grey50",export=NULL,shortpop=FALSE,tripletlabels=NULL,silent=TRUE,mycex=3,linepos=NULL,add_Z=TRUE,ymax=0.012)
	{
	ndata	<- nrow(mydf)
	if(length(mycex)==1)
		{
		mycex	<- rep(mycex,ndata)
		}
	mycols		<- ifelse(mydf$est>0,"black","orange")
	ypos		<- seq(0,1,1/(ndata))
	if(!is.null(linepos))
		{
		linepos	<- 0.5*(ypos[linepos]+ypos[linepos+1])
		}
	mypch			<- rep(16,nrow(mydf))
	if(shortpop)
		{
		myp1		<- ifelse(nchar(as.vector(mydf$pop1))>2,substr(as.vector(mydf$pop1),1,2),as.vector(mydf$pop1))
		myp2		<- ifelse(nchar(as.vector(mydf$pop2))>2,substr(as.vector(mydf$pop2),1,2),as.vector(mydf$pop2))
		myp3		<- ifelse(nchar(as.vector(mydf$pop3))>2,substr(as.vector(mydf$pop3),1,2),as.vector(mydf$pop3))
		mylabels	<- paste("(((",myp1,",",myp2,"),",myp3,"),O)",sep="")
		}else{
		mylabels	<- mydf$mylabels
		}
	#
	if(!is.null(export))
		{
		myheight		<- ndata*0.5+2.5
		myheight2		<- ndata*50+250
		mywidth			<- ifelse(shortpop,10,15)
		mywidth2		<- ifelse(shortpop,1000,1500)
		plotname		<- ifelse(shortpop,paste(plotname,"shortpop",sep="_"),plotname)
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf")
			{
			return(cat("File type win.metafile for LD-plot not accepted.",sep="\n"))
			#if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)} # this file is too big
			}
		}
	uppermargin	<- 2
	if(shortpop)
		{
		par(mar=c(5,14.5,uppermargin,4),cex.axis=2,cex.lab=3,cex.main=3)
		}else{
		par(mar=c(5,37,uppermargin,5),cex.axis=2,cex.lab=3,cex.main=3)
		}
	mymax	<- max(abs(mydf$est))
	mymax	<- ifelse(mymax<ymax,ymax,mymax)
	plot(c(-mymax,mymax),c(0,1),col="white",xlab="",ylab="",yaxt='n')
	axis(2,at=ypos[-(ndata+1)],mylabels,las=2,cex=2)
	text(y=1,x=-0.5*mymax,"admixture",cex=2.5)
	text(y=1,x=0.5*mymax,"NO admixture",cex=2.5)
	mtext(side=1,line=3.5,"f3 score",cex=3)
	abline(v=0,col=mycol,lwd=2)
	for(k in c(1:ndata))
		{
		if(!silent){cat(k,sep="\n")}
		if(!silent){cat(mydf$est[k],sep="\n")}
		if(!silent){cat(ypos[k],sep="\n")}
		if(!silent){cat(mypch[k],sep="\n")}
		points(x=mydf$est[k],y=ypos[k],pch=mypch[k],col=mycols[k],cex=mycex[k])
		#segments(x0=x_low[k],y0=ypos[k],x1=x_up[k],y1=ypos[k],col=mycol,lwd=3.5)
		}
	if(!is.null(linepos))
		{
		abline(h=linepos,lty=2)
		}
	if(!is.null(tripletlabels))
		{
		cat("Adding tripletlabels...",sep="\n")
		for(k in c(1:ndata))
			{
			text(y=ypos[k],x=-mymax,tripletlabels[k],cex=1.5,pos=4)
			}
		}
	if(add_Z)
		{
		axis(4,at=ypos[-(ndata+1)],round(mydf$z,1),las=2,cex.axis=1.5,labels=FALSE)
		myzscores	<- abs(round(mydf$z,1))
		mycols	<- ifelse(myzscores<3,"grey60","black")
		mtext(myzscores,at=ypos[-(ndata+1)],side=4,line=1,col=mycols,las=1,cex=1.75)
		}
	if(!is.null(export)){dev.off()}
	}

plotD<-function(mydf=mysambar$dscores,plotname="Dstats",mycol="grey50",export=NULL,n_chroms=NULL,plotDfst=FALSE,shortpop=FALSE,methodname="SambaR",doboxplot=FALSE,tripletlabels=NULL,Dmax=1,silent=TRUE,add_f=FALSE,add_Z=TRUE,mycex=3,linepos=NULL)
	{
	# method name should be 'SambaR' or 'HybridCheck'
	if(doboxplot)
		{
		ndata	<- length(as.vector(unique(mydf$mylabels)))
		}else{
		ndata	<- nrow(mydf)
		}
	if(length(mycex)==1)
		{
		mycex	<- rep(mycex,ndata)
		}
	ypos		<- seq(0,1,1/(ndata))
	if(!is.null(linepos))
		{
		linepos	<- 0.5*(ypos[linepos]+ypos[linepos+1])
		}
	#yposlabel	<- 1+1/(ndata)
	yposlabel	<- 1
	x_low		<- 0-mydf$D_err
	x_up		<- 0+mydf$D_err
	if(plotDfst)
		{
		mypch	<- rep(16,nrow(mydf))
		}else{
		if("sign"%in%colnames(mydf))
			{
			mysign	<- mydf$sign
			if(all(!is.na(mydf$sign)))
				{
				mypch	<- ifelse(mysign!="NS",16,21)
				}else{
				cat("WARNING: NA-values present in 'sign'-column of D-scores dataframe. Using the x-symbol to represent D-scores with unknown significance scores.",sep="\n")
				mypch	<- ifelse(is.na(mysign),4,ifelse(mysign!="NS",16,21))
				}
			}else{
			cat("WARNING: Input dataframe does not contain a column named 'sign' for significance. Assigning all data points same pch symbol.",sep="\n")
			mypch	<- rep(16,nrow(mydf))
			}
		}
	mypch	<<- mypch
	if(shortpop)
		{
		myp1		<- ifelse(nchar(as.vector(mydf$p1))>2,substr(as.vector(mydf$p1),1,2),as.vector(mydf$p1))
		myp2		<- ifelse(nchar(as.vector(mydf$p2))>2,substr(as.vector(mydf$p2),1,2),as.vector(mydf$p2))
		myp3		<- ifelse(nchar(as.vector(mydf$p3))>2,substr(as.vector(mydf$p3),1,2),as.vector(mydf$p3))
		mylabels	<- paste("(((",myp1,",",myp2,"),",myp3,"),O)",sep="")
		}else{
		mylabels	<- mydf$mylabels
		}
	#
	if(!is.null(export))
		{
		myheight	<- ndata*0.5+2.5
		myheight2	<- ndata*50+250
		mywidth		<- ifelse(shortpop,10,15)
		mywidth2	<- ifelse(shortpop,1000,1500)
		if(plotDfst)
			{
			plotname	<- "Dfst"
			}
		if(doboxplot)
			{
			plotname	<- paste(plotname,"boxplot",sep="_")
			}
		if(!is.null(n_chroms))
			{
			plotname	<- paste(plotname,"chrom",sep="_")
			}
		if(shortpop)
			{
			plotname	<- paste(plotname,"shortpop",sep="_")
			}
		Drangelabel		<- paste("max",Dmax,sep="")
		flabel			<- ifelse(add_f,"with_prop","no_prop")
		zlabel			<- ifelse(add_Z,"with_Z","no_Zscore")
		if(export=="eps"){postscript(paste(plotname,methodname,Drangelabel,flabel,zlabel,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,methodname,Drangelabel,flabel,zlabel,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,methodname,Drangelabel,flabel,zlabel,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf")
			{
			return(cat("File type win.metafile for LD-plot not accepted.",sep="\n"))
			#if(export=="wmf"){win.metafile(paste(plotname,methodname,Drangelabel,flabel,zlabel,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)} # this file is too big
			}
		}
	uppermargin	<- ifelse(add_f,4.5,2)
	if(shortpop)
		{
		par(mar=c(5,14.5,uppermargin,4),cex.axis=2,cex.lab=3,cex.main=3)
		}else{
		par(mar=c(5,37,uppermargin,5),cex.axis=2,cex.lab=3,cex.main=3)
		}
	if(doboxplot)
		{
		boxplot(mydf$D~mydf$mylabels,las=1,horizontal=TRUE,ylim=c(-Dmax,Dmax),xlab="",ylab="",col="grey80",border="grey60",outline=FALSE)
		stripchart(D~mylabels,data=mydf,vertical=FALSE,col="black",method="jitter",pch=16,cex=1.5,bg="bisque",add=TRUE,ylab="")
		abline(v=0)
		mtext(side=1,line=3.5,"D score",cex=3)
		#text(y=ndata+0.75,x=-0.5,"BABA excess",cex=2.5)
		#text(y=ndata+0.75,x=0.5,"ABBA excess",cex=2.5)
		text(y=ndata,x=-0.5*Dmax,"BABA excess",cex=2.5,pos=3)
		text(y=ndata,x=0.5*Dmax,"ABBA excess",cex=2.5,pos=3)
		}else{
		plot(c(-Dmax,Dmax),c(0,1),col="white",xlab="",ylab="",yaxt='n')
		axis(2,at=ypos[-(ndata+1)],mylabels,las=2,cex=2)
		text(y=yposlabel,x=-0.5*Dmax,"BABA excess",cex=2.5)
		text(y=yposlabel,x=0.5*Dmax,"ABBA excess",cex=2.5)
		if(plotDfst)
			{
			mtext(side=1,line=3.5,"Dfst score",cex=3)
			}else{
			mtext(side=1,line=3.5,"D score",cex=3)
			}
		abline(v=0,col=mycol,lwd=2)
		for(k in c(1:ndata))
			{
			if(!silent){cat(k,sep="\n")}
			if(!is.null(n_chroms))
				{
				mypch2	<- ifelse(Dchromlist$sign[,k]!="NS",16,21)
				points(x=Dbychrom[,k],y=rep(ypos[k],n_chroms),pch=mypch2,col="black",cex=3)
				}else{
				if(plotDfst)
					{
					points(x=mydf$Dfst[k],y=ypos[k],pch=mypch[k],col="black",cex=3)
					}else{
					if(!silent){cat(mydf$D[k],sep="\n")}
					if(!silent){cat(ypos[k],sep="\n")}
					if(!silent){cat(mypch[k],sep="\n")}
					points(x=mydf$D[k],y=ypos[k],pch=mypch[k],col="black",cex=mycex[k])
					segments(x0=x_low[k],y0=ypos[k],x1=x_up[k],y1=ypos[k],col=mycol,lwd=3.5)
					}
				}
			}
		if(!is.null(linepos))
			{
			abline(h=linepos,lty=2)
			}
		if(!is.null(tripletlabels))
			{
			cat("Adding tripletlabels...",sep="\n")
			for(k in c(1:ndata))
				{
				text(y=ypos[k],x=-Dmax,tripletlabels[k],cex=1.5,pos=4)
				}
			}
		if(add_Z)
			{
			if("D_Z"%in%colnames(mydf))
				{
				axis(4,at=ypos[-(ndata+1)],round(mydf$D_Z,1),las=2,cex.axis=1.5,labels=FALSE)
				myzscores	<- abs(round(mydf$D_Z,1))
				mycols		<- ifelse(myzscores<3,"grey60","black")
				mtext(round(mydf$D_Z,1),at=ypos[-(ndata+1)],side=4,line=1,col=mycols,las=1,cex=1.75)
				}else{
				cat("WARNING: column 'D_Z' is missing. Not adding z-scores to plot.",sep="\n")
				}
			}
		if(add_f)
			{
			if("f"%in%colnames(mydf))
				{
				par(new=TRUE,mgp=c(3,0.25,0))
				plot(c(-1,1),c(0,1),col="white",xlab="",ylab="",yaxt='n',xaxt='n')
				for(k in c(1:ndata))
					{
					if(!is.na(mydf$sign[k])&mydf$sign[k]!="NS")
						{
						points(x=mydf$f[k],y=ypos[k],pch=18,col="orange",cex=2.5)
						}
					}
				axis(side=3,col.axis="orange",col="orange")
				mtext(side=3,line=2,"f score",cex=3,col="orange")
				}else{
				cat("WARNING: column 'f' is missing. Not adding f-scores to plot.",sep="\n")
				}
			}
		}
	if(!is.null(export)){dev.off()}
	}

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
D.stat<-function(p1,p2,p3) 
	{
	ABBA <- (1-p1)*p2*p3
    BABA <- p1*(1-p2)*p3
	# 05_11_2021: get rid of NA-values:
	# return((sum(ABBA)-sum(BABA))/(sum(ABBA)+sum(BABA)))
    # option 1:
	# return((sum(ABBA,na.rm=TRUE)-sum(BABA,na.rm=TRUE))/(sum(ABBA,na.rm=TRUE)+sum(BABA,na.rm=TRUE)))
	# option 2:
	mybool		<- (!is.na(ABBA))&(!is.na(BABA))
	nretained	<- length(mybool[mybool])
	ntotal		<- length(mybool)
	#cat(paste("Number of retained blocks (no missing values): ",nretained," out of ",ntotal,".",sep=""),sep="\n")
	return((sum(ABBA[mybool])-sum(BABA[mybool]))/(sum(ABBA[mybool])+sum(BABA[mybool])))
	}

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data'):
# The D statistic does not quantify the proportion of the genome that has been shared. 
# A related method has been developed to estimate f, the 'admixture proportion'.
# The idea behind this approach is that we compare the observed excess of ABBA over BABA sites, to that which would be expected under complete admixture. 
# To approximate the expectation under complete admixture we re-count ABBA and BABA but substituting a second population of the P3 species in the place of P2. 
# If you lack a second population for p3, you can simply split your P3 samples into two. 
f.stat <- function(p1, p2, p3a, p3b) 
	{
    # same as D.stat, except:
	ABBA_numerator <- (1-p1)*p2*p3a
    BABA_numerator <- p1*(1-p2)*p3a
	#
    ABBA_denominator <- (1-p1)*p3b*p3a
    BABA_denominator <- p1*(1-p3b)*p3a
	#
    return(sum(ABBA_numerator)-sum(BABA_numerator))/(sum(ABBA_denominator)-sum(BABA_denominator))
    }

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
get_block_indices<-function(block_size,positions,chromosomes=NULL)
	{
    if(is.null(chromosomes)) 
		{
        block_starts 	<- seq(min(positions),max(positions),block_size)
        block_ends 		<- block_starts + block_size - 1
        lapply(1:length(block_starts), function(x) which(positions>=block_starts[x] & positions<=block_ends[x]))
        }else{
        chrom_names 	<- unique(chromosomes)
        block_starts 	<- lapply(chrom_names, function(chrom_name) seq(min(positions[chromosomes==chrom_name]), max(positions[chromosomes==chrom_name]), block_size)) 
        block_chroms 	<- unlist(lapply(1:length(block_starts), function(x) rep(chrom_names[x], length(block_starts[[x]]))))
        block_starts 	<- unlist(block_starts)
        block_ends 		<- block_starts + block_size - 1
        lapply(1:length(block_starts), function(x) which(chromosomes == block_chroms[x] & positions >= block_starts[x] & positions <= block_ends[x]))
        }
    }

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
# this function runs the jackknife procedure by calculating pseudovalues by removing one block at a time
# if the arguments specified by "..." are vectors, they will be indexed as they are; if they have two dimensions, they will be indexed along the first dimension
get_jackknife_sd<-function(block_indices, FUN, ...)
	{
    n_blocks 	<- length(block_indices)
    args 		<- list(...)
    overall_mean<- FUN(...)
    if (is.null(dim(args[1])))
		{
		blockestimates	<- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]]]))*(n_blocks-1))
        return(sd(blockestimates,na.rm=TRUE))
        }else{
		blockestimates	<- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]],]))*(n_blocks-1))
        return(sd(blockestimates,na.rm=TRUE))
        }
    }

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
block_jackknife <- function(block_indices, FUN, ...)
	{
    n_blocks	<- length(block_indices)
    args 		<- list(...)
    overall_mean<- FUN(...)
    if (is.null(dim(args[1])))
		{
        pseudovalues <- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]]]))*(n_blocks-1))
        }else{
        pseudovalues <- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]],]))*(n_blocks-1))
        }
    mean 		<- mean(pseudovalues,na.rm=TRUE)
    std_dev 	<- sd(pseudovalues,na.rm=TRUE)
    list(mean=mean,std_dev=std_dev)
    }

# Correlation between allele frequencies:
# This measure was first published by Sewall Wright in 1943 (Wright, 1943, see equation 48 and the SambaR manual).   
runWrightFst<-function(popnames=mysambar$populations,popcols=mysambar$mycolours)
	{
	if(length(popnames)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate genetic distance. Execution halted."))
		}
	npops			<- length(popnames)
	nsnps			<- nrow(snps)
	combitable		<- combn(popnames,m=2)
	mysambar$pairpop1		<<- combitable[1,]
	mysambar$pairpop2		<<- combitable[2,]
	mysambar$pairpopcol1	<<- vector()
	mysambar$pairpopcol2	<<- vector()
	for(k in c(1:ncol(combitable)))
		{
		mysambar$pairpopcol1[k]	<<- popcols[which(popnames==mysambar$pairpop1[k])]
		mysambar$pairpopcol2[k]	<<- popcols[which(popnames==mysambar$pairpop2[k])]
		}
	#
	pearsonvector	<- vector()
	varfstvector	<- vector()
	Wrightfstvector	<- vector()
	for(i in 1:ncol(combitable))
		{
		pop1	<- combitable[1,i]
		pop2	<- combitable[2,i]
		my_dataset<- paste(pop1,pop2,sep="_")
		if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
			maf1	<- as.vector(snps[,paste("maf",pop1,sep="_")])
			}else{
			return(cat(paste("No maf vector present for ",pop1,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop2,sep="_")%in%colnames(snps))
			{
			maf2	<- as.vector(snps[,paste("maf",pop2,sep="_")])
			}else{
			return(cat(paste("No maf vector present for ",pop2,".",sep=""),sep="\n"))
			}
		missfilter			<- !(is.na(maf1)|is.na(maf2))
		#
		# correlation between minor allele frequencies:
		pearsonvector[i]	<- round(cor(maf1[missfilter],maf2[missfilter],method="pearson"),2)
		#
		# fst based on variation between minor allele frequencies:
		# varfst = E( MAFmeta - MAFpop )^2 / npops
		popmafs			<- as.vector(snps[,paste("maf",c(pop1,pop2),sep="_")])
		npop1			<- nrow(inds[inds$filter&inds$pop==pop1,])
		npop2			<- nrow(inds[inds$filter&inds$pop==pop2,])
		nboth			<- npop1+npop2
		combimaf		<- (npop1*popmafs[,1]+npop2*popmafs[,2])/nboth
		mydevmat		<- matrix(NA,nrow=nsnps,ncol=2)
		mydevmat		<- (popmafs-combimaf)^2 
		snpvar			<- (mydevmat[,1]*npop1+mydevmat[,2]*npop2)/nboth
		Wrightfst		<- ifelse(snpvar==0,0,snpvar/(combimaf*(1-combimaf)))
		snpdev			<- sqrt(snpvar)
		snps$dev		<<- snpdev
		snps$Wrightfst	<<- Wrightfst
		names(snps)[names(snps) == "dev"] 		<<- paste("dev",my_dataset,sep = "_")
		names(snps)[names(snps) == "Wrightfst"] <<- paste("Wrightfst",my_dataset,sep = "_")
		varfstvector[i]		<- mean(snpdev[snps$filter&missfilter&is.finite(snpvar)],na.rm=TRUE) 
		Wrightfstvector[i]	<- mean(Wrightfst[snps$filter&missfilter&is.finite(Wrightfst)],na.rm=TRUE) 
		#
		# varfst:
		# varfst is a very intuitive measure: if you calculate fst this way, it is easy to understand what it means.
		# for example: a fst of 0.04 means that for each locus the difference between the metapop minor allele frequency and the population minor allele frequency is sqrt(0.04)=0.2. 
		# which would be the case if MAFpop1=0.1 and MAFpop2=0.5. 
		#
		# Wright 1943 fst:
		# The maximum varfst value is 0.25, namely when the metapop allele frequency is 0.5, and mafpop1=0 and mafpop2=1.
		# The mean distance between metapop MAF and populations MAF is in that case 0.5 (sqrt(0.25)).
		# Hence, the range of devfst is not 0 to 1, but 0 to 0.25 (given a mean MAF of 0.5).
		# It can be mathematically shown that for population pairs which are fixated for different alleles (i.e. MAFpop=1 and MAFpop2=0), varfst equals: p(1-p). This is the maximum possible value.
		# As in our example: 0.5(1-0.5)=0.25.
		# For a quick and dirty proof: 
		# randomly drawing alleles from a biallelic locus within a meta population, represents a binomial probability, because you can either draw allele A or a. 
		# For binomial distributions it is known that the mean equals np and the variance equals np(1-p). 
		# Anyway, we could represent fst as a ratio between the observed variance and maximum possible variance, to get a scale ranging between 0 and 1.
		# This can also be defined as the ratio between variance within the mean variance within population and the variance in the total population:
		# varfst = E( MAFmeta - MAFpop )^2 / npops
		# varmeta = pq = p(1-p)
		}
	varfstvector			<- round(varfstvector,4)
	Wrightfstvector			<- round(Wrightfstvector,4)
	mysambar$varfstvector	<<- varfstvector
	mysambar$Wrightfstvector<<- Wrightfstvector
	mysambar$pearsonvector	<<- pearsonvector
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

LKtest<-function(pop1="pheno1",pop2="pheno2")
	{
	if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
		maf1	<- as.vector(snps[,paste("maf",pop1,sep="_")])
		}else{
		return(cat(paste("No maf vector present for ",pop1,".",sep=""),sep="\n"))
		}
	if(paste("maf",pop2,sep="_")%in%colnames(snps))
		{
		maf2	<- as.vector(snps[,paste("maf",pop2,sep="_")])
		}else{
		return(cat(paste("No maf vector present for ",pop2,".",sep=""),sep="\n"))
		}
	#
	## calculate Wright Fst:
	popmafs				<- as.vector(snps[,paste("maf",c(pop1,pop2),sep="_")])
	npop1				<- nrow(inds[inds$filter&inds$type,])
	npop2				<- nrow(inds[inds$filter&(!inds$type),])
	nboth				<- npop1+npop2
	combimaf			<- (npop1*popmafs[,1]+npop2*popmafs[,2])/nboth
	mydevmat			<- matrix(NA,nrow=nrow(snps),ncol=2)
	mydevmat			<- (popmafs-combimaf)^2 
	snpvar				<- (mydevmat[,1]*npop1+mydevmat[,2]*npop2)/nboth
	fstvec				<- ifelse(snpvar==0,0,snpvar/(combimaf*(1-combimaf)))
	snps$Wrightfst_pheno<<- fstvec
	#	
	## Lewontin-Krakauer test:
	npops				<- 2
	fstmean				<- mean(fstvec[snps$filter2],na.rm=TRUE)
	snps$lkscore		<<- ((npops-1)*fstvec)/fstmean
	snps$lkpvalue		<<- pchisq(lkscore,df=(npops-1),lower.tail=FALSE)
	}

# 16-10-2021: still under construction:
FLKtest<-function()
	{
	# The variation of allele frequencies (p) within a single population over time is given by the formula:
	# Var(p)	<- Ft*p0*(1-p0)
	# in which:
	# - p0 denotes the allele frequence at T=0
	# - Ft, or Wright-Fisher fixation index, denotes the expected amount of genetic drift within a population after t generations.
	#	Ft = 1-(1-1/(2*Ne))^t  = t/(2Ne)
	#
	# In a kinship matrix, these Ft values are on the diagonal. They are denoted as Fi, in which i denotes population i.   
	# The off-diagonal values in a kinship matrix indicates the fixation index in an ancestral population of populations i and j. These values are denoted as f_ij.  	
	# In case of a stairlike phylogeny (radiation-like dispersal), all off-diagonal values equal zero.
	# The kinship matrix itself is denoted with the symbol F.
	# 
	# Thus, the expected variance of allele frequencies in population i (p_i) is given by:
	# Var(p_i)		<- Fi*p0*(1-p0)
	# The expected covariance of allele frequencies in population i and j is given by:
	# Cov(p_i,p_j)	<- Fi*p0*(1-p0)
	# The expected variance of allele frequencies in the metapopulation (p) is given by the matrix population:
	# Var(p)		<- F*p0*(1-p0)
	#
	# p0 is estimated as:
	# p0 = 	1'_n*(F^-1)*p	# divided by:
	#		1'_n*(F^-1)*1_n
	# in which: 
	# 1_n:	n-vector of 1's (length of number of populations)
	# 1'_n:	?
	#
	# This function constructs a kinship matrix following the algorithm of the FLK test (Bonhomme et al. 2013).
	#
	popnames			<- mysambar$populations
	npops				<- length(popnames)
	# calculate Reynolds distance:
	if(is.null(mysambar$popdistdf))
		{
		popdistances()
		}
	# get distance matrix:
	distvec				<- mysambar$popdistdf[,"Reynolds_Weir_Cockerham_1983_adegenet",drop=FALSE]
	mattemp				<- matrix(NA,nrow=npops,ncol=npops)
	colnames(mattemp)	<- popnames
	rownames(mattemp)	<- popnames
	mattemp[lower.tri(mattemp)]	<- distvec[,1]
	distmat						<- t(mattemp)
	distmat[lower.tri(distmat)]	<- mattemp[lower.tri(mattemp)]
	#
	# Neighbour-joining tree:
	mytree				<- phangorn::NJ(distmat)
	branchlengths		<- mytree[2]$edge.length
	#
	# Kinship matrix:
	kinmatrix			<- matrix(0,nrow=npops,ncol=npops)
	colnames(kinmatrix)	<- popnames[mytree$edge[,2]]
	rownames(kinmatrix)	<- popnames[mytree$edge[,2]]
	diag(kinmatrix)		<- branchlengths
	kinmatrix[2,1]		<- 0			# mytree[2]$node.length ? 
	kinmatrix[1,2]		<- 0			# mytree[2]$node.length ?
	#
	}

plotfst<-function(popnames=mysambar$populations,export=NULL,inputvector=mysambar$pearsonvector,exportname="Mafcorr.pop",plottitle="Pearson's correlation coefficient")
	{
	# this expects output of mafcorr() function
	npops			<- length(popnames)
	# plot correlation:
	m2				<- matrix(NA,nrow=npops,ncol=npops)
	m2[lower.tri(m2, diag=FALSE)] <- inputvector
	mymatrix 			<- t(m2)
	rownames(mymatrix)	<- popnames
	colnames(mymatrix)	<- popnames
	ordermat			<- mymatrix
	mymatrix[lower.tri(mymatrix, diag=TRUE)] <-	0
	#
	# reorder populations (27-04-2021):
	ordermat[lower.tri(ordermat,diag=FALSE)]<- inputvector
	ordermat			<- ordermat[mysambar$popordernr,mysambar$popordernr]
	ordermat			<- round(ordermat,3)
	ordermat[lower.tri(ordermat,diag=TRUE)] <-	0
	#
	# plot:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
	if(max(mymatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
		}
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(ordermat==0,NA,ordermat),
	notecol="black",notecex=2.5,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	if(!is.null(plottitle))
		{
		mtext(plottitle, side = 3, line = 1, cex = 2.5)	
		}
	if(!is.null(export)){dev.off()}
	}

# depends on chromfst
multichromfst<-function(exporttype=NULL,nrchroms=NULL,popnames=mysambar$populations,silent=TRUE)
	{
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	mycolours		<- as.vector(unique(inds$popcol))
	combicoltable	<- combn(mycolours,m=2)	
	myfstdf			<- snps[,grep("Wrightfst",colnames(snps))]
	for(combinr in c(1:ncombi))
		{
		my_fst		<- colnames(myfstdf)[combinr]
		mycolfunc 	<- colorRampPalette(c(combicoltable[1,combinr],combicoltable[2,combinr]))
		my_combicol	<- mycolfunc(3)[2]
		mypair		<- paste(combitable[1,combinr],combitable[2,combinr],sep="_")
		if(!silent){cat(my_fst,sep="\n")}
		if(!silent){cat(mypair,sep="\n")}
		chromfst(export=exporttype,n_chroms=nrchroms,myfst=my_fst,mycol=my_combicol,wideplot=TRUE,plotlabel=mypair)
		}
	}
	
chromfst<-function(export=NULL,n_chroms=NULL,myfst=NULL,mycol="darkorchid4",wideplot=FALSE,plotlabel=NULL,nsnpsplot=FALSE,yaxislabel="Fst",labcex=2.25)
	{
	if(is.null(n_chroms))
		{
		return(cat("Error: provide a value to the n_chroms flag.",sep="\n"))
		}
	if(is.null(myfst))
		{
		return(cat("Error: provide a string (Wrightfst_pop1_pop2) to the myfst flag.",sep="\n"))
		}
	snpstemp	<- snps[snps$chr2<=n_chroms&snps$filter,]
	snpstemp	<- snpstemp[order(snpstemp$chr2,snpstemp$pos),]
	if(!is.null(export))
		{
		if(wideplot)
			{
			mysize2	<- 4
			mysize	<- 14
			mysize4	<- 400
			mysize3	<- 1400
			plotname<- ifelse(is.null(plotlabel),"Chrom.fst",paste("Chrom.fst",plotlabel,sep="_"))
			}else{
			mysize2	<- 6
			mysize	<- 6
			mysize4	<- 600
			mysize3	<- 600
			plotname<- ifelse(is.null(plotlabel),"Chrom.fst.chromindex",paste("Chrom.fst.chromindex",plotlabel,sep="_"))
			}
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize2)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),,family=mysambar$myfont,width=mysize,height=mysize2)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mysize3,height=mysize4)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize2)}
		}
	par(mar=c(5,6.5,1,1),cex.axis=2)
	fstvalues	<- as.vector(snpstemp[,myfst])
	mycols		<- as.vector(snpstemp$chrcol)
	mycols		<- ifelse(mycols!="black",mycol,mycols)
	mycols2		<- as.vector(unique(mycols))
	if(wideplot)
		{
		plot(fstvalues,col=mycols,pch=16,cex=1.25,ylim=c(0,1),xlab="",ylab="",las=1)
		mtext(side=1,"SNP index",cex=labcex,line=3.5)
		}else{
		stripchart(fstvalues~chr2,data=snpstemp,vertical=TRUE,col=mycols2,method="jitter",pch=16,cex=0.5,bg="bisque",las=2,ylab="")
		mtext(side=1,"Chromosome index",cex=labcex,line=3.5)
		}
	mtext(side=2,yaxislabel,cex=labcex,line=4)
	if(!is.null(export)){dev.off()}
	if(nsnpsplot)
		{
		if(!is.null(export)){dev.off()}
		#
		# plot mean fst per chrom:
		if(!is.null(export))
			{
			plotname	<- ifelse(is.null(plotlabel),"Chrom.fst_vs_nsnps",paste("Chrom.fst_vs_nsnps",plotlabel,sep="_"))
			if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=6,height=6)}
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),,family=mysambar$myfont,width=6,height=6)}
			if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=600,height=600)}
			if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=6,height=6)}
			}
		par(mar=c(5,5,1,1))
		snpstemp	<- snpstemp[is.finite(fstvalues)&!is.na(fstvalues),]
		fstvalues	<- as.vector(snpstemp[,myfst])
		chrommeanfst<- aggregate(fstvalues,by=list(snpstemp$chr),FUN=mean)
		chromnsnps	<- aggregate(snpstemp$nsnps,by=list(snpstemp$chr),FUN=mean)
		plot(chromnsnps$x,chrommeanfst$x,xlab="",ylab="",pch=16,las=1,col="white")
		text(chromnsnps$x,chrommeanfst$x,as.character(chrommeanfst$Group.1),xlab="",ylab="",cex=1,las=1)
		mtext(side=1,"# SNPs per chrom",cex=2,line=3)
		mtext(side=2,"Chromosome mean ratio fst",cex=2,line=3)
		if(!is.null(export)){dev.off()}
		}
	}

# Reynolds genetic distance
# depends on popdistances function
pop_reynoldsmatrix<-function(export=NULL)
	{
	popnames	<- mysambar$populations
	npops		<- length(popnames)
	if(is.null(mysambar$popdistdf))
		{
		return(cat("ERROR: mysambar$popdistdf is missing. Did you run the popdistances function?",sep="\n")) 
		}
	# get distance matrix:
	if(!"RWC1983_ad"%in%colnames(mysambar$popdistdf))
		{
		return(cat("ERROR: column 'RWC1983_ad' not present in mysambar$popdistdf. Did you run the popdistances function?",sep="\n")) 
		}
	distvec						<- mysambar$popdistdf[,"RWC1983_ad",drop=FALSE]
	mattemp						<- matrix(NA,nrow=npops,ncol=npops)
	colnames(mattemp)			<- popnames
	rownames(mattemp)			<- popnames
	mattemp[lower.tri(mattemp)]	<- distvec[,1]
	distmat						<- t(mattemp)
	distmat[lower.tri(distmat)]	<- mattemp[lower.tri(mattemp)]
	#
	# reorder populations (27-04-2021):
	ordermat					<- distmat[mysambar$popordernr,mysambar$popordernr]
	ordermat[lower.tri(ordermat,diag=FALSE)] <-	0
	ordermat					<- round(ordermat,3)
	#
	# prepare plot:
	floor_dec 					<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec 				<- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin						<- floor_dec(min(ordermat,na.rm=TRUE),1)
	if(max(ordermat,na.rm=TRUE)==1)
		{
		mymax					<- 1
		}else{
		mymax					<- ceiling_dec(max(ordermat,na.rm=TRUE),1)
		}
	myBreaks					<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 					<- colorRampPalette(c("white","orange"))
	myColours					<- c(mycolfunc(length(myBreaks)-1))
	#
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("Reynoldsmatrix.pop.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("Reynoldsmatrix.pop.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("Reynoldsmatrix.pop.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("Reynoldsmatrix.pop.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(ordermat==0,NA,ordermat),
	notecol="black",notecex=2.5,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	mtext("Reynolds genetic distance", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	#
	mytmatrix					<- t(mymatrix)
	mysambar$popreynoldvector	<<- mytmatrix[lower.tri(mytmatrix,diag=FALSE)]
	mysambar$popreynoldmatrix	<<- ordermat
	}

# Nei's genetic distance
pop_neimatrix<-function(popnames=mysambar$populations,export=NULL)
	{
	npops				<- length(popnames)
	if(length(popnames)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate Nei's genetic distance. Execution halted."))
		}
	mymatrix			<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=TRUE)
	colnames(mymatrix)	<- rownames(mymatrix)
	mymatrix			<- mymatrix[popnames,popnames]
	ordermat			<- mymatrix
	#
	# prepare plot:
	mymatrix[lower.tri(mymatrix, diag=FALSE)] <-	0
	mymatrix			<- round(mymatrix,3)
	floor_dec 			<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec 		<- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin				<- floor_dec(min(mymatrix,na.rm=TRUE),1)
	if(max(mymatrix,na.rm=TRUE)==1)
		{
		mymax			<- 1
		}else{
		mymax			<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
		}
	myBreaks			<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 			<- colorRampPalette(c("white","orange"))
	myColours			<- c(mycolfunc(length(myBreaks)-1))
	#
	# reorder populations (27-04-2021):
	ordermat			<- ordermat[mysambar$popordernr,mysambar$popordernr]
	ordermat[lower.tri(ordermat,diag=FALSE)] <-	0
	ordermat			<- round(ordermat,3)
	#
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("Neimatrix.pop.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("Neimatrix.pop.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("Neimatrix.pop.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("Neimatrix.pop.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(ordermat==0,NA,ordermat),
	notecol="black",notecex=2.5,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	mtext("Nei's genetic distance", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	mytmatrix				<- t(mymatrix)
	mysambar$popneivector	<<- mytmatrix[lower.tri(mytmatrix,diag=FALSE)]
	mysambar$popneimatrix	<<- mymatrix
	#
	combitable				<- combn(popnames,m=2)
	mysambar$pairpop1		<<- combitable[1,]
	mysambar$pairpop2		<<- combitable[2,]
	}

# 04_10_2021:
# Below function is alternative to the more simple command:
# ordermat=mat[mysambar$popordernr,mysambar$popordernr]
# Note that the above single line command (and below function as well in fact) only works if values above and below diagonal are identical.
reordermat<-function(myvector=mysambar$popneivector)
	{
	popnames				<- mysambar$populations
	npops					<- length(popnames)
	mymat					<- matrix(0,nrow=npops,ncol=npops)
	colnames(mymat)			<- popnames
	rownames(mymat)			<- popnames
	mymat[lower.tri(mymat)]	<- myvector
	tmat					<- t(mymat)
	mymat[upper.tri(mymat)]	<- tmat[upper.tri(tmat)]
	#
	# reorganize order:
	mydf					<- data.frame("x"=rep(mysambar$popordernr,each=npops),"y"=rep(mysambar$popordernr,npops),"z"=NA)
	for(k in c(1:nrow(mydf)))
		{
		x				<- mydf$x[k]
		y				<- mydf$y[k]
		mydf$z[k]		<- mymat[x,y]
		}
	ordermat			<- matrix(mydf$z,npops,npops,byrow=TRUE)
	colnames(ordermat)	<- mysambar$poporder
	rownames(ordermat)	<- mysambar$poporder
	return(ordermat)
	}

# 22-09-2021, edited on 04-10-2021 (earlier version contained an issue with reordering)
exportneitable<-function(popnames=mysambar$populations)
	{
	if(is.null(mysambar$popneivector))
		{
		return(cat("ERROR: mysambar$popneivector not present.",sep="\n"))
		}
	# Nei's D:
	neimat	<- reordermat(myvector=mysambar$popneivector)
	if(!is.null(mysambar$Wrightfstvector))
		{
		# Wright Fst:
		wrightmat				<- reordermat(myvector=mysambar$Wrightfstvector)
		mymat					<- neimat
		mymat[lower.tri(mymat)]	<- wrightmat[lower.tri(wrightmat)]
		write.table(round(mymat,3),"NeiD_above_WrightFst_below.txt",row.names=TRUE,col.names=TRUE,sep="\t",quote=FALSE)
		}
	if(!is.null(mysambar$WC1983fstvector))
		{
		# Weir and Cockerham Fst:
		wcmat					<- reordermat(myvector=mysambar$WC1983fstvector)
		mymat					<- neimat
		mymat[lower.tri(mymat)]	<- wcmat[lower.tri(wcmat)]
		write.table(round(mymat,3),"NeiD_above_WC1983Fst_below.txt",row.names=TRUE,col.names=TRUE,sep="\t",quote=FALSE)
		}
	}

# tree for populations:
# This shows genetic difference between populations, not evolutionary relationship!
# i.e. a recently diverged founder population can be genetically more distant from the source population than a bigger population which diverged earlier. 
getpoptree<-function(mymatrix=mysambar$popneimatrix,exportlabel="neiD",labelcex=1.5,mytype="phylogram",myheight=NULL,mywidth=NULL,mylwd=3,edgecolors=TRUE,donj=TRUE,popnames=mysambar$populations,popcolours=mysambar$mycolours,silent=TRUE,doexport=TRUE,addnodelabels=TRUE,maxnodelabel=NULL)
	{
	#install.packages("phangorn")
	#library(phangorn)
	# 22-09-2021: replaced following line:
	# mymatrix[lower.tri(mymatrix)]	<- mymatrix[upper.tri(mymatrix)]
	# 22-09-2021: with the following lines:
	if(is.null(mymatrix))
		{
		return(cat("ERROR: input matrix (defined using mymatrix flag) does not exist. If input matrix is mysambar$popneimatrix (default), did you run the pop_neimatrix() function?",sep="\n"))
		}
	mymatrix						<- t(mymatrix)
	#mymatrix[lower.tri(mymatrix)]	<- mytmatrix[lower.tri(mytmatrix)]
	#
	colnames(mymatrix)				<- mysambar$populations
	colnames(mymatrix)				<- mysambar$populations
	if(!donj)
		{
		mytree						<- phangorn::upgma(mymatrix)
		}else{
		mytree						<- phangorn::NJ(mymatrix)
		}
	#
	mycolors2 				<- rep("black",Nedge(mytree))
	npops					<- length(popnames)
	mytree					<<- mytree
	if(edgecolors)
		{
		if(!silent){cat("Defining edge colours...",sep="\n")}
		tipindex				<- which(mytree$edge[,2]%in%c(1:npops))
		poporder				<- mytree$edge[tipindex,2]
		mycolors2[tipindex]		<- popcolours[poporder]
		}
	#
	# plot:
	plotname	<- ifelse(donj,paste("Poptree",exportlabel,mytype,"NJ.pdf",sep="."),paste("Poptree",exportlabel,mytype,"UPGMA.pdf",sep="."))
	if(doexport)
		{
		if(is.null(myheight)&is.null(mywidth))
			{
			pdf(plotname)
			}else{
			pdf(plotname,height=myheight,width=mywidth)
			}
		}
	labelangle	<- ifelse(mytype=="phylogram","horizontal","axial")
	plot.phylo(mytree,cex=labelcex,font=3,adj=0,edge.color=mycolors2,tip.color=popcolours,lwd=mylwd,edge.width=mylwd,show.node.label=TRUE,type=mytype,lab4ut=labelangle)
	if(addnodelabels)
		{
		if(!is.null(mytree$node.label))
			{
			if(!silent){cat("Adding node labels...",sep="\n")}
			# this are node labels (e.g. support values), not tip labels (e.g. sample names, stored at mytree$label)
			if(!is.null(maxnodelabel))
				{
				mytree$node.label	<- ifelse(mytree$node.label>=maxnodelabel,NA,mytree$node.label)
				}
			nodelabels(mytree$node.label,adj=c(1.3,-0.5),frame="n",cex=nodelabelcex,font=3,xpd=TRUE,col="grey50")
			}else{
			if(!silent){cat("Nodelabels not present.",sep="\n")}
			}
		}
	if(doexport){dev.off()}
	}

runhudsonfst<-function(maf1=0)
	{
	mafdiff	<- vector()
	fstvec	<- vector()
	maf2	<- seq(maf1,1,0.05)
	for(i in c(1:length(maf2)))
		{
		mafdiff[i]	<- abs(maf2[i]-maf1)  
		fstvec[i]	<- hudsonfst(q1=maf1,q2=maf2[i])
		}
	plot(mafdiff,fstvec,xlim=c(0,1),ylim=c(0,1),type='b')
	}

# Hudson Fst
# Hudson, RR.; Slatkin, M.; Maddison, WP. (Oct 1992). "Estimation of Levels of Gene Flow from DNA Sequence Data"
hudsonfst<-function(q1=0.1,q2=0.15)
	{
	# q1: maf pop1
	# q2: maf pop2
	#
	# within pop1:
	pi1		<- q1*(1-q1)*2
	# within pop2:
	pi2		<- q2*(1-q2)*2
	# mean within:
	pi_w	<- (pi1+pi2)/2
	# between:
	pi_b	<- q1*(1-q2)+(1-q1)*q2
	# fst:
	myfst	<- (pi_b-pi_w)/pi_b
	return(myfst)
	}

# Nei_1977_Fst	(until 17-06-2020 called Wright Fst)
locusNeiFst<-function(popnames=mysambar$populations,histo=FALSE,export=NULL)
	{
	combitable		<- combn(popnames,m=2)
	# Prepare plot:
	graphics.off()
	if(histo)
		{
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Nei1977_Fst.eps",family=mysambar$myfont,width=10,height=7)}
			if(export=="pdf"){pdf("Nei1977_Fst.pdf",family=mysambar$myfont,width=10,height=7)}
			if(export=="png"){png("Nei1977_Fst.png",family=mysambar$myfont,width=1000,height=720)}
			if(export=="wmf"){win.metafile("Nei1977_Fst.wmf",family=mysambar$myfont,width=10,height=7)}
			}
		par(mfrow=c(1,ncol(combitable)),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		maf2pops		<- glMean(mygenlight[inds$filter&inds$pop==combitable[1,i]|inds$pop==combitable[2,i],])		
		expHt			<- 2*maf2pops*(1-maf2pops)
		mafpop1			<- snps[names(snps) == paste("maf",combitable[1,i],sep="_")]
		mafpop2			<- snps[names(snps) == paste("maf",combitable[2,i],sep="_")]
		expHs			<- 0.5*((2*mafpop1[,1]*(1-mafpop1[,1]))+(2*mafpop2[,1]*(1-mafpop2[,1])))		# I included [,1] to avoid problems when snps-dataset contain multiple column with the same name
		snps$NeiFst		<<- (expHt-expHs)/expHt 
		# Names of both populations combined:
		combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
		# Plot:
		if(histo)
			{
			hist(snps$NeiFst[snps$filter],50,main=combiname,xlab="Wright Fst")
			}
		# Change name of column in snps dataset:
		names(snps)[names(snps) == "NeiFst"] <<- paste("NeiFst",combiname,sep = "_")			
		}
	if(histo)
		{
		if(!is.null(export)){dev.off()}
		}
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

runstamppFst<-function(n_boots=100,popnames=mysambar$populations,export=NULL,do_analysis=TRUE)
	{
	mymatrix	<- as.matrix(mygenlight[inds$filter,snps$filter])
	indstemp	<- droplevels(inds[inds$filter,])
	mymatrix	<- mymatrix[order(indstemp$pop),]
	indstemp2	<- indstemp[order(indstemp$pop),]
	tempgenlight<- as.genlight(mymatrix)
	pop(tempgenlight)<- indstemp2$pop
	npops		<- as.vector(length(unique(indstemp2$pop)))
	# sambarfunction_calcdistance:
	##### CALCDISTANCE #####
	# sambarfunction_calcdistance:
	### Fst analyses:
	# sambarfunction_calcdistance:
	if(do_analysis)
		{
		myfstout					<- stamppFst(tempgenlight, nboots = n_boots, percent = 95, nclusters = 1)
		myfstvalues					<- round(myfstout$Fsts[lower.tri(myfstout$Fsts,diag=FALSE)],4)
		mypvalues					<- round(myfstout$Pvalues[lower.tri(myfstout$Pvalues,diag=FALSE)],4)
		mylogpvalues				<- -log10(mypvalues)
		mylogpvalues[is.infinite(mylogpvalues)]	<- 20
		mysambar$WC1983fstvector	<<- myfstvalues
		mysambar$WC1983pvector		<<- mypvalues
		mysambar$WC1983logpvector	<<- mylogpvalues
		}else{
		cat("Using previously generated Stampp fst-values...",sep="\n")
		myfstvalues		<- mysambar$WC1983fstvector
		mypvalues		<- mysambar$WC1983pvector
		mylogpvalues	<- mysambar$WC1983logpvector 
		}
	### FST
	fstmat				<- matrix(NA,nrow=npops,ncol=npops)
	fstmat[lower.tri(fstmat, diag=FALSE)] <- myfstvalues
	fstmat 				<- t(fstmat)
	rownames(fstmat)	<- popnames
	colnames(fstmat)	<- popnames
	orderfstmat			<- fstmat
	fstmat[lower.tri(fstmat,diag=TRUE)] <-	0
	#
	# reorder populations (27-04-2021):
	orderfstmat[lower.tri(orderfstmat,diag=FALSE)]	<- myfstvalues
	orderfstmat			<- orderfstmat[mysambar$popordernr,mysambar$popordernr]
	orderfstmat[lower.tri(orderfstmat,diag=TRUE)] 	<-	0
	#
	### P-VALUES
	pmat				<- matrix(NA,nrow=npops,ncol=npops)
	pmat[lower.tri(pmat,diag=FALSE)] <- mypvalues
	pmat 				<- t(pmat)
	rownames(pmat)		<- popnames
	colnames(pmat)		<- popnames
	orderpmat			<- pmat
	pmat[lower.tri(pmat,diag=TRUE)] <-	0
	#
	# reorder populations (27-04-2021):
	orderpmat[lower.tri(orderpmat,diag=FALSE)]<- mypvalues
	orderpmat			<- orderpmat[mysambar$popordernr,mysambar$popordernr]
	orderpmat[lower.tri(orderpmat,diag=TRUE)] <-	0
	#	
	if(npops>2)
		{
		myfstmatrix	<- round(orderfstmat,3)
		mypmatrix	<- round(orderpmat,3)
		mycolfunc 	<- colorRampPalette(c("white","orange"))
		floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
		ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
		mymin		<- floor_dec(min(myfstmatrix,na.rm=TRUE),1)
		if(max(myfstmatrix,na.rm=TRUE)==1)
			{
			mymax	<- 1
			}else{
			mymax	<- ceiling_dec(max(myfstmatrix,na.rm=TRUE),1)
			}
		myBreaks	<- seq(mymin,mymax,(mymax-mymin)/10)
		myColours	<- c(mycolfunc(length(myBreaks)-1))
		#
		if(!is.null(export))
			{
			mysize	<- 3+npops*1.75
			mysize2	<- 300+npops*150
			if(export=="eps"){postscript("WC_1984_Fst_pvalues.eps",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="pdf"){pdf("WC_1984_Fst_pvalues.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="png"){png("WC_1984_Fst_pvalues.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
			if(export=="wmf"){win.metafile("WC_1984_Fst_pvalues.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
			}
		heatmap.2(mypmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=mypmatrix,
		notecol="black",notecex=2.5,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
		col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
		mtext("Weir & Cockerham 1984 Fst p-values", side = 3, line = 1, cex = 2.5)	
		if(!is.null(export)){dev.off()}
		#
		if(!is.null(export))
			{
			mysize	<- 3+npops*1.75
			mysize2	<- 300+npops*150
			if(export=="eps"){postscript("WC_1984_Fst.eps",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="pdf"){pdf("WC_1984_Fst.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="png"){png("WC_1984_Fst.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
			if(export=="wmf"){win.metafile("WC_1984_Fst.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
			}
		heatmap.2(myfstmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(myfstmatrix==0,NA,myfstmatrix),
		notecol="black",notecex=2.5,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
		col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
		mtext("Weir & Cockerham 1984 Fst", side = 3, line = 1, cex = 2.5)	
		if(!is.null(export)){dev.off()}
		}else{
		cat("Omitting heatmap because 2 populations only (1 pairwise comparison).",sep="\n")
		}
	}

# Weir and Cockerham Fst: 	
locusWCfst<-function(my_dataset=NULL,mycol="grey",do_plot=TRUE)
	{
	if(is.null(my_dataset))
		{
		return(cat("ERROR: provide input (i.e. pop1_pop2) to the my_dataset flag.",sep="\n"))
		}
	if(my_dataset=="pheno")
		{
		pop_1		<- "pheno1" 
		pop_2		<- "pheno2"
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		}
	mafpop1			<- snps[names(snps) == paste("maf",pop_1,sep="_")]	
	mafpop2			<- snps[names(snps) == paste("maf",pop_2,sep="_")]
	# I included [,1] to avoid problems when snps dataset contain multiple columns with the same name.
	pop1f0			<- (mafpop1[,1]*mafpop1[,1])+((1-mafpop1[,1])*(1-mafpop1[,1]))
	pop2f0			<- (mafpop2[,1]*mafpop2[,1])+((1-mafpop2[,1])*(1-mafpop2[,1]))
	f1				<- (mafpop1[,1]*mafpop2[,1])+((1-mafpop1[,1])*(1-mafpop2[,1]))	
	snps$WeirHe		<<- 1-f1 
	snps$WeirFst	<<- (0.5*(pop1f0+pop2f0)-f1)/snps$WeirHe
	my_dataset2		<- paste(pop_1,pop_2,sep="\n")
	# Plot:
	if(do_plot)
		{
		hist(snps$WeirFst[snps$filter],50,main=my_dataset2,col=mycol,xlim=c(0,1),breaks=seq(0,1,0.02),ylim=c(0,(nrow(snps[snps$filter,])/6)),xlab="")
		}
	# Change names of columns in snps dataset:
	names(snps)[names(snps) == "WeirHe"] <<- paste("WeirHe",my_dataset,sep = "_")		
	names(snps)[names(snps) == "WeirFst"] <<- paste("WeirFst",my_dataset,sep = "_")			
	# If the function has been run multiple times, duplicated columns can arise. 
	# This is not only redundant, but can also lead to ERRORs. To remove duplicated columns:
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]	
	}

# requires locusWCfst
run_locusWCfst<-function(popnames=mysambar$populations,export=NULL,silent=TRUE,doplot=TRUE)
	{
	npops			<- length(mysambar$populations)
	if(npops==1)
		{
		return(cat("Currently only 1 population defined. Not possible to calculate Fst measures.",sep="\n"))
		}
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	mycolours		<- as.vector(unique(inds$popcol))
	combicoltable	<- combn(mycolours,m=2)	
	npops			<- length(mysambar$populations)
	#
	# Prepare histogram plot:
	if(doplot)
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("WC_Fst.eps",family=mysambar$myfont,width=5*ncombi+2,height=7)}
			if(export=="pdf"){pdf("WC_Fst.pdf",family=mysambar$myfont,width=5*ncombi+2,height=7)}
			if(export=="png"){png("WC_Fst.png",family=mysambar$myfont,width=200*ncombi+75,height=700)}
			if(export=="wmf"){win.metafile("WC_Fst.wmf",family=mysambar$myfont,width=5*ncombi+2,height=7)}
			}
		par(mfrow=c(1,ncol(combitable)+1),mai=c(0.75,1,0.75,0.25),oma=c(1,1,2,1),cex.main=2,cex.lab=2,cex.axis=1.5)
		}
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		mypop_1		<- combitable[1,i]
		mypop_2		<- combitable[2,i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		mypoppair	<- paste(my_pops[1],my_pops[2],sep="_")
		if(!silent){cat(mypoppair,sep="\n")}
		# As colour we are going to use a blend of the two population colours:
		mycol1			<- combicoltable[1,i]
		mycol2			<- combicoltable[2,i]
		mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
		mycol3			<- mycolfunc3(3)[2]
		locusWCfst(my_dataset=mypoppair,mycol=mycol3,do_plot=doplot)
		if(doplot)
			{
			mtext("WC Fst",cex=2,side=1,line=3)
			}
		}
	#mtext("Weir & Cockerham Fst",cex=2,side=1,line=-1.5,outer=TRUE)	# not handy if user wants to subselect tiles
	#
	# WeirHe_meta:
	if(npops==2)
		{
		mypop_1		<- combitable[1,1]
		mypop_2		<- combitable[2,1]
		myhe		<- snps[,paste("WeirHe",my_pops[1],my_pops[2],sep="_")]
		snps$WeirHe_metapop			<<- myhe
		}else{
		snps2		<- snps
		if("WeirHe_pheno" %in% colnames(snps2))
			{
			snps2$WeirHe_pheno	<- NULL
			}
		if("WeirHe_metapop" %in% colnames(snps2))
			{
			snps2$WeirHe_metapop	<- NULL
			}
		snpstemp					<- snps2[,grep("WeirHe_",colnames(snps2))]
		snps$WeirHe_metapop			<<- apply(snpstemp,1,function(x){mean(x,na.rm=TRUE)})
		}
	# WeirFst_meta:
	if(npops==2)
		{
		mypop_1		<- combitable[1,1]
		mypop_2		<- combitable[2,1]
		myfst		<- snps[,paste("WeirFst",mypop_1,mypop_2,sep="_")]
		snps$WeirFst_metapop		<<- myfst
		}else{
		snps2		<- snps
		if("WeirFst_pheno" %in% colnames(snps2))
			{
			snps2$WeirFst_pheno	<-NULL
			}
		if("WeirFst_metapop" %in% colnames(snps2))
			{
			snps2$WeirFst_metapop<-NULL
			}
		snpstemp	<- snps2[,grep("WeirFst_",colnames(snps2))]
		snps$WeirFst_metapop		<<- apply(snpstemp,1,function(x){mean(x,na.rm=TRUE)})
		}
	if(doplot)
		{
		hist(snps$WeirFst_metapop[snps$filter],50,main="metapop",col="white",xlim=c(0,1),breaks=seq(0,1,0.02),ylim=c(0,(nrow(snps[snps$filter,])/6)),xlab="")
		mtext("WC Fst",cex=2,side=1,line=3)
		if(!is.null(export)){dev.off()}
		}
	# If the function has been run multiple times, duplicated columns can arise. 
	# This is not only redundant, but can also lead to ERRORs. To remove duplicated columns:
	snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}	
	
Fdist_plot<-function(my_dataset="Busen_Norway",showlegend=FALSE,showlabels=TRUE,exporttype=NULL,axislabels=TRUE,add_borders=FALSE,add_outliers=FALSE,outliercex=2,addsd=FALSE,y_axis='s',x_axis='s',my_labels=NULL,dothin=TRUE,silent=TRUE,legendpheno=FALSE)
	{
	#cat(my_dataset,sep="\n")
	WeirHe		<- snps[,names(snps) == paste("WeirHe",my_dataset,sep="_")]
	WeirFst		<- snps[,names(snps) == paste("WeirFst",my_dataset,sep="_")]
	nsnps		<- nrow(snps[snps$filter,])
	mycex		<- ifelse(nsnps>10000,0.5,ifelse(nsnps>5000,1,1.25))
	if(dothin)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf		<- as.data.frame(cbind(WeirHe,WeirFst))
		mydf		<- unique(mydf[snps$filter2,])
		WeirHe2		<- mydf$WeirHe
		WeirFst2	<- mydf$WeirFst
		}else{
		WeirHe2		<- WeirHe
		WeirFst2	<- WeirFst
		}
	if(!is.null(exporttype))
		{
		myplotlabels<- ifelse(is.null(my_labels),my_dataset,paste(my_labels[1],my_labels[2],sep="_"))
		plotname	<- ifelse(add_outliers,paste("Fdist.outliers",myplotlabels,sep="."),paste("Fdist",myplotlabels,sep="."))
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=7,height=7)}
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=7,height=7)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=700,height=700)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=7,height=7)}
		}
	#plot(WeirHe2[1:5],WeirFst2[1:5],main="",xlim=c(0,1),ylim=c(0,1),pch=16,cex=mycex,xlab="",ylab="",yaxt=y_axis,xaxt=x_axis,las=1,col="grey50")
	# 01-05-2021: for some reason previous line was in use (only first 5 SNPs)
	plot(WeirHe2,WeirFst2,main="",xlim=c(0,1),ylim=c(0,1),pch=16,cex=mycex,xlab="",ylab="",yaxt=y_axis,xaxt=x_axis,las=1,col="grey50")
	if(add_borders)
		{
		# Boundaries of He-Fst space:
		wche				<- seq(0,1,0.01)
		wcfst1				<- (2*wche-1)/wche
		wcfst1[wcfst1<0]	<- NA
		wcfst2				<- wche
		points(wche,wcfst1,type='l',col="grey")
		points(wche,wcfst2,type='l',col="grey")
		points(WeirHe2,WeirFst2,pch=16,cex=mycex,col="grey65")
		if(!showlegend&my_dataset!="pheno") 
			{
			text(x=0.4,y=0.5,"Left border:\nMAFpop1 = 0\n| MAFpop2 = 0",adj=1,cex=1.75)
			text(x=0.6,y=0.2,"Right border:\nMAFpop1 =\n1 - MAFpop2",adj=0,cex=1.75)
			}
		}
	if(add_outliers)
		{
		snpcolnames		<- colnames(snps)
		if(!silent){cat("OutFLANK",sep="\n")}
		mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
		add_outflankout	<- mycolumn%in%snpcolnames
		#
		noutflankout	<- 0
		nbayescanout	<- 0
		nfsthetout		<- 0
		ngwdsout		<- 0
		npcadaptout		<- 0
		bayescan_other	<- FALSE	# do outliers occur in other comparisons?
		fsthet_other	<- FALSE
		gwds_other		<- FALSE
		outflank_other	<- FALSE
		pcadapt_other	<- FALSE
		#
		if(add_outflankout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("OutFLANK",my_dataset,sep="_")]
			noutflankout	<- length(outlierfilter[outlierfilter])
			if(noutflankout==0)
				{
				cat("WARNING: no outliers found by one of the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^OutFLANK', names(snps))] 
				alltestdf		<- alltestdf[,seq(1,ncol(alltestdf),3)]
				outflank_other	<- any(as.matrix(alltestdf))
				}
				
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="orange",pch=15,cex=outliercex)
			}
		#
		if(!silent){cat("Bayescan",sep="\n")}
		mycolumn			<- paste("bayescanout",my_dataset,sep="_")
		addbayescanout		<- mycolumn%in%snpcolnames
		if(addbayescanout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("bayescanout",my_dataset,sep="_")]
			nbayescanout	<- length(outlierfilter[outlierfilter])
			if(nbayescanout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^bayescanout', names(snps))] 
				bayescan_other	<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="red",pch=17,cex=outliercex)
			}
		#
		if(!silent){cat("Fsthet",sep="\n")}
		mycolumn			<- paste("fsthetout",my_dataset,sep="_")
		addfsthetout		<- mycolumn%in%snpcolnames
		if(addfsthetout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("fsthetout",my_dataset,sep="_")]
			nfsthetout	<- length(outlierfilter[outlierfilter])
			if(nfsthetout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^fsthetout', names(snps))] 
				fsthet_other	<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="darkorchid4",pch=20,cex=outliercex)
			}
		#
		if(!silent){cat("GWDS",sep="\n")}
		mycolumn			<- paste("rfisherout",my_dataset,sep="_")
		addgwds				<- mycolumn%in%snpcolnames
		if(addgwds)	
			{
			outlierfilter	<- snps[,names(snps) == paste("rfisherout",my_dataset,sep="_")]
			ngwdsout		<- length(outlierfilter[outlierfilter])
			if(ngwdsout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^rfisherout', names(snps))] 
				gwds_other		<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="blue",pch=16,cex=outliercex)
			}else{
			cat(paste("The snps dataframe does not contain column with GWDS logp values for population pair ",my_dataset," and therefore GWDS outliers are omitted from the Fdist plot.",sep=""),sep="\n")
			}
		#
		if(!silent){cat("pcadapt",sep="\n")}
		mycolumn			<- paste("PCadaptout",my_dataset,sep="_")
		addpcadapt			<- mycolumn%in%snpcolnames
		if(addpcadapt)		
			{
			outlierfilter	<- snps[,names(snps) == paste("PCadaptout",my_dataset,sep="_")]
			npcadaptout		<- length(outlierfilter[outlierfilter])
			if(npcadaptout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^PCadaptout', names(snps))] 
				pcadapt_other	<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="darkgreen",pch=18,cex=outliercex)
			}else{
			cat(paste("The snps dataframe does not contain column with PCadapt logp values for population pair ",my_dataset," and therefore PCadapt outliers are omitted from the Fdist plot.",sep=""),sep="\n")
			cat(paste("If you are running the assocfisher command, or if you are running the selectionanalyses function with the flag 'do_pcadapt' set to FALSE, this is expected behaviour.",sep=""),sep="\n")
			}
		#
		}
	if(my_dataset=="pheno"|showlegend)
		{
		mylegend1	<- ifelse(addbayescanout&nbayescanout>0,"Bayescan",ifelse(bayescan_other&legendpheno,"Bayescan","nolegend"))
		mylegend2	<- ifelse(addfsthetout&nfsthetout>0,"Fsthet",ifelse(fsthet_other&legendpheno,"Fsthet","nolegend"))
		mylegend3	<- ifelse(addgwds&ngwdsout>0,"GWDS",ifelse(gwds_other&legendpheno,"GWDS","nolegend"))
		mylegend4	<- ifelse(add_outflankout&noutflankout>0,"OutFLANK",ifelse(outflank_other&legendpheno,"OutFLANK","nolegend"))
		mylegend5	<- ifelse(addpcadapt&npcadaptout,"PCadapt",ifelse(pcadapt_other&legendpheno,"PCadapt","nolegend"))
		mylegend	<- c(mylegend1,mylegend2,mylegend3,mylegend4,mylegend5)
		mylegend	<- mylegend[!mylegend=="nolegend"]
		#
		mycolour1	<- ifelse(addbayescanout&nbayescanout>0,"red",ifelse(bayescan_other&legendpheno,"red","nocolour"))
		mycolour2	<- ifelse(addfsthetout&nfsthetout>0,"darkorchid4",ifelse(fsthet_other&legendpheno,"darkorchid4","nocolour"))
		mycolour3	<- ifelse(addgwds&ngwdsout>0,"blue",ifelse(gwds_other&legendpheno,"blue","nocolour"))
		mycolour4	<- ifelse(add_outflankout&noutflankout>0,"orange",ifelse(outflank_other&legendpheno,"orange","nocolour"))
		mycolour5	<- ifelse(addpcadapt&npcadaptout,"darkgreen",ifelse(pcadapt_other&legendpheno,"darkgreen","nocolour"))
		mycolour	<- c(mycolour1,mycolour2,mycolour3,mycolour4,mycolour5)
		mycolour	<- mycolour[!mycolour=="nocolour"]
		#
		if(length(mylegend)!=0)
			{
			legend(x=0,y=0.95,legend=mylegend,fill=mycolour,bty='n',cex=2)
			}
		}
	if(showlabels)
		{
		if(my_dataset=="pheno"|my_dataset=="assoc1_assoc2")
			{
			if(is.null(my_labels))
				{
				mtext("typeA_typeB",side=3,line=-3,cex=2)
				}else{
				mtext(paste(my_labels[1],my_labels[2],sep="_"),side=3,line=-3,cex=2)
				}
			}else{
			mtext(my_dataset,side=3,line=-3,cex=2)
			}
		}
	if(axislabels)
		{
		mtext("Weir & Cockerham (1987) Fst", side = 2, cex = 2, line = 2.5)
		mtext("Weir & Cockerham (1987) He", side = 1, cex = 2, line = 3)
		}
	if(addsd)
		{
		points(snps$WeirHe_metapop[snps$mafSDtop1000],snps$WeirFst_metapop[snps$mafSDtop1000],col="grey",cex=0.75,pch=16)
		points(snps$WeirHe_metapop[snps$mafSDtop250],snps$WeirFst_metapop[snps$mafSDtop250],col="grey20",cex=0.75,pch=16)
		points(snps$WeirHe_metapop[snps$mafSDtop125],snps$WeirFst_metapop[snps$mafSDtop125],col="red",cex=0.75,pch=16)
		}
	if(!is.null(exporttype)){dev.off()}
	}	
	
# requires Fdist_plot
Fdist_multiplot<-function(popnames=mysambar$populations,export=NULL)
	{
	combitable	<- combn(popnames,m=2)
	npairwise	<- ncol(combitable)
	ntiles		<- ifelse(npairwise==1,1,ifelse((npairwise==2||npairwise==3||npairwise==4),3,5))
	ntabs		<- ceiling(ncol(combitable)/ntiles)
	for (n in c(1:ntabs))
		{ 	
		graphics.off()
		if(n<ntabs)
			{
			combisubtable	<- as.matrix(combitable[,c(((n-1)*ntiles+1):(n*ntiles))])		# 17-5-2019: as.matrix is needed in case we select one column only
			}else{
			combisubtable	<- as.matrix(combitable[,c(((n-1)*ntiles+1):ncol(combitable))]) # 17-5-2019: as.matrix is needed in case we select one column only
			}
		ncomparisons		<- ncol(combisubtable)
		myheight1			<- ntiles*8
		myheight2			<- ntiles*500
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Fdist",n,"eps",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			if(export=="pdf"){pdf(paste("Fdist",n,"pdf",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			if(export=="png"){png(paste("Fdist",n,"png",sep="."),family=mysambar$myfont,width=720,height=myheight2)}
			if(export=="wmf"){win.metafile(paste("Fdist",n,"wmf",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			}
		# If multiple plots (multiple pairwise comparisons), divide the screen:
		par(mfrow=c(ntiles,1),oma=c(5,7,1,1),mar=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		for (i in c(1:ncomparisons))
			{
			combiname	<- paste(combisubtable[1,i],combisubtable[2,i],sep="_")
			addborders	<- ifelse(i==1,TRUE,FALSE)
			Fdist_plot(my_dataset=combiname,axislabels=FALSE,add_borders=addborders)
			if(n<ntabs)
				{
				if(i==ntiles)
					{
					mtext("Weir & Cockerham (1987) He", side = 1, cex = 2.75, line = 4)
					}
				}else{
				if(i==(ncol(combisubtable)))
					{
					mtext("Weir & Cockerham (1987) He", side = 1, cex = 2.75, line = 4)
					}
				}
			}
		mtext("Weir & Cockerham (1987) Fst", side = 2, cex = 3, line = 3.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	}	

# Multilocus Weir and Cockerham Fst
multiLocusWeirFst<-function(popnames=mysambar$populations,export=NULL)
	{
	# duplicated columns in snps dataframe will lead to ERRORs, so therefore we first execute: 
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	combitable			<- combn(popnames,m=2)
	multilocusweirfstvector		<- vector()
	npops				<- length(popnames)
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		pop1			<- combitable[1,i]
		pop2			<- combitable[2,i]
		# select columns with minor allele frequencies:
		mafpop1			<- snps[names(snps) == paste("maf",pop1,sep="_")]	
		temp			<- colnames(mafpop1)
		mafpop1			<- mafpop1[[temp]]
		mafpop2			<- snps[names(snps) == paste("maf",pop2,sep="_")]
		temp			<- colnames(mafpop2)
		mafpop2			<- mafpop2[[temp]]
		#test1			<<- mafpop1
		#test2			<<- mafpop2
		# filter:
		mafpop1			<- mafpop1[snps$filter]
		mafpop2			<- mafpop2[snps$filter] 	
		## first define the required variables:
		r				<- 2							# number of pops
		npop1			<- length(inds$name[inds$pop==pop1])
		npop2			<- length(inds$name[inds$pop==pop2])
		nmean			<- mean(npop1,npop2)					# mean sample size per pop
		nloci			<- length(mafpop1)					# number of loci
		nvar			<- (npop1^2)/(r*nmean)+(npop2^2)/(r*nmean)
		nc				<- (r*nmean - nvar)/(r-1)
		mafavg			<- 1/2*(mafpop1+mafpop2)	
		mafvarmat		<- matrix(nrow=3,ncol=nloci)
		for (j in c(1:nloci))
			{
			mafvarmat[1,j]	<- (npop1*(mafpop1[j]-mafavg[j])^2)/((r-1)*nmean)
			mafvarmat[2,j]	<- (npop2*(mafpop1[j]-mafavg[j])^2)/((r-1)*nmean)	
			mafvarmat[3,j]	<- mafvarmat[1,j]+mafvarmat[2,j]
			}
		mafvar			<- mafvarmat[3,]	
		# For he, assuming Hardy-Weinberg:
		he			<- 1/2*((2*mafpop1*(1-mafpop1))+(2*mafpop2*(1-mafpop2))) 
		## now we can calculate a, b and c:
		a			<- (nmean/nc)*(mafvar-(1/(nmean-1))*(mafavg*(1-mafavg)-mafvar*((r-1)/r)-1/4*he))
		b			<- (nmean/(nmean-1))*((mafavg*(1-mafavg))-(((r-1)/r)*mafvar)-((2*he*nmean-1)/(4*nmean)))  
		weirc		<- 1/2*he
		# now we can calculate the multilocus-Fst:
		multilocusweirfstvector[i]	<- round(sum(a)/(sum(a)+sum(b)+sum(weirc)),3)
		}
	# Visualize using heatmap
	myfstmatrix	<<- matrix(0,npops,npops)
	myfstmatrix[lower.tri(myfstmatrix, diag=FALSE)] <<- multilocusweirfstvector	# in two steps, to get the order right (we want it by row, rather than by column)
	myfstmatrix <<- t(myfstmatrix)						# in two steps, to get the order right (we want it by row, rather than by column)
	myfstmatrix	<<- round(myfstmatrix,3)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(myfstmatrix,na.rm=TRUE),1)
	if(max(myfstmatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(myfstmatrix,na.rm=TRUE),1)
		}
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/10)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("WeirFst.multilocus.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("WeirFst.multilocus.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("WeirFst.multilocus.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("WeirFst.multilocus.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(myfstmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(myfstmatrix==0,NA,myfstmatrix),
	notecol="black",notecex=2.5,labCol=popnames,labRow=popnames,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	mtext("Weir & Cockerham 1983 multilocus Fst", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	# return a table:
	myfstmatrix				<<- rbind(combitable,multilocusweirfstvector)
	rownames(myfstmatrix)	<<- c("pop1","pop2","fst")
	myfstmatrix				<<- as.data.frame(myfstmatrix,stringsAsFactors = FALSE)
	colnames(myfstmatrix)	<<- c(1:ncol(myfstmatrix))
	}

mypopdivergencetable<-function()
	{
	mydf				<- rbind(myfstmatrix,mysambar$popneivector)
	rownames(mydf)[4]	<- "nei's D"
	write.table(mydf,"SambaR.popdivergence.stats.txt",row.names=TRUE,col.names=TRUE,quote=FALSE,sep="\t")
	}	

pidf2matrix_old<-function(pidf=tajdlist_meta[[1]],myinds=inds$nr[inds$filter],do_colour=FALSE)
	{
	ninds									<- length(myinds)
	m2										<- matrix(NA,nrow=ninds,ncol=ninds)
	if(do_colour)
		{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"colour"]
		diag(m2)							<- pidf[(1:ninds),"colour"]
		}else{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		diag(m2)							<- pidf[(1:ninds),"ndiffpersite"]
		}
	colnames(m2)							<- myinds
	rownames(m2)							<- myinds
	pimatrix								<- t(m2)
	if(do_colour)
		{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"colour"]
		}else{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		}
	return(pimatrix)
	}	

pidf2matrix<-function(pidf=tajdlist_meta[[1]],myinds=inds$nr[inds$filter],mypops=inds$pop[inds$filter],do_colour=FALSE,onlybetweenpop=FALSE,onlywithinpop=FALSE)
	{
	ninds									<- length(myinds)
	m2										<- matrix(NA,nrow=ninds,ncol=ninds)
	if(do_colour)
		{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"colour"]			# below diagonal between individual scores
		diag(m2)							<- pidf[(1:ninds),"colour"]						# on diagonal individual scores	
		}else{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]	# below diagonal between individual scores
		diag(m2)							<- pidf[(1:ninds),"ndiffpersite"]				# on diagonal individual scores
		}
	colnames(m2)							<- myinds
	rownames(m2)							<- myinds
	pimatrix								<- t(m2)
	if(do_colour)
		{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"colour"]
		}else{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		}
	if(onlybetweenpop)
		{
		for(i in c(1:ninds))
			{
			for(j in c(1:ninds))
				{
				mypop1	<- mypops[i]
				mypop2	<- mypops[j]
				if(mypop1==mypop2)
					{
					pimatrix[i,j]			<- NA
					}
				}
			}
		}
	if(onlywithinpop)
		{
		for(i in c(1:ninds))
			{
			for(j in c(1:ninds))
				{
				mypop1	<- mypops[i]
				mypop2	<- mypops[j]
				if(mypop1!=mypop2)
					{
					pimatrix[i,j]			<- NA
					}
				}
			}
		}
	return(pimatrix)
	}	

# Migration analyses:	
create_bayesass_input<-function(nind=NULL,maxlines=36000,exportname="Bayesassinput")
	{
	# bayesinput can have maximum just over 36000 lines, as far as I know.
	# each line represents a locus for a single individual
	# therefore, the total number of loci equals 36000/nind.
	if(is.null(nind))
		{
		nind	<- nrow(inds[inds$filter,])
		}
	nloci	<- floor(maxlines/nind) 
	subselectdata(nrsnps=nloci,export=exportname)
	}

# plot bayesass output: 
plotmigration<-function(myinputmatrix="bayesassmatrix.txt",mycolours=NULL,export=NULL,addaxis=FALSE,addlabels=TRUE,use_current_dir=FALSE)
	{
	# 07-05-2020: Thomas ran into error: Error in (function (classes, fdef, mtable): unable to find an inherited method for function 'desc' for signature '"numeric"'
	# Not solved yet
	# Maybe because the function desc is masked by a particular package?
	# the function works when typing desc returns: 'standardGeneric for "desc" defined from package "IRanges"'
	if(!use_current_dir)
		{
		if(exists("mysambar"))
			{
			setwd(mysambar$inputfilesdir)
			}else{
			return(cat("ERROR: Inputfilesdir not defined. First run the importdata() function, or alternatively run the plotmigration function with the flag 'use_current_dir' set to TRUE.",sep="\n"))
			}
		}
	if(!file.exists(myinputmatrix))
		{
		cat(paste("ERROR: SambaR expects to find the file '",myinputmatrix,"' in the directory:",sep=""),sep="\n")
		mypath	<- ifelse(use_current_dir,getwd(),mysambar$inputfilesdir)
		return(cat(mypath,sep="\n"))
		}
	# this function expects to find in sambardir directory a file containing a matrix defining migration rates, like:
	# EastAnglia m[0][0]: 0.8973(0.0348) m[0][1]: 0.0066(0.0028) m[0][2]: 0.0554(0.0209)
	# Ayrshire m[1][0]: 0.0138(0.0086) m[1][1]: 0.8262(0.0610) m[1][2]: 0.1110(0.0575)
	# Wurttemberg m[2][0]: 0.0016(0.0012) m[2][1]: 0.0043(0.0031) m[2][2]: 0.9895(0.0036)
	# So the first column contains population names and the other columns comprise the matrix outputted by Bayesass.
	m 			<- read.table(myinputmatrix,stringsAsFactors=FALSE)
	populations	<- m[,1]
	m			<- m[,(2:ncol(m))]
	m2			<- m[,c(FALSE,TRUE)]
	n			<- nrow(m)
	m			<- m2
	for(i in c(1:ncol(m2)))
		{
		m[,i]<- as.numeric(substr(m2[,i],1,6))
		}
	# 29-01-2019:
	# The following commands assumes migration flow is from i to j. (i = row number, j = column number)
	# However, in the Bayesass output table, migration flow is from j to to i.
	# From the Bayesass manual:
	# "Note that m[i][j] is the fraction of individuals in population i that are migrants derived from population j (per generation)."	
	# So we have to transpose the table:
	m	<- t(m)
	# create colours:
	# define colours:
	npops	<- length(mysambar$populations)
	if(npops!=nrow(m))
		{
		cat("ERROR: Number of populations in input file does not correspond to the expected number of populations.",sep="\n")
		cat(paste("Number of populations in input file (i.e. number of rows in Bayesass output file): ",nrow(m),".",sep=""),sep="\n")
		cat(paste("Number of expected populations (i.e. length(mysambar$populations)): ",npops,".",sep=""),sep="\n")
		}
	if(is.null(mycolours))
		{
		#mycolours	<- as.vector(unique(inds$popcol))
		mycolours	<- mysambar$mycolours[1:npops]
		}
	# make df1:
	df1			<- as.data.frame(cbind(c(1:n),populations))
	names(df1)	<- c("order","region")
	df1			<- arrange(df1, order)
	df1$region 	<- factor(df1$region, levels=df1$region) 
	# install packages:
	if("migest" %in% rownames(installed.packages()) == FALSE) {install.packages("migest",repos='http://cran.us.r-project.org')}
	if("plyr" %in% rownames(installed.packages()) == FALSE) {install.packages("plyr",repos='http://cran.us.r-project.org')}
	if("circlize" %in% rownames(installed.packages()) == FALSE) {install.packages("circlize",repos='http://cran.us.r-project.org')}
	if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages("gplots",repos='http://cran.us.r-project.org')}
	library("migest")
	library("plyr")
	library("circlize")
	library("gplots")
	# edit m:
	df1			<- as.data.frame(cbind(c(1:n),populations))
	names(df1)	<- c("order","region")
	df1			<- arrange(df1, order)
	df1$region 	<- factor(df1$region, levels=df1$region) 
	# edit df1:
	df1$xmin 	<- 0
	df1$xmax 	<- rowSums(m)+colSums(m)
	myrgbs		<- t(col2rgb(mycolours, alpha = FALSE))
	df1			<- as.data.frame(cbind(df1,myrgbs))
	names(df1)[5:7]	<- c("r","g","b")
	df1$rgb		<- paste(df1$r,df1$g,df1$b,sep=",")
	df1$rcol	<- col2hex(mycolours)
	df1$lcol	<- paste(df1$rcol,"C8",sep="")			# lighter colour. If you want to use, set as option in panel.fun
	df1			<<- df1
	# create df2 (needed to add migration rates):
	df1$sum1 	<- colSums(m)
	df1$sum2 	<- numeric(n)
	rownames(m)	<- populations
	df2			<- cbind(as.data.frame(m),orig=rownames(m), stringsAsFactors=FALSE)
	df2			<- reshape(df2, idvar="orig", varying=list(1:n),direction="long",timevar="dest", time=rownames(m),v.names = "m")
	df2			<- arrange(df2,desc(m))
	df2			<<- df2
	# df2		<- subset(df2, m>quantile(m,0.5))	# optionally ignore small migration rates
	# create circos plot:
	graphics.off()
	if(!use_current_dir&!is.null(mysambar$demographydir)){setwd(mysambar$demographydir)}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Migration.circosplot.eps",family=mysambar$myfont,width=7,height=7)}
		if(export=="pdf"){pdf("Migration.circosplot.pdf",family=mysambar$myfont,width=7,height=7)}
		}
	par(mar=rep(0,4))
	circos.clear()
	circos.par(cell.padding=c(0,0,0,0),track.margin=c(0,0.15),start.degree=90,gap.degree=4,points.overflow.warning=FALSE)
	circos.initialize(factors=df1$region,xlim=cbind(df1$xmin, df1$xmax))
	circos.trackPlotRegion(ylim = c(0, 1), factors=df1$region, track.height=0.1, 
	panel.fun = function(x, y) 
		{
		name 	= get.cell.meta.data("sector.index")
		i 		= get.cell.meta.data("sector.numeric.index")
		xlim 	= get.cell.meta.data("xlim")
		ylim 	= get.cell.meta.data("ylim")
		pi 	= circlize(mean(xlim), 1.3)[1, 1] %% 360
		dd 		= ifelse(pi < 90 || pi > 270,"clockwise", "reverse.clockwise")
		aa 		= c(1,0.5)	
		if(pi < 90 || pi > 270)  aa =c(1,0.5)
		# if you want to add region labels:
		if(addlabels)
			{
			circos.text(x=max(xlim), y=1.9,labels=populations[i], facing = "bending", cex=2.5,  adj = aa)
			}
		circos.rect(xleft=xlim[1], ybottom=ylim[1],xright=xlim[2], ytop=ylim[2],col = df1$rcol[i], border=df1$rcol[i])
		circos.rect(xleft=xlim[1], ybottom=ylim[1],xright=xlim[2]-sum(df2$m)[i], ytop=ylim[1]+0.3,col = "white", border = "white")
		circos.rect(xleft=xlim[1], ybottom=0.3,	xright=xlim[2], ytop=0.32, col = "white", border = "white")
		# if you want to add region axes:
		if(addaxis)
			{
			circos.axis(labels.cex=0.6, direction="outside", major.at=seq(from=0, to=floor(df1$xmax)[i],by=5), minor.ticks=1, labels.away.percentage = 0.15)
			}
		})
	# add migration routes:
	for(k in 1:nrow(df2))
		{
		i<-match(df2$orig[k],df1$region)
		j<-match(df2$dest[k],df1$region)
		if(is.na(i)|is.na(j)){return(cat(paste("ERROR: no match between df2$orig and df1$region for k =",k,sep = " ")))}
		circos.link(
			sector.index1=df1$region[i], 
			point1=c(df1$sum1[i],df1$sum1[i] + abs(m[i,j])),
			sector.index2=df1$region[j], 
			point2=c(df1$sum2[j],df1$sum2[j] + abs(m[i,j])), 
			col = df1$lcol[i])
		df1$sum1[i] = df1$sum1[i] + abs(m[i,j])
		df1$sum2[j] = df1$sum2[j] + abs(m[i,j])
		}
	if(!is.null(export))
		{
		dev.off()
		if(!use_current_dir)
			{
			if(exists("mysambar$sambardir")){setwd(sambardir)}
			cat("Circos plot with migration rates has been exported to demography directory.",sep="\n")
			}else{
			cat("Circos plot with migration rates has been exported to working directory.",sep="\n")
			}
		}
	}	
	
# End of population differentiation analyses 
###############################################################################################################





###############################################################################################################
# Genetic diversity analyses

# This function executes all genetic distance analyses at once:
# I decided not to include calcLD, because it only calculates LD for adjacent snps (otherwise it takes too long).
# What's more, SambaR provides excellent plotting function for PLINK output. 

calcdiversity<-function(nrsites=NULL,nrsegsites=NULL,nrsnps=NULL,legend_cex=2.5,silent=TRUE,u_g=1.0*10^-8,dohwe=TRUE,do_sfs=TRUE,redo_tajd=TRUE)
	{
	# nrsites must be a vector of length of either 1 or length of vector mysambar$populations
	# nrsegsites must be vector of length of either 1 or length of vector mysambar$populations
	# nrsnps must be a vector of length of either 1 or length of nrow(inds)
	#
	#				inds$nsites1		# number of sites retained by snps$filter						snps$filter
	#				inds$nsites2		# number of sites per individual								snps$filter&!is.na		# same as inds$nsites5 and inds$ndata
	#  				inds$nsegsites1		# number of segregating sites per population (filtered)			snps$filter&popmaf>0
	#  				inds$nsegsites2		# number of segregating sites per individual (filtered)			snps$filter&popmaf>0&!is.na
	# nrsegsites: 	inds$nsegsites3		# number of segregating sites per population (not filtered)		popmaf>0
	# nrsnps: 		inds$nsegsites4		# number of segregating sites per individual (not filtered)		popmaf>0&!is.na
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
		my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")		
	setwd(mysambar$diversitydir)
	if(!silent){cat("plotgenotri",sep="\n")}
	plotgenotri(export="eps",allsites=FALSE)
	plotgenotri(export="pdf",allsites=FALSE)
	plotgenotri(export="png",allsites=FALSE)
	if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
	plotgenotri(export="eps",allsites=TRUE)
	plotgenotri(export="pdf",allsites=TRUE)
	plotgenotri(export="png",allsites=TRUE)
	if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
	cat("Hardy Weinberg calculations...",sep="\n")
	cat("If you receive an error after this line, set the flag dohwe to FALSE.",sep="\n")
	if(dohwe)
		{
		hwe(export="pdf")
		}
	if(all(inds$hetero==0,na.rm=TRUE))
		{
		return(cat("All individuals fully homozygous. Haploid data? Not generating plots.",sep="\n"))
		}
	if("inbreedR" %in% rownames(installed.packages()))
		{
		if("inbreedR" %in% (.packages()) == FALSE){library(inbreedR)}
		cat("Calculating (standardized) multilocus heterozygosity (sMLH) using inbreedR...",sep="\n")
		calcMLH()
		cat("Plotting standardized multilocus heterozygosity...",sep="\n")
		MLHboxplot(export="eps",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
		MLHboxplot(export="pdf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
		MLHboxplot(export="png",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
		if(mysambar$os=="Windows"){MLHboxplot(export="wmf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")}
		cat("Plotting multilocus heterozygosity...",sep="\n")
		MLHboxplot(export="eps",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")
		MLHboxplot(export="pdf",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")
		MLHboxplot(export="png",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")
		if(mysambar$os=="Windows"){MLHboxplot(export="wmf",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")}
		}else{
		# the function will use the column 'hetero_all' rather than MLH (identical values): 
		cat("Plotting multilocus heterozygosity...",sep="\n")
		MLHboxplot(export="eps",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
		MLHboxplot(export="pdf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
		MLHboxplot(export="png",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
		if(mysambar$os=="Windows"){MLHboxplot(export="wmf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")}
		}
	#
	# identical to MLH:
	indheboxplot(export="eps",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)
	indheboxplot(export="pdf",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)
	indheboxplot(export="png",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)
	if(mysambar$os=="Windows"){indheboxplot(export="wmf",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)}
	# segregating sites only:	
	indheboxplot(export="eps",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)
	indheboxplot(export="pdf",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)	
	indheboxplot(export="png",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)
	if(mysambar$os=="Windows"){indheboxplot(export="wmf",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)}
	#
	# plot_F(export=TRUE)				# 26-09-2019: incorrect at the moment, needs to be improved	
	if(length(mysambar$populations)==1)
		{
		cat("Currently only 1 population defined. Most plots won't be generated, as they are meant to compare diversity between populations.",sep="\n")
		}
	npops	<- length(mysambar$populations)
	if(is.null(nrsites))
		{
		cat("You didn't provide the total number of sequenced sites (i.e.: nsites=NULL).",sep="\n")
		cat("You miss out on various interesting analyses! See SambaR manual for more details.",sep="\n")
		}else{
		if(length(nrsites)==1)
			{
			inds$allseqsites	<<- nrsites
			}else{
			if(length(nrsites)!=npops)
				{
				return(cat("ERROR: length of vector input to nrsites flag should be either 1 or equal to number of populations.",sep="\n"))
				}else{
				inds$allseqsites		<<- NA
				for(i in c(1:nrow(inds)))
					{
					inds$allseqsites[i]	<<- nrsites[which(mysambar$populations==inds$pop[i])]
					}
				}
			}
		inds$S			<<- inds$nsegsites3/inds$allseqsites
		}
	if(length(mysambar$populations)>1)
		{
		cat("Counting number of private alleles...",sep="\n")
		private_hist(snpsfilter=NULL,export="eps")
		private_hist(snpsfilter=NULL,export="pdf")
		private_hist(snpsfilter=NULL,export="png")
		if(mysambar$os=="Windows"){private_hist(snpsfilter=NULL,export="wmf")}
		private_hist(snpsfilter=snps$filter,export="eps")
		private_hist(snpsfilter=snps$filter,export="pdf")
		private_hist(snpsfilter=snps$filter,export="png")
		if(mysambar$os=="Windows"){private_hist(snpsfilter=snps$filter,export="wmf")}
		if(length(mysambar$populations)<6)
			{
			# Venn diagram showing overlap of polymorphic sites between loci
			# Works for maximum 5 populations
			markervenn(export=TRUE,doprop=FALSE)
			markervenn(export=TRUE,doprop=TRUE)
			}
		}else{
		cat("Only 1 population defined. Skipping count of private alleles.")
		}
	cat("Plotting genocounts...",sep="\n")
	plotgenocounts(addlabels=FALSE,export=TRUE)
	plotgenocounts(addlabels=TRUE,export=TRUE)
	#
	if(!do_sfs)
		{
		cat("Skipping site frequency spectra analyses because the flag do_sfs is set to TRUE.",sep="\n")
		}else{
		cat("Generating site frequency spectra...",sep="\n")
		cat("If you run into an error soon after this line, rerun the calcdiversity() function with the flag do_sfs set to FALSE.",sep="\n")
		multirunsfs(do_silent=silent,number_sites=nrsites,number_segsites=nrsegsites)
		}
	#
	cat("Calculating pi and tajima's D per population...",sep="\n")
	popnind <- as.vector(table(inds$pop[inds$filter]))
	popbool	<- popnind>1
	if(all(popbool))
		{
		if(!is.null(mysambar$tajd))
			{
			if(!redo_tajd)
				{
				cat("WARNING: using existing Tajima's statistics table stored at mysambar$tajd.",sep="\n")
				cat("If you want to redo the calculations, set the flag redo_tajd to TRUE.",sep="\n")
				}else{
				cat("Rerunning 'calcpi' function. To save time, set the flag redo_tajd to FALSE.",sep="\n")
				calcpi(pi_per_pop=TRUE)
				}
			}
		if(length(mysambar$populations)>1)
			{
			seqdivplot(export=TRUE)
			if(!silent){cat("plottajd",sep="\n")}
			plottajd(export=TRUE,insetbarplot=TRUE,legendcex=legend_cex)
			}
		plottajd(export=TRUE,insetbarplot=FALSE,legendcex=legend_cex)
		if(!silent){cat("plotpi_vs_he",sep="\n")}
		plotpi_vs_he(export="eps",genomewide=FALSE)
		plotpi_vs_he(export="pdf",genomewide=FALSE)
		plotpi_vs_he(export="png",genomewide=FALSE)
		if(mysambar$os=="Windows"){plotpi_vs_he(export="wmf",genomewide=FALSE)}
		if(!silent){cat("calcS",sep="\n")}
		calcS(export="eps")
		calcS(export="pdf")
		calcS(export="png")
		if(mysambar$os=="Windows"){calcS(export="wmf")}
		}else{
		cat("Skipping calculations on nucleotide diversity, Tajima's D, and number of segregation sites, because one or more populations contain only 1 retained individual.",sep="\n")
		}
	if(!silent){cat("plotcompareF(genomewide=TRUE)",sep="\n")}
	plotcompareF(export="eps",genomewide=FALSE)
	plotcompareF(export="pdf",genomewide=FALSE)
	plotcompareF(export="png",genomewide=FALSE)
	if(mysambar$os=="Windows"){plotcompareF(export="wmf",genomewide=FALSE)}
	#
	if(!silent){cat("plotdispersal",sep="\n")}
	calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="eps")
	calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="pdf")
	calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="png")
	#
	if(mysambar$os=="Windows"){calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="wmf")}
	if(!is.null(nrsites))
		{
		if(any(table(inds$pop[inds$filter])==1))
			{
			cat("WARNING: One or more population(s) contain(s) one individual only (after filtering).",sep="\n")
			cat("For that reason, not generating genome wide diversity statistics. Define different population assignment or different filter settings, and then try again.",sep="\n")
			}else{
			cat("Plotting genome wide heterozygosity and pi...",sep="\n")
			getgenomepi(nsites=inds$allseqsites,nsnps=nrsnps)
			if(!silent){cat("plotHe_perind",sep="\n")}
			plotHe_perind(export="eps",genomehe=TRUE)
			plotHe_perind(export="pdf",genomehe=TRUE)
			plotHe_perind(export="png",genomehe=TRUE)
			if(mysambar$os=="Windows"){plotHe_perind(export="wmf",genomehe=TRUE)}
			if(!silent){cat("plotgenomehe",sep="\n")}
			plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="eps",do_stripchart=TRUE)
			plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="pdf",do_stripchart=TRUE)
			plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="png",do_stripchart=TRUE)
			#if(mysambar$os=="Windows"){plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="wmf",do_stripchart=TRUE)}	# this returns an error
			if("vioplot" %in% (.packages()))
				{
				plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="eps",do_stripchart=FALSE)
				plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="pdf",do_stripchart=FALSE)
				plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="png",do_stripchart=FALSE)
				}
			if(mysambar$os=="Windows"){plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="wmf",do_stripchart=FALSE)}
			if(!silent){cat("plotpi_vs_he(genomewide=TRUE)",sep="\n")}
			plotpi_vs_he(export="eps",genomewide=TRUE)
			plotpi_vs_he(export="pdf",genomewide=TRUE)
			plotpi_vs_he(export="png",genomewide=TRUE)
			if(mysambar$os=="Windows"){plotpi_vs_he(export="wmf",genomewide=TRUE)}
			if(!silent){cat("plotcompareF(genomewide=TRUE)",sep="\n")}
			plotcompareF(genomewide=TRUE,export="pdf")
			plotcompareF(export="eps",genomewide=TRUE)	
			plotcompareF(export="pdf",genomewide=TRUE)
			plotcompareF(export="png",genomewide=TRUE)
			if(mysambar$os=="Windows"){plotcompareF(export="wmf",genomewide=TRUE)}
			if(length(mysambar$populations)>1)
				{
				if(!silent){cat("seqdivplot",sep="\n")}
				seqdivplot(nsites=nrsites,export=TRUE)
				if(!silent){cat("plottajd",sep="\n")}
				plottajd(export=TRUE,insetbarplot=TRUE,genome_wide=TRUE,legendcex=legend_cex)
				}
			if(!silent){cat("plottajd",sep="\n")}
			plottajd(export=TRUE,insetbarplot=FALSE,genome_wide=TRUE)
			cat("Plotting proportion of segregating sites vs number of individuals...",sep="\n")
			calcS(nsites=nrsites,export="eps")
			calcS(nsites=nrsites,export="pdf")
			calcS(nsites=nrsites,export="png")
			if(mysambar$os=="Windows"){calcS(nsites=nrsites,export="wmf")}
			cat("Generating summary statistics...",sep="\n")	
			popstats(nsites=nrsites,u=u_g)
			}
		}else{
		cat("Generating summary statistics...",sep="\n")
		popstats()
		}
	# plotstats()
	#if("dist" %in% colnames(snps))
	#	{
		# homorun(export="pdf")
		# if(!silent){cat("multimafdiff",sep="\n")}
		# multimafdiff(export=TRUE,do_boxplot=FALSE,do_scatterplot=TRUE,addoutliers=FALSE)
		# 08-05-2020: replace with (still to be polished):
		# rundetectROHs()
	#	}
	# reset working directory:
	setwd(mysambar$inputdatadir)
	cat("Analysis finished.",sep="\n")
	}

calcdispersal<-function(popnames=mysambar$populations,domatrix=FALSE,export=NULL)
	{
	# function to calculate directionality index:
	# Peter and Slatkin, 2013, DETECTING RANGE EXPANSIONS FROM GENETIC DATA
	npops	<- length(popnames)
	meanmaf	<<- vector()
	for (k in c(1:npops))
		{
		mypop		<- popnames[k]
		mafcolumn	<- paste("maf",mypop,sep="_")
		if(!mafcolumn%in%colnames(snps))
			{
			return(cat("ERROR: mafcolumn not present.",sep="\n"))
			}else{
			mafvec		<- as.vector(snps[,mafcolumn])
			}
		meanmaf[k]	<<- mean(mafvec[mafvec>0],na.rm=TRUE)
		}
	#
	mafdf		<- data.frame("pop"=popnames,"maf"=meanmaf)
	mafdf		<- mafdf[mysambar$popordernr,]
	mafdf$col	<- mysambar$colorder
	mafdf$nind	<- NA
	for(k in c(1:nrow(mafdf)))
		{
		mypop			<- mafdf$pop[k]
		mafdf$nind[k]	<- nrow(inds[as.character(inds$pop)==mypop,])  
		}
	#
	if(!is.null(export))
		{
		plotname	<- "Popmaf_segregatingsites"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} 
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(mafdf$nind,mafdf$maf,pch=16,cex=4,xlab="Number of individuals",col=mysambar$colorder,ylab="Mean MAF (MAF>0)",ylim=c(0,1))
	legend("topright",legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=1.5)
	if(!is.null(export)){dev.off()}
	#
	#
	if(domatrix)
		{
		popnr		<- c(1:npops)
		combitable	<- combn(popnr,m=2)
		nametable	<- combn(popnames,m=2)
		dirindex	<- rep(NA,ncol(combitable))
		for (i in c(1:ncol(combitable)))
			{
			popnr1		<- combitable[1,i]	
			popnr2		<- combitable[2,i]	
			mean1		<- meanmaf[popnr1]
			mean2		<- meanmaf[popnr2]
			dirindex[i]	<- round(mean1-mean2,3)
			}
		dirindextable	<<- rbind(combitable,nametable,dirindex)
		b							<- matrix(1,nrow=npops,ncol=npops)
		b[lower.tri(b, diag=FALSE)] <- dirindex
		b							<- t(b)
		b[lower.tri(b, diag=FALSE)] <- dirindex
		colnames(b)					<- popnames
		rownames(b)					<- popnames
		dirindexmat		<<- b
		#
		plotfst(popnames=mysambar$populations,export="pdf",inputvector=dirindex,exportname="Directionaly_index",plottitle="Directionality index")
		}
	}	

calcMLH<-function(popnames=mysambar$populations,phenovector=NULL)
	{
	#install.packages("inbreedR",repos=myrepos)
	#library(inbreedR)
	# for metapop:
	inds$MLH					<<- NA
	inds$sMLH					<<- NA
	#mydf						<- as.data.frame(mygenlight[inds$filter,snps$filter])
	mydf						<- as.data.frame(mygenlight[,snps$filter])
	mydf[mydf==2]				<- 0
	#inds$MLH[inds$filter]		<<- MLH(mydf)	# multilocus heterozygosity
	#inds$sMLH[inds$filter]		<<- sMLH(mydf)	# standardized multilocus heterozygosity
	inds$MLH					<<- MLH(mydf)	# multilocus heterozygosity
	inds$sMLH					<<- sMLH(mydf)	# standardized multilocus heterozygosity
	#
	if(!is.null(phenovector))
		{
		# HETEROZYGOSITY-FITNESS CORRELATIONS (HFC)
		# inbreedR can also be used to calculate heterozygosity-fitness correlations (HFC).
		# calculate identity distribution (a proxy of inbreeding coefficient):
		myf 	<- g2_snps(try,nperm=100,nboot=10,CI=0.95,parallel=FALSE,ncores=NULL)
		# alternative to identity distribution: heterozygosity-heterozygosity correlation coefficients (HCP)
		# myhhc <- HHC(try,reps=100)
		#
		# linear model of fitness trait (mypheno) on heterozygosity
		mypheno	<- phenovector[inds$filter]		# this should be a quantitative trait, such as body size or number of offspring
		mymodel <- lm(mypheno ~ het)
		mybeta 	<- coef(mod)[2]
		#
		# r2 between fitness and heterozygosity:
		Wh 		<- cor(mypheno,predict(mymodel))^2
		# r2 between inbreeding and heterozygosity:
		hf 		<- r2_hf(genotypes=mydf,type="snps")
		# r2 between inbreeding and fitness:
		Wf 		<- r2_Wf(genotypes=mydf,trait=mypheno,family=gaussian,type="snps")
		}
	}

MLHboxplot<-function(export=NULL,sMLH=FALSE,plotname="MLH_boxplot",popnames=mysambar$poporder,popcolours=mysambar$colorder,ylabel="Multi locus heterozygosity (%)",yline=5.25,silent=TRUE)
	{
	indstemp	<- droplevels(inds[inds$filter,])
	npops		<- length(popnames)
	#
	if(!"MLH"%in%colnames(inds))
		{
		# SambaR's hetero_all estimate is identical to the MLH estimate of the package inbreedR
		cat("Column 'MLH' not present in inds dataframe. Setting it equal to inds$hetero_all.",sep="\n")
		indstemp$MLH<- indstemp$hetero_all
		}
	#
	if(sMLH)
		{
		if(!"sMLH"%in%colnames(inds))
			{
			return(cat("Column 'sMLH' not present in inds dataframe. First run the calcMLH function.",sep="\n"))
			}
		ymax		<- 1.1*max(indstemp$sMLH,na.rm=TRUE)
		ymin		<- 0.9*min(indstemp$sMLH,na.rm=TRUE)
		}else{
		ymax		<- 1.1*max(indstemp$MLH,na.rm=TRUE)
		ymin		<- 0.8*min(indstemp$MLH,na.rm=TRUE)
		ymax		<- ifelse(ymax>1,1,ymax)
		ymin		<- ifelse(ymin<0,0,ymin)
		}
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=npops*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=npops*mywidth+2,height=8)}
		}
	par(oma=c(9,8,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
	if(sMLH)
		{
		boxplot(indstemp$sMLH~indstemp$poporder,border=popcolours,col="grey90",cex.axis=2.5,pch=16,outline=FALSE,ylim=c(ymin,ymax),las=2,xlab="",ylab="")
		stripchart(sMLH~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2,col=popcolours,bg="bisque",add=TRUE)
		abline(h=1,lty=2)
		}else{
		boxplot(indstemp$MLH~indstemp$poporder,border=popcolours,col="grey90",cex.axis=2.5,pch=16,outline=FALSE,ylim=c(ymin,ymax),las=2,xlab="",ylab="")
		stripchart(MLH~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2,col=popcolours,bg="bisque",add=TRUE) 
		}
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	#mtext(side=1,"Population",line=6.5,cex=2)
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Boxplot with per sample multi locus heterozygosity values has been exported to the directory:",sep="\n")}
		if(!silent){cat(getwd(),sep="\n")}
		}
	}


# calculate Ne from LD profile:
stratag_ne<-function(snpmissmax=NULL,write_genepop=FALSE,ncores=1)
	{
	if("strataG" %in% rownames(installed.packages()) == FALSE)	
		{
		cat("Installing package strataG...",sep="\n")
		devtools::install_github('ericarcher/strataG',build_vignettes=FALSE,upgrade="never")
		}
	if("strataG"%in%(.packages()) == FALSE)	
		{
		cat("Loading package strataG...",sep="\n")
		library(strataG)
		}
	if(is.null(mysambar$genind))
		{
		cat("Converting genlight to genind...",sep="\n")
		genlight2genind()
		}
	mygenind	<- mysambar$genind
	if(is.null(snpmissmax))
		{
		mygenind2	<- mygenind
		}else{
		mygenind2	<- missingno(mygenind,type="loci",cutoff=snpmissmax)		# optionally shrink dataset
		}
	cat("Converting genind to gtypes...",sep="\n")
	snps_gtypes <- genind2gtypes(mygenind2)
	if(write_genepop)
		{
		cat("Exporting genepop file (in case you would like to run the software Ne_estimator)...",sep="\n")
		genepopWrite(snps_gtypes,"gstrata_genepop.txt")
		# alternatively:
		# genlight2genepop()
		}
	cat("Calculating Ne...",sep="\n")
	myne 		<<- ldNe(snps_gtypes,maf.threshold=0,by.strata=TRUE,ci=0.95,drop.missing=TRUE,num.cores=ncores)
	myne		<<- round(myne,3)
	# Save the results:
	write.table(myne,"Ne_gstrata.txt",row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")	
	cat("Results are stored in 'myne'. In addition, a file called 'Ne_gstrata' has been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}

rundetectROHs<-function(doexample=TRUE,pernsnps=FALSE,het_run=FALSE,create_newfile=FALSE)
	{
	# if het_run is TRUE, detection of runs of heterozygosity rather than runs of homozygosity
	if(doexample)
		{
		genotypeFilePath<- system.file("extdata", "Kijas2016_Sheep_subset.ped", package="detectRUNS")
		mapFilePath 	<- system.file("extdata", "Kijas2016_Sheep_subset.map", package="detectRUNS")
		if(!pernsnps)
			{
			# sliding window:
			slidingRuns 	<- slidingRUNS.run(genotypeFile=genotypeFilePath,mapFile=mapFilePath,windowSize=15,threshold=0.05,minSNP=20,ROHet=het_run,maxOppWindow=1,maxMissWindow=1,maxGap=10^6,minLengthBps=250000,minDensity=1/10^3,maxOppRun=NULL,maxMissRun=NULL)
			# minDensity is: # SNP/kbps
			}else{
			# consecutive SNPs:
			consecutiveRuns <- consecutiveRUNS.run(genotypeFile=genotypeFilePath,mapFile=mapFilePath,minSNP=20,ROHet=het_run,maxGap=10^6,minLengthBps=250000,maxOppRun=1,maxMissRun=1)
			}
		#
		# summary statistics:
		# summaryList <- summaryRuns(runs=slidingRuns,mapFile=mapFilePath,genotypeFile=genotypeFilePath,Class=6,snpInRuns=TRUE)
		# summaryList$summary_ROH_count
		# summaryList$summary_ROH_mean_chr
		# head(summaryList$SNPinRun)		# The dataframe “SNPinRun” contains, for each SNP, the proportion of times it falls inside a run in any given population/group
		# topRuns <- tableRuns(runs=slidingRuns,genotypeFile=genotypeFilePath,mapFile=mapFilePath,threshold=0.7)
		#
		# plot (ggplot based):
		plot_Runs(runs=slidingRuns)
		plot_StackedRuns(runs=slidingRuns)
		plot_SnpsInRuns(runs=slidingRuns[slidingRuns$chrom==2,],genotypeFile=genotypeFilePath,mapFile=mapFilePath)
		plot_SnpsInRuns(runs=slidingRuns[slidingRuns$chrom==24,],genotypeFile=genotypeFilePath,mapFile=mapFilePath)
		plot_manhattanRuns(runs=slidingRuns[slidingRuns$group=="Jacobs",],genotypeFile=genotypeFilePath,mapFile=mapFilePath)
		#
		# Inbreeding statistics: Froh = Lroh/Lgenome
		# genome_wide:
		my_froh	<- Froh_inbreeding(runs=slidingRuns,mapFile=mapFilePath,genome_wide=TRUE)
		# per chromosome: genome_wide=FALSE
		my_froh	<- Froh_inbreeding(runs=slidingRuns,mapFile=mapFilePath,genome_wide=FALSE)
		}else{
		setwd(mysambar$inputfilesdir)
		if(!file.exists("allinds.filter2.ped")|create_newfile)
			{
			# Note: need to be space separated, not tab separated, otherwise you get the error:
			# Error: Number of markers differ in mapFile and genotype: are those file the same dataset?
			genlight2ped(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter2,indsfilter=rep(TRUE,nrow(inds)),exportname="allinds.filter2",pheno=NULL,genonumber=FALSE,quiet=FALSE,miss_char="N",use_tab=FALSE) 
			}
		myrohs 	<- consecutiveRUNS.run(genotypeFile="allinds.filter2.ped",mapFile="allinds.filter2.map",minSNP=200,ROHet=het_run,maxGap=10^6,minLengthBps=250000,maxOppRun=1,maxMissRun=1)
		# calculate Froh:
		myfroh				<- Froh_inbreeding(runs=myrohs,mapFile="allinds.filter2.map",genome_wide=TRUE)
		myfroh2				<- myfroh[,c("id","Froh_genome")]
		colnames(myfroh2)	<- c("name","Froh")  
		indstemp			<- merge(inds,myfroh2,by="name",all=TRUE)
		inds				<<- indstemp
		}
	}

twofactorbarplot<-function(mydf=dataallwhales,export=NULL)
	{
	mypops			<- unique(mydf$Species)
	mydf$Species	<- factor(mydf$Species,levels=as.character(mypops))	# reorder factors alphabetically
	npops			<- length(mypops)
	if(!is.null(export))
		{
		myheight	<- 0.25
		myheight2	<- 75
		plotname	<- "Froh_barplot_2factor"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=npops*myheight+2,width=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=npops*myheight+2,width=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=npops*myheight2+200,width=600)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=npops*myheight+2,width=6)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=1.5)
	barplot(mydf$Froh~mydf$Cutoffs+mydf$Species,las=2,col=colors()[c(23,89,12,11,5)],horiz=TRUE,xlab="",ylab="",border=NA)
	if(!is.null(export)){dev.off()}
	}

# If you want to do it your way, it requires a few more steps:
onefactorbarplot<-function(export=NULL)
	{
	# first define factor levels:
	allcombi 		<- expand.grid(a = unique(mydf$Cutoffs), b = unique(mydf$Species))
	allcombi$c		<- paste(allcombi$b,allcombi$b,sep="_")
	allcombi$c		<- paste(allcombi$b,allcombi$a,sep="_")
	#
	# define classes:
	mydf$class		<- paste(mydf$Species,mydf$Cutoffs,sep="_")
	mydf$classorder <- factor(mydf$class,levels=allcombi$c)
	#
	nclass			<- length(unique(mydf$classorder))
	if(!is.null(export))
		{
		myheight	<- 0.25
		myheight2	<- 75
		plotname	<- "Froh_barplot_1factor"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=nclass*myheight+2,width=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=nclass*myheight+2,width=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=nclass*myheight2+200,width=600)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=nclass*myheight+2,width=6)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=1.25)
	barplot(mydf$Froh~mydf$Cutoffs+mydf$classorder,las=2,horiz=TRUE,xlab="",ylab="",border=NA)
	if(!is.null(export)){dev.off()}
	}

private_hist<-function(popnames=mysambar$populations,snpsfilter=NULL,export=NULL)
	{
	npops		<- length(popnames)
	snpstemp	<- snps[,paste("maf",popnames,sep="_")]
	mafsum		<- rowSums(snpstemp)
	privatevec	<- vector()
	for(j in c(1:npops))
		{
		mypop			<- popnames[j]
		mymaf			<- snps[,paste("maf",mypop,sep="_")]
		if(is.null(snpsfilter))
			{
			privatevec[j]	<- length(mymaf[mymaf==mafsum&mafsum!=0]) 
			}else{
			privatevec[j]	<- length(mymaf[mymaf==mafsum&snpsfilter&mafsum!=0]) 
			}
		#mymaf			<<- mymaf
		#mafsum			<<- mafsum
		}
	if(!is.null(export))
		{
		plotname	<- ifelse(is.null(snpsfilter),"Private_alleles_unfiltered","Private_alleles_filtered")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=npops*2+1,width=14)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=npops*2+1,width=14)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=npops*250+100,width=1400)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=npops*2+1,width=14)}
		}
	par(mar=c(6,20,3,0),cex.axis=3)
	privatevec2	<- privatevec/1000
	xx<-barplot(privatevec2,las=1,col=mysambar$mycolours,border=NA,space=0.1,names.arg=mysambar$populations,horiz=TRUE,xlim=c(0,max(privatevec2)*1.3))
	text(x=privatevec2,y=xx,privatevec2,pos=4,cex=3)
	mtext("# private alleles (k)",side=1,line=3.5,cex=3)
	snpstotal	<- ifelse(!is.null(snpsfilter),nrow(snps[snpsfilter&mafsum!=0,]),nrow(snps[mafsum!=0,]))
	mtext(paste("# SNPs:",snpstotal/1000,"k",sep=" "),side=3,line=0.75,cex=3)
	if(!is.null(export)){dev.off()}
	}

# 14-09-2021:
# Shows number of private allele as well as shared alleles
# Works for maximum 5 populations
markervenn<-function(export=FALSE,plotname="Private_and_shared_alleles_venndiagram",minmaf=0,myfilter=snps$filter,popnames=mysambar$populations,popcolours=mysambar$mycolours,silent=TRUE,numbercex=2.5,labelcex=2.5,addtotal=FALSE,include_overall=FALSE,doprop=FALSE)
	{
	seglist		<<- list()
	npops		<- length(popnames)
	for(k in c(1:npops))
		{
		mypop		<- as.character(popnames[k])
		mafvec		<- snps[,paste("maf",mypop,sep="_")]
		seglist[[k]]<<- snps$name[myfilter&mafvec>minmaf]
		}
	if(addtotal)
		{
		names(seglist)	<<- paste(as.vector(summary(seglist)[,1]),popnames,sep="\n")
		}else{
		names(seglist)	<<- popnames
		}
	#
	if(is.null(popcolours))
		{
		popcolours	<- vector()
		for(k in c(1:npops))
			{
			mypop			<- as.character(popnames[k])
			popcolours[k]	<- mysambar$mycolours[which(mysambar$populations==mypop)]
			}
		}
	if(include_overall)
		{
		# useless:
		seglist$overall	<<- snps$name[myfilter&snps$maf>minmaf]
		popcolours		<- c(popcolours,"grey50") 
		}
	if(!silent){cat("Plotting...",sep="\n")}
	# depends on package VennDiagram
	plotname	<- ifelse(doprop,paste(plotname,"prop",sep="."),plotname)
	if(export){pdf(paste(plotname,minmaf,"pdf",sep="."),height=6,width=8)}
	#v1 <- venn.diagram(seglist,filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkorchid4"),col=c("blue","darkgreen","darkorchid4"),margin=0.1)
	v1 	<<- venn.diagram(seglist,filename=NULL,alpha=0.6,cex=numbercex,cat.cex=labelcex,fill=popcolours,col=popcolours,margin=0.1)
	if(doprop)
		{
		# 01-10-2021: has been tested on four populations:
		ngroups		<- 0
		for(j in c(1:npops))
			{
			ngroups	<- ngroups+choose(npops,j)
			}
		labelvec	<- vector()
		for(k in c(1:ngroups))
			{
			labelvec[k]	<- as.numeric(v1[[k+(npops*2)]][1]) 
			}
		mysum	<- sum(labelvec)
		for(k in c(1:ngroups))
			{
			v1[[k+(npops*2)]][1]	<- round(labelvec[k]/mysum,2) 
			}
		}
	grid.newpage()
	grid.draw(v1)
	if(export)
		{
		dev.off()
		cat("Venn diagram has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	vennlogfiles <- list.files(pattern = "\\.log$")
	unlink(vennlogfiles)
	}

snp_sim<-function(snp1=NULL,snp2=NULL)
	{
	# how similar are genotype scores of two snps?
	# expects genotype scores of two biallelic snps (e.g 0,1,2) 
	# output is stored in scalar 'snpsim'
	# The similarity roughly indicates whether snps have same distribution of a minor and a major allele. 
	nodata	<- is.na(snp1)|is.na(snp2)
	if(sum(nodata)==length(nodata))
		{
		snpsim <<- NA
		}else{
		snp1	<- snp1[!nodata]	
		snp2	<- snp2[!nodata]	
		onediff	<- sum(abs(snp2-snp1)==1)
		twodiff	<- sum(abs(snp2-snp1)==2)
		snpsim	<<- 1-((onediff+2*twodiff)/(2*length(snp1)))	
		}
	#cat(paste("Similarity score:",snpsim,sep=" "),sep="\n")
	}

gethaplo<-function()
	{
	# install.packages("C:/Users/Menno_de_Jong/Documents/software/HaploBlocker/HaploBlocker-master/HaploBlocker_1.6.06.zip",repos=NULL,type="source")
	# library(HaploBlocker)
	# Error: package 'RandomFieldsUtils' 0.5.3 is loaded, but >= 0.6.6 is required by 'HaploBlocker'
	#
	# try to solve by installing latest version from source (0.6 not available yet on CRAN) 
	# detach(package:RandomFieldsUtils,unload = TRUE)
	# install.packages("C:/Users/Menno_de_Jong/Documents/software/HaploBlocker/HaploBlocker-master/RandomFieldsUtils_0.6.6.tar.gz",repos=NULL,type="source")
	# Warning in system(cmd) : 'make' not found; ERROR: compilation failed for package 'RandomFieldsUtils'
	# 
	# after following instructions to install Rtools40 from this website:
	# https://cran.r-project.org/bin/windows/Rtools/
	# when I retry to install RandomFieldsUtils, I get the error:
	# sh: line 1: c:/Rtools/mingw_32/bin/g++: No such file or directory; make: *** [C:/PROGRA~1/R/R-3.6.2/etc/i386/Makeconf:213: RFoptions.o] Error 127
	#
	# Because I did not manage to solve this error, for now using an older version:
	# install.packages("C:/Users/Menno_de_Jong/Documents/software/HaploBlocker/HaploBlocker-master/Old_version/HaploBlocker_1.5.18.zip",repos=NULL,type="source")
	# library("HaploBlocker")
	#
	# INPUT DATA AND RUN CALCULATIONS:
	# Note: assuming phased data (for example with SHAPEIT)
	# blocklist	<- block_calculation(dhm=ex_maze)
	setwd(mysambar$inputdatadir)
	blocklist	<- block_calculation(dhm="brown121_MT_blackout.ped",bp_map=snps$pos)
	blocklist	<- block_calculation(dhm="brown121_ychrom_blackout.ped",bp_map=snps$pos)
	#
	# CREATE PLOT:
	pdf("Haploblocks.pdf")
	plot_block(blocklist,type="bp")												# type="bp" only works if bp_map flag was not set to NULL (default) when running block_calculation
	# mtext(side=2,rep(inds$pop,rep=2),at=c(1:(2*nrow(inds))),las=2,cex=0.25) 	# not ordered per pop, so does not correspond.
	dev.off()
	#
	# alternative ways to visualize:
	# block_plot(blocklist)
	# blocklist_plot(blocklist)
	# blocklist_plot_xsize(blocklist)
	#
	# OBSERVE OUTPUT:
	# which individuals per block?
	nblocks		<- length(blocklist)
	blockinds	<- list()
	for(i in c(1:nblocks))
		{
		myindex		<- ceiling(blocklist[[i]][6][[1]]/2)
		cat(paste("BLOCK:",i,sep=" "),sep="\n")
		blockinds[[i]]	<- as.character(inds$name[myindex])
		}
	# which individuals missing:
	allinds		<- unlist(blockinds,use.names=FALSE)
	as.character(inds$name[!as.character(inds$name)%in%allinds])
	}
	
# This function calculates LD only for adjacent snps.	
# 27-03-2019: To do for more than just adjacent snps takes a long time, so better to use PLINK.
calcLD<-function(mypop=NULL,add_snpsim=FALSE)
	{
	cat("Calculating LD estimates for unphased data (squared pearson correlation coefficients)...",sep="\n")
	if(is.null(mypop))
		{
		indfilter	<- inds$filter
		}else{
		indfilter	<- inds$filter&inds$pop==mypop
		}
	# This function outputs LD values (squared pearson correlation coefficients) between adjacent snps: 
	# It generates NA if a SNP contains no variation (so only 0's, 1's or 2's (except from NA))
	mymatrix	<- as.matrix(mygenlight)[indfilter,snps$filter2]
	mysnps		<- as.vector(snps$name[snps$filter2])
	mychr		<- snps$chr[snps$filter2]
	mypos		<- snps$pos[snps$filter2]
	myld		<- vector()
	myld[1]		<- NA
	# to suppress warnings:
	op 			<- options(warn = (-1))
	ldmatrix	<- as.data.frame(matrix(NA,ncol=8,nrow=length(mysnps)))
	colnames(ldmatrix)	<- c("snp1","snp2","chr1","chr2","pos1","pos2","ld","sim")
	ldmatrix$sim<- NA
	#for (k in c(2:ncol(mymatrix)))	# replacement has 37 rows, data has 36
	for (k in c(2:nrow(ldmatrix)))	# replacement has 36 rows, data has 175
		{
		ldmatrix$snp1[k]	<- mysnps[k-1]
		ldmatrix$snp2[k]	<- mysnps[k]
		ldmatrix$chr1[k]	<- mychr[k-1]
		ldmatrix$chr2[k]	<- mychr[k]	
		ldmatrix$pos1[k]	<- mypos[k-1]
		ldmatrix$pos2[k]	<- mypos[k]	
		mypair				<- mymatrix[,c((k-1),k)]
		mycorr				<- cor(mypair,method="pearson",use="na.or.complete")
		myld[k]				<- mycorr[2,1]
		ldmatrix$ld[k]		<- mycorr[2,1]
		# Note: this has nothing to do with LD, but just to see how similar the snps are:
		if(add_snpsim)
			{
			snp_1				<- mypair[,1]
			snp_2				<- mypair[,2]
			snp_sim(snp1=snp_1,snp2=snp_2)
			ldmatrix$sim[k]		<- snpsim
			}
		}
	# ldmatrix$ld will have NA if at least one of both snps has identical genotype scores for all individuals (so all individuals are either 0,1,2)
	# this is ignoring individuals with NA scores (note: NA in either the individual itself, or NA in the other individual)
	# enable warnings again:
	ldmatrix				<<- ldmatrix
	options(op)
	snps$ldtemp				<<-	NA 				# this NA values can be discriminated from NA values mentioned above by using snps$filter
	snps$ldtemp[snps$filter]<<- round(myld^2,4)
	if(is.null(mypop))
		{
		names(snps)[names(snps)=="ldtemp"]	<<- "ld_meta"
		}else{
		names(snps)[names(snps)=="ldtemp"]	<<- paste("ld",mypop,sep="_")
		}
	snps 		<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	}	

calcpopLD<-function(popnames=mysambar$populations)
	{
	for (my_pop in popnames)
		{
		cat(my_pop,sep="\n")
		calcLD(mypop=my_pop)
		}
	snps 		<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	}
	
# depends on wintajd:	
wintajd_multiplewinsizes<-function(my_chr=25,doexport=TRUE)
	{
	if(doexport){pdf(paste("TajimaD",my_chr,"multiple_windowsizes.pdf",sep="."),height=16,width=12)}
	par(mfrow=c(4,1),oma=c(3,3,2,3))
	wintajd(my_chrom=my_chr,winsize=500000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=1000000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=1500000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=2000000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	mtext("Position (Mb)",side=1,line=0,outer=TRUE,cex=2)
	mtext("Tajima's D",side=2,line=-1,outer=TRUE,cex=2)
	mtext(paste("Chromosome",my_chr,sep=" "),side=3,line=-2.5,outer=TRUE,cex=2)
	mtext("Number of SNPs per window",side=4,line=-0.5,outer=TRUE,cex=2)
	if(doexport){dev.off()}
	# and separate plots:
	wintajd(my_chrom=my_chr,winsize=500000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=1000000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=1500000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=2000000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	}

# depends on function wintajd()	
wintajd_multiplechroms<-function(mycomparisons=NULL,popnames=mysambar$populations,ntiles=18,mychroms=NULL,windowsize=50000000,windowstep=30000000,export=NULL,addX=TRUE,myyrange=c(-3,3),my_lwd=1.5)
	{
	myxmax	<- max(snps$pos[snps$filter],na.rm=TRUE)
	my_xlim	<- c(0,myxmax/1000000)
	setwd(mysambar$selectiondir)
	# run windowfst function recursively:
	if(is.null(mycomparisons))
		{
		mycomparisons=seq(1:ncol(combn(popnames,m=2)))
		}
	if(is.null(mychroms))
		{
		mychroms<-sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
		}
	nchroms		<- length(mychroms)
	ntabs		<- ceiling(nchroms/ntiles)
	for (n in c(1:ntabs))
		{ 
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"eps",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="pdf"){pdf(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"pdf",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="png"){png(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"png",sep="."),family=mysambar$myfont,width=540,height=720)}
			if(export=="wmf"){win.metafile(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"wmf",sep="."),family=mysambar$myfont,width=6,height=8)}
			}
		layout(matrix(c(c(c(1:(ntiles/2)),ntiles+1),c((ntiles/2+1):(ntiles+1))),nrow=(ntiles/2+1),ncol=2,byrow=FALSE))
		#layout(matrix(c(1:ntiles),(ntiles/2),2,byrow=FALSE))
		par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))
		if(n<ntabs)
			{
			chromset	<- mychroms[((n-1)*ntiles+1):(ntiles*n)]
			}else{
			chromset	<- mychroms[((n-1)*ntiles+1):length(mychroms)]
			}
		for (chromname in chromset)
			{
			# cat(chromname,sep="\n")
			if(chromname%%(ntiles/2)==0)
				{
				wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addinfo=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
				#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
				}else{
				if(mychroms[nchroms]==chromname&&addX==FALSE)
					{
					wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=FALSE,subtitlepos=-2)
					#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
					}else{
					wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=FALSE,subtitlepos=-2)
					#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=FALSE,mylwd=my_lwd)
					}
				}
			}
		if(addX&n==ntabs)
			{
			wintajd(my_chrom="X",winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=TRUE,subtitlepos=-2)
			#windowfst(chrom="X",selectcombi=mycomparisons,width=windowsize,yrange=c(0.025,0.225),yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
			}
		mtext("Tajima's D", side=2, line=0, outer=TRUE,cex=1.5)
		mtext("Position along chromosome (Mb)", side=1, line=-3.5, outer=TRUE,cex=1.25)
		# addlegend:
		if(n==ntabs)
			{
			nempty	<- ifelse(addX,(ntabs*ntiles-length(mychroms)-1+1),(ntabs*ntiles-length(mychroms)+1))
			for(mycounter in c(1:(nempty)+1))
				{
				plot(1,type ="n",axes=FALSE,xlab="",ylab="")	
				}
			}else{
			plot(1,type= "n",axes=FALSE,xlab="",ylab="")
			}
		legend(x="bottom",legend=popnames,horiz=T,fill=mysambar$mycolours[1:length(popnames)],cex=1.25,bty="n")
		if(!is.null(export)){dev.off()}
		}
	setwd(mysambar$inputdatadir)
	}		
	
# depends on calcpi:
wintajd<-function(my_chrom=25,winsize=1000000,winstep=200000,popnames=mysambar$populations,do_analysis=TRUE,export=FALSE,addlab=TRUE,addinfo=TRUE,addxaxis=TRUE,subtitlepos=-1.5,myxlim=NULL)
	{
	if(!my_chrom%in%snps$chr)
		{
		return(cat("ERROR: specified chromosome/contig not present in snps$chr column. Aborting.",sep="\n"))
		}
	npops			<- length(popnames)
	mycols			<- mysambar$mycolours[1:npops]
	if(do_analysis)
		{
		mymax		<- max(snps$pos[snps$chr==my_chrom],na.rm=TRUE)
		mystarts	<- seq(0,winsize,winstep)
		mywindows	<- vector() 
		for(mystart in mystarts)
			{
			mywindow	<- seq(mystart,mymax,winsize)
			mywindows	<- c(mywindows,mywindow)
			}
		windowstart	<- sort(as.vector(unique(mywindows)))
		windowend	<- windowstart+winsize
		nwin		<- length(windowstart)
		cat(paste("Calculating Tajima's D for",nwin,"windows of",winsize/1000000,"Mb width on contig/chromosome",my_chrom,"...",sep=" "),sep="\n")
		for(k in c(1:nwin))
			{
			cat(k,sep="\n")
			mywindow	<- c(windowstart[k],windowend[k])
			calcpi(mychrom=my_chrom,myrange=mywindow,silent=TRUE,pi_per_pop=TRUE)
			if(k==1)
				{
				wintaj	<<- mysambar$tajd
				}else{
				wintaj	<<- rbind(wintaj,mysambar$tajd)
				}
			}
		mymean	<- round(mean(wintaj$mean_nsites,na.rm=TRUE),1) 
		cat(paste("Average number of SNPs per window:",mymean,sep=" "),sep="\n")
		cat(paste("Results have been written to a dataframe called wintaj."),sep="\n")
		mymax	<- max(wintaj$TajimaD,na.rm=TRUE)
		mymin	<- min(wintaj$TajimaD,na.rm=TRUE)
		mymax	<- ifelse(mymax< 3, 3, mymax)
		mymin	<- ifelse(mymax> -3,-3, mymin)
		}
	# plot:
	if(export){pdf(paste("TajimaD",my_chrom,"winsize",winsize/1000000,"Mb.pdf",sep="."),height=5,width=12)}
	if(addinfo)
		{
		par(mar=c(4,4.5,3,5),cex.axis=1.5)		# par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))		
		}
	myxaxt		<- ifelse(addxaxis,'s','n')
	mypop		<- popnames[1]
	plot(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],type='l',las=1,lwd=2,col=mycols[1],xaxt=myxaxt,ylim=c(mymin,mymax),xlim=myxlim,ylab="",xlab="",main="")
	if(npops>1)
		{
		for(i in c(2:npops))
			{	
			mypop	<- popnames[i]
			points(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],type='l',lwd=2,col=mycols[i])
			}
		}
	if(addlab)
		{
		mtext("Tajima's D",side=2,line=2.5,cex=2)
		mtext("Position (Mb)",side=1,line=2.5,cex=2)
		mytitle		<- paste("chromosome",my_chrom,sep=" ")
		mtext(mytitle,side=3,line=0,cex=2)
		}else{
		mtext(my_chrom,side=3,line=-1,cex=0.75)
		}
	if(addinfo)
		{
		mysubtitle	<- paste("window size:",winsize/1000000,"Mb",sep=" ")
		mtext(mysubtitle,side=3,line=subtitlepos,cex=1.5)
		}
	# plot number of snps per window:
	if(addinfo)
		{
		par(new=TRUE)
		mymin2	<- min(wintaj$mean_nsites,na.rm=TRUE)
		mymax2	<- max(wintaj$mean_nsites,na.rm=TRUE)
		myrange2<- mymax2-mymin2
		myrange1<- mymax-mymin
		mypop	<- popnames[1]
		plot(wintaj$mid[wintaj$pop==mypop],wintaj$mean_nsites[wintaj$pop==mypop],col="white",type='l',yaxt='n',xaxt=myxaxt,ylab="",xlab="",xaxt='n',ylim=c(mymin2,myrange1*mymax2))
		polygon(x=c(wintaj$mid[wintaj$pop==mypop],rev(wintaj$mid[wintaj$pop==mypop])),y=c(rep(0,length(wintaj$mean_nsites[wintaj$pop==mypop])),rev(wintaj$mean_nsites[wintaj$pop==mypop])),col="grey",border=NA)
		axis(side=4,las=1)
		if(addlab)
			{
			mtext("SNPs per window",side=4,cex=2,line=3.5)
			}
		par(new=TRUE)
		plot(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],col=mycols[1],type='l',ylim=c(mymin,mymax),xaxt=myxaxt,ylab="",xlab="",main="",yaxt='n',xaxt='n')
		# last two lines are needed to add outlier borders
		}
	# add Tajima's D outlier borders:
	abline(h=c(2,-2),lty=2)
	if(addinfo)
		{
		text(x=0,y=-2,"positive selection",adj=c(0,1.25),cex=1)
		text(x=0,y=2,"balancing selection",adj=c(0,-0.5),cex=1)
		}
	if(export){dev.off()}
	}
	
# depends on output of calcpi with flag pi_per_pop set to TRUE:
plottajd<-function(tajdtable=NULL,genome_wide=FALSE,nsites=NULL,nsegsites=NULL,popnames=mysambar$populations,export=TRUE,insetbarplot=TRUE,legendcex=2)
	{
	# if genome_wide is set to FALSE, nucleotide diversity (pi) and Watterson theta are for snp dataset only 
	# if genome_wide is set to TRUE, nucleotide diversity (pi) and Watterson theta are genome wide (i.e. * segregating/sequenced sites)
	if(insetbarplot&length(popnames)==1)
		{
		return(cat("Only 1 population defined. No space in plot for inset. Set insetbarplot to FALSE.",sep="\n"))
		}
	popnind <- as.vector(table(inds$pop[inds$filter]))
	popbool	<- popnind>1
	if(any(!popbool))
		{
		return(cat("Populations present with only 1 individual. Not generating Tajima's D plots.",sep="\n"))
		}
	npops	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npops]
	if(!is.null(tajdtable))
		{
		if(nrow(tajdtable)!=length(popnames))
			{
			return(cat("ERROR: Number of rows in input tajdtable does not equal number of populations.",sep="\n"))
			}else{
			tajd	<- tajdtable	# else: tajd should be in environment, created by calcpi(pi_per_pop=TRUE)
			}
		}
	if(is.null(mysambar$tajd))
		{
		calcpi(pi_per_pop=TRUE)
		}
	if(nrow(mysambar$tajd)!=length(popnames))
		{
		calcpi(pi_per_pop=TRUE)
		}
	tajd	<- mysambar$tajd
	mywatt	<- tajd$Watterson_scaled		# tajd$Watterson/tajd$mean_nsites	
	mypi	<- tajd$pi_scaled				# tajd$mean_pi/tajd$mean_nsites
	mytajd	<- tajd$TajimaD_scaled			# tajd$TajimaD/tajd$mean_nsites
	if(genome_wide)
		{
		if(is.null(nsegsites))
			{
			indstemp	<- inds[,c("pop","nsegsites3")]
			aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			if(length(nsegsites)!=npops)
				{		
				return(cat("The length of vector input to nsegsites does not equal the number of populations. SambaR can not generate Tajima's D plot.",sep="\n"))
				}else{
				myseg		<- nsegsites			
				}
			}
		if(is.null(nsites))
			{
			indstemp	<- inds[,c("pop","allseqsites")]
			aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			allsites	<- nsites
			}
		mywatt	<- mywatt*myseg/allsites*100
		mypi	<- mypi*myseg/allsites*100
		mytajd	<- mytajd*myseg/allsites*100
		myscores<<- cbind(mywatt,mypi,mytajd)
		}
	mymin	<- min(mywatt,mypi)-0.02
	mymax	<- max(mywatt,mypi)+0.02
	myrange	<- c(mymin,mymax)
	if(export)
		{
		if(genome_wide)
			{
			plotname	<- ifelse(insetbarplot,"Wattersontheta_vs_pi.withTajima.genomewide.pdf","Wattersontheta_vs_pi.genomewide.pdf")
			}else{
			plotname	<- ifelse(insetbarplot,"Wattersontheta_vs_pi.withTajima.snpdata.pdf","Wattersontheta_vs_pi.snpdata.pdf")
			}
		pdf(plotname,height=8,width=8)		
		}
	par(fig = c(0,1,0,1),cex.axis=1.5,cex.lab=2,mar=c(5,6,2,1))
	plot(mywatt,mypi,xlim=myrange,ylim=myrange,las=1,col=mycols,pch=16,cex=2,ylab="",xlab="")
	lines(x=c(0,1),y=c(0,1),lty=2)
	#text(0.11,0.105,"Excess of rare alleles",srt=45,adj=c(0,1),cex=1.5) 	
	#text(0.105,0.11,"Lack of rare alleles",srt=45,adj=c(0,0),cex=1.5) 
	mymin2<-mymin+0.0075
	text(mymin2,mymin2-0.00375,"Excess of rare alleles",srt=45,adj=c(0,1),cex=1.5) 	
	text(mymin2-0.00375,mymin2,"Lack of rare alleles",srt=45,adj=c(0,0),cex=1.5) 
	mtext("Nucleotide diversity (%)",side=2,line=4,cex=2)
	mtext("Watterson's theta (%)",side=1,line=3,cex=2)
	legend("topleft",popnames,fill=mycols,cex=legendcex,bty='n')
	if(insetbarplot)
		{
		if(all(popbool))
			{
			barwidth	<- 0.3/npops 
			myx			<- 1-(npops*barwidth)-0.025
			myx			<- ifelse(myx<0.1,0.1,myx)
			par(fig=c(myx,0.975,0.025,0.425),new=TRUE)
			mymin2		<- min(mytajd)-0.002
			mymax2		<- max(mytajd)+0.002
			myrange2	<- c(mymin2,mymax2)
			barplot(mytajd,col=mycols,las=1,ylim=myrange2,border=mycols,space=0.1)
			if(npops>2)		# with less populations, the title doesn't fit
				{
				mtext(side=3,"Tajima's D",line=0.5,cex=1.5)
				}
			}else{
			cat("Not including Tajima's D barplot because at least one populations contains only 1 individual only.",sep="\n") 
			}
		}	
	if(export){dev.off()}
	#
	# separate barplot Tajima's D:
	if(!insetbarplot)
		{
		if(all(popbool))
			{	
			graphics.off()
			if(export)
				{
				if(genome_wide)
					{
					pdf("TajimaD.barplot.genomewide.pdf")
					}else{
					pdf("TajimaD.barplot.snpdata.pdf")
					}
				}
			par(mar=c(4,8,2.5,2.5))
			barplot(mytajd,col=mycols,border=mycols,space=0.1,horiz=TRUE,main="Tajima's D",names.arg=popnames,las=2)
			if(export){dev.off()}
			}else{
			cat("Not including Tajima's D barplot because at least one populations contains only 1 individual only.",sep="\n") 
			}
		}
	}

# pairwise missingness:
calcpairmiss<-function(popnames=mysambar$populations,exporttype=NULL,use_currentdir=TRUE,silent=TRUE,snpsfilter=FALSE,legendcex=2.5,nrbins=20,definebreaks=FALSE,addmiss=TRUE,plotexpected=FALSE,my_Breaks=NULL,include_allsites=FALSE)
	{
	if(min(inds$miss,na.rm=TRUE)==0)
		{
		return(cat("No missing data points. Omitting pairwise_missingness plots.",sep="\t"))
		}
	my_wd		<- getwd()
	myinds		<- inds$nr
	combitable	<- combn(myinds,m=2)
	npairs		<- ncol(combitable)
	if(!snpsfilter)
		{
		plotlabel	<- "allsnps"
		snpsfilter	<- rep(TRUE,nrow(snps))
		}else{
		plotlabel	<- "snpsfilter"
		snpsfilter	<- snps$filter
		}
	if(!is.null(mysambar$missdf))
		{
		missdf			<- mysambar$missdf
		}else{
		setwd(mysambar$inputdatadir)
		if(file.exists("pairwise_missingness.txt"))
			{
			mydftemp	<- read.table("pairwise_missingness.txt",header=TRUE)
			}else{
			# create dummy:
			mydftemp	<- data.frame("col1"=c(1:2),"col2"=c(1:2)) 
			}
		if(nrow(mydftemp)==npairs)
			{
			missdf			<- mydftemp
			mysambar$missdf	<<- missdf
			}else{
			cat("Pairwise_missingness.txt file is not present or does not have the expected number of rows. Creating datafile now.",sep="\n")  
			cat("This will take some time, but the next time you run the filterdata() function this step will be automatically omitted and then it will be much faster.",sep="\n") 
			mymatrix	<- as.matrix(mygenlight[,snpsfilter])
			mymatrix2	<- as.matrix(mygenlight)
			ind1vec		<- vector()
			ind2vec		<- vector()
			ind1miss	<- vector()
			ind2miss	<- vector()
			ind1pop		<- vector()
			ind2pop		<- vector()
			ind1subpop	<- vector()
			ind2subpop	<- vector()
			missvec		<<- vector()
			missvec_all	<<- vector()	# when analysing all sites
			expvec		<- vector()
			for (i in c(1:npairs))
				{
				if(i%%1000==0&!silent)
					{
					cat(paste(i," in ",ncol(combitable)," pairwise comparisons.",sep=""),sep="\n") 
					}
				ind1		<- combitable[1,i]
				ind2		<- combitable[2,i]
				ind1vec[i]	<- ind1
				ind2vec[i]	<- ind2
				ind1miss[i]	<- inds$miss[ind1]
				ind2miss[i]	<- inds$miss[ind2]
				ind1pop[i]	<- as.vector(inds$pop[ind1])
				ind2pop[i]	<- as.vector(inds$pop[ind2])
				ind1subpop[i]<- as.vector(inds$pop2[ind1])
				ind2subpop[i]<- as.vector(inds$pop2[ind2])
				expvec[i]	<- 1-((1-ind1miss[i])*(1-ind2miss[i]))
				geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[ind2,]
				#
				geno1_all	<- mymatrix[ind1,]
				geno2_all	<- mymatrix[ind2,]
				# Count number of SNPs with NA's in either or both individuals:
				missvec[i]		<- length(geno1[is.na(geno1)|is.na(geno2)])/length(geno1)
				missvec_all[i]	<- length(geno1_all[is.na(geno1_all)|is.na(geno2_all)])/length(geno1_all)
				}
			if(!include_allsites)
				{
				missdf			<- data.frame("ind1"=ind1vec,"ind2"=ind2vec,"pop1"=ind1pop,"pop2"=ind2pop,"subpop1"=ind1subpop,"subpop2"=ind2subpop,"ind1_miss"=ind1miss,"ind2_miss"=ind2miss,"pairmiss_exp"=expvec,"pairmiss_obs"=missvec)
				}else{
				missdf			<- data.frame("ind1"=ind1vec,"ind2"=ind2vec,"pop1"=ind1pop,"pop2"=ind2pop,"subpop1"=ind1subpop,"subpop2"=ind2subpop,"ind1_miss"=ind1miss,"ind2_miss"=ind2miss,"pairmiss_exp"=expvec,"pairmiss_obs"=missvec,"pairmiss_obs_all"=missvec_all)
				}
			missdf$diff		<- abs(missdf$pairmiss_exp-missdf$pairmiss_obs)
			missdf$outlier	<- missdf$diff>(8*sd(missdf$diff))		# 09-03-2020: 8 is random, should come up with something better 
			mysambar$missdf	<<- missdf
			setwd(mysambar$inputdatadir)
			write.table(mysambar$missdf,"pairwise_missingness.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
			}
		setwd(my_wd)
		}
	# PLOTTING
	mymin		<- min(inds$miss,na.rm=TRUE)
	if(definebreaks)
		{
		my_Breaks	<- c(0.02,0.05,0.1,0.15,0.2,0.3,0.4,0.5,0.75,1)
		my_Breaks	<- c(0,my_Breaks[my_Breaks>mymin])
		}else{
		my_Breaks	<- NULL
		}
	if(!use_currentdir)
		{
		setwd(mysambar$QCdir)
		}
	# matrix missingness:
	# Note: indsfilter=TRUE will create plots for both filtered and unfiltered data.
	if(!silent){cat("Plotting indmatrix...",sep="\n")}
	plot_indmatrix(export=exporttype,indsfilter=TRUE,plottitle="Observed missing data",inputvalues=missdf$pairmiss_obs,miss_labels=addmiss,popnames=mysambar$populations,mybreaks=my_Breaks,n_bins=nrbins,legpos_x=0.1,legpos_y=0.55,leg_cex=legendcex,matcol="orange",plotprefix=paste("Pairwise_miss_obs",plotlabel,sep="."),currentdir=TRUE,perpop=FALSE,sub_title="per sample pair")
	if(plotexpected)
		{
		if(!silent){cat("Plotting expected 1...",sep="\n")}
		plot_indmatrix(export=exporttype,indsfilter=TRUE,plottitle="Expected missing data",inputvalues=missdf$pairmiss_exp,miss_labels=addmiss,popnames=mysambar$populations,mybreaks=my_Breaks,n_bins=nrbins,legpos_x=0.1,legpos_y=0.7,leg_cex=legendcex,matcol="orange",plotprefix=paste("Pairwise_miss_exp",plotlabel,sep="."),currentdir=TRUE,perpop=FALSE)
		if(!silent){cat("Plotting expected 2...",sep="\n")}
		plot_indmatrix(export=exporttype,indsfilter=TRUE,plottitle="Missing data deviation",inputvalues=missdf$diff,miss_labels=addmiss,popnames=mysambar$populations,mybreaks=my_Breaks,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plotprefix=paste("Pairwise_miss_deviation",plotlabel,sep="."),currentdir=TRUE,perpop=FALSE)
		}
	# scatterplot pairwise miss:
	if(!silent){cat("Plotting batcheffect...",sep="\n")}
	plotbatcheffects(export=exporttype,dothin=TRUE,mydf=missdf)
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	if(!silent){cat("Generation Batch effect matrix...",sep="\n")}
	#batcheffectmat()
	}
	
batcheffectmat<-function()
	{
	missdf			<- mysambar$missdf
	missdf$reldiff	<- missdf$diff/(missdf$pairmiss_exp)
	popnames		<- unique(c(as.vector(missdf$subpop1),as.vector(missdf$subpop2)))
	combitable		<- combn(popnames,m=2)
	#
	missdf$subpop1	<- as.character(missdf$subpop1)
	missdf$subpop2	<- as.character(missdf$subpop2)
	#
	# between pop comparisons:
	betweenvec		<- rep(NA,ncol(combitable))
	for (i in c(1:ncol(combitable)))
		{
		pop1		<- combitable[1,i]	
		pop2		<- combitable[2,i]	
		mytempdf	<- missdf[(missdf$subpop1==pop1&missdf$subpop2==pop2)|(missdf$subpop2==pop1&missdf$subpop1==pop2),]
		#betweenvec[i]<- mean(abs(mytempdf$diff),na.rm=TRUE) 
		betweenvec[i]<- mean(abs(mytempdf$reldiff),na.rm=TRUE) 
		}
	# within pop comparisons:
	withinvec		<- rep(NA,length(popnames))
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mytempdf	<- missdf[(missdf$subpop1==mypop&missdf$subpop2==mypop),]
		#withinvec[i]<- mean(abs(mytempdf$diff),na.rm=TRUE)
		withinvec[i]<- mean(abs(mytempdf$reldiff),na.rm=TRUE)
		}
	b							<<- matrix(1,nrow=length(popnames),ncol=length(popnames))
	b[lower.tri(b, diag=FALSE)] <<- betweenvec
	b							<<- t(b)
	b[lower.tri(b, diag=FALSE)] <<- 0
	diag(b)						<<- withinvec
	colnames(b)					<<- popnames
	rownames(b)					<<- popnames
	}

# 27-04-2021:
# depends on calcpi and plotfst 
popmeandxy<-function(do_overwrite=FALSE,nrsites=NULL)
	{
	if(is.null(mysambar$tajdlist_meta)|do_overwrite)
		{
		cat("Generating pairwise distance scores...",sep="\n")
		calcpi(pi_per_pop=FALSE)
		}
	pidf				<- mysambar$tajdlist_meta[[1]]
	pidf$poppair		<- ifelse(pidf$pop1<pidf$pop2,paste(pidf$pop1,pidf$pop2,sep="_"),paste(pidf$pop2,pidf$pop1,sep="_"))
	pidf2				<- pidf[pidf$pop1!=pidf$pop2,]
	meandxy 			<- aggregate(pidf2$ndiffpersite,by=list(pidf2$poppair),FUN=mean,na.rm=TRUE)
	colnames(meandxy)	<- c("poppair","dxy")
	meandxy$pop1		<- sapply(strsplit(meandxy$poppair,"_"),"[",1)
	meandxy$pop2		<- sapply(strsplit(meandxy$poppair,"_"),"[",2)
	if(!is.null(nrsites))
		{
		meandxy$dxy_allsites	<- meandxy$dxy*nrow(snps)/nrsites
		dxyvec					<- meandxy$dxy_allsites
		}else{
		dxyvec					<- meandxy$dxy
		}
	mysambar$meandxy	<<- meandxy
	#
	cat("Exporting matrices with mean Dxy values...",sep="\n")
	plotfst(popnames=mysambar$populations,export="eps",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	plotfst(popnames=mysambar$populations,export="png",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	plotfst(popnames=mysambar$populations,export="pdf",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	plotfst(popnames=mysambar$populations,export="wmf",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	}

dxystripchart<-function(dxydf=mysambar$dxy,export=NULL,addylabel=TRUE,logy=FALSE,mycex=1.75,mytitle=NULL,plotlabel=NULL,ymax=NULL,plotwidth=6)
	{
	popcols			<- mysambar$colorder
	popnames		<- mysambar$poporder
	dxydf			<- droplevels(dxydf[dxydf$bool1&dxydf$bool2&as.character(dxydf$ind1)!=as.character(dxydf$ind2),])
	dxydf$poporder	<- factor(dxydf$pop1,levels=mysambar$poporder)
	npops			<- length(popnames)
	if(!is.null(export))
		{
		myheight=0.25
		myheight2=75
		mylabel	<- ifelse(is.null(plotlabel),"boxplot",paste("boxplot",plotlabel,sep="."))
		if(export=="eps"){postscript(paste("Dxy_pop",mylabel,"eps",sep="."),family=mysambar$myfont,height=npops*myheight+2,width=plotwidth)}
		if(export=="pdf"){pdf(paste("Dxy_pop",mylabel,"pdf",sep="."),family=mysambar$myfont,height=npops*myheight+2,width=plotwidth)}
		if(export=="png"){png(paste("Dxy_pop",mylabel,"png",sep="."),family=mysambar$myfont,height=npops*myheight2+200,width=plotwidth*100)}
		if(export=="wmf"){win.metafile(paste("Dxy_pop",mylabel,"wmf",sep="."),family=mysambar$myfont,height=npops*myheight+2,width=plotwidth)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=3)
	if(is.null(ymax))
		{
		y_lim	<- c(0,1.025*max(dxydf$dxy2[dxydf$bool1&dxydf$bool2],na.rm=TRUE))
		}else{
		y_lim	<- c(0,ymax)
		}
	boxplot(dxydf$dxy2~dxydf$poporder,border="white",col="white",las=1,xlab="",ylab="",horizontal=TRUE,cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim,yaxt='n')
	#axis(2); axis(1, labels = NA); box()
	mtext(popnames,at=1:npops,side=2,line=0.5,col=popcols,las=1,cex=1.75)
	for(j in c(1:npops))
		{
		mypop		<- as.character(popnames[j])
		#cat(mypop,sep="\n")
		popdxy		<- dxydf[as.character(dxydf$pop2)==mypop,]
		mycolour	<- popcols[j]
		#cat(mycolour,sep="\n")
		stripchart(dxy2~poporder,data=popdxy,vertical=FALSE,method="jitter",pch=16,cex=mycex,col=mycolour,bg="bisque",add=TRUE)
		}
	if(addylabel)
		{	
		#mtext(side=2,"Proportion missing data",line=3.75,cex=2)
		mtext(side=1,"Dxy (%)",line=0.75,cex=2.25,outer=TRUE,las=0)
		}
	if(!is.null(mytitle))
		{
		mtext(side=3,mytitle,cex=2,line=0.25)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.5)
	if(!is.null(export)){dev.off()}
	}

indscatter<-function(export=NULL,plotname="Lroh_vs_Nroh",xscore="nroh",yscore="lroh",xlabel="Number of ROHs",ylabel="Total ROH length (Mb)",legendpos="topleft",yline=5.5)
	{
	ind		<- dwd$ind
	popinfo			<- dwd$popinfo
	mypops			<- as.character(popinfo$pop)
	mycolours		<- as.character(popinfo$popcol)
	#
	inputdf			<- ind[,c(xscore,yscore)]
	colnames(inputdf)<- c("xscore","yscore")
	#
	xmax			<- max(inputdf$xscore)
	ymax			<- max(inputdf$yscore)
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,8.5,2.5,0.5),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(inputdf$xscore,inputdf$yscore,pch=16,col=as.character(ind$popcol),xlim=c(0,xmax),ylim=c(0,ymax),cex=3,xlab=xlabel,ylab="",las=1)
	mtext(side=2,line=yline,ylabel,cex=3)
	legend(legendpos,legend=mypops,bty='n',fill=mycolours,cex=2.5)
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# cladedxy(excludepops=c("polar","Black","Himalaya","Syrian","Amur"))
cladedxy<-function(export=NULL,excludepops=NULL,plotlabel=NULL,ymax=NULL,pairorder=NULL,dxy=mysambar$dxy)
	{
	if(!"clade1"%in%colnames(dxy)|!"clade2"%in%colnames(dxy))
		{
		return(cat("ERROR: columns 'clade1' and/or 'clade2' are missing. Rerun the nrmismatch() function with the flag addclade set to TRUE.",sep="\n"))
		}
	dxy$cladepair	<- ifelse(dxy$clade1<dxy$clade2,paste(dxy$clade1,dxy$clade2,sep="_"),paste(dxy$clade2,dxy$clade1,sep="_"))
	dxy$sameclade	<- dxy$clade1==dxy$clade2
	if(!is.null(excludepops))
		{
		dxy2		<- dxy[!(dxy$pop1%in%excludepops)&!(dxy$pop2%in%excludepops),]
		}else{
		dxy2		<- dxy
		}
	#
	dxy2$cladepair[dxy2$sameclade]	<- "within"
	dxy2							<- droplevels(dxy2)	
	if(!is.null(pairorder))
		{
		dxy2$pairorder				<- factor(dxydf$cladepair,levels=pairorder)
		}else{
		dxy2$pairorder				<- dxy2$cladepair
		}
	mypairs							<- unique(dxy2$cladepair)
	npairs							<- length(mypairs)
	#
	#tempdxy				<- dxy1[!duplicated(dxy1$poppair),]
	#tempdxy				<- tempdxy[order(tempdxy$poppair),]
	#between$cladecol1	<- tempdxy$cladecol1
	#between$cladecol2	<- tempdxy$cladecol2
	#
	if(!is.null(export))
		{
		myheight=0.25
		myheight2=75
		mylabel	<- ifelse(is.null(plotlabel),"between",paste("between",plotlabel,sep="."))
		if(export=="eps"){postscript(paste("Dxy_clade",mylabel,"eps",sep="."),family=mysambar$myfont,height=npairs*myheight+2,width=6)}
		if(export=="pdf"){pdf(paste("Dxy_clade",mylabel,"pdf",sep="."),family=mysambar$myfont,height=npairs*myheight+2,width=6)}
		if(export=="png"){png(paste("Dxy_clade",mylabel,"png",sep="."),family=mysambar$myfont,height=npairs*myheight2+200,width=600)}
		if(export=="wmf"){win.metafile(paste("Dxy_clade",mylabel,"wmf",sep="."),family=mysambar$myfont,height=npairs*myheight+2,width=6)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=3)
	if(is.null(ymax))
		{
		y_lim	<- c(0.975*min(dxy2$dxy2[!dxy2$sameclade],na.rm=TRUE),1.025*max(dxy2$dxy2,na.rm=TRUE))
		}else{
		y_lim	<- c(0,ymax)
		}
	boxplot(dxy2$dxy2~dxy2$pairorder,border="grey50",col="grey80",las=1,xlab="",ylab="",horizontal=TRUE,cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim,yaxt='n')
	mtext(mypairs,at=1:npairs,side=2,line=0.5,col="black",las=1,cex=1.75)
	}

importdxydata<-function(myfile="allvcfdist.noheaders.txt",haploid=FALSE,error_rate=0.0001,mut_rate=1.2*10^-8,gen_time=8)
	{
	# Expects to find in the working directory the file 'vcfdist.txt' file generated with the 'VCF_calcdist.sh' script.
	# Error rate for y chromosome: 1*10^-4
	# Error rate for autosomes (diploid): 0.7*10^-5
	cat("Importing data...",sep="\n")
	if(!file.exists(myfile))
		{
		return(cat("ERROR: file specified to the 'myfile' flag does not exist.",sep="\n"))
		}
	x			<- read.table(myfile,header=TRUE)
	x			<- x[order(x$ind1,x$ind2),]
	if(haploid)
		{
		cat("Haploid data.",sep="\n")
		x$dxy			<- ifelse(x$name1!=x$name2,ifelse(x$n0+x$n1!=0,x$n1/(x$n0+x$n1)*100,NA),0)
		x$he		 	<- 0
		x$exp_nerror 	<- ifelse(x$name1!=x$name2,ifelse(x$n0+x$n1!=0,round((x$n0+x$n1)*error_rate),NA),0)
		x$dxy_corrected	<- ifelse(x$name1!=x$name2,ifelse(x$n0+x$n1!=0,(x$n1-x$exp_nerror)/(x$n0+x$n1)*100,NA),0)
		x$tmrca_g		<- (1/100*x$dxy_corrected)/(2*mut_rate)
		x$tmrca_y		<- x$tmrca_g*gen_time
		}else{
		cat("Diploid data.",sep="\n")
		x$dxy	<- (x$n1*0.5+x$n2he*0.5+x$n2ho)/(x$n0+x$n1+x$n2he+x$n2ho)*100
		x$he	<- x$n2he/(x$n2he+x$n0)
		}
	x$dxy2		<- x$dxy
	x$dxy3		<- x$dxy
	cat("Extracting information from inds dataframe...",sep="\n")
	y			<- inds[,c("name","pop","clade","popcol","cladecol","filter","longitude3","latitude")]
	colnames(y)	<- c("name1","pop1","clade1","popcol1","cladecol1","bool1","long1","lat1")
	x			<- merge(x,y,by="name1")
	colnames(y)	<- c("name2","pop2","clade2","popcol2","cladecol2","bool2","long2","lat2")
	x			<- merge(x,y,by="name2")
	x			<- x[order(x$ind1,x$ind2),]
	x$poppair	<- ifelse(as.character(x$pop1)<as.character(x$pop2),paste(x$pop1,x$pop2,sep="_"),paste(x$pop1,x$pop2,sep="_"))
	x$long		<- abs(x$long2-x$long1)
	x$lat		<- abs(x$lat2-x$lat1)
	x$geodist	<- sqrt(x$long^2+x$lat^2)
	mydistdf	<<- x
	cat("Results saved in dataframe object called 'mydistdf'.",sep="\n")
	}

dxyhisto<-function(mydf=mydistdf,pairdf=NULL,export=NULL,mybreaks=seq(-1,10000,500),xmax=70000,plotwidth=8,ymax=0.15,legendpos="topright",plotname="Dxy_histo",silent=TRUE,per_year=TRUE,mycolours=NULL)
	{
	if(is.null(mycolours))
		{
		mycolours	<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
		}
	if(is.null(pairdf))
		{
		return(cat("ERROR: provide a dataframe with the columns pop1 and pop2, listing the population pairs you want to plot.",sep="\n"))
		}
	npairs		<- nrow(pairdf)
	myscore		<- ifelse(per_year,mydf$tmrca_y/1000,mydf$tmrca_g/1000)
	if(max(myscore,na.rm=TRUE)>max(mybreaks))
		{
		return(cat("ERROR: mybreaks do not span entire range.",sep="\n"))
		}
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=plotwidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=plotwidth,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=plotwidth*90,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=plotwidth,height=8)} 
		}
	# outline of plot:
	par(mar=c(6,7,2,2),cex.axis=2,cex.lab=2.5)
	hist(myscore,breaks=mybreaks/1000,xlim=c(0,xmax/1000),freq=TRUE,col="white",border=NA,ylim=c(0,ymax),xlab="",ylab="",main="",las=2)
	mtext(side=1,"Y-chrom TMCRA (kya)",line=4.5,cex=2.5)
	mtext(side=2,"Sample pair frequency",line=4.75,cex=2.5)
	# add LGM:
	if(per_year)
		{
		rect(xleft=18000/1000,ybottom=0,xright=32000/1000,ytop=1,border="grey70",col="grey70")
		text(x=25000/1000,y=ymax*0.975,"LGM",cex=2.25)
		}
	#
	allsubdf	<- list()
	for(k in c(1:npairs))
		{
		cat(k,sep="\n")
		pop1		<- as.character(pairdf[k,1])
		pop2		<- as.character(pairdf[k,2])
		if(!silent){cat(pop1,sep="\n")}
		if(!silent){cat(pop2,sep="\n")}
		subdf		<- droplevels(mydf[(as.character(mydf$pop1)==pop1&as.character(mydf$pop2)==pop2)|(as.character(mydf$pop2)==pop1&as.character(mydf$pop1)==pop2),])
		subdf		<- subdf[subdf$bool1&subdf$bool2,]
		allsubdf[[k]]	<- subdf
		popcol1		<- as.character(subdf$popcol1[1])
		popcol2		<- as.character(subdf$popcol2[2])
		if(per_year)
			{
			myscore		<- subdf$tmrca_y/1000
			}else{
			myscore		<- subdf$tmrca_g/1000
			}
		mydensity	<- density(myscore,na.rm=TRUE)
		lines(mydensity$x,mydensity$y,col=popcol1,lwd=7)
		lines(mydensity$x,mydensity$y,col=popcol2,lwd=7,lty=2)
		}
	# mask negative:
	rect(-50000,-ymax/1000,0,ymax/1000,col="white",border="white")	
	# legend:
	alldf 	<- do.call("rbind",allsubdf)
	mypops	<- data.frame("pop"=c(as.character(alldf$pop1),as.character(alldf$pop2)),"popcol"=c(as.character(alldf$popcol1),as.character(alldf$popcol2)))
	mypops	<- mypops[order(mypops$pop),]
	mypops	<- mypops[!duplicated(mypops$pop),]
	legend(legendpos,legend=mypops$pop,bty='n',fill=as.character(mypops$popcol),cex=2.5,border=as.character(mypops$popcol))
	if(!is.null(export))
		{
		dev.off()
		cat("Histograms showing genome wide scores per sample has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}



# dxyfac(excludepops=c("polar","Black"))
dxyfac<-function(dxy=mysambar$dxy,doclades=FALSE,excludepops=NULL,dobetween=TRUE,dowithin=FALSE,export=NULL,plotname="Dxy_vs_dist",addlines=NULL,usecladecol=FALSE,plottitle=NULL,mylinemat=NULL,mycex=3,myxlim=NULL,axiscex=2,labcex=2.5,maincex=3,xline=4,yline=4.75,addlegend=TRUE,legendpos="topleft",legend2pos="bottomright",legendcex=2,vline=NULL,xlabel="Distance (degrees)",ylabel="Dxy (%)",addregression=TRUE)
	{
	if(usecladecol&(!"clade1"%in%colnames(dxy)|!"clade2"%in%colnames(dxy)))
		{
		return(cat("ERROR: columns 'clade1' and/or 'clade2' are missing. Rerun the nrmismatch() function with the flag addclade set to TRUE, or alternatively rerun the dxyfac function with the flag usecladecol set to FALSE.",sep="\n"))
		}
	if(!"bool1"%in%colnames(dxy)|!"bool2"%in%colnames(dxy))
		{
		return(cat("ERROR: columns 'bool1' and/or 'bool2' are missing.",sep="\n"))
		}
	dxy				<- dxy[dxy$bool1&dxy$bool2,]
	dxy$cladepair	<- paste(dxy$clade1,dxy$clade2,sep="_")
	dxy$poppair		<- paste(dxy$pop1,dxy$pop2,sep="_")
	dxy$sameclade	<- dxy$clade1==dxy$clade2
	dxy$samepop		<- dxy$pop1==dxy$pop2	
	if(!is.null(excludepops))
		{
		mybool		<- !(dxy$pop1%in%excludepops)&!(dxy$pop2%in%excludepops)
		#mybool		<- (!dxy$pop1%in%c("polar","Black"))&(!dxy$pop2%in%c("polar","Black"))
		#mybool		<- (!dxy$pop1%in%c("polar","Black","Syrian","Himalaya","Amur"))&(!dxy$pop2%in%c("polar","Black","Syrian","Himalaya","Amur"))
		dxy2		<- dxy[mybool,]
		}else{
		mybool		<- TRUE
		dxy2		<- dxy
		}
	#
	if(dowithin&!dobetween)
		{
		# within:
		dxy1			<- dxy[mybool&dxy$samepop,c("geodist","dxy3","pop1","pop2","popcol1","popcol2")]
		agg1 			<- aggregate(dxy1$dxy3,by=list(dxy1$pop1),FUN=mean,na.rm=TRUE)
		colnames(agg1)	<- c("pop","dxy")
		agg2 			<- aggregate(dxy1$geodist,by=list(dxy1$pop1),FUN=mean,na.rm=TRUE)
		colnames(agg2)	<- c("pop","dist")
		agg3 			<- aggregate(dxy1$popcol1,by=list(dxy1$pop1),FUN=unique)
		colnames(agg3)	<- c("pop","popcol")
		#
		within			<- data.frame("pop"=agg1$pop,"dxy"=agg1$dxy,"dist"=agg2$dist,"popcol"=agg3$popcol)
		plot(within$dist,within$dxy,cex=3,pch=16,col=as.character(within$popcol),log="x")
		}
	if(dobetween)
		{
		if(dowithin)
			{
			dxy1		<- dxy[mybool,c("geodist","dxy3","poppair","pop1","pop2","popcol1","popcol2","clade1","clade2","cladecol1","cladecol2")]
			}else{
			dxy1		<- dxy[mybool&(!dxy$samepop),c("geodist","dxy3","poppair","pop1","pop2","popcol1","popcol2","clade1","clade2","cladecol1","cladecol2")]
			}
		agg1 			<- aggregate(dxy1$dxy3,by=list(dxy1$poppair),FUN=mean,na.rm=TRUE)
		colnames(agg1)	<- c("poppair","dxy")
		agg2 			<- aggregate(dxy1$geodist,by=list(dxy1$poppair),FUN=mean,na.rm=TRUE)
		colnames(agg2)	<- c("poppair","dist")
		agg3 			<- aggregate(dxy1$popcol1,by=list(dxy1$poppair),FUN=unique)
		colnames(agg3)	<- c("poppair","popcol1")
		agg4 			<- aggregate(dxy1$popcol2,by=list(dxy1$poppair),FUN=unique)
		colnames(agg4)	<- c("poppair","popcol2")
		between			<- data.frame("pop"=agg1$poppair,"dxy"=agg1$dxy,"dist"=agg2$dist,"popcol1"=agg3$popcol,"popcol2"=agg4$popcol2)
		#
		tempdxy				<- dxy1[!duplicated(dxy1$poppair),]
		tempdxy				<- tempdxy[order(tempdxy$poppair),]
		between$cladecol1	<- tempdxy$cladecol1
		between$cladecol2	<- tempdxy$cladecol2
		dxybetween			<<- between
		#
		if(!is.null(export))
			{
			plotname	<- ifelse(usecladecol,paste(plotname,"cladecol",sep="_"),paste(plotname,"popcol",sep="_"))
			legendlabel	<- ifelse(addlegend,"WITHlegend","NOlegend")
			if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
			if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
			if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
			}
		par(mar=c(5.5,6.5,3,0.25),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex)	
		if(!usecladecol)
			{
			if(is.null(myxlim))
				{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$popcol1),col=as.character(between$popcol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,main=plottitle)
				}else{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$popcol1),col=as.character(between$popcol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
				}
			if(!is.null(addlines)){abline(h=addlines,lty=2,col="grey50")}
			#if(length(mysambar$populations)==19)
			#	{
			#	legend("top",legend=mysambar$populations[c(14:17,19,18)],bty='n',fill=mysambar$mycolours[c(14:17,19,18)],cex=1.5)
			#	legend("topleft",legend=mysambar$populations[1:13],bty='n',fill=mysambar$mycolours[1:13],cex=1.5)
			#	}else{
				if(addlegend){legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)}
				#legend(legendpos,legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=1.5)
				#legend(legendpos,legend=unique(c(as.character(mydf$pop1),as.character(mydf$pop2))),bty='n',fill=unique(c(as.character(mydf$popcol1),as.character(mydf$popcol2))),cex=2)
			#	}
			}else{
			if(is.null(myxlim))
				{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$cladecol1),col=as.character(between$cladecol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,main=plottitle)
				}else{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$cladecol1),col=as.character(between$cladecol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
				}
			if(!is.null(addlines)){abline(h=addlines,lty=2,col="grey50")}
			#legend(legendpos,legend=c("Syrian","Himalaya","Eurasia-west","Eurasia-east","Amur","Alaska","Westcoast"),bty='n',fill=c("indianred1","orangered1","darkred","midnightblue","mediumpurple1","darkgreen","greenyellow"),cex=2)
			if(addlegend){legend(legendpos,legend=unique(as.character(dxy$clade1)),bty='n',fill=unique(as.character(dxy$cladecol1)),border=unique(as.character(dxy$cladecol1)),cex=legendcex)}
			}
		if(!is.null(mylinemat))
			{
			cat("Adding lines...",sep="\n")
			for (k in c(1:nrow(mylinemat)))
				{
				lines(c(mylinemat[k,1],mylinemat[k,2]),c(mylinemat[k,3],mylinemat[k,4]),lwd=3)
				}
			}
		mtext(side=1,line=xline,xlabel,cex=labcex)
		mtext(side=2,line=yline,ylabel,cex=labcex)
		#if(!is.null(plottitle))
		#	{
		#	mtext(side=3,line=0.5,plottitle,cex=3.5)
		#	}
		#
		# regression:
		if(addregression)
			{
			mydata		<- between[,c("dist","dxy")] 
			myfit		<<- lm(dxy ~ log10(dist),data=mydata)
			abline(myfit,lty=2,lwd=3)
			myfit2		<<- summary(myfit)
			myr			<<- round(myfit2$r.squared,3)
			myp			<<- round(myfit2$coefficients[2,4],4)
			legend(legend2pos,legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
			}
		#wdata		<- between[between$cladecol1==between$cladecol2&between$dist>5,c("dist","dxy")] 
		#wfit		<<- lm(dxy ~ log10(dist),data=wdata)
		#abline(wfit,lty=2,lwd=3)
		#
		#bdata		<- between[between$cladecol1!=between$cladecol2&between$dist>5,c("dist","dxy")] 
		#bfit		<<- lm(dxy ~ log10(dist),data=bdata)
		#abline(bfit,lty=2,lwd=3)
		#
		if(!is.null(vline))
			{
			abline(v=vline,lty=2,col="grey80")	
			}
		#
		if(!is.null(export))
			{
			dev.off()
			cat("Scatterplot has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	#
	if(doclades)
		{
		# between clades:
		dxy1			<- dxy[mybool&(!dxy$sameclade),c("geodist","dxy3","clade1","clade2","cladecol1","cladecol2")]
		dxy1$cladepair	<- paste(dxy1$clade1,dxy1$clade2,sep="_")
		agg1 			<- aggregate(dxy1$dxy3,by=list(dxy1$cladepair),FUN=mean,na.rm=TRUE)
		colnames(agg1)	<- c("cladepair","dxy")
		agg2 			<- aggregate(dxy1$geodist,by=list(dxy1$cladepair),FUN=mean,na.rm=TRUE)
		colnames(agg2)	<- c("cladepair","dist")
		agg3 			<- aggregate(dxy1$cladecol1,by=list(dxy1$cladepair),FUN=unique)
		colnames(agg3)	<- c("cladepair","cladecol1")
		agg4 			<- aggregate(dxy1$cladecol2,by=list(dxy1$cladepair),FUN=unique)
		colnames(agg4)	<- c("cladepair","cladecol2")
		clade			<- data.frame("cladepair"=agg1$cladepair,"dxy"=agg1$dxy,"dist"=agg2$dist,"cladecol1"=agg3$cladecol1,"cladecol2"=agg4$cladecol2)
		plot(clade$dist,clade$dxy,pch=21,bg=as.character(clade$cladecol1),col=as.character(clade$cladecol2),cex=mycex,lwd=3,log="x")
		legend("topleft",mysambar$populations,fill=mysambar$mycolours,bty='n',cex=2.5)
		}
	}

makemanteldf<-function(addclade=TRUE,docalc=TRUE,onlybetween=FALSE,onlywithin=FALSE,dofst=TRUE)
	{
	if(docalc&dofst){runWrightFst()}
	if(docalc&!dofst){pop_neimatrix()}
	if(dofst)
		{
		myscore		<- mysambar$Wrightfstvector
		}else{
		myscore		<- mysambar$popneivector
		}
	mydf				<- data.frame("pop1"=mysambar$pairpop1,"pop2"=mysambar$pairpop2,"popdist"=myscore,"long"=NA,"lat"=NA,"cladecol1"=NA,"cladecol2"=NA,"popcol1"=NA,"popcol2"=NA)
	npairs				<- nrow(mydf)
	for(i in c(1:npairs))
		{
		pop1			<- as.character(mydf$pop1[i])
		pop2			<- as.character(mydf$pop2[i])
		#
		# geographical distance:
		long1			<- mean(inds$longitude3[as.character(inds$pop)==pop1],na.rm=TRUE)
		long2			<- mean(inds$longitude3[as.character(inds$pop)==pop2],na.rm=TRUE)
		lat1			<- mean(inds$latitude[as.character(inds$pop)==pop1],na.rm=TRUE)
		lat2			<- mean(inds$latitude[as.character(inds$pop)==pop2],na.rm=TRUE)
		mydf$long[i]	<- abs(long2-long1)
		mydf$lat[i]	<- abs(lat2-lat1)
		if(addclade)
			{
			mydf$clade1[i]		<- unique(inds$clade[as.character(inds$pop)==pop1])[1]
			if(length(unique(inds$clade[as.character(inds$pop)==pop1]))>1){cat(paste("WARNING: more than 1 clade defined for population ",pop1,".",sep=""),sep="\n")}
			mydf$clade2[i]		<- unique(inds$clade[as.character(inds$pop)==pop2])[1]
			if(length(unique(inds$clade[as.character(inds$pop)==pop2]))>1){cat(paste("WARNING: more than 1 clade defined for population ",pop2,".",sep=""),sep="\n")}
			mydf$cladecol1[i]	<- unique(inds$cladecol[as.character(inds$pop)==pop1])[1]
			if(length(unique(inds$cladecol[as.character(inds$pop)==pop1]))>1){cat(paste("WARNING: more than 1 cladecol defined for population ",pop1,".",sep=""),sep="\n")}
			mydf$cladecol2[i]	<- unique(inds$cladecol[as.character(inds$pop)==pop2])[1]
			if(length(unique(inds$cladecol[as.character(inds$pop)==pop2]))>1){cat(paste("WARNING: more than 1 clade defined for population ",pop2,".",sep=""),sep="\n")}
			mydf$popcol1[i]		<- unique(inds$popcol[as.character(inds$pop)==pop1])[1]
			if(length(unique(inds$popcol[as.character(inds$pop)==pop1]))>1){cat(paste("WARNING: more than 1 popcol defined for population ",pop1,".",sep=""),sep="\n")}
			mydf$popcol2[i]		<- unique(inds$popcol[as.character(inds$pop)==pop2])[1]
			if(length(unique(inds$popcol[as.character(inds$pop)==pop2]))>1){cat(paste("WARNING: more than 1 popcol defined for population ",pop2,".",sep=""),sep="\n")}
			}
		}
	mydf$geodist		<- sqrt(mydf$long^2+mydf$lat^2) 
	if(dofst)
		{
		mydf$popdist	<- mydf$popdist/(1-mydf$popdist)
		}
	mydf$cladepair		<- ifelse(mydf$clade1<mydf$clade2,paste(mydf$clade1,mydf$clade2,sep="_"),paste(mydf$clade2,mydf$clade1,sep="_"))
	if(onlybetween)
		{
		mydf			<- mydf[mydf$clade1!=mydf$clade2,]
		}
	if(onlywithin)
		{
		mydf			<- mydf[mydf$clade1==mydf$clade2,]
		}
	#mydf				<- mydf[mydf$cladepair=="Eastern_NewWorld",]
	#mydf				<- mydf[mydf$cladepair=="Eastern_Western"|mydf$cladepair=="Eastern_Eastern"|mydf$cladepair=="Western_Western"|mydf$cladepair=="Central_Western"|mydf$cladepair=="Central_Eastern",]
	mydf				<- mydf[mydf$cladepair=="NewWorld_NewWorld"|mydf$cladepair=="Eastern_Western"|mydf$cladepair=="Alaska_Eastern"|mydf$cladepair=="Alaska_Western"|mydf$cladepair=="Eastern_Eastern"|mydf$cladepair=="Western_Western",]
	popdistdf			<<- mydf
	}

plotmantel<-function(mydf=popdistdf,export=NULL,usecladecol=FALSE,myxlim=NULL,legendpos="bottomright",plotname="Fst_vs_dist",xlabel="Distance (degrees)",ylabel="Fst/(1-Fst)",legendcex=2)
	{
	if(!is.null(export))
		{
		plotname	<- ifelse(usecladecol,paste(plotname,"cladecol",sep="_"),paste(plotname,"popcol",sep=""))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(7,6.5,2.5,0.25),cex.axis=2,cex.lab=2.5,cex.main=3)	
	if(!usecladecol)
		{
		if(is.null(myxlim))
			{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=3,lwd=4,xlab="",ylab="",las=2)
			}else{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=3,lwd=4,xlab="",ylab="",las=2,xlim=myxlim)
			}
		#legend(legendpos,legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=1.5)
		legend(legendpos,legend=unique(c(as.character(mydf$pop1),as.character(mydf$pop2))),bty='n',fill=unique(c(as.character(mydf$popcol1),as.character(mydf$popcol2))),cex=2)
		}else{
		mybg		<- ifelse(mydf$clade1<mydf$clade2,mydf$cladecol1,mydf$cladecol2)
		mycol		<- ifelse(mydf$clade1<mydf$clade2,mydf$cladecol2,mydf$cladecol1)
		if(is.null(myxlim))
			{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=mybg,col=mycol,cex=3,lwd=4,xlab="",ylab="",las=2)
			}else{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=mybg,col=mycol,cex=3,lwd=4,xlab="",ylab="",las=2,xlim=myxlim)
			}
		#legend(legendpos,legend=c("Syrian","Himalaya","Eurasia-west","Eurasia-east","Amur","Alaska","Westcoast"),bty='n',fill=c("indianred1","orangered1","darkred","midnightblue","mediumpurple1","darkgreen","greenyellow"),cex=2)
		legend(legendpos,legend=unique(as.character(mydf$clade1)),bty='n',fill=unique(as.character(mydf$cladecol1)),cex=2)
		}
	mtext(side=1,line=4.5,xlabel,cex=2.75)
	mtext(side=2,line=4.5,ylabel,cex=2.75)
	#
	# regression:
	mydata		<- mydf[,c("geodist","popdist")] 
	myfit		<<- lm(popdist ~ geodist,data=mydata)
	abline(myfit,lty=2,lwd=2)
	myfit2		<<- summary(myfit)
	myr			<<- round(myfit2$r.squared,2)
	myp			<<- round(myfit2$coefficients[2,4],4)
	legend("topleft",legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
	#
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

nrmismatch<-function(nrsites=NULL,haploid=FALSE,addclade=FALSE)
	{
	ninds		<- nrow(inds)
	myinds		<- as.character(inds$name)
	mypops		<- as.character(inds$pop)
	mynr		<- as.character(inds$nr)
	mybool		<- inds$filter
	mycol		<- inds$popcol
	mydf		<- data.frame("ind1"=rep(myinds,each=ninds),"ind2"=rep(myinds,times=ninds),"nr1"=rep(mynr,each=ninds),"nr2"=rep(mynr,times=ninds),"pop1"=rep(mypops,each=ninds),"pop2"=rep(mypops,times=ninds),"bool1"=rep(mybool,each=ninds),"bool2"=rep(mybool,times=ninds),"popcol1"=rep(mycol,each=ninds),"popcol2"=rep(mycol,times=ninds))
	mydf$nsites	<- NA
	mydf$ndiff	<- NA
	mydf$long	<- NA
	mydf$lat	<- NA
	if(addclade)
		{
		mydf$clade1		<- NA
		mydf$clade2		<- NA
		mydf$cladecol1	<- NA
		mydf$cladecol2	<- NA
		}
	#
	npairs	<- nrow(mydf)
	for(i in c(1:npairs))
		{
		ind1			<- as.integer(as.character(mydf$nr1[i]))
		ind2			<- as.integer(as.character(mydf$nr2[i]))
		geno1			<- as.matrix(mygenlight[ind1,])
		geno2			<- as.matrix(mygenlight[ind2,])
		long1			<- inds$longitude3[ind1]
		long2			<- inds$longitude3[ind2]
		lat1			<- inds$latitude[ind1]
		lat2			<- inds$latitude[ind2]
		if(addclade)
			{
			mydf$clade1[i]		<- as.character(inds$clade[ind1])
			mydf$clade2[i]		<- as.character(inds$clade[ind2])
			mydf$cladecol1[i]	<- as.character(inds$cladecol[ind1])
			mydf$cladecol2[i]	<- as.character(inds$cladecol[ind2])
			}
		mybool			<- !is.na(geno1)&!is.na(geno2)
		geno1			<- geno1[mybool]
		geno2			<- geno2[mybool]
		mydf$nsites[i]	<- length(mybool[mybool])
		if(haploid)
			{
			mydf$ndiff[i]	<- length(geno1[geno1!=geno2])
			}else{
			# To avoid that NA is included when stating geno==1, we change NA to 3:
			geno1[is.na(geno1)]	<- 3
			geno2[is.na(geno2)]	<- 3
			## we have 4 combinations of haplotypes between individuals: 
			## If both individuals are homozygous, but for different allele:
			mybool		<- (geno1==0&geno2==2)|(geno1==2&geno2==0)
			ndiff1		<- 4*length(mybool[mybool])
			# If one individual is homozygous and the other heterozygous:
			mybool		<- (geno1==0&geno2==1)|(geno1==2&geno2==1)|(geno1==1&geno2==0)|(geno1==1&geno2==2)
			ndiff2		<- 2*length(mybool[mybool])		
			# If both individuals are heterozygous: 
			mybool		<- geno1==1&geno2==1
			ndiff3		<- 2*length(mybool[mybool])
			## combine:
			mydf$ndiff[i]<- ndiff1+ndiff2+ndiff3
			}
		mydf$long[i]	<- abs(long2-long1)
		mydf$lat[i]		<- abs(lat2-lat1)
		}
	mydf$dxy			<- mydf$ndiff/mydf$nsites
	mydf$geodist		<- sqrt(mydf$long^2+mydf$lat^2) 
	if(!is.null(nrsites))
		{
		mydf$dxy2	<- mydf$ndiff/nrsites*100
		}else{
		mydf$dxy2	<- mydf$dxy*100 
		}
	mydf$dxy3		<- mydf$nsites/max(mydf$nsites,na.rm=TRUE)*mydf$dxy2		# correct for differences in levels of missing data
	mysambar$dxy	<<- mydf
	}

# 15-03-19: new version to calculate pi: 
calcpi<-function(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,samplesize=NULL,mychrom=NULL,myrange=NULL,corrected=FALSE,silent=TRUE)
	{
	# This function calculates pi: the average number of variant sites when randomly drawing 2 sequences from a population.
	## pi is calculated as follows:
	# Say genlight object is as follows (3 individuals, 2 snps):
	# 0 1
	# 2 NA
	# 1 0
	# First NA is converted into 3, because R sometimes counts NA as 1.
	#
	# Second we calculate the number of differences between and within individuals, and take into account that each pairwise (diploid) individual comparison entails 4 haplotype comparisons (AB,Ab,aB,ab)
	# comparison	snp1	snp2	total			meanpairwise
	# ind1-ind2: 	4 + 	NA = 	4		/4 =	1	
	# ind1-ind3: 	2 + 	2 = 	4		/4 =	1
	# ind2-ind3: 	2 + 	NA = 	2		/4 =	0.5
	# ind1: 		0 + 	1 = 	1				1
	# ind2: 		0 + 	NA = 	0				0
	# ind3: 		1 + 	0 = 	1				1
	# total:						12				4.5
	# average:										0.75		
	# So we find that on average 0.75 sites differ between two haplotypes. This is the observed pi. 
	#
	# Third we calculate the number of missing data:
	# comparison	snp1	snp2	total			meanpairwise	meannonmissing
	# ind1-ind2: 	0 + 	4 = 	4		/4 =	1				1
	# ind1-ind3: 	0 + 	0 = 	0		/4 =	0				2
	# ind2-ind3: 	0 + 	4 = 	4		/4 =	1				1
	# ind1: 		0 + 	0 = 	0				0				2
	# ind2: 		0 + 	1 = 	1				1				1
	# ind3: 		0 + 	0 = 	0				0				2
	# total:						9				3				9
	# average:										0.5				1.5		
	# So we find that on average we have data for 1.5 sites per haplotype, rather than for 2 sites.
	# The corrected pi therefore equals: 0.75/2*1.5 = 0.5625 differences per haplotype (of 2 bp length). 
	# The default is to use the corrected pi. Set corrected to FALSE, to use uncorrected pi. 
	#
	# 18-03-2019: I don't understand why the following reasoning doesn't give the same outcomes as above for uncorrected and corrected pi:
	# Total number of differences: 				12
	# Total snp comparisons: 					4*(choose(nind,2))+nind)*nsnp 	= 	15*2 = 30
	# Total number of missing datapoints: 		9
	# Total number of non-missing datapoints:	30-9 = 21
	# Uncorrected pi:							12/30 = 0.4
	# Corrected pi: 							12/21 = 0.5714
	# Just to avoid confusion: this is just a consideration. Not used for actual calculations. 
	#
	# 15-5-2020: Looking again at this, I realize that 0.5714 is the right value, not 0.5625.
	# We have the following differences for within individual comparisons:.
	# SNP1: 0 0 1 
	# SNP2: 1 N 0
	# and for between individual comparisons:
	# SNP1: 1 1 1 1 0 0 1 1 0 0 1 1 
	# SNP2: N N N N 0 0 1 1 N N N N
	# This is 12/21 = 0.5714
	# The reason that the calculation leads to 0.5622 is because it is not correct to give a single 'within-comparison' the same weight as 4 'between-comparisons' 
	## 04-08-2021: NOTE THAT WHEN FLAG CORRECTED IS SET TO TRUE, THE CALCULATION AND THE OUTPUT VALUES ARE SLIGHTLY DIFFERENT; IT ATTEMPTS TO CORRECT FOR MISSING DATA
	#
	## Watterson's estimate of theta is calculated as follows (corrected for missing data):
	# The per snp average number of inds with data:	(3 + 2)/2 = 2.5
	# The average number of haplotypes: 			nind*2 = 2.5*2 = 5 			# 6 haplotypes for first SNP, 4 haplotypes for second SNP
	# n-1: 											5-1 = 4  
	# Number of snps with maf>0 (S):				2 
	# Corrected Watterson's estimate of theta:		S/(sum(1/(1/1+...+1/(n-1))) = 2/(1/1+1/2+1/3+1/4) = 2/2.083 = 0.96
	# This number is telling us that for each pairwise comparison of haplotypes (of 2 bp length) we expect 0.96 sites to differ between both haplotypes.  
	# Uncorrected Watterson's estimate of theta:	2/(1/1+1/2+1/3+1/4+1/5) = 2/2.28 = 0.87  
	#
	## Tajima's D is calculated as follows:
	# Observed uncorrected pi minus corrected Watterson's estimate:
	# Tajima's D: 0.75 - 0.96 = -0.21 
	#
	# I first tried by the way to calculate sliding window with snpR, using the following steps, but that resulted in an ERROR: 
	# options(repos=c(CRAN='http://cran.us.r-project.org'))
	# install_github("hemstrow/snpR")
	# library(snpR)
	# mymatrix	<- as.matrix(mygenlight[inds$filter,snps$filter2])
	# mymatrix	<- cbind(inds$nr[inds$filter],inds$pop[inds$filter],mymatrix)
	# newmat		<- format_snps(mymatrix, ecs=2, output = 1, input_form = "0_geno") 
	# but then I got an ERROR it couldn't find 'm'
	#
	# define which snps to be included in analysis:
	if(is.null(mychrom)&!is.null(myrange)){return(cat("ERROR: not allowed to define a range (myrange flag) without defining chromosome/contig (mychrom flag)",sep="\n"))}
	if(!is.null(mychrom)&!is.null(myrange))	{snpselection	<- snpselection&snps$chr==mychrom&snps$pos>=myrange[1]&snps$pos<=myrange[2]}
	if(!is.null(mychrom)&is.null(myrange))	{snpselection	<- snpselection&snps$chr==mychrom}
	if(!is.null(mychrom)&!is.null(myrange))
		{
		# cat(paste("chrom =",mychrom,sep=" "),sep="\n")
		# cat(paste("range =",myrange,sep=" "),sep="\n")
		nsnps	<- nrow(snps[snps$chr==mychrom&snps$pos>myrange[1]&snps$pos<myrange[2]&snps$filter,])
		if(nsnps<1){return(cat("No snps in specified range.",sep="\n"))}
		}
	# Prepare output table:
	if(pi_per_pop)
		{
		popnames		<- popnames
		}else{
		popnames		<- "metapop"
		}
	npops			<- length(popnames)
	ninds			<- nrow(inds[inds$filter,])
	outmat			<- as.data.frame(matrix(NA,ncol=14,nrow=npops))
	colnames(outmat)<- c("pop","chrom","start","end","mid","mean_nsites","mean_pi","mean_maf","expected_pi","S","harmonic_number","Watterson","TajimaD","sd_pi")
	outmat$pop		<- popnames
	tajdlist		<- list()
	if(!is.null(mychrom)&!is.null(myrange))
		{
		outmat$chrom<- mychrom
		outmat$start<- myrange[1]
		outmat$end	<- myrange[2]
		outmat$mid	<- round(mean(myrange))
		}
	if(!is.null(mychrom)&is.null(myrange))	{outmat$chrom<- mychrom}
	# Run calculation:
	if(any(snpselection))
		{
		mymatrix		<- as.matrix(myinput[,snpselection]) 
		for (p in c(1:npops))
			{
			mypop		<- popnames[p]
			mypopcol	<- mysambar$mycolours[p]
			# cat(mypop,sep="\n")
			if(!pi_per_pop)
				{
				myinds		<- inds$nr[indselection]
				mymaf		<- snps$maf[snpselection]
				}else{
				myinds		<- inds$nr[inds$pop==mypop&indselection]
				mymaf		<- snps[snpselection,paste("maf",mypop,sep="_")]
				}
			if(!is.null(samplesize))
				{
				myinds		<- sample(myinds,samplesize,replace=FALSE)
				}
			## compare haplotypes between individuals (4 possible combinations per pair):
			if(length(myinds)<2)
				{
				cat("Only one retained individual for population:",sep="\n")
				cat(mypop,sep="\n")
				return(cat("Exiting.",sep="\n"))
				}
			combitable	<- combn(myinds,m=2)	
			ndiffvec	<- vector() 
			ndatavec	<- vector()
			nnavec		<- vector()
			for (i in c(1:ncol(combitable)))
				{
				ind1		<- combitable[1,i]
				ind2		<- combitable[2,i]
				geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[ind2,]
				# To avoid that NA is included when stating geno==1, we change NA to 3:
				geno1[is.na(geno1)]	<- 3
				geno2[is.na(geno2)]	<- 3
				## we have 4 combinations of haplotypes between individuals: 
				## If both individuals are homozygous, but for different allele:
				mybool		<- (geno1==0&geno2==2)|(geno1==2&geno2==0)
				ndiff1		<- 4*length(mybool[mybool])
				# If one individual is homozygous and the other heterozygous:
				mybool		<- (geno1==0&geno2==1)|(geno1==2&geno2==1)|(geno1==1&geno2==0)|(geno1==1&geno2==2)
				ndiff2		<- 2*length(mybool[mybool])		
				# If both individuals are heterozygous: 
				mybool		<- geno1==1&geno2==1
				ndiff3		<- 2*length(mybool[mybool])
				## combine:
				ndiffvec[i]	<- ndiff1+ndiff2+ndiff3
				## datapoints:
				mybool		<- (geno1!=3)&(geno2!=3)
				ndata		<- length(mybool[mybool])
				ndatavec[i]	<- ndata
				mybool		<- (geno1==3)|(geno2==3)
				nna			<- 4*length(mybool[mybool])
				nnavec[i]	<- nna
				}
			## compare haplotypes within individuals (1 possible combination per individual:
			nhevec			<- vector() 
			ninddatavec		<- vector()
			nindnavec		<- vector()
			for (i in c(1:length(myinds)))
				{
				myind					<- myinds[i]
				mygeno					<- mymatrix[myind,]
				# To avoid that NA is included when stating mygeno==1, we change NA to 3:
				mygeno[is.na(mygeno)]	<- 3				
				nhevec[i]				<- length(mygeno[mygeno==1]) 
				ninddatavec[i]			<- length(mygeno[mygeno!=3]) 
				nindnavec[i]			<- length(mygeno[mygeno==3]) 
				}
			## store info in dataframe:
			mycomp1					<- as.data.frame(cbind(combitable[1,],combitable[2,],4,ndatavec,nnavec/4,ndatavec*4,nnavec,ndiffvec))
			colnames(mycomp1)		<- c("ind1","ind2","npairwise","nsites","nnasites","ncomp","nnacomp","ndiff")
			mycomp2					<- as.data.frame(cbind(myinds,myinds,1,ninddatavec,nindnavec,ninddatavec,nindnavec,nhevec))
			colnames(mycomp2)		<- c("ind1","ind2","npairwise","nsites","nnasites","ncomp","nnacomp","ndiff")
			mycomp					<- as.data.frame(rbind(mycomp2,mycomp1)) 
			mycomp$ndiffperhaplo	<- round(mycomp$ndiff/mycomp$npairwise,3)
			mycomp$ndiffpersite		<- mycomp$ndiffperhaplo/mycomp$nsites
			mycomp$ndiffpersite[!is.finite(mycomp$ndiffpersite)]	<- NA	
			mycomp$totalsites		<- mycomp$nsites+mycomp$nnasites
			mycomp$pop1				<- mypop
			mycomp$pop2				<- mypop
			mycomp$colour			<- mypopcol
			tajdlist[[p]]			<- mycomp
			# how many individuals (and therefore haplotypes) per snp on average? (Only individuals with non-missing data)
			popmatrix				<- mymatrix[myinds,]
			#popmatrix				<<- popmatrix
			if(is.null(ncol(popmatrix)))
				{
				# counting NA is fine (counting 1's cause problems, because NA's are regarded 1s, but the other way around does not cause problems)
				nind		<- length(popmatrix[is.na(popmatrix)])
				}else{
				nind		<- mean(apply(popmatrix,2,function(x){sum(!is.na(x))}),na.rm=TRUE)
				}
			nhaplotypes		<- 2*nind
			# Number of (segregating) sites:
			nseg			<- length(mymaf[mymaf>0])
			nsitesall		<- length(mymaf)
			# Now we calculate observed pi, watterson's theta, and based on those two numbers Tajima's D:
			outmat[p,6]		<- round(mean(mycomp$nsites,na.rm=TRUE),1)				# nsites with data
			#outmat[p,7]	<- round(mean(mycomp$ndiffperhaplo,na.rm=TRUE),4)		# pi (mean number of differences between 2 sequences)
			uncorrected_pi	<- round(mean(mycomp$ndiffperhaplo,na.rm=TRUE),2)
			#corrected_pi	<- round(uncorrected_pi/nsitesall*outmat[p,6],4)		# edited on 16-5-2020
			corrected_pi	<- round(sum(mycomp$ndiff,na.rm=TRUE)/sum(mycomp$ncomp,na.rm=TRUE),4)	# edited on 16-5-2020. ncomp=nsites*4 (or nsites*1 for within). nsites is totalsites - nnasites  
			outmat[p,7]		<- ifelse(corrected,corrected_pi,uncorrected_pi)
			outmat[p,10]	<- nseg																# segregating sites						
			outmat[p,8]		<- round(mean(mymaf[mymaf>0],na.rm=TRUE),2)							# mean maf of segregating sites
			outmat[p,9]		<- round((2*outmat[p,8]*(1-outmat[p,8])*outmat[p,10]),1)			# expected nucleotide diversity (pi) based on minor allele frequency
			outmat[p,11]	<- round(sum(1/(1:(nhaplotypes-1))),2)								# harmonic number
			outmat[p,12]	<- round(outmat[p,10]/outmat[p,11],2)								# watterson's theta
			outmat[p,13]	<- ifelse(corrected,NA,round(outmat[p,7]-outmat[p,12],2))			# tajima's d
			# added 04-08-2021:
			uncorrected_pisd<- round(sd(mycomp$ndiffperhaplo,na.rm=TRUE),4)
			outmat[p,14]	<- uncorrected_pisd			# not possible to calculate corrected (scaled) value?
			}
		}else{
		outmat$mean_nsites	<- 0
		}
	# add population names and colours:
	if(!pi_per_pop)
		{
		pop_names			<- mysambar$populations
		n_pops				<- length(pop_names)
		mycols				<- mysambar$mycolours[1:n_pops]
		pi_df				<- tajdlist[[1]]
		pi_df$pop1 			<- NA
		pi_df$pop2 			<- NA
		pi_df$colour		<- NA
		for (i in c(1:nrow(pi_df)))
			{
			myindnr1			<- pi_df$ind1[i]
			myindnr2			<- pi_df$ind2[i]
			if(n_pops>1)
				{
				pop1			<- as.vector(inds$pop)[inds$nr==myindnr1]
				pop2			<- as.vector(inds$pop)[inds$nr==myindnr2]
				pi_df$pop1[i]	<- pop1
				pi_df$pop2[i]	<- pop2
				mycol1			<- mycols[which(pop_names==pop1)]
				mycol2			<- mycols[which(pop_names==pop2)]
				mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
				pi_df$colour[i]	<- mycolfunc3(3)[2]
				}else{
				pi_df$colour[i]	<- mycols	
				}
			}
		tajdlist[[1]]	<- pi_df 
		}
	# output tajdlist:
	names(tajdlist)			<- popnames
	if(pi_per_pop)
		{
		mysambar$tajdlist_pop	<<- tajdlist
		}else{
		mysambar$tajdlist_meta	<<- tajdlist		
		}
	if(corrected)
		{
		# edited on 16-5-2020: with new method the estimate is already scaled
		outmat$pi_scaled		<- outmat$mean_pi
		outmat$pi_scaled_sd		<- round(outmat$sd_pi/outmat$mean_nsites,4)
		outmat$mean_pi			<- round(outmat$pi_scaled*outmat$mean_nsites,2)
		}else{
		outmat$pi_scaled		<- round(outmat$mean_pi/outmat$mean_nsites,4)
		outmat$pi_scaled_sd		<- round(outmat$sd_pi/outmat$mean_nsites,4)
		}
	outmat$Watterson_scaled	<- round(outmat$Watterson/outmat$mean_nsites,4)
	if(corrected)
		{
		outmat$TajimaD_scaled	<- round(outmat$pi_scaled-outmat$Watterson_scaled,4)
		outmat$TajimaD			<- round(outmat$TajimaD_scaled*outmat$mean_nsites,2)
		}else{
		outmat$TajimaD_scaled	<- round(outmat$TajimaD/outmat$mean_nsites,4)
		}
	outmat$X2				<- round(((outmat$mean_pi-outmat$Watterson)^2)/outmat$Watterson,2)
	outmat$pvalue			<- round(pchisq(outmat$X2,df=1,lower.tail=FALSE),6)
	outmat$sign				<- ifelse(outmat$pvalue>0.05,"NS",ifelse(outmat$pvalue<0.01,"**","*"))
	outmat$rare_alleles		<- ifelse(outmat$TajimaD< -2,"many_rare",ifelse(outmat$TajimaD>2,"lack_of_rare","neutral"))
	outmat$demography		<- ifelse(outmat$TajimaD< -2,"expansion_after_bottleneck",ifelse(outmat$TajimaD>2,"contraction","neutral"))
	outmat$selection		<- ifelse(outmat$TajimaD< -2,"selective_sweep",ifelse(outmat$TajimaD>2,"balancing","neutral"))	
	if(!is.null(mychrom)&!is.null(myrange))	{tajd			<- outmat}
	if(!is.null(mychrom)&is.null(myrange))	{tajd			<- outmat[,c(1,2,6:24)]}	
	if(is.null(mychrom)&is.null(myrange))	{tajd			<- outmat[,c(1,6:24)]}	
	if(pi_per_pop)
		{
		write.table(tajd,paste(mysambar$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),col.names=TRUE,quote=FALSE,row.names=FALSE,sep="\t")
		cat("Table with summary statistics ('TajimaD.statistics.perpop.txt') has been exported to the Diversity subdirectory.",sep="\n") 
		}else{
		write.table(tajd,paste(mysambar$diversitydir,"TajimaD.statistics.metapop.txt",sep="/"),col.names=TRUE,quote=FALSE,row.names=FALSE,sep="\t")
		cat("Table with summary statistics ('TajimaD.statistics.metapop.txt') has been exported to the Diversity subdirectory.",sep="\n")
		}
	if(!silent)
		{
		cat("Summary table has been written to a dataframe called tajd.",sep="\n")
		cat("All scores for comparisons within and between individuals has been written to a list called tajdlist.",sep="\n")
		}
	if(pi_per_pop)
		{
		myinds							<- inds$nr[inds$filter]
		nsnps							<- nrow(snps)
		ninds							<- nrow(inds[inds$filter,])
		inds$hetero_all2				<<- NA
		# add data heterozygosity to inds dataframe:
		for(i in c(1:ninds))
			{
			myind								<- myinds[i]
			mypop								<- inds$pop[inds$nr==myind]	
			pidf								<- mysambar$tajdlist_pop[[which(names(mysambar$tajdlist_pop)==mypop)]]
			inds$hetero_all2[inds$nr==myind]	<<- pidf$ndiffpersite[pidf$ind1==myind&pidf$ind2==myind]
			}
		# add data pi to inds dataframe:
		inds$pi							<<- NA 
		for(i in c(1:ninds))
			{
			myind						<- myinds[i]
			mypop						<- inds$pop[inds$nr==myind]	
			npoly						<- inds$nsegsites1[inds$nr==myind]
			pidf						<- mysambar$tajdlist_pop[[which(names(mysambar$tajdlist_pop)==mypop)]]
			inds$pi[inds$nr==myind]		<<- mean(pidf$ndiffpersite[(pidf$ind1==myind|pidf$ind2==myind)&!(pidf$ind1==myind&pidf$ind2==myind)],na.rm=TRUE)
			}
		# add autozygosity to inds dataframe:
		inds$autozygosity				<<- 1-inds$hetero_all/inds$pi 
		# add TajimaD scores:
		inds$pi2					<- NA
		inds$pi2sd					<- NA
		inds$harmonic_number		<- NA
		inds$Watterson				<- NA
		inds$TajimaD				<- NA
		inds$pi2_scaled				<- NA
		inds$pi2_scaled_sd			<- NA
		inds$Watterson_scaled		<- NA
		inds$TajimaD				<- NA
		inds$rare_alleles			<- NA
		for (mypop in popnames)
			{
			myselection							<- inds$filter&inds$pop==mypop
			inds$pi2[myselection]				<- tajd$mean_pi[tajd$pop==mypop]
			inds$pi2sd[myselection]				<- tajd$sd_pi[tajd$pop==mypop]
			inds$harmonic_number[myselection]	<- tajd$harmonic_number[tajd$pop==mypop]
			inds$Watterson[myselection]			<- tajd$Watterson[tajd$pop==mypop]
			inds$TajimaD[myselection]			<- tajd$TajimaD[tajd$pop==mypop]
			inds$pi2_scaled[myselection]		<- tajd$pi_scaled[tajd$pop==mypop]
			inds$pi2_scaled_sd[myselection]		<- tajd$pi_scaled_sd[tajd$pop==mypop]
			inds$Watterson_scaled[myselection]	<- tajd$Watterson_scaled[tajd$pop==mypop]
			inds$TajimaD_scaled[myselection]	<- tajd$TajimaD_scaled[tajd$pop==mypop]
			inds$rare_alleles[myselection]		<- tajd$rare_alleles[tajd$pop==mypop]
			}
		}
	# 
	# remove duplicate columns		
	inds 							<<- inds[, !duplicated(colnames(inds),fromlast=TRUE)]
	mysambar$tajd					<<- tajd
	}	

#get genome wide heterozygosity and pi:
getgenomepi<-function(nsites=NULL,nsnps=NULL)
	{
	if(is.null(nsites))
		{
		cat("Warning: you did not provide the total number of sequenced sites to the nsites argument.",sep="\n")
		cat("As a result, SambaR will not calculate genome wide estimates.",sep="\n") 
		cat("Instead, the columns 'genomehe' and 'genomepi' are set to NA.",sep="\n")
		inds$genomepi			<<- NA
		inds$genomehe			<<-	NA
		}else{
		if(is.null(inds$pi))
			{
			cat("Column inds$pi not found. Generating now using the calcpi function...",sep="\n")
			calcpi(pi_per_pop=TRUE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE,silent=TRUE)
			}
		if(is.null(nsnps))
			{
			n_snps					<- inds$nsegsites4		# 08072019: instead of: nrow(snps)
			}else{
			n_snps					<- nsnps
			}
		inds$genomepi			<<- inds$pi*n_snps/nsites
		inds$genomehe			<<-	inds$hetero_all*n_snps/nsites
		# Two possibilities:
		# genomepi				<<- (pi * length(snps[i,]))/allsites
		# genomepi2				<<- (pi * length(snps[i,snps$popmaf>0]))/allsites
		# You could argue in favour of both, but I got the impression genomepi gives me more credible estimates than genomepi2, so I went with genomepi.
		}
	}

# old version (which calculates pi based on a sample of individuals (4) rather than all individuals):	
getpi<-function(nsites=NULL,nsample=4,popnames=mysambar$populations)
	{
	# This function calculates pi: the average number of variant sites when randomly drawing 2 sequences from a population.
	# We calculate two versions:
	# pi						(hetero * length(snps[i,]))/allsites
	# pi2					(hetero * length(snps[i,snps$popmaf>0]))/allsites
	# You could argue in favour of both, but I think pi gives me more credible estimates than pi2.
	if(is.null(nsites))
		{
		return(cat("ERROR: you need to provide the total number of sequenced sites to the nsites argument.",sep="\n"))
		}
	# Create matrix
	nsnps					<- nrow(snps)
	npops					<- length(popnames)
	for(j in c(1:npops))
		{
		mypop				<- popnames[j]
		myinds				<- inds$nr[inds$pop==mypop]
		ninds				<- length(myinds)
		for (i in c(1:ninds))
			{
			myind1			<- myinds[i]
			myind2			<- rep(myind1,nsample)
			otherinds1		<- inds$nr[inds$pop==mypop&inds$filter]
			otherinds2		<- otherinds1[!(otherinds1 == myind1)]
			otherinds3		<- sample(otherinds2,nsample,replace=FALSE)
			combitabletemp	<- rbind(myind2,otherinds3)
			if(i==1&&j==1)
				{
				combitable	<- combitabletemp
				}else{
				combitable	<- cbind(combitable,combitabletemp)
				}
			}
		}
	npairs					<- ncol(combitable)
	mydiffmatrix			<<- as.data.frame(matrix(NA,nrow=npairs,ncol=9))
	colnames(mydiffmatrix)	<<- c("ind1","ind2","pop1","pop2","diff","nsites","allsites","pi","pi2")
	# to find number of clusters, maybe try the R package modes?
	# modes(data,nmore=2)[1,][rev(order(modes(data,nmore=2)[2,]))]
	for (i in c(1:npairs))
		{
		# cat(paste(i,"out of",npairs,"pairwise comparisons",sep =" "),sep="\n")
		myind1				<- combitable[1,i]
		myind2				<- combitable[2,i]
		mygeno				<- as.matrix(mygenlight[inds$nr==myind1|inds$nr==myind2,snps$filter])
		genosum				<- !is.na(colSums(mygeno))
		ngeno				<- length(genosum[genosum])
		ndiff				<- vector() 
		for (j in c(1:ncol(mygeno)))
			{
			geno1			<- mygeno[1,j]
			geno2			<- mygeno[2,j]
			ndiff[j]		<- ifelse((!genosum[j]),0,ifelse(((geno1==0&&geno2==0)||(geno1==2&&geno2==2)),0,ifelse((geno1==0&&geno2==2)||(geno1==2&&geno2==0),1,0.5)))
			}
		mymeandiff			<- round((sum(ndiff,na.rm=TRUE)/ngeno),3)
		npoly				<- inds$nsegsites1[inds$nr==myind1]
		mydiffmatrix[i,1]	<<- myind1
		mydiffmatrix[i,2]	<<- myind2
		mydiffmatrix[i,3]	<<- inds$pop[inds$nr==myind1]
		mydiffmatrix[i,4]	<<- inds$pop[inds$nr==myind2]
		mydiffmatrix[i,5]	<<- mymeandiff
		mydiffmatrix[i,6]	<<- ngeno
		mydiffmatrix[i,7]	<<- nsites
		mydiffmatrix[i,8]	<<- mymeandiff*nsnps/nsites	
		mydiffmatrix[i,9]	<<- mymeandiff*npoly/nsites	
		# you might wonder: why not multiply with ngeno rather than nsnps? 
		# ngeno is nsnps - nmissing		# with nmissing being number of missing data points
		# missing data points are not considered in calculation (as we divide by ngeno, and as non missing data points are set to 0)																
		# so meandiff is truly the probability of heterozygous site if you compare two 2 randomly drawn sequences (after all: it is an average, not a sum) 
		# this is the probability over the entire snp data set (polymorphic sites in retained reads)
		# we want to rescale to all sites (also non-polymorphic sites in retained reads)  
		# hence we multiply with nsnps (and more specifically: all polymorphic sites, also the ones which don't meet filter criteria)									 
		}
	pitemp				<- aggregate(mydiffmatrix$pi,list(mydiffmatrix$ind1),mean)
	colnames(pitemp)		<- c("nr","pi")
	pitemp2				<- aggregate(mydiffmatrix$pi2,list(mydiffmatrix$ind1),mean)
	colnames(pitemp2)	<- c("nr","pi")
	inds$pi				<<- pitemp$pi
	# inds$pi2			<<- pitemp2$pi
	inds$autozygosity2	<<- 1-inds$genomehe/inds$pi
	}
	
plotpi_vs_he<-function(export=NULL,mycolours=mysambar$mycolours,popnames=mysambar$populations,adddiscarded=FALSE,genomewide=TRUE)
	{	
	if(genomewide)
		{
		if(!"genomepi"%in%colnames(inds))
			{
			return(cat("Column 'genomepi' not present in inds dataframe. Omitting 'he_vs_pi' plot.",sep="\n"))
			}
		if(!"genomehe"%in%colnames(inds))
			{
			return(cat("Column 'genomehe' not present in inds dataframe. Omitting 'he_vs_pi' plot.",sep="\n"))
			}
		}
	graphics.off()
	if(!is.null(export))
		{
		mylabel	<- ifelse(genomewide,"genomewide","snpdata")
		if(export=="eps"){postscript(paste("he_vs_pi",mylabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("he_vs_pi",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("he_vs_pi",mylabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("he_vs_pi",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)	
	if(genomewide)
		{
		mypi				<- inds$genomepi*100
		mygenomehe			<- inds$genomehe*100
		myylab				<- "Genome wide heterozygosity (%)"
		}else{
		mypi				<- inds$pi*100
		mygenomehe			<- inds$hetero_all*100
		myylab				<- "Heterozygosity (%)"
		}
	mymin				<- 0.95*min(c(min(mypi[inds$filter],min(mygenomehe[inds$filter]))))
	mymax				<- 1.05*max(c(max(mypi[inds$filter],max(mygenomehe[inds$filter]))))
	plot(mypi[inds$filter],mygenomehe[inds$filter],xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="Nucleotide diversity (%)",ylab=myylab,cex=2,col="white")
	npops					<- length(popnames)
	mycolours				<- mycolours[1:npops]
	for (j in c(1:npops))
		{
		mypop				<- popnames[j]
		points(mypi[inds$pop==mypop&inds$filter],mygenomehe[inds$pop==mypop&inds$filter],col=mycolours[j],pch=16,cex=2)
		if(adddiscarded)
			{
			points(mypi[inds$pop==mypop&!inds$filter],mygenomehe[inds$pop==mypop&!inds$filter],col=mycolours[j],cex=2)
			}
		}
	lines(c(0,100),c(0,100))
	if(!is.null(export)){dev.off()}
	}	

plotcompareF<-function(export=NULL,mycolours=mysambar$mycolours,popnames=mysambar$populations,adddiscarded=FALSE,genomewide=TRUE)
	{	
	if(!"F"%in%colnames(inds))
		{
		return(cat("Column 'F' not present in inds dataframe (which is generated by calckinship function). Omitting 'Inbreeding_Fpi_vs_Fh' plot.",sep="\n"))	
		}
	if(genomewide)
		{
		if(!"autozygosity2"%in%colnames(inds))
			{
			return(cat("Column 'autozygosity2' not present in inds dataframe. Omitting 'Inbreeding_Fpi_vs_Fh' plot.",sep="\n"))
			}
		}else{
		if(!"autozygosity"%in%colnames(inds))
			{
			return(cat("Column 'autozygosity' not present in inds dataframe. Omitting 'Inbreeding_Fpi_vs_Fh' plot.",sep="\n"))
			}
		}
	graphics.off()
	if(!is.null(export))
		{
		mylabel	<- ifelse(genomewide,"genomewide","snpdata")
		if(export=="eps"){postscript(paste("Inbreeding_Fpi_vs_Fh",mylabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("Inbreeding_Fpi_vs_Fh",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("Inbreeding_Fpi_vs_Fh",mylabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("Inbreeding_Fpi_vs_Fh",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)	
	if(genomewide)
		{
		myauto				<- inds$autozygosity2
		}else{
		myauto				<- inds$autozygosity
		}
	myylab				<- "F_pi"
	mymin				<- 0.95*min(c(min(myauto[inds$filter],min(inds$F[inds$filter]))))
	mymax				<- 1.05*max(c(max(myauto[inds$filter],max(inds$F[inds$filter]))))
	plot(inds$F[inds$filter],myauto[inds$filter],xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="F_h",ylab=myylab,cex=3,col="white")
	lines(c(-100,100),c(-100,100))
	npops					<- length(popnames)
	mycolours				<- mycolours[1:npops]
	for (j in c(1:npops))
		{
		mypop				<- popnames[j]
		points(inds$F[inds$pop==mypop&inds$filter],myauto[inds$pop==mypop&inds$filter],pch=16,cex=3,col=mycolours[j])
		if(adddiscarded)
			{
			points(inds$F[inds$pop==mypop&!inds$filter],myauto[inds$pop==mypop&!inds$filter],pch=16,cex=3,col=mycolours[j])
			}
		}
	if(!is.null(export)){dev.off()}
	}	

# requires package vioplot if dostripchart is set to FALSE
plotsampleHe<-function(popnames=mysambar$poporder,yrange=c(0,0.55),yrange2=c(0.0005,0.0025),mycolours=mysambar$colorder,shortpop=NULL,allsites=FALSE,dostripchart=FALSE)
	{
	if(allsites&!("genomehe"%in%colnames(inds)))
		{
		return(cat("ERROR: column 'genomehe' not present in inds dataframe. Set flag allsites to FALSE.",sep="\n"))
		}
	if(is.null(shortpop))
		{
		shortpop<-substr(popnames,1,2)
		}
	x 			<- rnorm(100)
	y 			<- rnorm(100)
	npop		<- length(popnames)
	mycolours	<- mycolours[1:npop]
	if(allsites)
		{
		#cat("You have set nsites=TRUE. Plot will show genome wide heterozygosity (inds$genomehe) which you calculated when setting nsites=TRUE with the function 'pophetero'.",sep="\n")
		#myyrange <- yrange2	# 21052019: flag 'yrange2' can probably be removed
		myyrange <- c(min(inds$genomehe[inds$filter]),max(inds$genomehe[inds$filter]))
		}else{
		#myyrange <- yrange		# 21052019: flag 'yrange' can probably be removed
		myyrange <- c(min(inds$hetero[inds$filter]),max(inds$hetero[inds$filter]))
		}	
	par(cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(dostripchart)
		{
		indstemp		<- droplevels(inds[inds$filter,])
		if(allsites)
			{
			boxplot(indstemp$genomehe~indstemp$poporder,border=mycolours,names=shortpop,col="grey90",xlab="",ylab="",cex.axis=2.5,pch=16,outline=FALSE)
			stripchart(genomehe~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2.5,col=mycolours,bg="bisque",add=TRUE) 
			}else{
			boxplot(indstemp$hetero~indstemp$poporder,border=mycolours,names=shortpop,col="grey90",xlab="",ylab="",cex.axis=2.5,pch=16,outline=FALSE,las=3)
			stripchart(hetero~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2.5,col=mycolours,bg="bisque",add=TRUE) 
			}
		}else{
		if(allsites)
			{
			myheteroallinds	<- inds$genomehe[inds$filter]
			}else{
			myheteroallinds	<- inds$hetero[inds$filter]
			}
		plot(x, y, xlim=c(0.5,npop+0.5),ylim=c(0.975*min(myheteroallinds,na.rm=TRUE),1.025*max(myheteroallinds,na.rm=TRUE)),col="white",xaxt="n",xlab="",ylab="")
		for (i in c(1:npop))
			{
			mypop			<- popnames[i]
			if(allsites)
				{
				myhetero	<- inds$genomehe[inds$pop==mypop&inds$filter]
				}else{
				myhetero	<- inds$hetero[inds$pop==mypop&inds$filter]
				}
			vioplot(myhetero,at=i,add=TRUE,names=popnames[i],col=mycolours[i])
			}
		axis(side=1,at=seq(1,npop),labels=shortpop,lty=1,las=3)
		}
	# mtext("Population",1,line=2.5,cex=1.25)
	mtext("Proportion of heterozygote sites",2,line=3.5,cex=2.5)
	if(allsites)
		{
		mtext("For all sites",3,line=-2.5,cex=2)
		}else{
		mtext("For segregating sites only",3,line=-2.5,cex=2)
		}
	}

# This function uses the plotsampleHe function
plotgenomehe<-function(popnames=mysambar$populations,shortpop=NULL,nsites=NULL,nsegsites=NULL,mycolours=mysambar$mycolours,export=NULL,dofilter=FALSE,do_stripchart=FALSE)
	{
	npops		<- length(popnames)
	mycolours	<- mycolours[1:npops]
	if(is.null(shortpop))
		{
		shortpop<- substr(popnames,1,2)
		}
	# derive proportion of segregating sites:
	if(is.null(nsegsites))
		{
		indstemp	<- inds[,c("pop","nsegsites3")]
		aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
		}else{
		if(length(nsegsites)!=npops)
			{		
			return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
			}else{
			myseg		<- nsegsites			
			}
		}
	if(is.null(nsites))
		{
		indstemp	<- inds[,c("pop","allseqsites")]
		aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
		myseg		<- myseg/allsites
		}else{
		myseg		<- myseg/nsites
		}
	# Plot:
	if(!is.null(export))
		{
		mylabel		<- ifelse(do_stripchart,"stripchart","vioplot")
		if(export=="eps"){postscript(paste("pi.pop",mylabel,"eps",sep="."),family=mysambar$myfont,width=25,height=10)}
		if(export=="pdf"){pdf(paste("pi.pop",mylabel,"pdf",sep="."),family=mysambar$myfont,width=25,height=10)}
		if(export=="png"){png(paste("pi.pop",mylabel,"png",sep="."),family=mysambar$myfont,width=1800,height=720)}
		if(export=="wmf"){win.metafile(paste("pi.pop",mylabel,"wmf",sep="."),family=mysambar$myfont,width=25,height=10)}
		}
	par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	# layout(matrix(c(1,2,3),1,3))
	# Plot proportion of segregating sites:
	if(do_stripchart)
		{
		par(lwd=4)
		xx<-barplot(myseg,names.arg=shortpop,col="grey",border=mycolours,ylab=NULL,ylim=c(0,max(myseg)+1/10*max(myseg)),xpd = FALSE)
		par(lwd=1)
		}else{
		xx<-barplot(myseg,names.arg=shortpop,col=mycolours,ylab=NULL,ylim=c(0,max(myseg)+1/10*max(myseg)),xpd = FALSE)
		}
	text(x = xx, y = myseg,label=round(myseg,4),pos=3,cex=3.5,col="black")
	mtext("Proportion of segregating sites",side=2,line=3.5,cex=2.5)
	# Plot he for segregating sites:
	plotsampleHe(allsites=FALSE,dostripchart=do_stripchart)
	# Plot pi:
	plotsampleHe(allsites=TRUE,dostripchart=do_stripchart)
	mtext("Nucleotide diversity",3,line=-3.5,cex=3,outer=TRUE)
	mtext("Population",1,line=-1.5,cex=2.5,outer=TRUE)
	if(!is.null(export)){dev.off()}
	}

# summary statistics:
popstats<-function(popnames=mysambar$populations,nsites=NULL,u=1.0*10^-8)
	{
	npops				<- length(popnames)
	mystats				<- as.data.frame(matrix(NA,nrow=npops+1,ncol=13))
	colnames(mystats)	<- c("pop","n_inds","maf_all","maf_seg","MLH","sMLH","n_snps","nsequenced","S","genomehe","genomepi","Ne_he","Ne_pi")
	mystats$pop[1]		<- "Metapop"
	mystats$n_inds[1]	<- nrow(inds[inds$filter,])
	mystats$maf_all[1]	<- round(mean(inds$maf_all[inds$filter]),3)  
	mystats$maf_seg[1]	<- round(mean(inds$maf[inds$filter]),3)  
	mystats$MLH[1]		<- round(mean(inds$hetero_all[inds$filter],na.rm=TRUE),3)			# multilocus heterozygosity (same as inds$MLH and inds$hetero_all)  
	if("sMLH"%in%colnames(inds))
		{
		mystats$sMLH[1]		<- round(mean(inds$sMLH[inds$filter],na.rm=TRUE),3)					# standardized multilocus heterozygosity (same as inds$MLH and inds$hetero_all)  
		}else{
		mystats$sMLH[1]		<- NA
		}
	mystats$n_snps[1]	<- round(mean(inds$nsites_nofilter[inds$filter]))	
	myvector			<- snps$maf
	nsegsites			<- length(myvector[myvector>0])
	if(!is.null(nsites))
		{
		if(length(nsites)==1)
			{
			mystats$S[1]		<- round(nsegsites/nsites,4)
			}else{
			mystats$S[1]		<- round(nsegsites/max(nsites),4)
			}
		mystats$nsequenced[1]<- nsites
		mystats$genomehe[1]	<- round(mean(inds$genomehe[inds$filter]),4)
		mystats$genomepi[1]	<- round(mean(inds$genomepi[inds$filter]),4)
		#mystats$Watterson[1]<- round(mean(inds$Watterson_scaled[inds$filter]),4)
		#mystats$TajimaD[1]	<- round(mean(inds$TajimaD_scaled[inds$filter]),4)
		cat(paste("Ne is calculating as pi/4*u, with u (generation mutation rate) set to ",u,". You can change this value using the u flag (or u_g flag if you invoke the popstats function using the calcdiversity function).",sep=""),sep="\n") 
		mystats$Ne_he[1]		<- round(mean(inds$genomehe[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
		mystats$Ne_pi[1]		<- round(mean(inds$genomepi[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = pi/4u
		}else{
		mystats$S[1]			<- NA
		mystats$nsequenced[1]	<- NA
		mystats$genomehe[1]		<- NA
		mystats$genomepi[1]		<- NA
		#mystats$Watterson[1]	<- NA
		#mystats$TajimaD[1]		<- NA
		mystats$Ne_he[1]		<- NA
		mystats$Ne_pi[1]		<- NA
		}
	for (i in c(1:npops))
		{
		mypop				<- popnames[i]
		mystats$pop[i+1]	<- mypop
		mystats$n_inds[i+1]	<- nrow(inds[inds$filter&inds$pop==mypop,])
		mystats$maf_all[i+1]<- round(mean(inds$maf_all[inds$filter&inds$pop==mypop]),3)  
		mystats$maf_seg[i+1]<- round(mean(inds$maf[inds$filter&inds$pop==mypop]),3)  
		mystats$MLH[i+1]	<- round(mean(inds$hetero[inds$filter&inds$pop==mypop]),3) 
		if("sMLH"%in%colnames(inds))
			{
			mystats$sMLH[i+1]	<- round(mean(inds$sMLH[inds$filter&inds$pop==mypop]),3)	
			}else{
			mystats$sMLH[i+1]	<- NA
			}
		mystats$n_snps[i+1]	<- round(mean(inds$nsites_nofilter[inds$filter&inds$pop==mypop]))	
		myvector			<- snps[,names(snps) == paste("maf",mypop,sep="_")]
		nsegsites			<- length(myvector[myvector>0])
		if(!is.null(nsites))
			{
			if(length(nsites)==1)
				{
				mystats$S[i+1]			<- round(nsegsites/nsites,4)
				}else{
				mystats$S[i+1]			<- round(nsegsites/nsites[i],4)
				}
			mystats$nsequenced[i+1]	<- nsites
			mystats$genomehe[i+1]	<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop]),4) 
			mystats$genomepi[i+1]	<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop]),4) 
			#mystats$Watterson[i+1]	<- round(mean(inds$Watterson_scaled[inds$filter&inds$pop==mypop]),4)
			#mystats$TajimaD[i+1]	<- round(mean(inds$TajimaD_scaled[inds$filter&inds$pop==mypop]),4)
			mystats$Ne_he[i+1]		<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
			mystats$Ne_pi[i+1]		<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop])/(4*u))  # theta = pi = 4Neu, hence: Ne = pi/4u
			}else{
			mystats$S[i+1]			<- NA
			mystats$nsequenced[i+1]	<- NA
			mystats$genomehe[i+1]	<- NA
			mystats$genomepi[i+1]	<- NA
			#mystats$Watterson[i+1]	<- NA
			#mystats$TajimaD[i+1]	<- NA
			mystats$Ne_he[i+1]		<- NA
			mystats$Ne_pi[i+1]		<- NA
			}
		} 
	mystats	<- t(mystats)
	write.table(mystats,"SambaR.popdiversity.stats.txt",row.names=TRUE,col.names=FALSE,quote=FALSE,sep="\t")
	}


# summary statistics:
popstats_old<-function(popnames=mysambar$populations,nsites=NULL,u=1.0*10^-8)
	{
	npops				<- length(popnames)
	mystats				<- as.data.frame(matrix(NA,nrow=npops+1,ncol=16))
	colnames(mystats)	<- c("pop","n","maf_all","ho_all","he_all","perc_He_deficit","perc_He_surplus","maf_seg","ho_seg","he_seg","F_seg","S","genomehe","genomepi","Ne_he","Ne_pi")
	mystats$pop[1]		<- "Metapop"
	mystats$n[1]		<- nrow(inds[inds$filter,])
	mystats$maf_all[1]	<- round(mean(inds$maf_all[inds$filter]),3)  
	mystats$ho_all[1]	<- round(mean(inds$hetero_all[inds$filter]),3)  
	mystats$he_all[1]	<- round(mean(inds$expHe_all[inds$filter]),3)  
	mystats$perc_He_deficit[1]<-mysambar$hwetable[1,3]
	mystats$perc_He_surplus[1]<-mysambar$hwetable[1,4]
	mystats$maf_seg[1]	<- round(mean(inds$maf[inds$filter]),3)  
	mystats$ho_seg[1]	<- round(mean(inds$hetero[inds$filter]),3) 
	mystats$he_seg[1]	<- round(mean(inds$expHe[inds$filter]),3) 
	mystats$F_seg[1]	<- round(mean(inds$F[inds$filter]),3)  
	myvector			<- snps$maf
	nsegsites			<- length(myvector[myvector>0])
	if(!is.null(nsites))
		{
		if(length(nsites)==1)
			{
			mystats$S[1]		<- round(nsegsites/nsites,4)
			}else{
			mystats$S[1]		<- round(nsegsites/max(nsites),4)
			}
		mystats$genomehe[1]	<- round(mean(inds$genomehe[inds$filter]),4)
		mystats$genomepi[1]	<- round(mean(inds$genomepi[inds$filter]),4)
		cat(paste("Ne is calculating as pi/4*u, with u (generation mutation rate) set to ",u,". You can change this value using the u flag (or u_g flag if you invoke the popstats function using the calcdiversity function).",sep=""),sep="\n") 
		mystats$Ne_he[1]		<- round(mean(inds$genomehe[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
		mystats$Ne_pi[1]		<- round(mean(inds$genomepi[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = pi/4u
		}else{
		mystats$S[1]			<- NA
		mystats$genomehe[1]		<- NA
		mystats$genomepi[1]		<- NA
		mystats$Ne_he[1]		<- NA
		mystats$Ne_pi[i]		<- NA
		}
	for (i in c(1:npops))
		{
		mypop				<- popnames[i]
		mystats$pop[i+1]	<- mypop
		mystats$n[i+1]		<- nrow(inds[inds$filter&inds$pop==mypop,])
		mystats$maf_all[i+1]<- round(mean(inds$maf_all[inds$filter&inds$pop==mypop]),3)  
		mystats$ho_all[i+1]	<- round(mean(inds$hetero_all[inds$filter&inds$pop==mypop]),3)  
		mystats$he_all[i+1]	<- round(mean(inds$expHe_all[inds$filter&inds$pop==mypop]),3)  
		mystats$perc_He_deficit[i+1]<-mysambar$hwetable[i+1,3]
		mystats$perc_He_surplus[i+1]<-mysambar$hwetable[i+1,4]	
		mystats$maf_seg[i+1]<- round(mean(inds$maf[inds$filter&inds$pop==mypop]),3)  
		mystats$ho_seg[i+1]	<- round(mean(inds$hetero[inds$filter&inds$pop==mypop]),3) 
		mystats$he_seg[i+1]	<- round(mean(inds$expHe[inds$filter&inds$pop==mypop]),3) 
		mystats$F_seg[i+1]	<- round(mean(inds$F[inds$filter&inds$pop==mypop]),3)  
		myvector			<- snps[,names(snps) == paste("maf",mypop,sep="_")]
		nsegsites			<- length(myvector[myvector>0])
		if(!is.null(nsites))
			{
			if(length(nsites)==1)
				{
				mystats$S[i+1]			<- round(nsegsites/nsites,4)
				}else{
				mystats$S[i+1]			<- round(nsegsites/nsites[i],4)
				}
			mystats$genomehe[i+1]	<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop]),4) 
			mystats$genomepi[i+1]	<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop]),4) 
			mystats$Ne_he[i+1]		<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
			mystats$Ne_pi[i+1]		<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop])/(4*u))  # theta = pi = 4Neu, hence: Ne = pi/4u
			}else{
			mystats$S[i+1]			<- NA
			mystats$genomehe[i+1]	<- NA
			mystats$genomepi[i+1]	<- NA
			mystats$Ne_he[i+1]		<- NA
			mystats$Ne_pi[i+1]		<- NA
			}
		} 
	mystats	<- t(mystats)
	write.table(mystats,"SambaR.popdiversity.stats.txt",row.names=TRUE,col.names=FALSE,quote=FALSE,sep="\t")
	}

plotstats<-function(myfilter=inds$filter,popnames=mysambar$populations)
	{
	layout(matrix(c(1:8),4,2,byrow=FALSE))
	par(mar=c(2,4.0,0.5,0.5),oma=c(3,2,2,2))
	# segregating sites only:
	boxplot(maf[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="MAF",xlab="Population",main="Segregating sites only")
	boxplot(hetero[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="Ho",xlab="Population")
	boxplot(expHe[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="He",xlab="Population")
	boxplot(F[myfilter]~pop[myfilter],data=inds,frame.plot=F,notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="F (1-Ho/He)",xlab="Population",names=popnames)
	# all sites:
	boxplot(maf_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population",names=rep("",length(popnames)),main="All sites")
	boxplot(hetero_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population")
	boxplot(expHe_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population")
	boxplot(F_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population",names=popnames)
	mtext("Population",side=1,line=1,outer=TRUE)
	}

multirunsfs<-function(do_silent=TRUE,number_sites=NULL,number_segsites=NULL)
	{
	myrunnames	<- c("allsnps_NOTimputed","allsnps_imputed","snpfilter_NOTimputed","snpfilter_imputed")
	for(mysfsrun in c(1:4))
		{
		if(!do_silent){cat(myrunnames[mysfsrun],sep="\n")}
		setwd(mysambar$diversitydir)
		sfsfolder	<- paste("SFS",myrunnames[mysfsrun],sep="_")
		if(file.exists(sfsfolder))
			{
			setwd(file.path(mysambar$diversitydir,sfsfolder))
			}else{
			dir.create(file.path(mysambar$diversitydir,sfsfolder))
			setwd(file.path(mysambar$diversitydir,sfsfolder))
			}
		do_snpfilter	<- ifelse(mysfsrun>2,TRUE,FALSE)
		do_imputeddata	<- ifelse(mysfsrun%%2==0,TRUE,FALSE)
		if(!do_silent){cat("Running getfoldedsfs...",sep="\n")}
		getfoldedsfs(dofilter=do_snpfilter,do_impute=do_imputeddata)
		#
		if(do_snpfilter&do_imputeddata)
			{
			sfs_table	<- mysambar$foldedsfstable_snpfilter_imputed
			sfs_heprop	<- mysambar$foldedsfs_prophe_snpfilter_imputed
			sfs_mean	<- mysambar$bootsfsmean_snpfilter_imputed
			sfs_sd		<- mysambar$bootsfssd_snpfilter_imputed
			}
		if((!do_snpfilter)&do_imputeddata)
			{
			sfs_table	<- mysambar$foldedsfstable_imputed
			sfs_heprop	<- mysambar$foldedsfs_prophe_imputed
			sfs_mean	<- mysambar$bootsfsmean_imputed
			sfs_sd		<- mysambar$bootsfssd_imputed		
			}
		if(do_snpfilter&(!do_imputeddata))
			{
			sfs_table	<- mysambar$foldedsfstable_snpfilter
			sfs_heprop	<- mysambar$foldedsfs_prophe_snpfilter
			sfs_mean	<- mysambar$bootsfsmean_snpfilter
			sfs_sd		<- mysambar$bootsfssd_snpfilter
			}
		if((!do_snpfilter)&(!do_imputeddata))
			{	
			sfs_table	<- mysambar$foldedsfstable
			sfs_heprop	<- mysambar$foldedsfs_prophe
			sfs_mean	<- mysambar$bootsfsmean
			sfs_sd		<- mysambar$bootsfssd
			}
		imputelabel		<- ifelse(do_imputeddata,"imputed","NOTimputed")
		# barplots without bootstrap:
		if(!do_silent){cat("Creating barplots withOUT bootstrap...",sep="\n")}
		#barplotsfs(export="eps",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)
		barplotsfs(export="pdf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)
		barplotsfs(export="png",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)
		if(mysambar$os=="Windows"){barplotsfs(export="wmf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)}
		#
		# barplots with bootstrap error bars:
		if(!do_silent){cat("Creating barplots with bootstrap error bars...",sep="\n")}
		#barplotsfs(export="eps",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)
		barplotsfs(export="pdf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)
		barplotsfs(export="png",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)
		if(mysambar$os=="Windows"){barplotsfs(export="wmf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)}
		#
		# proportion heterozygous sites per MAC class:
		if(!do_silent){cat("He_per_SFSbin plots...",sep="\n")}
		myplotname	<- paste("He_per_SFSbin",myrunnames[mysfsrun],sep="_")
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		#
		if(mysfsrun%%2!=0)
			{
			# not yet implemented for imputed data.
			if(length(mysambar$populations)>1)
				{
				if(!do_silent){cat("plot2Dsfs",sep="\n")}
				plot2Dsfs(export="eps",dofilter=do_snpfilter)	
				plot2Dsfs(export="pdf",dofilter=do_snpfilter)
				plot2Dsfs(export="png",dofilter=do_snpfilter)
				if(mysambar$os=="Windows"){plot2Dsfs(export="wmf",dofilter=do_snpfilter)}		
				# combine 2D-SFS plots on one page:
				# if(do_snpfilter)
				#	{
				# 	plot2Dsfs_multi(export="pdf",exportname="SFS.2D.all",mylist=mysambar$sfs2Dlist_snpfilter,inverse=FALSE)
				#	}else{
				#	plot2Dsfs_multi(export="pdf",exportname="SFS.2D.all",mylist=mysambar$sfs2Dlist_allsnps,inverse=FALSE)
				#	}
				}
			}
		if(mysfsrun==3)
			{
			# only available for not imputed, with snp filter
			# SFS binned:
			if(!do_silent){cat("plotsfs",sep="\n")}
			plotsfs(export="eps",silent=do_silent)										# without barplot showing number of segregating sites
			plotsfs(export="pdf",silent=do_silent)
			plotsfs(export="png",silent=do_silent)
			if(mysambar$os=="Windows"){plotsfs(export="wmf",silent=do_silent)}
			plotsfs(export="eps",silent=do_silent,addlegend=FALSE)										
			plotsfs(export="pdf",silent=do_silent,addlegend=FALSE)
			plotsfs(export="png",silent=do_silent,addlegend=FALSE)
			if(mysambar$os=="Windows"){plotsfs(export="wmf",silent=do_silent,addlegend=FALSE)}
			#
			if(!is.null(number_sites))
				{
				cat("Plotting proportion of segregating sites...",sep="\n")
				plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="eps",silent=TRUE)	# with barplot with number of segregating sites is included
				plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="pdf",silent=TRUE)
				plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="png",silent=TRUE)
				if(mysambar$os=="Windows"){plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="wmf",silent=TRUE)}
				}
			}
		}
	setwd(mysambar$diversitydir)
	}

getfoldedsfs<-function(popnames=mysambar$populations,histo=FALSE,yrange=c(0,nrow(snps)/4),dofilter=FALSE,do_impute=FALSE,nbootstrap=100,silent=TRUE)
	{
	if(do_impute)
		{
		if(is.null(mysambar$imputedmatrix_persnp))
			{
			sambarimpute(per_snp=TRUE)
			}
		inputgenlight	<- as.genlight(mysambar$imputedmatrix_persnp)
		cat("Because the flag do_impute is set to TRUE, SFS vectors are being calculated using imputed dataset.",sep="\n")
		}else{
		inputgenlight	<- mygenlight
		}
	foldedsfs			<- list()
	foldedsfs_prophe	<- list()
	bootsfsmean			<- list()
	bootsfssd			<- list()
	#
	# BACKGROUND INFO: CALCULATION OF MINOR ALLELE COUNTS PER SNP
	# how many (non-)missing data points per SNP?
	# misscount				<- glNA(inputgenlight[inds$filter,],alleleAsUnit=FALSE)
	# nonmissallelecount 	<- 2*(nInd(inputgenlight[inds$filter,])-misscount)
	#
	# glSum: computes the mean number of second allele in each SNP.
	# the second allele is represented twice in genotype 2, and once in genotype 1
	#
	# When considering all individuals, the second allele is always the minor allele
	# However, after filtering out individuals, this could have changed.
	# Imagine you have a dataset of six diploid individuals, with for a certain site the genotypes 2,2,0,0,1,0
	# If individuals 3 and 4 are filtered out, then the remaining genotypes are 2,2,1,0. The second allele has become the major allele.
	# We need to correct for that, and to make sure that we have exclusively counts of the minor allele, and not of the major allele.
	# mymac				<- as.vector(glSum(inputgenlight[inds$filter,]))
	# mymac				<- ifelse(mymac>0.5*nonmissallelecount,nonmissallelecount-mymac,mymac)
	# However, no need to generate this vectors here again, because already generated during importdata() and filterdata() functions, or sambarimpute() function
	#
	nind					<- nrow(inds[inds$filter,])
	if(!do_impute)
		{
		nonmissallelecount	<- snps$nonmissallelecount
		mymac				<- snps$minorcount
		myhecount			<- snps$Aa
		}else{
		#nonmissallelecount	<- rep(2*nind,nrow(snps))			# no missing data in imputed dataset
		nonmissallelecount	<- snps$nonmissallelecount
		mymac				<- snps$imputed_minorcount
		myhecount			<- snps$imputed_Aa
		}
	if(length(mymac)!=length(nonmissallelecount))
		{
		return(cat("ERROR: length of mymac vector (metapopulation) does not correspond with length of nonmissallelecount vector (1).",sep="\n"))
		}
	#mymac					<- ifelse(any(mymac>(0.5*nonmissallelecount)),nonmissallelecount-mymac,mymac)
	mymac					<- ifelse(mymac>(0.5*nonmissallelecount),nonmissallelecount-mymac,mymac)
	#
	if(histo)
		{
		graphics.off()
		par(mfrow=c(1,length(popnames)+1))
		hist(mymac[mymac!=0],ylim=yrange,main="Metapop",xlab=NULL,breaks=seq(0,nrow(inds[inds$filter,]),1))
		}
	#
	# We consider only individuals which passed filter settings:
	nind			<- nrow(inds[inds$filter,])
	if(dofilter)
		{
		# If flag dofilter is set to TRUE, we consider only snps which passed filter settings:
		nonmissallelecount	<- nonmissallelecount[snps$filter]
		mymac				<- mymac[snps$filter]
		myhecount			<- myhecount[snps$filter]
		}
	if(length(mymac)!=length(nonmissallelecount))
		{
		return(cat("ERROR: length of mymac vector (metapopulation) does not correspond with length of nonmissallelecount vector (2).",sep="\n"))
		}
	#mymac				<- ifelse(any(mymac>(0.5*nonmissallelecount)),nonmissallelecount-mymac,mymac)
	mymac				<- ifelse(mymac>(0.5*nonmissallelecount),nonmissallelecount-mymac,mymac)
	if(any(mymac<0,na.rm=TRUE))
		{
		return(cat("ERROR: negative minor allele counts (for metapopulation data). Please contact the developer of SambaR.",sep="\n"))
		}
	#
	# SFS VECTOR METAPOPULATION:
	# the minor allele, being the minor allele, can be represented by maximum 50% of all allele copies
	# in a diploid population, the total number of allele copies is 2*nind
	# hence, the maximum number of allele copies of the minor allele is 2*nind/2 = nind.
	# the sfs-vector is simply a histogram which shows how many SNPs (y-axis: minorclassesfreq) have a certain number of copies of the minor allele (x-axis: minorclasses)
	# In other words, the sfs-vector shows the number of SNPs in which the minor allele is present once, twice, three times, four times, etc.
	minorclasses		<- c(1:nind)	# Note: not c(0:nind), because we ignore monomorphic sites
	minorclassesfreq	<- vector()
	minorclassesheprop	<- vector()
	for (j in minorclasses)
		{
		class_indices		<- which(mymac==j)
		minorclassesfreq[j]	<- length(class_indices)
		# total number heterozygote sites divided by potential number of heterozygote sites (if all minor alleles occur in heterozygote individuals only):
		minorclassesheprop[j]<- sum(myhecount[class_indices],na.rm=TRUE)/(j*minorclassesfreq[j])
		}
	foldedsfs[[1]]			<- minorclassesfreq
	foldedsfs_prophe[[1]]	<- minorclassesheprop
	#
	if(length(minorclassesfreq)!=nind)
		{
		cat("WARNING: Length of the SFS-vector does not equal the number of retained individuals in the overall dataset. Contact developer of SambaR.",sep="\n")
		}
	#
	if(nbootstrap!=0)
		{
		btmatrix		<- matrix(NA,nrow=nbootstrap,ncol=nind)
		for(k in c(1:nbootstrap))
			{
			btmac		<- sample(x=mymac,replace=TRUE,size=length(mymac))
			for (j in minorclasses)
				{
				btmatrix[k,j]	<- length(which(btmac==j))
				}
			}
		bootsfsmean[[1]]	<- round(apply(btmatrix,2,mean,na.rm=TRUE))
		bootsfssd[[1]]		<- round(apply(btmatrix,2,sd,na.rm=TRUE))
		}
	#
	# SFS VECTOR PER POPULATION:
	for (i in (1:length(popnames)))
		{
		if(!silent){cat(popnames[i],sep="\n")}
		mypop				<- as.character(popnames[i])
		nind				<- nrow(inds[inds$filter&as.character(inds$pop)==mypop,])
		#misscount			<- glNA(inputgenlight[inds$filter&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		#nonmissallelecount <- 2*(nInd(inputgenlight[inds$filter&inds$pop==popnames[i],])-misscount)
		#snps$mactemp		<<- as.vector(glSum(inputgenlight[inds$filter&inds$pop==popnames[i],]))
		#snps$mactemp		<<- ifelse(snps$mactemp>0.5*nonmissallelecount,nonmissallelecount-snps$mactemp,snps$mactemp)
		if(!do_impute)
			{
			nonmissallelecount	<- 2*as.vector(snps[,paste("n",popnames[i],sep="_")])
			mymac				<- as.vector(snps[,paste("mac",popnames[i],sep="_")])
			myhecount			<- as.vector(snps[,paste("Aa",popnames[i],sep="_")])
			}else{
			nonmissallelecount	<- rep(2*nind,nrow(snps))						# no missing data in imputed dataset
			if(!silent){cat(nonmissallelecount,sep="\n")}
			mymac				<- as.vector(snps[,paste("imputed_mac",popnames[i],sep="_")])
			myhecount			<- as.vector(snps[,paste("imputed_Aa",popnames[i],sep="_")])
			}
		if(histo)
			{
			#hist(snps$mactemp[snps$mactemp!=0],ylim=yrange,main = popnames[i],xlab=NULL,breaks=seq(0,nrow(inds[inds$filter&as.character(inds$pop)==popnames[i],]),1))
			hist(mymac[mymac!=0],ylim=yrange,main = popnames[i],xlab=NULL,breaks=seq(0,nrow(inds[inds$filter&as.character(inds$pop)==popnames[i],]),1))
			}
		minorclasses			<- c(1:nind)
		if(dofilter)
			{
			nonmissallelecount	<- nonmissallelecount[snps$filter]
			mymac				<- mymac[snps$filter]
			myhecount			<- myhecount[snps$filter]
			}
		if(length(mymac)!=length(nonmissallelecount))
			{
			return(cat("ERROR: length of mymac vector does not correspond with length of nonmissallelecount vector.",sep="\n"))
			}
		mymac					<- ifelse(mymac>0.5*nonmissallelecount,nonmissallelecount-mymac,mymac)
		if(any(mymac<0,na.rm=TRUE))
			{
			return(cat("Negative minor allele counts. Please contact the developer of SambaR.",sep="\n"))
			}
		#
		minorclassesfreq	<- vector()
		minorclassesheprop	<- vector()
		for (j in minorclasses)
			{
			class_indices			<- which(mymac==j)
			minorclassesfreq[j]		<- length(class_indices)
			minorclassesheprop[j]	<- sum(myhecount[class_indices])/(j*minorclassesfreq[j])
			}
		foldedsfs[[i+1]]		<- minorclassesfreq
		foldedsfs_prophe[[i+1]]	<- minorclassesheprop
		#
		#write.table(minorclassesfreq,file=paste("SFSvector",popnames[i],"txt",sep="."),sep="\n",quote=FALSE,col.names=FALSE,row.names=FALSE)
		cat(minorclassesfreq,file=paste("SFSvector",popnames[i],"txt",sep="."),sep=" ")
		#names(snps)[names(snps) == "mactemp"] <<- paste("mac",popnames[i],sep = "_")
		if(length(minorclassesfreq)!=nind)
			{
			cat(paste("WARNING: Length of the SFS-vector does not equal the number of retained individuals in ",popnames[i],". Contact developer of SambaR.",sep=""),sep="\n")
			}
		#
		if(nbootstrap!=0)
			{
			btmatrix		<- matrix(NA,nrow=nbootstrap,ncol=nind)
			for(k in c(1:nbootstrap))
				{
				btmac		<- sample(x=mymac,replace=TRUE,size=length(mymac))
				for (j in minorclasses)
					{
					btmatrix[k,j]	<- length(which(btmac==j))
					}
				}
			bootsfsmean[[i+1]]	<- round(apply(btmatrix,2,mean,na.rm=TRUE))
			bootsfssd[[i+1]]	<- round(apply(btmatrix,2,sd,na.rm=TRUE))
			}
		}
	snps 						<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	names(foldedsfs)			<- c("Metapop",popnames)
	if(nbootstrap!=0)
		{
		names(bootsfsmean)		<- c("Metapop",popnames)
		names(bootsfssd)		<- c("Metapop",popnames)
		}
	#
	if(do_impute)
		{
		if(dofilter)
			{
			mysambar$foldedsfstable_snpfilter_imputed	<<- foldedsfs
			mysambar$foldedsfs_prophe_snpfilter_imputed	<<- foldedsfs_prophe
			mysambar$bootsfsmean_snpfilter_imputed		<<- bootsfsmean
			mysambar$bootsfssd_snpfilter_imputed		<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable_snpfilter_imputed'.",sep="\n")
			}else{
			mysambar$foldedsfstable_imputed				<<- foldedsfs
			mysambar$foldedsfs_prophe_imputed			<<- foldedsfs_prophe
			mysambar$bootsfsmean_imputed				<<- bootsfsmean
			mysambar$bootsfssd_imputed					<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable_imputed'.",sep="\n")
			}
		}else{
		if(dofilter)
			{
			mysambar$foldedsfstable_snpfilter			<<- foldedsfs
			mysambar$foldedsfs_prophe_snpfilter			<<- foldedsfs_prophe
			mysambar$bootsfsmean_snpfilter				<<- bootsfsmean
			mysambar$bootsfssd_snpfilter				<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable_snpfilter'.",sep="\n")
			}else{
			mysambar$foldedsfstable						<<- foldedsfs
			mysambar$foldedsfs_prophe					<<- foldedsfs_prophe
			mysambar$bootsfsmean						<<- bootsfsmean
			mysambar$bootsfssd							<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable'.",sep="\n")
			}
		}
	}

plotsfshe<-function(export=NULL,plotname="He_per_SFSbin",popnames=mysambar$populations,mycolours=mysambar$mycolours,heproplist=mysambar$foldedsfs_prophe_imputed,yline=4,legendpos="bottomleft")
	{
	popnames	<- c("metapop",popnames) 
	npops		<- length(popnames)
	mycolours	<- c("black",mycolours)
	#
	xlabel	<- "Minor allele count (MAC) class"
	ylabel	<- "(sum(#He))/(MAC*nsites)"
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=8,height=8)}
		}
	par(mar=c(4.5,6.5,1.5,0.5),cex.axis=2,cex.lab=2.5,cex.main=2.5)
	for(k in c(1:npops))
		{
		heprop	<- heproplist[[k]]
		if(k==1)
			{
			plot(heprop,col=mycolours[k],pch=16,cex=2,ylim=c(0,1),las=1,xlab=xlabel,ylab="")
			}else{
			points(heprop,col=mycolours[k],pch=16,cex=2)
			}
		}
	mtext(side=2,line=yline,ylabel,cex=3)
	legend(legendpos,legend=popnames,fill=mycolours,cex=2.5,bty='n')
	if(!is.null(export)){dev.off()}
	}

barplotsfs<-function(popnames=mysambar$populations,silent=TRUE,export=NULL,plotlabel="NOTimputed",foldedsfstable=mysambar$foldedsfstable,bootstrapmean=mysambar$bootsfsmean,bootstrapsd=mysambar$bootsfssd)
	{
	npops	<- length(popnames)
	if(is.null(foldedsfstable))
		{
		return(cat("ERROR: Object 'foldedsfstable' is missing. Please first (re)run getfoldedsfs() function.",sep="\n"))
		}
	if(npops+1!=length(foldedsfstable))
		{
		return(cat("ERROR: Unexpected number of populations in 'foldedsfstable' object. Please first (re)run getfoldedsfs() function.",sep="\n"))
		}
	if(is.null(bootstrapsd)|is.null(bootstrapmean))
		{
		if(!silent){cat("WARNING: Object 'bootstrapsd' is missing. Not adding error bars.",sep="\n")}
		}else{
		if((npops+1)!=length(bootstrapmean)|(npops+1)!=length(bootstrapsd))
			{
			return(cat("ERROR: Unexpected number of populations in 'bootstrapsd' and/or 'bootstrapmean' object.",sep="\n"))
			}
		}
	maxn	<- lengths(foldedsfstable[-1])[which(lengths(foldedsfstable[-1])==max(lengths(foldedsfstable[-1])))]
	#
	# POPULATIONS:
	graphics.off()
	if(!is.null(export))
		{
		myheight	<- 8
		myheight2	<- 1000
		mywidth		<- 7
		mywidth2	<- 700
		plotname	<- ifelse(!is.null(bootstrapsd)&!is.null(bootstrapmean),paste("SFSbarplot",plotlabel,"withbootstrap",sep="."),paste("SFSbarplot",plotlabel,sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2*npops+200,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		}
	nindsperpop	<- as.vector(table(inds$pop[inds$filter]))
	mycex		<- ifelse(any(nindsperpop>30),0.25,0.5)
	par(mfrow=c(1,npops),mar=c(2,4.0,0.5,0.5),oma=c(5,7,2,2),cex.axis=mycex)
	mymax		<- max(unlist(foldedsfstable[-1]))*1.15
	for (i in (1:npops))
		{
		mypop	<- popnames[i]
		mysfs	<- unlist(foldedsfstable[names(foldedsfstable)==mypop])
		ninds	<- length(mysfs)
		barcenters	<- barplot(mysfs,col=mysambar$mycolours[i],border=NA,names.arg=c(1:ninds),las=2,ylim=c(0,mymax),yaxt='n')
		axis(side=2,cex.axis=2.5,las=1)
		mtext(mypop,side=3,line=-3.5,cex=3.5)
		if(i==1){mtext("Number of sites",side=2,line=6.75,cex=3.5)}
		#
		if(!is.null(bootstrapsd)&!is.null(bootstrapmean))
			{
			mymean	<- unlist(bootstrapmean[names(bootstrapmean)==mypop])
			mysd	<- unlist(bootstrapsd[names(bootstrapsd)==mypop])
			#segments(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5)
			arrows(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5,angle=90,code=3,length=0.03)
			}
		}
	mtext("Number of minor allele copies",side=1,line=2,cex=3.5,outer=TRUE)
	if(!is.null(export)){dev.off()}	
	#
	# META-POPULATION:
	mysfs	<- foldedsfstable[[1]]
	mymax	<- max(mysfs,na.rm=TRUE)*1.05
	ninds	<- length(mysfs)
	mycex	<- ifelse(ninds>30,0.5,1)
	graphics.off()
	if(!is.null(export))
		{
		myheight	<- 8
		myheight2	<- 800
		mywidth		<- 12
		mywidth2	<- 1200
		plotname	<- ifelse(!is.null(bootstrapsd)&!is.null(bootstrapmean),paste("SFSbarplot_metapopulation",plotlabel,"withbootstrap",sep="."),paste("SFSbarplot_metapopulation",plotlabel,sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	par(oma=c(1,5,1,1),cex.axis=mycex)
	barcenters	<- barplot(mysfs,col="grey50",border=NA,names.arg=c(1:ninds),las=2,ylim=c(0,mymax),yaxt='n')
	axis(side=2,cex.axis=2.5,las=1)
	mtext("Metapopulation",side=3,line=0,cex=3)
	mtext("Number of sites",side=2,line=7,cex=3)
	#
	if(!is.null(bootstrapsd)&!is.null(bootstrapmean))
		{
		mymean	<- unlist(bootstrapmean[[1]])
		mysd	<- unlist(bootstrapsd[[1]])
		#segments(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5)
		arrows(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5,angle=90,code=3,length=0.03)
		}
	mtext("Number of minor allele copies",side=1,line=-1,cex=3,outer=TRUE)
	if(!is.null(export))
		{
		dev.off()
		if(!silent)
			{
			cat("Barplots have been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}	
	}

extractmafdata<-function(mypops=mysambar$populations)
	{
	npops		<- length(mypops)
	for(j in c(1:npops))
		{
		mypop			<- mypops[j]
		maftemp			<- snps[,c(paste("maf2",mypop,sep="_"),"filter")]
		colnames(maftemp)<- c("maf","filter")
		maftemp$species	<- mypop
		if(j==1)
			{
			mymaf		<- maftemp
			}else{
			mymaf		<- rbind(mymaf,maftemp) 
			}
		}
	return(mymaf)
	}

# this function expects maf2 column, generated by getpopmaf-function.
plotsfs<-function(nbins=5,mafbincounts=NULL,addbarplot=FALSE,mylwd=4,labelsize=2.5,mypops=mysambar$populations,nsites=NULL,nsegsites=NULL,export=NULL,shortpop=NULL,mycolours=mysambar$mycolours,silent=FALSE,legendcex=2.5,addlegend=TRUE)
	{
	# You can choose to provide to the mafbincounts argument, a table from which SFS plot will be drawn.
	# This should be a matrix with npop rows and 5 columns with percentages of number of snps in maf bins 0-0.1,0.1-0.2,0.2-0.3,0.3-0.4,0.4-0.5
	# If not provided (default), this function will generate this table.  
	#
	if(addbarplot&is.null(nsites)&!"allseqsites"%in%colnames(inds))
		{
		return(cat("ERROR: addbarplot is TRUE, but nsites is NULL and column 'inds$allseqsites' does not exist either.",sep="\n"))
		}
	# addbarplot can only be set to TRUE if nsites is not
	#
	if(is.null(shortpop))
		{
		shortpop<-substr(mypops,1,2)
		}
	npops		<- length(mypops)
	mycolours	<- mysambar$mycolours[1:npops]
	### SFS ###
	if(is.null(mafbincounts))
		{
		mymaf			<- extractmafdata()
		temp1			<- mymaf
		colnames(mymaf)	<- c("maf","filter","species")
		mymaf			<- mymaf[mymaf$maf!=0,]
		if(nbins==5)
			{
			mylabels		<- seq(0.05,0.45,0.1)
			mymaf$binned	<- cut(mymaf$maf,5, include.lowest=TRUE,labels=mylabels)
			}
		if(nbins==10)
			{
			mylabels		<- seq(0.025,0.475,0.05)
			mymaf$binned	<- cut(mymaf$maf,10, include.lowest=TRUE,labels=mylabels)
			}
		mymafcounts 	<- table(mymaf$species,mymaf$binned)
		# restore order (to order of populations vector):
		temp1			<- rownames(mymafcounts)
		temp2			<- match(temp1,mypops)
		mymafcounts		<- mymafcounts[order(temp1),] 
		write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE)
		mypops			<- mypops[temp2]	
		mycolours		<- mycolours[temp2]	
		if(npops==1)
			{
			write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE,col.names=FALSE)
			mymafcounts		<-  mymafcounts/sum(mymafcounts)*100
			write.table(mymafcounts,"SFS.binned.percentages.txt",sep="\t",quote=FALSE,col.names=FALSE)
			}else{
			write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE)
			for(j in c(1:length(mypops)))
				{
				mymafcounts[j,]	<- mymafcounts[j,]/sum(mymafcounts[j,])*100
				}
			write.table(mymafcounts,"SFS.binned.percentages.txt",sep="\t",quote=FALSE)
			}
		}else{
		mymafcounts		<- mafbincounts
		mylabels		<- seq(0.05,0.45,0.1)
		}
	# mymafcounts	<<- mymafcounts
	### SEGREGATING SITES ###
	if(addbarplot)
		{
		if(is.null(nsegsites))
			{
			if(!"nsegsites3"%in%colnames(inds))
				{
				if(!is.null(export)){dev.off()}
				return(cat("ERROR: column 'nsegsites3' is missing from inds dataframe. First run the function: ind_maf(allsites=TRUE)",sep="\n"))
				}
			indstemp	<- inds[,c("pop","nsegsites3")]
			aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			if(length(nsegsites)!=npops)
				{		
				return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
				}else{
				myseg		<- nsegsites			
				}
			}
		if(is.null(nsites))
			{
			indstemp	<- inds[,c("pop","allseqsites")]
			aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
			myseg		<- myseg/allsites
			}else{
			myseg		<- 100*myseg/nsites
			}
		}
	#
	### PLOT ###
	if(!is.null(export))
		{
		graphics.off()
		mywidth		<- ifelse(addbarplot,12,10)
		mystring	<- ifelse(addbarplot,ifelse(addlegend,"with_barplot","with_barplot.no_legend"),ifelse(addlegend,"no_barplot","no_barplot.no_legend"))
		if(export=="eps"){postscript(paste("SFS.binned",mystring,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="pdf"){pdf(paste("SFS.binned",mystring,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="png"){png(paste("SFS.binned",mystring,"png",sep="."),family=mysambar$myfont,width=864,height=720)}
		if(export=="wmf"){win.metafile(paste("SFS.binned",mystring,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		}
	if(addbarplot)
		{
		layout(matrix(c(1,1,1,1,1,2,2,2),1,8))
		par(mar=c(4,7,5,2),oma=c(5,4,2,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}else{
		par(mar=c(4,6,5,2),oma=c(5,4,2,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}
	# SFS:
	if(npops>1)
		{
		plot(as.vector(unlist(mymafcounts[1,])),type="b",log="x",col="white",lwd=4,ann=FALSE,xaxt="n",xlab=NULL,ylab=NULL,ylim=c(0,max(mymafcounts)),las=1)
		for(j in c(1:length(mypops)))
			{
			mypop	<- mypops[j]
			npopinds<- nrow(inds[inds$filter&inds$pop==mypop,])
			#cat(mypop,sep="\n")
			#cat(npopinds,sep="\n")
			if(npopinds<5)
				{
				cat(paste("Less than 5 individuals in",mypop,"population. Excluded from plot, because snps with maf<0.1 will be underrepresented."),sep="\n")
				}else{
				points(as.vector(unlist(mymafcounts[j,])),type="b",col=mycolours[j],lwd=mylwd)
				}
			}
		if(addlegend)
			{
			legend("topright",legend=mypops,fill=mycolours,box.lty=0,cex=legendcex)
			}
		}else{
		plot(as.vector(mymafcounts),log="x",type="b",col=mycolours[1],lwd=4,ann=FALSE,xaxt="n",xlab=NULL,ylab=NULL,ylim=c(0,max(mymafcounts)),las=1)
		}
	axis(side=1, at=seq(1,length(mylabels),1), labels=mylabels,las=2)
	mtext("MAF class midpoint",side=1,line=7.5,cex=labelsize)
	mtext("Polymorphic sites (%)",side=2,line=4.5,cex=labelsize)
	#mtext("Folded SFS",side=3,line=0.5,cex=labelsize)
	# SEGREGATING SITES:
	if(addbarplot)
		{
		# Segregating sites:
		xx<-barplot(myseg,names.arg=shortpop,col=mycolours,las=2,ylab=NULL,ylim=c(0,max(myseg)+0.05),cex.names=3)
		text(x = xx, y = myseg,label=round(myseg,2),pos=3,cex=2.5,col="black")
		mtext("Segregating sites (%)",side=2,line=5.75,cex=2.5)
		}else{
		if(!silent)
			{
			cat("The flag 'addbarplot' is set to FALSE. Therefore, barplot with number of segregating sites not included.",sep="\n")
			}
		}
	if(!is.null(export)){dev.off()}	
	}

Sbarplot<-function(shortpop=NULL,mypops=mysambar$populations,labelsize=3,barlabelsize=2.5,nsites=NULL,nsegsites=NULL,mycolours=mysambar$mycolours)
	{
	if(is.null(shortpop))
		{
		shortpop<-substr(mypops,1,2)
		}
	npops		<- length(mypops)
	mycolours	<- mysambar$mycolours[1:npops]
	### SEGREGATING SITES ###
	if(is.null(nsegsites))
		{
		indstemp	<- inds[,c("pop","nsegsites3")]
		aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
		}else{
		if(length(nsegsites)!=npops)
			{		
			return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
			}else{
			myseg		<- nsegsites			
			}
		}
	if(is.null(nsites))
		{
		indstemp	<- inds[,c("pop","allseqsites")]
		aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
		myseg		<- myseg/allsites
		}else{
		myseg		<- 100*myseg/nsites
		}
	# plot:
	xx<-barplot(myseg,names.arg=shortpop,col=mycolours,las=2,ylab=NULL,ylim=c(0,max(myseg)+0.05),cex.names=labelsize)
	text(x = xx, y = myseg,label=round(myseg,2),pos=3,cex=barlabelsize,col="black")
	mtext("Segregating sites (%)",side=2,line=5.75,cex=labelsize)
	}

plot2Dsfs_multi<-function(export=NULL,exportname="SFS.2D.all",mylist=mysambar$sfslist,inverse=FALSE)
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	# library(grid)
	# install.packages("gridGraphics")
	# library(gridGraphics)
	# library(gridExtra)
	gl <- lapply(1:length(mylist), function(i){
		pop1		<- mysambar$sfscombitable[1,i]
		pop2		<- mysambar$sfscombitable[2,i]
		mymatrix	<- unclass(mylist[[i]])
		myBreaks	<- mysambar$sfsbreaks[[i]]
		myColours	<- mysambar$sfscolours[[i]]
		mytitle		<- names(sfsmatrix)[i]
		my_margins=c(2.5,2.5)	# under/above,right/left
		heatmap.2(mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=90,key=FALSE,margins=my_margins,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow = -0.5,offsetCol=-0.5)
		#mtext(myylab, side = 4, line = 1, cex = 2, las=2)
		#mtext(myxlab, side = 1, line = 3.25, cex = 2)
		mtext(pop1, side=2, line = 0.5, cex = 3)
		mtext(pop2, side = 3, line = 0.5, cex = 3)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		#if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8,width=24,onefile=FALSE)}	# 3 columns
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=24,width=8,onefile=FALSE)}		# 1 column
		if(export=="png"){png(paste(exportname,"png",sep="."),height=1325,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=1325,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=1, clip=TRUE, as.table = FALSE)	
	if(!is.null(export)){dev.off()}
	}

plot2Dsfs<-function(popnames=mysambar$populations,mycolours=mysambar$mycolours,ndecimals=3,export=NULL,dofilter=TRUE)
	{
	# this function generates pairwise 2D-SFS plots
	# this function expects mac columns in snp datasets, produced by 'getfoldedsfs'-function
	#
	# which pairwise comparisons?
	combitable					<- combn(popnames,m=2)
	combicoltable				<- combn(mycolours,m=2)
	multilocusweirfstvector		<- vector()
	npops						<- length(popnames)
	mysambar$sfslist			<<- list()
	mysambar$sfscolours			<<- list()
	mysambar$sfsbreaks			<<- list()
	mysambar$sfscombitable		<<- combitable
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		# cat(i,sep="\n")
		pop1		<- combitable[1,i]
		pop2		<- combitable[2,i]
		if(dofilter)
			{
			mac1		<- snps[snps$filter,paste("mac",pop1,sep="_")]
			mac2		<- snps[snps$filter,paste("mac",pop2,sep="_")]
			}else{
			mac1		<- snps[,paste("mac",pop1,sep="_")]
			mac2		<- snps[,paste("mac",pop2,sep="_")]
			}
		nsamples1	<- length(mac1)
		nsamples2	<- length(mac2)
		nsamples	<- max(c(nsamples1,nsamples2))
		mymatrix	<- table(mac1,mac2)
		mymatrix	<- mymatrix/(sum(mymatrix))*100
		if(nrow(mymatrix)>1&ncol(mymatrix)>1)
			{
			# as colour we are going to use a blend of the two population colours:
			mycol1		<- combicoltable[1,i]
			mycol2		<- combicoltable[2,i]
			mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
			mycol		<- mycolfunc3(3)[2]
			# define colour scale
			mycolfunc1 	<- colorRampPalette(c("grey85",mycol))
			myBreaks1	<- seq(0,0.99,0.01)
			myCol1		<- c(mycolfunc1(length(myBreaks1)-1))
			mycolfunc2 	<- colorRampPalette(c(mycol,"black"))
			mymax		<- ceiling(max(mymatrix))
			myBreaks2	<- seq(1,mymax,1)
			myCol2		<- c(mycolfunc2(length(myBreaks2)-1))
			# combine:
			myBreaks	<- c(myBreaks1,myBreaks2)
			myColours	<- c(myCol1,mycol,myCol2)
			# create plot:
			if(!is.null(export))
				{
				filterlabel	<- ifelse(dofilter,"snpfilter","allsnps")
				myprefix	<- paste("SFS.2D",pop1,pop2,filterlabel,sep="_")
				if(export=="eps"){postscript(paste(myprefix,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf(paste(myprefix,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png(paste(myprefix,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(myprefix,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
				}
			mycex<-ifelse(nsamples>35,0.75,1.5)
			heatmap.2(mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=mycex,cexRow=mycex,
			ylab="",xlab="",srtRow=0,srtCol=90,key=FALSE)
			myylab	<- paste("# allele copies in",pop1,sep=" ")
			myxlab	<- paste("# allele copies in",pop2,sep=" ")
			mtext(myylab, side = 4, line = 1, cex = 2)
			mtext(myxlab, side = 1, line = 3.5, cex = 2)
			mtext(paste(pop1,"vs",pop2,sep=" "), side = 3, line = 1, cex = 2.5)
			if(!is.null(export)){dev.off()}
			#
			if(dofilter)
				{
				mysambar$sfs2Dlist_snpfilter[[i]]		<<- mymatrix
				names(mysambar$sfs2Dlist_snpfilter)[i]	<<- paste(pop1,"vs",pop2,sep=" ")
				}else{
				mysambar$sfs2Dlist_allsnps[[i]]			<<- mymatrix
				names(mysambar$sfs2Dlist_allsnps)[i]	<<- paste(pop1,"vs",pop2,sep=" ")
				}
			mysambar$sfscolours[[i]]	<<- myColours
			mysambar$sfsbreaks[[i]]		<<- myBreaks
			}else{
			mypoppair<-paste(pop1,"_",pop2,sep="")
			cat(paste("SFS vector of length 1 for pairwise population comparison:",mypoppair,sep=" "),sep="\n")
			cat("Outputting a table rather than a plot.",sep="\n")
			write.table(mymatrix,paste("SFS.2D",mypoppair,"txt",sep="."),quote=FALSE,row.names=TRUE,col.names=TRUE)
			}
		}
	}

wattersonplot<-function(export=NULL,do_expected=FALSE)
	{
	if(!"pop_ninds"%in%colnames(inds))
		{
		mynind			<- as.data.frame(table(inds$pop[inds$filter]))
		inds$pop_ninds	<- NA
		for (i in c(1:nrow(inds)))
			{
			mypop				<- inds$pop[i]
			mypop2				<- which(mynind$Var1==mypop)
			inds$pop_ninds[i]	<- mynind$Freq[mypop2]
			}
		}
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Watterson.numbers.pdf",height=6,width=6)}
		}
	par(cex.lab=1.5,cex.lab=1.5)
	plot(inds$pop_ninds,inds$nsegsites1,col=inds$popcol,pch=16,cex=1.5,xlab="# individuals",ylab="# segregating sites")
	legend("bottomright",legend=mysambar$populations,fill=mysambar$mycolours,bty='n',cex=1.25)
	#
	# expected S, based on harmonic (unfortunately results don't add up, so I don't include it):
	if(do_expected)
		{
		mymax 	<- max(inds$pop_ninds,na.rm=TRUE)+5
		myrange	<- c(1:mymax)
		myexp	<- vector()
		for(j in myrange)
			{
			myexp[j]	<- sum(1/c(1:(myrange[j]*2))) 
			}
		mypi	<- mean(inds$genomepi,na.rm=TRUE)
		expS	<- mypi*myexp
		}
	if(!is.null(export)){dev.off()}
	if(!"S"%in%colnames(inds))
		{
		cat("No column called 'S' in inds dataframe. Not generating 'Watterson.proportions' plot.",sep="\n")
		cat("The 'S' column is generated by calcdiversity() function if an input is provided to nsites argument.",sep="\n")
		}else{
		inds$harmonic			<<- NA
		for(j in c(1:nrow(inds)))
			{
			inds$harmonic[j]	<<- sum(1/c(1:(inds$pop_ninds[j]*2)))
			}
		if(!"genomepi_pop"%in%colnames(inds))
			{
			mynind					<- as.data.frame(table(inds$genomepi[inds$filter]))
			inds$genomepi_pop	<<- NA
			for (i in c(1:nrow(inds)))
				{
				mypop				<- inds$pop[i]
				mypivector		<- inds$genomepi[inds$pop==mypop]
				inds$genomepi_pop[i]	<<- mean(mypivector,na.rm=TRUE)
				}
			}
		if(!is.null(export))
			{
			if(export=="pdf"){pdf("Watterson.proportions.pdf",height=6,width=6)}
			}
		par(cex.lab=1.5,cex.lab=1.5)
		plot(inds$pop_ninds,inds$S,col=inds$popcol,pch=16,cex=1.5,xlab="# individuals",ylab="Proportion segregating sites")
		legend("bottomright",legend=mysambar$populations,fill=mysambar$mycolours,bty='n',cex=1.25)
		if(do_expected)
			{
			lines(myrange,expS)
			}
		if(!is.null(export)){dev.off()}
		}	
	}	

calcS<-function(popnames=mysambar$populations,export=NULL,plotexpected=FALSE,nsites=NULL,dofilter=FALSE,plotretainedinds=FALSE)
	{
	npops			<- length(popnames)
	ninds			<- nrow(inds[inds$filter,])
	if(dofilter)
		{
		myfilter	<- snps$filter
		}else{
		myfilter	<- rep(TRUE,nrow(snps))
		}
	nsnps			<- nrow(snps[myfilter,])
	polylist		<- list() 
	mymax			<- 1
	for (p in c(1:npops))
		{
		mypop		<- popnames[p]
		#cat(mypop,sep="\n")
		myinds		<- inds$nr[inds$pop==mypop&inds$filter]
		npopinds	<- length(myinds)
		npolyvec	<- rep(NA,npopinds)
		if(npopinds<2)
			{
			cat("Only one retained individual for population:",sep="\n")
			cat(mypop,sep="\n")
			return(cat("Exiting.",sep="\n"))
			}
		svec		<- rep(FALSE,nsnps)
		for (i in c(1:npopinds))
			{
			myind		<- myinds[i]
			mygeno		<- as.matrix(mygenlight[myind,myfilter])
			mygeno[is.na(mygeno)]	<- 3
			svec		<- svec|(mygeno==1|mygeno==2)
			npolyvec[i]	<- length(svec[svec])
			}
		mymax			<- ifelse(max(npolyvec)>mymax,max(npolyvec),mymax)
		polylist[[p]]	<- npolyvec
		}
	xmax	<- max(table(inds$pop[inds$filter]))
	if(!is.null(nsites))
		{
		maxnsites<- max(nsites)	# 01052020: in case of a vector, not sure if it makes sense
		mymax	<- mymax/maxnsites*100
		mysteps	<- ifelse(mymax>1,0.5,ifelse(mymax<0.2,0.05,0.1))
		y_lab	<- "segregating sites (%)"
		}else{
		mysteps	<- ifelse(mymax>20000,10000,ifelse(mymax<10000,1000,2000)) 
		y_lab	<- "# segregating sites (k)"
		}
	if(!is.null(export))
		{
		mylabel		<- ifelse(!is.null(nsites),"genomewide","snpsonly")
		if(export=="eps"){postscript(paste("S_vs_nind",mylabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("S_vs_nind",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("S_vs_nind",mylabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("S_vs_nind",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)
	#par(cex.axis=1.5,cex.lab=2,mar=c(5,6,2,1))
	plot(c(0,xmax),c(0,mymax),col="white",xlab="# individuals",ylab=y_lab,yaxt='n')
	myaxis	<- seq(0,mymax,mysteps)
	if(!is.null(nsites))
		{
		axis(2,at=myaxis,labels=myaxis)
		}else{
		axis(2,at=myaxis,labels=myaxis/1000)
		}
	#mtext("# segregating sites (k)",side=2,line=4,cex=2)
	#mtext("# individuals",side=1,line=3,cex=2)
	for (p in c(1:npops))
		{
		# observed:
		mypop		<- popnames[p]
		mypopcol	<- mysambar$mycolours[p]
		if(is.null(nsites))
			{
			lines(polylist[[p]],col=mypopcol,lwd=4)
			}else{
			maxnsites	<- max(nsites)
			lines(polylist[[p]]/maxnsites*100,col=mypopcol,lwd=4)
			}
		if(plotexpected)
			{
			mypi		<- inds$pi2[inds$pop==mypop][1]
			nind		<- length(polylist[[p]]) 
			an			<- cumsum(1/(seq(2,ninds,2)))	# harmonic number: 2 sequences per individual
			mywat		<- 2*mypi*an	# why times 2? no idea if it makes sense
			lines(mywat,col=mypopcol,lty=2,lwd=3.5)
			}
		if(plotretainedinds)
			{
			abline(v=nrow(inds[inds$pop==mypop&inds$filter,]),col=mypopcol,lty=2,lwd=0.5)
			}
		}
	# legend:
	legend("bottom",legend=popnames,cex=3,fill=mysambar$mycolours,bty="n")
	if(!is.null(export)){dev.off()}
	}
	
# Plot output from PLINK (linkage disequilibrium):
LD_plot<-function(export=NULL,doimport=TRUE,silent=FALSE,doboxplot=TRUE,addstripchart=FALSE,dopopboxplot=FALSE,doscatter=TRUE,plotmeans=TRUE,popnames=mysambar$populations,maxr2filter=TRUE,inverse=FALSE,xrange=c(0,1000000),stepsize=100000,cols=NULL,myxmax=1,xloc=0.6,yloc=0.9,legendsize=2.5,symbolsize=2.5,yaxismax=1,axiscex=1,axislabelcex=3.5,xlabdistance=5.5,ylabdistance=4,symboltype=c(17,20,18,15),nsequences=100,showmedian=FALSE)
	{
	cat("REMINDER: Use xrange (default is c(0,1000000) and stepsize (default is 100000) to set distance bins.",sep="\n")
	# This function expects to find inputfiles files generated by plink R2 command called after the names of the populations.
	npops				<- length(popnames)
	if(is.null(cols))
		{
		cols	<- mysambar$mycolours[1:npops]
		}
	# set distance bins and their labels (midpoints):
	br					<- seq(xrange[1],xrange[2],stepsize)
	mids				<- vector() 
	for(i in c(1:length(br)-1))
		{
		mids[i]			<- sum(br[i],br[i+1])/2
		}
	if(doimport)
		{
		# read data from plink output (ld files created by plink R2 command) and divide into distance bins:
		setwd(mysambar$inputfilesdir)
		cat("Importing files from directory:",sep="\n")
		cat(getwd(),sep="\n")
		mylist				<- list()
		for (i in c(1:npops))
			{
			myinputfile				<- paste(popnames[i],"ld",sep=".")
			if(!myinputfile%in%list.files())
				{
				return(cat(paste("ERROR: Could not find file called ",myinputfile,".",sep=""),sep="\n"))
				}
			mylist[[i]]				<- read.table(paste(popnames[i],"ld",sep="."),header=TRUE)
			colnames(mylist[[i]])	<- c("CHR_A","BP_A","SNP_A","CHR_B","BP_B","SNP_B","R2")  	# not really necessary, but just in case spaces in input files causes problems
			mylist[[i]]$dist		<- (mylist[[i]]$BP_B-mylist[[i]]$BP_A)
			mylist[[i]]$below1		<- ifelse(!(mylist[[i]]$R2==1&maxr2filter==TRUE),TRUE,FALSE)
			mylist[[i]]$distclass	<- cut(mylist[[i]]$dist,breaks=br,labels=mids) 
			mylist[[i]]$pop			<- as.factor(popnames[i])
			}
		names(mylist)				<- popnames
		mylist						<<- mylist
		x							<- do.call(rbind,mylist)
		LDtable						<<- x
		cat("Plink LD estimates stored in a dataframe called 'LDtable'.",sep="\n")
		}else{
		x	<- LDtable
		}
	# 
	if(dopopboxplot)
		{
		for (i in c(1:length(popnames)))
			{
			popdata		<- mylist[[i]]
			myyaxt		<- ifelse(i==1,'s','n')
			boxplot(popdata$R2~popdata$distclass,outline=FALSE,col=cols[i],ylim=c(0,1),xaxt='n',yaxt=myyaxt)
			axis(side=1,labels=mids/100000,at=mids)
			axis(side=1)
			mtext(side=3,popnames[i],line=0,cex=2)
			}
		}
	# scatter plot:	
	setwd(mysambar$diversitydir)
	if(doscatter)
		{
		if(!silent){cat("LDscatter",sep="\n")}
		if(!is.null(export))
			{
			if(export=="eps"){postscript("LDscatter.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("LDscatter.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("LDscatter.png",family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile("LDscatter.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		if(nrow(LDtable)>10000)
			{
			mysample	<- sample(c(1:nrow(LDtable)),10000,replace = FALSE)
			xsample		<- LDtable[mysample,]
			}else{
			xsample		<- LDtable 
			}
		plot(xsample$dist,xsample$R2,col="white",xlab="Distance (bp)",ylab="R2")
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			mycol	<- cols[j]
			points(xsample$dist[xsample$pop==mypop],xsample$R2[xsample$pop==mypop],col=mycol,xlab="Distance (bp)",pch=16,cex=0.5)
			}
		legend("topright",popnames,fill=cols[1:npops],bty='n',cex=legendsize)
		if(!is.null(export))
			{
			dev.off()
			cat("A file called  has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	# boxplot:
	if(doboxplot)
		{
		if(!silent){cat("LD.boxplot",sep="\n")}
		cat("If you receive an error, try again without the boxplot by typing: LD_plot(doboxplot=FALSE).",sep="\n")
		graphics.off()
		if(!is.null(export))
			{
			plotname	<- ifelse(addstripchart,"LD.boxplot.stripchart","LD.boxplot")
			stepsize2	<- stepsize/1000
			if(export=="eps"){postscript(paste(plotname,paste(stepsize2,"K",sep=""),"eps",sep="."),family=mysambar$myfont,width=8,height=8)}
			if(export=="pdf"){pdf(paste(plotname,paste(stepsize2,"K",sep=""),"pdf",sep="."),family=mysambar$myfont,width=8,height=8)}
			if(export=="png"){png(paste(plotname,paste(stepsize2,"K",sep=""),"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotname,paste(stepsize2,"K",sep=""),"wmf",sep="."),family=mysambar$myfont,width=8,height=8)}
			}
		par(mar=c(6,5,1,1),cex.axis=1.5,cex.main=2.5)
		mydistclass	<- as.vector(x$distclass)
		mydistclass	<- mydistclass[!is.na(mydistclass)]
		mybins	<- as.vector(unique(mydistclass))
		#nclass	<- length(mybins)-1
		nclass	<- length(mybins)
		myloc	<- c(1:(nclass*(npops+1)-1))
		myloc2	<- myloc[myloc%%(npops+1)!=0]	
		boxplot(x$R2~as.vector(x$distclass)*as.vector(x$pop),outline=FALSE,col=mysambar$mycolours[1:npops],ylim=c(0,1),xaxt='n',at=myloc2,las=1,xlab="",ylab="")
		if(addstripchart)
			{
			cat("If you receive an error, try again without the boxplot by typing: LD_plot(addstripchart=FALSE).",sep="\n")
			mysample<-sample(c(1:nrow(x)),5000,replace = FALSE)
			xsample	<- x[mysample,]
			stripchart(R2~as.vector(distclass)*as.vector(pop),data=xsample,vertical=TRUE,method="jitter",pch=16,cex=0.5,col="grey50",bg="bisque",las=2,at=myloc2,xlab="",ylab="",add=TRUE) 
			}
		legend("topright",popnames,fill=cols[1:npops],bty='n',cex=2)
		if(plotmeans)
			{
			# 14-04-2020: This seems to give strange results (probably because sorting a factor complicates the analysis), so I excluded it for now:
			# add means:
			mymeans <- aggregate(R2 ~ pop*distclass, x, mean)
			points(myloc2,mymeans$R2,pch=21,col="black",cex=1.5,bg="white")
			#
			}
		# add xaxis:
		labelloc1<- round(mean(1:npops))
		labelloc2<- seq(labelloc1,nclass*(npops+1),(npops+1))
		#
		axis(side=1,at=labelloc2,label=(mids/100000)[1:nclass],las=2)
		mtext(side=1,"Physical distance (100 kB)",line=4.5,cex=2.5)
		mtext(side=2,"LD (r2)",line=3,cex=2.5)
		if(!is.null(export))
			{
			dev.off()
			cat("A file called LD.boxplot has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	#
	# 14-04-2020: This seems to give strange results (probably because sorting a factor complicates the analysis), so I excluded it for now:
	if(plotmeans)
		{
		if(!silent){cat("LDmean",sep="\n")}
		# calculate mean per dataclass:
		r2matrix				<<- matrix(nrow=(length(popnames)+1),ncol=(length(br)-1))
		r2matrix[1,]			<<- mids
		r2medianmat				<<- r2matrix
		for(i in c(1:length(br)-1))
			{ 
			temp				<- mids[i]
			for (j in c(1:npops))
				{
				#cat(j,sep="\n")
				#cat((names(mylist)[j]),sep="\n")
				r2matrix[j+1,i]		<<- ifelse(inverse,1/(mean(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE)),mean(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE))
				r2medianmat[j+1,i]	<<- ifelse(inverse,1/(median(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE)),median(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE))
				}
			}
		# Plot means only:
		if(!is.null(export))
			{
			setwd(mysambar$diversitydir)
			graphics.off()
			plotlabel	<- ifelse(is.null(nsequences),"LDmean","LDmean_expected")
			if(export=="eps"){postscript(paste(plotlabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf(paste(plotlabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png(paste(plotlabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotlabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5,7,5,2),oma=c(2,0,2,0),cex.axis=2,cex.lab=axislabelcex,cex.main=3.5)
		xaxismax			<<- myxmax*xrange[2]
		if(is.null(yaxismax))
			{
			yaxismax			<<- max(r2matrix[2:length(popnames),],na.rm=TRUE)
			}
		#plot(r2matrix[1,],r2matrix[2,],pch=symboltype[1],col=cols[1],xaxt="n",xlab="Physical distance (100 kb)",ylab="",cex=2.5,ylim=c(0,yaxismax),xlim=c(0,xaxismax),bty="n")
		plot(r2matrix[1,],r2matrix[2,],pch=16,col=cols[1],xlab="",ylab="",xaxt='n',cex=2.5,ylim=c(0,yaxismax),xlim=c(0,xaxismax),bty="n",las=1)
		if(showmedian)
			{
			points(r2medianmat[1,],r2medianmat[2,],pch=17,col=cols[1],cex=1)
			}
		axis(side=1,at=seq(0,xaxismax,100000),labels=(seq(0,xaxismax,100000)/100000),lty=1,las=1,mgp=c(3,2,0))
		mtext("Physical distance (100 kb)",side=1,cex=axislabelcex,line=xlabdistance)
		#ylabel			<- ifelse(inverse,"1/(mean R2)","mean R2")
		mtext("LD (mean R2)",side=2,cex=axislabelcex,line=ylabdistance)
		for (i in c(2:length(popnames)))
			{
			#if(length(popnames)<=4)
			#	{
			#	points(r2matrix[1,],r2matrix[i+1,],pch=symboltype[i],col=cols[i],cex=2.5,xlim=c(0,xaxismax))
			#	}else{
				points(r2matrix[1,],r2matrix[i+1,],pch=16,col=cols[i],cex=symbolsize,xlim=c(0,xaxismax))
				if(showmedian)
					{
					points(r2medianmat[1,],r2medianmat[i+1,],pch=17,col=cols[i],cex=1)
					}
			#	}
			}
		if(!is.null(nsequences))
			{
			expld(Ne=50,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="black",xmax=max(xrange))
			expld(Ne=100,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey20",xmax=max(xrange))
			expld(Ne=500,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey40",xmax=max(xrange))
			expld(Ne=1000,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey60",xmax=max(xrange))
			expld(Ne=5000,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey80",xmax=max(xrange))
			expld(Ne=10000,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey90",xmax=max(xrange))
			legend("topleft",legend=c("50","100","500","1000","5000","10000"),fill=c("black","grey20","grey40","grey60","grey80","grey90"),cex=2,bty='n')
			}	
		#if(length(popnames)<=4)
		#	{
		#	legend(x=xloc*xaxismax,y=yloc*yaxismax,legend=popnames,pch=symboltype,fill=cols,cex=legendsize,bty="n")
		#	}else{
			#legend(x=xloc*xaxismax,y=yloc*yaxismax,legend=popnames,fill=cols,cex=legendsize,bty="n")
			legend("topright",legend=popnames,fill=cols,cex=legendsize,bty='n')
		#	}
		if(!is.null(export))
			{
			dev.off()
			cat("A file called LDmean has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	setwd(mysambar$inputdatadir)
	}

expld<-function(Ne=50,n=60,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=FALSE,mycol="black",xmax=1000000)
	{
	# It is assumed that for the recombination rate per generation (r) is 0.01 per 1Mb
	# Hence, the population mutation rate (4*Ne*r) equals 0.04*Ne*d, in which d is the distance between two loci in Mb (so 1 means 1 Mb)
	#
	d		<- seq(stepsize,maxdistance,stepsize)
	r		<- d*0.01
	p		<- 4*Ne*r
	# probability no crossing-over:
	pr0		<- (18+p)/(18+13*p+p^2)
	# expected r2:
	x1		<- (10+p)/((2+p)*(11+p))
	x2		<- (3+p)*(12+12*p+p^2)
	x3		<- n*(2+p)*(11+p)
	ld		<- x1*(1+x2/x3)  
	if(doplot)
		{
		plot(d,ld,ylim=c(0,1),type='l',col=mycol,xlab="Physical distance (Mb)",ylab="LD (r2)")
		abline(h=1/n,lty=2)
		}
	if(addline)
		{
		d<-d*1000000*(xmax/1000000)
		lines(d,ld,ylim=c(0,1),type='l',col=mycol)
		abline(h=1/n,lty=2)
		}
	}

LDperchrom<-function(addX=FALSE,popnames=mysambar$populations,export=NULL,maxr2filter=TRUE,cols=as.vector(unique(inds$popcol)))
	{
	# This function expects to find inputfiles subdirectory files generated by plink R2 command called after the names of the populations.
	setwd(mysambar$inputfilesdir)
	# read data from plink output (ld files created by plink R2 command) and add columns: 
	mylist	<- list()
	for (i in c(1:length(popnames)))
		{
		mylist[[i]]				<- read.table(paste(popnames[i],"ld",sep="."),header=TRUE)
		colnames(mylist[[i]])	<- c("CHR_A","BP_A","SNP_A","CHR_B","BP_B","SNP_B","R2")  	# not really necessary, but just in case spaces in input files causes problems
		mylist[[i]]$dist		<- mylist[[i]]$BP_B-mylist[[i]]$BP_A
		mylist[[i]]$below1		<- ifelse(!(mylist[[i]]$R2==1&maxr2filter==TRUE),TRUE,FALSE)
		mylist[[i]]$distclass	<- cut(mylist[[i]]$dist,breaks=br,labels=mids) 
		}
	names(mylist)				<- popnames
	# Calculate LD per chrom:
	mychroms					<- sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
	if(addX){mychroms			<- c(mychroms,"X")}
	LDmatrix					<<- matrix(ncol=length(popnames),nrow=length(mychroms))
	rownames(LDmatrix)			<<- mychroms
	colnames(LDmatrix)			<<- popnames
	for (i in c(1:length(popnames)))
		{
		for (i in mychroms)
			{
			temp				<- mylist[[j]]$R2[mylist[[j]]$CHR_A==i&mylist[[j]]$below1]
			LDmatrix[i,j]		<<- round(mean(temp,na.rm=TRUE),3)
			}
		}
	setwd(mysambar$diversitydir)
	write.table(LDmatrix,file="LDperchrom.txt",na="NA",row.names=TRUE,col.names=TRUE,sep="\n",quote=FALSE)
	setwd(mysambar$inputdatadir)
	}

# Boxplots of differences in maf between adjacent snps.
# Not entirely sure how this relates to LD. 
multimafdiff<-function(export=FALSE,popnames=mysambar$populations,mymaxdistances=c(500,10000,500000),my_log="",do_boxplot=TRUE,do_scatterplot=TRUE,addoutliers=FALSE)
	{
	if(!"dist" %in% colnames(snps))
		{
		return(cat("ERROR: no column called dist in snps dataframe.",sep="\n"))
		}
	npop	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npop]
	if(do_boxplot)
		{
		if(export){pdf("DeltaMAF_vs_spacing.pdf",width=9,height=npop*3)}
		par(mfrow=c(3,npop),oma=c(2,5,2.5,1),mar=c(4,0.5,0.5,0.5),cex.axis=1.5)
		for (k in c(1:3))
			{
			mydistance	<- mymaxdistances[k]
			mystepsize	<- mydistance/10
			for(p in c(1:npop))
				{
				mypop	<- popnames[p]
				mypopcol<- mycols[p]
				mypopmaf<- snps[,paste("maf",mypop,sep="_")]
				add_y	<- ifelse(p==1,TRUE,FALSE)
				mytitle	<- ifelse(k==1,mypop,"")
				if(k==1)
					{
					mafdiff(mypopmaf,mycol=mypopcol,plottitle=mytitle,addyaxis=add_y,addylabel=FALSE,stepsize=mystepsize,distrange=c(0,mydistance),mylog=my_log,addtosnps=TRUE)
					names(snps)[names(snps)=="mafdiff"]	<<- paste("mafdiff",mypop,sep="_")
					}else{
					mafdiff(mypopmaf,mycol=mypopcol,plottitle=mytitle,addyaxis=add_y,addylabel=FALSE,stepsize=mystepsize,distrange=c(0,mydistance),mylog=my_log,addtosnps=FALSE)
					}
				}
			}
		mtext("SNP spacing (kb)",side=1,cex=2,line=0.5,outer=TRUE)
		mtext(side=2,line=2.5,"MAF difference",cex=2,outer=TRUE)
		if(export){dev.off()}
		}
	snps 	<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	if(do_scatterplot&npop>1)
		{
		if(export)
			{
			n_pair	<- ncol(combitable)
			mywidth	<- ifelse(n_pair==2,10,15)
			myheight<- ifelse(n_pair==2,5,ifelse(n_pair==3,15,ifelse(n_pair>3&n_pair<7,10,ifelse(n_pair>6&n_pair<10,15,20))))
			pdf("DeltaMAF_interpopulation.pdf",height=myheight,width=mywidth)
			}
		par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5),mar=c(5,6,2.5,2))
		combitable		<<- combn(popnames,m=2)
		for (j in c(1:ncol(combitable)))
			{
			mypop1	<- combitable[1,j]
			mypop2	<- combitable[2,j]
			mylabel	<- paste(mypop1,mypop2,sep="_")
			mydiff1	<- snps[,paste("mafdiff",mypop1,sep="_")]
			mydiff2	<- snps[,paste("mafdiff",mypop2,sep="_")]
			diffmat	<- as.data.frame(cbind(mydiff1,mydiff2))
			colnames(diffmat)	<- c("pop1","pop2")
			if(addoutliers)
				{
				diffmat$out<-snps$rfisherout_pheno
				}
			diffmat	<- as.data.frame(unique(diffmat))
			plot(diffmat$pop2[snps$filter2],diffmat$pop1[snps$filter2],xlim=c(0,1),ylim=c(0,1),pch=16,cex=0.75,las=1,cex.axis=1.5,ylab="",xlab="")
			if(addoutliers)
				{
				outmat<- diffmat[diffmat$out,]
				outmat	<<- outmat
				points(outmat$pop2[2],outmat$pop1[2],col="red",pch=16,cex=2)
				points(outmat$pop2[3],outmat$pop1[3],col="red",cex=2)
				}
			mtext(paste(mypop2,"Delta_MAF",sep=" "),side=1,line=3.5,cex=2.5)
			mtext(paste(mypop1,"Delta_MAF",sep=" "),side=2,line=3.5,cex=2.5)
			}
		if(export){dev.off()}
		
		}
	}

mafdiff<-function(mymaf=snps$maf,stepsize=500,doboxplot=TRUE,distrange=c(0,10000),mycol="grey",addylabel=TRUE,addyaxis=TRUE,plottitle=NULL,mylog="",addtosnps=FALSE)
	{
	if(!"dist" %in% colnames(snps))
		{
		return(cat("ERROR: no column called dist in snps dataframe.",sep="\n"))
		}
	# calculate difference in maf between adjacent snps:
	new_chr			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	new_chr			<- c(TRUE,new_chr[1:(length(new_chr)-1)])
	mymaf1			<- mymaf
	mymaf2			<- c(as.vector(mymaf[2:length(mymaf)]),NA)
	mydiff			<- mymaf2-mymaf1
	mydiff			<- abs(c(NA,mydiff[1:(length(mydiff)-1)]))
	mydiff[new_chr]	<- NA
	# set distance bins and their labels (midpoints):
	br					<- seq(distrange[1],distrange[2],stepsize)
	mids				<- vector() 
	for(i in c(1:length(br)-1))
		{
  		mids[i]			<- sum(br[i],br[i+1])/2
		}	
	mids				<- mids/1000
	mydistclass			<- cut(snps$dist,breaks=br,labels=mids) 
	#meanperdistclass	<<- aggregate(mydiff,list(mydistclass),mean)
	myyaxt				<- ifelse(addyaxis,'s','n')
	if(doboxplot)
		{
		if(mylog=="y")
			{
			boxplot(mydiff[snps$filter2&mydiff!=0]~mydistclass[snps$filter2&mydiff!=0],las=2,col=mycol,ylim=c(0.0001,1),yaxt=myyaxt,log=mylog)
			}else{
			boxplot(mydiff[snps$filter2&!is.na(mydiff)]~mydistclass[snps$filter2&!is.na(mydiff)],las=2,col=mycol,ylim=c(0,1),yaxt=myyaxt,log=mylog)
			}
		if(addylabel)
			{
			mtext(side=2,line=2.5,"MAF difference",cex=2)
			}
		if(!is.null(plottitle))
			{
			mtext(plottitle,side=3,line=0.5,cex=1.5)
			}
		}
	if(addtosnps)
		{
		snps$mafdiff		<<- mydiff
		}
	mydiff	<<- as.data.frame(cbind(mymaf1,mymaf2,mydiff)) 
	}

homorun<-function(export=NULL,sims=FALSE,input=mygenlight,popnames=mysambar$populations,indselection=inds$filter,snpselection=snps$filter,maxrohlength=100,lowmaf=TRUE,colourcode=inds$popcol)
	{
	# 19032019: I removed simulations because I run into ERROR after changing from line plot to boxplot
	npops	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npops]
	if(!(any(names(snps)=="dist")))
		{
		return(cat("ERROR: snps$dist column missing. This function can only be executed if you know the location of your snps.",sep="\n"))
		}
	nindsperpop			<- as.vector(table(inds$pop[inds$filter]))
	if(any(nindsperpop<5))
		{
		return(cat("Some populations contain less than 5 retained individuals. SambaR will not generate ROH plot.",sep="\n"))
		}
	# First we need to calculate mean spacing:
	if(any(snps$autosomal))
		{
		meanspacing			<- mean(snps$dist[snps$autosomal],na.rm=TRUE)	
		medianspacing		<- median(snps$dist[snps$autosomal],na.rm=TRUE)
		}else{
		meanspacing			<- mean(snps$dist,na.rm=TRUE)	
		medianspacing		<- median(snps$dist,na.rm=TRUE)
		}
	# Now create dataframe in which these values are multiplied with various numbers of snps:
	rohlength			<- c(1:maxrohlength)
	meanbp				<- rohlength*meanspacing
	medianbp			<- rohlength*medianspacing
	roh					<- data.frame(rohlength,meanbp,medianbp)
	# Select snps:
	if(lowmaf==TRUE)
		{
		if(any(snps$autosomal))
			{
			snpselect		<- snps$filter&snps$autosomal&snps$maf<0.1  
			}else{
			snpselect		<- snps$filter&snps$maf<0.1 
			}
		}else{
		if(any(snps&autosomal))
			{
			snpselect		<- snps$filter&snps$autosomal&snps$maf>0.1
			}else{
			snpselect		<- snps$filter&snps$maf>0.1
			}
		}
	mymatrix			<- as.matrix(input[,snpselect])
	if(length(mymatrix[is.na(mymatrix)])/(nrow(mymatrix)*ncol(mymatrix))>0.2)
		{
		return(cat("More than 20 percent missing data points. SambaR will not generate ROH-plot.",sep="\n"))
		}
	# Do the actual calculation:
	for (j in (1:npops))
		{
		mypop			<- popnames[j]
		mycol			<- mycols[j]
		# Select individuals:
		indnr			<- inds$nr[indselection&inds$pop==popnames[j]] 
		# Now calculate for each selected individual roh-lengths:
		for (i in indnr)
			{ 
			sample				<- mymatrix[inds$nr==i,]
			sample				<- sample[!is.na(sample)]
			# Give minor homozygotes and major homozygotes the same code (0):
			for (k in (1:(length(sample))))
				{
				sample[k]		<-ifelse(sample[k]==1,1,0)
				}
			# Now we are ready to apply the rle-function:
			temp				<- rle(sample)
			temp2				<- cbind(as.data.frame(temp$values),as.data.frame(temp$length))
			colnames(temp2)		<- c("values","length")
			# select runs of homozygosity:
			temp2				<- temp2[temp2$values==0,]
			# Count the occurences of each rohlength:
			results				<- as.data.frame(table(temp2$length))
			colnames(results)	<- c("rohlength","count")
			results$rohlength	<- as.numeric(results$rohlength)
			# What is the frequency?
			results$count		<- as.numeric(results$count)
			results$freq		<- results$count/(sum(results$count))
			results$freqsum		<- cumsum(results$freq)
			results$p		<- ifelse(results$rohlength==1,1,NA)
			for (l in (2:(nrow(results))))
				{
				results$p[l]	<- 1-results$freqsum[l-1]
				}
			results$count		<- NULL
			results$freq		<- NULL
			results$freqsum		<- NULL
			roh					<- merge(x=roh, y=results, by="rohlength", all=TRUE)
			#lines(roh$rohlength[1:125],roh[1:125,ncol(roh)],col=mycol,ann=FALSE,xlim=c(0,100))
			names(roh)[ncol(roh)] 	<- paste0("sample", i)
			} # end of ind loop 
		} # end of population loop 
	# Plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="wmf"){win.metafile("ROH.wmf",height=6,width=12)}
		if(export=="pdf"){pdf("ROH.pdf",height=6,width=12)}
		}
	#plot(rohlength,rep(0.5,100),ylim=c(0,1),col="white",ann=FALSE,xlim=c(0,100))
	for(j in c(1:npops))
		{
		mypop	<- popnames[j]
		mycol	<- mycols[j]
		roh2	<- t(roh)
		temp	<- roh2[4:nrow(roh2),]
		my_pops	<- inds$pop[inds$filter]
		my_inds	<- my_pops==mypop 
		temp2	<- temp[my_inds,]
		addplot	<- ifelse(j==1,FALSE,TRUE)
		myaxt	<- ifelse(j==1,'s','n')
		boxplot(temp2,use.cols=TRUE,col=mycol,outline=FALSE,las=2,add=addplot,xaxt=myaxt,yaxt='n',cex.axis=0.75)
		}
	axis(side=2,cex=1.5,las=1)
	mtext("ROH length (number of snps)",side=1,line=3,cex=2)
	mtext("Probability",side=2,line=2.5,cex=2)
	mtext("Runs of homozygosity",side=3,line=0.5,cex=2)
	legend("topright",legend=popnames,fill=mycols,cex = 1,bty='n')
	if(!is.null(export)){dev.off()}
	}		

# careful: heavy plot!
genoheatmap<-function(export=FALSE,dofilter=TRUE)
	{
	genlighttemp	<- mygenlight[order(as.character(inds$pop)),]
	indstemp		<- inds[order(as.character(inds$pop)),]
	if(dofilter)
		{
		mysamples		<- indstemp$name[indstemp$filter]
		}else{
		mysamples		<- indstemp$name
		}
	nsamples		<- length(mysamples)
	#
	if(export)
		{
		plotname	<- ifelse(dofilter,"Genotypes.filtered.pdf","Genotypes.alldata.pdf")
		pdf(plotname,height=nsamples*0.14+5,width=30)
		}
	par(mar=c(5,5,3,10))
	if(dofilter)
		{
		glPlot(genlighttemp[indstemp$filter,snps$filter],col=c("black","blue","yellow"),legend=TRUE,posi="bottomleft",yaxt='n',mar=c(3,3,3,6))
		}else{
		glPlot(genlighttemp,col=c("black","blue","yellow"),legend=TRUE,posi="bottomleft",yaxt='n',mar=c(3,3,3,6))
		}
	axis(side=4,at=seq(1,nsamples,1),label=rev(mysamples),cex=0.25,las=1)
	if(export){dev.off()}
	}

# Function to create Mondriaan plot:
multiglPlots<-function(popnames=mysambar$populations,chromosome=1,mycols=as.vector(unique(inds$popcol)),export=NULL)
	{
	setwd(mysambar$diversitydir)
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("ROH.eps",family=mysambar$myfont,width=6,height=8)}
		if(export=="pdf"){pdf("ROH.pdf",family=mysambar$myfont,width=6,height=8)}
		if(export=="png"){png("ROH.png",family=mysambar$myfont,width=540,height=720)}
		if(export=="wmf"){win.metafile("ROH.wmf",family=mysambar$myfont,width=6,height=8)}
		}
	if(any(names(snps) == "chr"))
		{
		par(mfrow=c(length(popnames),1),mai=c(0.05,0.05,0.05,0.05),oma=c(3.5,3.5,2,0))
		for (i in (1:(length(popnames))))
			{ 
			mycol<-c("black",mycols[i],"grey20")
			glPlot(mygenlight[inds$filter&inds$pop==popnames[i],snps$filter&snps$chr==chromosome],col=mycol,legend=FALSE,main="") 
			mtext(popnames[i],side=2,line=2.5)
			}
		}else{
		print("Snps-dataset should contains a vector called 'chr' with information about the location of the snp")
		}
	mtext("SNP ID",side=1,line=2,outer=TRUE)
	mtext(paste("Chromosome",chromosome,sep=" "),side=3,line=0.3,outer=TRUE,font=2)
	if(!is.null(export)){dev.off()}
	setwd(mysambar$inputdatadir)
	}
   
# End of genetic diversity analyses 
###############################################################################################################










###############################################################################################################
# Kinship/relatedness calculations

calckinship<-function(silent=TRUE,calcF=TRUE,plot_inbreeding=TRUE,F_correct_maf=TRUE,overwrite_kindf=TRUE,do_wahlund=TRUE)
	{
	setwd(mysambar$sambardir)
	kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
	if(!overwrite_kindf&is.null(mysambar$kindf))
		{
		cat("WARNING: the flag 'overwrite_kindf' is set to FALSE but mysambar$kindf does not exist. Setting the flag to TRUE.",sep="\n")
		overwrite_kindf	<- TRUE
		}
	if(!dir.exists("Kinship"))
		{
		if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
		dir.create(file.path(kinshipdir))
		mysambar$kinshipdir	<<- kinshipdir
		setwd(kinshipdir)
		}else{
		setwd(kinshipdir)
		if(!silent){cat("Overwriting results in directory:",sep="\n")}
		cat(getwd(),sep="\n")	
		}
	#
	if(calcF)
		{
		if(!silent){cat("calc_indF(correctmaf=FALSE)",sep="\n")}
		calc_indF(correctmaf=FALSE)
		if(plot_inbreeding)
			{
			cat("Plotting individual inbreeding statistics. If you receive an error after this line, rerun the calckinship function with the flag plot_inbreeding set to FALSE.",sep="\n")
			if(!silent){cat("plot_indF",sep="\n")}
			plot_indF(export="eps",plotname="Inbreeding")	
			plot_indF(export="pdf",plotname="Inbreeding")
			plot_indF(export="png",plotname="Inbreeding")
			if(!silent){cat("plotscatter_indF",sep="\n")}
			plotscatter_indF(dolabels=TRUE,export="eps")
			plotscatter_indF(dolabels=TRUE,export="png")
			plotscatter_indF(dolabels=TRUE,export="pdf")
			if(mysambar$os=="Windows"){plotscatter_indF(dolabels=TRUE,export="wmf")}
			if(!silent){cat("barplotF_perind",sep="\n")}
			barplotF_perind(export="eps")
			barplotF_perind(export="pdf")
			barplotF_perind(export="png")
			if(mysambar$os=="Windows"){barplotF_perind(export="wmf")}
			FvsHe(export="eps",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE)
			FvsHe(export="pdf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE)
			FvsHe(export="png",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE)}
			FvsHe(export="eps",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE)
			FvsHe(export="pdf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE)
			FvsHe(export="png",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE)}
			}
		if(!silent){cat("calc_indF(correctmaf=TRUE)",sep="\n")}
		if(F_correct_maf)
			{
			cat("Calculating individual inbreeding statistics using corrected minor allele frequencies (excluding individual under investigation). If you receive an error after this line, rerun the filterdata function with the flag F_correct_maf set to FALSE.",sep="\n")
			calc_indF(correctmaf=TRUE)
			if(!silent){cat("plot_indF(plotname='Inbreeding_corrected')",sep="\n")}
			plot_indF(export="eps",plotname="Inbreeding_corrected",Fcorrect=TRUE)	
			plot_indF(export="pdf",plotname="Inbreeding_corrected",Fcorrect=TRUE)
			plot_indF(export="png",plotname="Inbreeding_corrected",Fcorrect=TRUE)
			if(mysambar$os=="Windows"){plot_indF(export="png",plotname="Inbreeding_corrected",Fcorrect=TRUE)}
			FvsHe(export="eps",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE)
			FvsHe(export="pdf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE)
			FvsHe(export="png",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE)}
			FvsHe(export="eps",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE)
			FvsHe(export="pdf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE)
			FvsHe(export="png",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE)}
			}
		if(!silent){cat("expHe_vs_He",sep="\n")}
		expHe_vs_He(export="eps",allsites=FALSE)
		expHe_vs_He(export="pdf",allsites=FALSE)
		expHe_vs_He(export="png",allsites=FALSE)
		if(mysambar$os=="Windows"){expHe_vs_He(export="wmf",allsites=FALSE)}
		if(!silent){cat("expHe_vs_He allsites",sep="\n")}
		expHe_vs_He(export="eps",allsites=TRUE)
		expHe_vs_He(export="pdf",allsites=TRUE)
		expHe_vs_He(export="png",allsites=TRUE)
		if(mysambar$os=="Windows"){expHe_vs_He(export="wmf",allsites=TRUE)}
		}
	if(!silent){cat("Calculating kinship...",sep="\n")}
	calckin(do_overwrite=overwrite_kindf,export="pdf")
	multi_geno2Dmat(kindf=mysambar$kindf,maxplots=20,mythres=0.4,export_type="pdf")
	if(!silent){cat("Creating boxplots...",sep="\n")}
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_kingrobust",kinshipscore="kingrobust",ylabel="King-robust score",yline=4.5,onlywithin=TRUE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot",kinshipscore="kincoef",ylabel="Relatedness coefficient",yline=4.5,onlywithin=TRUE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_k2",kinshipscore="k2",ylabel="Proportion identical genotypes",yline=4.5,onlywithin=TRUE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_kingrobust",kinshipscore="kingrobust",ylabel="King-robust score",yline=4.5,onlywithin=FALSE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot",kinshipscore="kincoef",ylabel="Relatedness coefficient",yline=4.5,onlywithin=FALSE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_k2",kinshipscore="k2",ylabel="Proportion identical genotypes",yline=4.5,onlywithin=FALSE)
	#
	# F vs kin:
	Fvskin(dolabels=FALSE,export="eps",limitrange=FALSE)
	Fvskin(dolabels=FALSE,export="pdf",limitrange=FALSE)
	Fvskin(dolabels=FALSE,export="png",limitrange=FALSE)
	Fvskin(dolabels=TRUE,export="eps",limitrange=FALSE)
	Fvskin(dolabels=TRUE,export="pdf",limitrange=FALSE)
	Fvskin(dolabels=TRUE,export="png",limitrange=FALSE)
	Fvskin(dolabels=FALSE,export="eps",limitrange=TRUE)
	Fvskin(dolabels=FALSE,export="pdf",limitrange=TRUE)
	Fvskin(dolabels=FALSE,export="png",limitrange=TRUE)
	Fvskin(dolabels=TRUE,export="eps",limitrange=TRUE)
	Fvskin(dolabels=TRUE,export="pdf",limitrange=TRUE)
	Fvskin(dolabels=TRUE,export="png",limitrange=TRUE)
	if(do_wahlund)
		{
		cat("Creating Wahlund effect plot. If you receive an error after this line, set the flag do_wahlund to FALSE.",sep="\n")
		wahlundplot(export="eps")
		wahlundplot(export="pdf")
		wahlundplot(export="png")
		#if(mysambar$os=="Windows"){wahlundplot(export="wmf")}
		}
	}

calckin<-function(exporttype=NULL,use_currentdir=TRUE,silent=TRUE,legendcex=2.5,do_overwrite=FALSE,kinthreshold=0.4)
	{
	my_wd		<- getwd()
	myinds		<- inds$nr
	combitable	<- combn(myinds,m=2)
	npairs		<- ncol(combitable)
	if(!is.null(mysambar$kindf)&!do_overwrite)
		{
		if(!silent){cat("Using existing dataframe with relatedness estimates.",sep="\n")}
		kindf	<- mysambar$kindf
		}else{
		setwd(mysambar$inputdatadir)
		if(file.exists("pairwise_relatedness.txt")&!do_overwrite)
			{
			if(!silent){cat("Reading file 'pairwise_relatedness.txt'.",sep="\n")}
			mydftemp	<- read.table("pairwise_relatedness.txt",header=TRUE,comment.char="")
			}else{
			# create dummy:
			mydftemp	<- data.frame("col1"=c(1:2),"col2"=c(1:2)) 
			}
		if(nrow(mydftemp)==npairs&!do_overwrite)
			{
			if(!silent){cat("Generating dataframe with relatedness estimates.",sep="\n")}
			kindf			<<- mydftemp
			mysambar$kindf	<<- kindf
			}else{
			cat("Pairwise_relatedness.txt file is not present or does not have the expected number of rows, or flag do_overwrite is set to TRUE. Creating datafile now.",sep="\n")  
			cat("This will take some time, but the next time you run the filterdata() function this step will be automatically omitted and then it will be much faster.",sep="\n")  
			mymatrix	<- as.matrix(mygenlight[,snps$filter])
			ind1vec		<- vector()
			ind2vec		<- vector()
			name1vec	<- vector()
			name2vec	<- vector()
			pop1vec		<- vector()
			pop2vec		<- vector()
			popcol1vec	<- vector()
			popcol2vec	<- vector()
			ind1bool	<- vector()
			ind2bool	<- vector()
			ndata1vec	<- vector()
			ndata2vec	<- vector()
			f1vec		<- vector()
			f2vec		<- vector()
			r0vec		<- vector() 
			r1vec		<- vector()
			kingvec		<- vector()
			k0vec		<- vector()
			k1vec		<- vector()
			k2vec		<- vector()
			kincoef		<- vector()
			# indsfslist	<<- list()
			if(!silent){cat("Starting sample pairwise calculations...",sep="\n")}
			for (i in c(1:ncol(combitable)))
				{
				if(i%%1000==0&!silent)
					{
					cat(paste(i," in ",ncol(combitable)," pairwise comparisons.",sep=""),sep="\n") 
					}
				ind1		<- combitable[1,i]
				ind2		<- combitable[2,i]
				ind1vec[i]	<- ind1
				ind2vec[i]	<- ind2
				name1vec[i]	<- as.character(inds$name[ind1])
				name2vec[i]	<- as.character(inds$name[ind2])
				pop1vec[i]	<- as.character(inds$pop[ind1])
				pop2vec[i]	<- as.character(inds$pop[ind2])
				popcol1vec[i]<- as.character(inds$popcol[ind1])
				popcol2vec[i]<- as.character(inds$popcol[ind2])
				ind1bool[i]	<- inds$filter[ind1]
				ind2bool[i]	<- inds$filter[ind2]
				ndata1vec[i]<- inds$ndata[ind1]
				ndata2vec[i]<- inds$ndata[ind2]
				if("F"%in%colnames(inds))
					{
					f1vec[i]	<- round(inds$F[ind1],4)
					f2vec[i]	<- round(inds$F[ind2],4)
					}else{
					f1vec[i]	<- NA
					f2vec[i]	<- NA
					}
				geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[ind2,]
				# Optionally add genotypes if a genotype is missing (otherwise table function does not return the expected 4x4 table):
				if(length(unique(geno1[!is.na(geno1)]))<3)
					{
					geno1	<- c(geno1,0,1,2)
					geno2	<- c(geno2,0,1,2)
					}
				if(length(unique(geno2[!is.na(geno2)]))<3)
					{
					geno1	<- c(geno1,0,1,2)
					geno2	<- c(geno2,0,1,2)
					}
				# To avoid that NA is included when stating geno==0/1/2, we change NA to 3:
				geno1[is.na(geno1)]	<- 3
				geno2[is.na(geno2)]	<- 3
				# get 2D-SFS:
				indsfs		<- table(geno1,geno2)
				indsfs		<- indsfs[1:3,1:3]
				# 
				# indsfslist[[i]]	<<- indsfs
				# calculate statistics:
				r0vec[i]	<- (indsfs[3,1]+indsfs[1,3])/indsfs[2,2]  
				r1vec[i]	<- (indsfs[2,2])/(indsfs[1,2]+indsfs[1,3]+indsfs[2,1]+indsfs[2,3]+indsfs[3,1]+indsfs[3,2])
				kingvec[i]	<- (indsfs[2,2]-2*(indsfs[1,3]+indsfs[3,1]))/(indsfs[2,1]+indsfs[1,2]+indsfs[2,3]+indsfs[3,2]+2*indsfs[2,2])
				mysum		<- sum(indsfs)
				k0vec[i]	<- (indsfs[3,1]+indsfs[1,3])/mysum
				k1vec[i]	<- (indsfs[1,2]+indsfs[2,1]+indsfs[2,3]+indsfs[3,2])/mysum
				k2vec[i]	<- (indsfs[1,1]+indsfs[2,2]+indsfs[3,3])/mysum
				kincoef[i]	<- round(k1vec[i]/4+k2vec[i]/2,3)
				# kincoefficient values formula is based on explanation in introduction of Waples et al, 2018, Allele frequency free inference of close familial relationships from genotypes or low depth sequencing data
				# At first glance not very distinctive estimates, so I didn't bother (yet) plotting the results
				# still to incorporate: PLINK pi_hat estimates
				# for detailed description of pihat calculation see: Purcell et al, 2007, PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses
				#
				if(kingvec[i]>=kinthreshold&(!silent))
					{
					cat(paste("High relatedness-score for individual ",ind1," and ",ind2,".",sep=""),sep="\n")
					}
				}
			kindf			<- data.frame("ind1"=ind1vec,"ind2"=ind2vec,"name1"=name1vec,"name2"=name2vec,"pop1"=pop1vec,"pop2"=pop2vec,"popcol1"=popcol1vec,"popcol2"=popcol2vec,"ind1_bool"=ind1bool,"ind2_bool"=ind2bool,"ndata1"=ndata1vec,"ndata2"=ndata2vec,"F1"=f1vec,"F2"=f2vec,"r0"=r0vec,"r1"=r1vec,"kingrobust"=kingvec,"k0"=k0vec,"k1"=k1vec,"k2"=k2vec,"kincoef"=kincoef)
			kindf$samepop	<- kindf$pop1==kindf$pop2
			mysambar$kindf	<<- kindf
			setwd(mysambar$inputdatadir)
			write.table(mysambar$kindf,"pairwise_relatedness.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
			}
		setwd(my_wd)
		}
	#
	# PLOTTING
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
		if(!dir.exists("Kinship"))
			{
			if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
			dir.create(file.path(kinshipdir))
			mysambar$kinshipdir	<<- kinshipdir
			setwd(kinshipdir)
			}else{
			setwd(kinshipdir)
			if(!silent){cat("(Over)writing results in directory:",sep="\n")}
			cat(getwd(),sep="\n")	
			}
		}
	# scatterplot:
	if(!silent){cat("Creating kin scatter plot...",sep="\n")}
	if(!is.null(exporttype))
		{
		if(exporttype=="pdf"){pdf("kin_scatter.pdf",family=mysambar$myfont,width=16,height=8)}
		}
	par(mfrow=c(1,2),mar=c(4,5.5,1,1),oma=c(1,1,1,0.5))
	myfilter	<- kindf$ind1_bool&kindf$ind2_bool
	options(warn=-1)
	kindf	<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	plot(kindf$r1[myfilter],kindf$r0[myfilter],log="x",ylab="",xlab="R1",cex.lab=2.5,cex.axis=2,pch=16,las=1,cex=2,col="orange")
	mtext("R0",side=2,line=3.75,cex=2.5)
	plot(kindf$r1[myfilter],kindf$kingrobust[myfilter],log="x",ylab="",xlab="R1",cex.lab=2.5,cex.axis=2,pch=16,las=1,cex=2,col="orange")
	options(warn=0)
	mtext("KING-robust",side=2,line=3.75,cex=2.5)
	if(!is.null(exporttype)){dev.off()}
	#
	# 16-3-20: if only 1 sample per population, you will run into the error:
	# error in heatmap2.: x must be a numeric matrix.
	# matrix:
	kindf	<- mysambar$kindf
	if(any(is.infinite(kindf$kingrobust)))
		{
		if(!silent){cat("Infinite kingrobust values. Omitting kin matrix...",sep="\n")}
		}else{
		if(!silent){cat("Creating kin matrix...",sep="\n")}
		plot_indmatrix(export=exporttype,silent=silent,inputvalues=kindf$kingrobust,popnames=mysambar$populations,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="KING-robust",plotprefix="KINGrelatedness",currentdir=TRUE)
		}
	#
	# EXPORT TABLE
	kindf	<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	for (k in seq(0,0.45,0.05))
		{
		kintable(my_thres=k,silent=TRUE)
		}
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	}

multi_geno2Dmat<-function(kindf=mysambar$kindf,maxplots=20,mythres=0.4,export_type="pdf",n_bins=5,silent=TRUE)
	{
	if(is.null(kindf))
		{
		return(cat("ERROR: kindf dataframe not found.",sep="\n"))
		}
	kindf		<- kindf[kindf$ind1_bool&kindf$ind2_bool&kindf$kingrobust>=mythres,]
	npairs		<- nrow(kindf)
	cat(paste("Number of sample pairs with King-robust relatedness-score >= ",mythres," equals ",npairs,".",sep=""),sep="\n")
	if(npairs>maxplots)
		{
		return(cat("WARNING: Many related pairs. If you want to plot them anyway, run the multi_geno2Dmat function with a higher value specified to the flag maxplots (default is 20).",sep="\n"))
		}
	cat("Creating heatmaps with 2D sample genotypes proportions of sample pairs with high relatedness scores.",sep="\n") 
	for(i in c(1:npairs))
		{
		if(!silent){cat(i,sep="\n")}
		geno2Dmat(ind1=kindf$ind1[i],ind2=kindf$ind2[i],export=export_type,use_currentdir=TRUE,nbins=n_bins,doprop=TRUE,ndecimals=3,myBreaks=seq(0,0.1,0.1/n_bins))
		}
	cat("Heatmaps with 2D sample genotype proportions have been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	cat("Orange colour scale indicates deviation from random expectations (dark orange: high deviation; white: low deviation).",sep="\n")
	}
	

geno2Dmat<-function(ind1=1,ind2=2,export=NULL,use_currentdir=TRUE,nbins=5,doprop=TRUE,ndecimals=3,myBreaks=seq(0,0.1,0.1/nbins))
	{
	# This plot create a heatmap with two dimensional genotype score proportions.
	# The colours represent the magnitude of difference compared to expected (random combination) values.
	# If no relatedness, there will be hardly any orange colour.
	#
	############# get 2D genotype scores:
	name1		<- as.character(inds$name[ind1])
	name2		<- as.character(inds$name[ind2])
	genlightmat			<- as.matrix(mygenlight[,snps$filter])
	geno1				<- genlightmat[ind1,]
	geno2				<- genlightmat[ind2,]
	# To avoid that NA is included when stating geno==0/1/2, we change NA to 3:
	geno1[is.na(geno1)]	<- 3
	geno2[is.na(geno2)]	<- 3
	obsmatrix			<- matrix(NA,nrow=3,ncol=3)
	genos				<- c(0,1,2)
	colnames(obsmatrix)	<- genos
	rownames(obsmatrix)	<- genos
	expmatrix			<- obsmatrix
	genoprop1			<- vector()
	genoprop2			<- vector()
	for (i in c(1:3))
		{
		g1	<- genos[i]
		for (j in c(1:3))
			{
			g2	<- genos[j]
			obsmatrix[i,j]	<- length(geno1[geno1==g1&geno2==g2])
			}
		}
	if(doprop)
		{
		mymatrix	<- round(obsmatrix/sum(obsmatrix),ndecimals)
		}else{
		mymatrix	<- obsmatrix
		}
	#
	############ expected 2D genotype scores:
	for (i in c(1:3))
		{
		g1				<- genos[i]
		p1				<- length(geno1[geno1==g1])/length(geno1[geno1!=3])
		genoprop1[i]	<- round(length(geno1[geno1==g1])/length(geno1[geno1!=3]),2)
		genoprop2[i]	<- round(length(geno2[geno2==g1])/length(geno2[geno2!=3]),2)
		for (j in c(1:3))
			{
			g2				<- genos[j]
			p2				<- length(geno1[geno2==g2])/length(geno2[geno2!=3])
			expmatrix[i,j]	<- p1*p2
			}
		}
	exppropmat	<- round(expmatrix/sum(expmatrix),ndecimals)
	ntotal		<- length(geno1[geno1!=3&geno2!=3])		
	obsmatrix	<- obsmatrix
	expnmat		<- round(expmatrix*ntotal)
	ndiffmat	<- expnmat-obsmatrix
	propdiffmat	<<- abs(ndiffmat/sum(obsmatrix))
	#
	### PLOTTING
	# balloonplot(as.table(mymatrix),xlab=name1,ylab=name2,main="")
	# create colours:
	myvec	<- c("0","1","2")
	rownames(propdiffmat)	<- paste(myvec,genoprop1,sep=": ")
	colnames(propdiffmat)	<- paste(myvec,genoprop2,sep=": ")
	if(is.null(myBreaks))
		{
		#if(doprop)
		#	{
		#	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
		#	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
		#	mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
		#	mymax		<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
		#	}else{
		#	mymin		<- min(mymatrix,na.rm=TRUE)
		#	mymax		<- max(mymatrix,na.rm=TRUE)
		#	}
		mymin		<- min(propdiffmat,na.rm=TRUE)
		mymax		<- max(propdiffmat,na.rm=TRUE)
		binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
		myBreaks	<- seq(mymin,mymax,binsize)
		}
	myBreaks	<<- myBreaks
	mycolfunc 	<<- colorRampPalette(c("white","darkorange"))
	myColours	<<- c(mycolfunc(length(myBreaks)-1))
	#
	my_wd		<- getwd()
	if(!use_currentdir)
		{
		setwd(kinshipdir)
		}
	graphics.off()
	if(!is.null(export))
		{
		ngeno	<- 3
		mysize	<- 3+ngeno*1.75
		mysize2	<- 300+ngeno*150
		plotname<- paste("Geno2Dmat",paste(ind1,"vs",ind2,sep=""),sep=".")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(propdiffmat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=mymatrix,
	notecol="black",notecex=2.5,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	mtext(name1, side = 1, cex = 2, line = 3.5)
	mtext(name2, side = 4, cex = 2, line = 0.5)
	mtext("2D sample genotype proportions", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	}

kintable<-function(my_thres=0,silent=FALSE)
	{
	kindf	<- mysambar$kindf
	kindf	<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	if(is.null(mysambar$kindf))
		{
		return(cat("ERROR: 'mysambar$kindf' not found.",sep="\n"))
		}
	kindf			<- mysambar$kindf
	kindf			<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	#
	kindf$r0		<- round(kindf$r0,3)
	kindf$r1		<- round(kindf$r1,3)
	kindf$kingrobust<- round(kindf$kingrobust,3)
	kindf$k0		<- round(kindf$k0,3)
	kindf$k1		<- round(kindf$k1,3)
	kindf$k2		<- round(kindf$k2,3)
	kindf$kincoef	<- round(kindf$kincoef,3)
	#
	if(any(kindf$kingrobust>my_thres))
		{
		closekindf	<- kindf[kindf$kingrobust>my_thres,]
		write.table(closekindf,paste("Close_kin",paste("threshold",my_thres,sep=""),"txt",sep="."),quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
		if(!silent){cat("A table listing close kin pairs has been exported to the directory:",sep="\n")}
		if(!silent){cat(getwd(),sep="\n")}
		}else{
		if(!silent){cat("No sample pairs with a king robust estimate above 0. Not exporting data.",sep="\n")}
		}
	}

Fvskin<-function(dolabels=FALSE,export=NULL,limitrange=FALSE)
	{
	kindf			<- mysambar$kindf
	kindf			<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	kindf$F			<- 0.5*(kindf$F1+kindf$F2)
	mycols			<- ifelse(kindf$samepop,as.character(kindf$popcol1),rep("grey10",nrow(kindf)))
	#
	if(!is.null(export))
		{
		plotname	<- ifelse(dolabels,"F_vs_relatedness.labels","F_vs_relatedness")
		plotlabel	<- ifelse(limitrange,"limitedrange","fullrange")
		if(export=="eps"){postscript(paste(plotname,plotlabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,plotlabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,plotlabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile(paste(plotname,plotlabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(!limitrange)
		{
		limx	<- c(-1,1)
		limy	<- c(-1,0.5)
		}else{
		limx	<- c(min(kindf$F,na.rm=TRUE),max(kindf$F,na.rm=TRUE))
		limy	<- c(min(kindf$kingrobust,na.rm=TRUE),max(kindf$kingrobust,na.rm=TRUE))
		}
	if(!dolabels)
		{
		plot(kindf$F,kindf$kingrobust,col=mycols,cex=3,pch=16,xlab="Inbreeding coefficient",ylab="King-robust score",xlim=limx,ylim=limy)
		points(kindf$F[kindf$samepop],kindf$kingrobust[kindf$samepop],pch=16,col=mycols[kindf$samepop],cex=3.5,xlim=limx,ylim=limy)
		}else{
		plot(kindf$F,kindf$kingrobust,cex=1.5,pch=16,col="white",xlab="Inbreeding coefficient",ylab="King-robust score",xlim=limx,ylim=limy)
		text(kindf$F,kindf$kingrobust,paste(kindf$ind1,kindf$ind2,sep="_"),pch=16,col=mycols,cex=0.25,xlim=limx,ylim=limy)
		}
	abline(h=0.5,lty=2)
	legend("bottomleft",legend=c(mysambar$populations,"between"),fill=c(mysambar$mycolours,"black"),bty='n',cex=1.5)
	if(!is.null(export)){dev.off()}
	}

kinboxplot<-function(export=NULL,plotname="Relatedness_boxplot",kinshipscore="kincoef",ylabel="Relatedness coefficient",yline=4.5,onlywithin=TRUE)
	{
	kindf				<- mysambar$kindf
	kindf				<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	kindf$withinpop		<- kindf$pop1==kindf$pop2
	kindf$pop3			<- ifelse(kindf$withinpop,as.character(kindf$pop1),rep("between",nrow(kindf)))	
	if(onlywithin)
		{
		tempdf			<- kindf[kindf$withinpop,c("pop1",kinshipscore)]
		colnames(tempdf)<- c("pop","kinscore")
		tempdf$poporder	<- factor(tempdf$pop,levels=mysambar$poporder2)
		tempdf			<- droplevels(tempdf[tempdf$pop%in%mysambar$populations,])
		popbool			<- mysambar$poporder%in%tempdf$pop
		npops			<- length(popbool[popbool])
		mycolours		<- mysambar$colorder[popbool]
		}else{		
		tempdf			<- kindf[,c("pop3",kinshipscore)]
		colnames(tempdf)<- c("pop","kinscore")
		tempdf$poporder	<- factor(tempdf$pop,levels=c("between",mysambar$poporder2))
		tempdf			<- droplevels(tempdf[tempdf$pop%in%c("between",mysambar$populations),])
		popbool			<- mysambar$poporder%in%tempdf$pop
		npops			<- length(popbool[popbool])+1
		mycolours		<- c("black",mysambar$colorder[popbool])
		}
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		plotname		<- ifelse(onlywithin,plotname,paste(plotname,"with_betweenpops",sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=npops*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=npops*mywidth+2,height=8)}
		}
	par(oma=c(9,7,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	ymin	<- 0.975*min(tempdf$kinscore,na.rm=TRUE)
	if(kinshipscore=="kingrobust"|kinshipscore=="kincoef")
		{
		ymax	<- 0.5
		}else{
		ymax	<- 1.025*max(tempdf$kinscore,na.rm=TRUE)
		}
	#		
	boxplot(tempdf$kinscore~tempdf$poporder,border=mycolours,col="grey90",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=FALSE,ylim=c(ymin,ymax))
	stripchart(kinscore~poporder,data=tempdf,vertical=TRUE,method="jitter",pch=16,cex=2,col=mycolours,bg="bisque",add=TRUE) 
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	if(kinshipscore=="kingrobust"|kinshipscore=="kincoef")
		{
		abline(h=0.5,lty=2)
		}
	if(kinshipscore=="k2")
		{
		abline(h=1,lty=2)
		}
	#mtext(side=1,"Sample",line=6.5,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

plinkrelatedness<-function(silent=TRUE,infile="plink.kin.retainedinds.genome",infile2="plink.kin.allinds.genome",popnames=mysambar$populations,export=NULL,shortpop=NULL,legendcex=2.5)
	{
	setwd(mysambar$inputfilesdir)
	infile1present	<- file.exists(infile)
	infile2present	<- file.exists(infile2)
	if((!infile1present)&(!infile2present))
		{
		cat(paste("ERROR: SambaR could not find files ",infile," (specified by 'infile' argument) and ",infile2," (specified by 'infile2' argument) in the directory:",sep=""),sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	if(!infile1present)
		{
		cat(paste("WARNING: SambaR could not find file called ",infile," (specified by 'infile' argument) in directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		cat("Omitting 'Relatedness.plink.between' and 'Relatedness.plink.within' plots.",sep="\n")
		}else{
		ibd			<<- read.table(infile,header=TRUE)
		ibd$PI_HAT[!is.finite(ibd$PI_HAT)]	<<- NA
		}
	infile2present	<- file.exists(infile2)
	if(!infile2present)
		{
		cat(paste("WARNING: SambaR could not find file called ",infile2," (specified by 'infile2' argument) in directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		cat("Omitting 'Relatedness.plink.matrix' plot.",sep="\n")
		}else{
		ibd2		<<- read.table(infile2,header=TRUE)
		ibd2$PI_HAT[!is.finite(ibd2$PI_HAT)]	<<- NA
		}
	#
	# 26-04-2021:
	setwd(mysambar$sambardir)
	kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
	if(!dir.exists("Kinship"))
		{
		if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
		dir.create(file.path(kinshipdir))
		mysambar$kinshipdir	<<- kinshipdir
		setwd(kinshipdir)
		}else{
		setwd(kinshipdir)
		if(!silent){cat("Overwriting results in directory:",sep="\n")}
		cat(getwd(),sep="\n")	
		}
	#setwd(mysambar$QCdir)
	if(infile1present)
		{
		infilepopnames	<- unique(c(as.vector(ibd$FID1),as.vector(ibd$FID2)))
		if(any(!infilepopnames%in%popnames))
			{
			cat(paste("ERROR: Population names in FID1 and FID2 columns of the file '",infile,"' do not correspond with population names in inds dataset.",sep=""),sep="\n")
			return(cat("Please rerun PLINK on dataset currently used by SambaR, or alternatively edit population names in the input file.",sep="\n"))
			}
		infilepopnames	<- unique(c(ibd$FID1,ibd$FID2))
		ibd$bothpops	<- paste(ibd$FID1,ibd$FID2,sep="_")
		ibd$bothpops2	<- paste(ibd$FID1,ibd$FID2,sep="\n")
		ibd$diffpop		<- ibd$FID1!=ibd$FID2
		# mypairwise	<- as.vector(unique(ibd$bothpops[ibd$diffpop]))
		# mypairwise2	<- as.vector(unique(ibd$bothpops2[ibd$diffpop]))
		mypairwise		<- combn(popnames,m=2)
		mypairwise2		<- paste(mypairwise[1,],mypairwise[2,],sep="_")
		mypairwise3		<- paste(mypairwise[2,],mypairwise[1,],sep="_")
		mypairwise4		<- paste(mypairwise[1,],mypairwise[2,],sep="\n")
		npairwise		<- length(mypairwise2)
		# create combicolours colours:
		mypops			<- mysambar$populations
		npops			<- length(mypops)
		mycolours		<- mysambar$mycolours[1:npops]
		mypopcols		<- cbind(mypops,mycolours)
		combicoltable	<- combn(mycolours,m=2)	
		combitable		<- combn(mypops,m=2)
		combivector		<- paste(combitable[1,],combitable[2,],sep="_")	
		mycombitable	<- rbind(combivector,combitable,combicoltable)	
		mycolvector		<- vector()
		# define short population names:
		if(is.null(shortpop))
			{
			shortpop<-substr(mypops,1,2)
			}
		for(i in c(1:npairwise))
			{
			mycol1		<- mycombitable[4,i]
			mycol2		<- mycombitable[5,i]
			mycolfunc 	<- colorRampPalette(c(mycol1,mycol2))
			mycolvector[i]	<- mycolfunc(3)[2]
			}
		myvector		<- rep(NA,ncol(mycombitable))
		mycombitable	<- rbind(mycombitable,myvector)
		#
		# Plot relatedness between populations:
		cat("Plotting relatedness between populations...",sep="\n")	
		# Prepare plotting:
		if("vioplot" %in% rownames(installed.packages()) == FALSE){install.packages("vioplot",repos='http://cran.us.r-project.org')}
		library(vioplot)
		# Plot relatedness between different populations:	
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Relatedness.plink.between.pdf",width=npairwise*2.75,height=7)}	
			if(export=="pdf"){pdf("Relatedness.plink.between.pdf",width=npairwise*2.75,height=7)}
			if(export=="png"){png("Relatedness.plink.between.png",width=npairwise*200,height=720)}
			if(export=="wmf"){win.metafile("Relatedness.plink.between.wmf",width=npairwise*2.75,height=7)}
			}
		par(mar=c(7,5,2,2),cex.axis=1.75)
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npairwise+0.5),col="white",ylim=c(min(ibd$PI_HAT,na.rm=TRUE),max(ibd$PI_HAT,na.rm=TRUE)),xaxt="n",xlab="",ylab="")
		for (i in c(1:npairwise))
			{
			mypair		<- mypairwise2[i]
			mypair_rev	<- mypairwise3[i]
			mypair_label<- mypairwise4[i]
			mycol	<- mycolvector[which(combivector==mypair)]
			# cat(mypair,sep="\n")
			if(sum(ibd$PI_HAT[ibd$bothpops==mypair])==0)
				{
				boxplot(ibd$PI_HAT[(ibd$bothpops==mypair|ibd$bothpops==mypair_rev)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names="",col=mycol,ylab="",yaxt='n')
				}else{
				vioplot(ibd$PI_HAT[(ibd$bothpops==mypair|ibd$bothpops==mypair_rev)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names="",col=mycol)
				}
			}
		axis(side=1,at=seq(1,npairwise),labels=mypairwise4,lty=1,las=1,mgp=c(3,3,0))
		mtext("Pairwise population comparison",1,line=5,cex=2)
		mtext("proportion IBD",2,line=3,cex=2)
		if(!is.null(export)){dev.off()}	
		#
		# Plot relatedness within populations:
		cat("Plotting relatedness within populations...",sep="\n")	
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Relatedness.plink.within.pdf",width=npops*2.5,height=7)}	
			if(export=="pdf"){pdf("Relatedness.plink.within.pdf",width=npops*2.5,height=7)}
			if(export=="png"){png("Relatedness.plink.within.png",width=npops*120,height=720)}
			if(export=="wmf"){win.metafile("Relatedness.plink.within.wmf",width=npops*2.5,height=7)}
			}
		par(mar=c(4,5,2,2),cex.axis=1.75)
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(ibd$PI_HAT,na.rm=TRUE),max(ibd$PI_HAT,na.rm=TRUE)),xaxt="n",xlab="",ylab="")
		for (i in c(1:npops))
			{
			mypop	<- mypops[i]
			mycol	<- mycolours[i]
			if(sum(ibd$PI_HAT[ibd$FID1==mypop&!ibd$diff])==0)
				{
				boxplot(ibd$PI_HAT[(ibd$FID1==mypop&!ibd$diff)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names=mypop,col=mycol,ylab="",yaxt='n')
				}else{
				vioplot(ibd$PI_HAT[(ibd$FID1==mypop&!ibd$diff)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names=mypop,col=mycol)
				}
			}
		axis(side=1,at=seq(1,npops),labels=mypops,lty=1,las=1,mgp=c(3,1,0))
		mtext("Population",1,line=2.5,cex=2)
		mtext("proportion IBD",2,line=3,cex=2)
		if(!is.null(export)){dev.off()}	
		#
		# Plot relatedness per sample:
		cat("Plotting relatedness per sample...",sep="\n")
		indstemp	<- inds[order(as.character(inds$pop)),]
		mycols	<- as.vector(indstemp$popcol[indstemp$filter])
		myinds	<- as.vector(indstemp$name[indstemp$filter])
		myindnrs<- indstemp$nr[indstemp$filter]
		ninds	<- length(myinds)
		#mypops	<- as.vector(unique(inds$pop[indstemp$filter]))
		mypops	<- mysambar$populations
		mypops2<- as.vector(indstemp$pop[indstemp$filter])
		npops	<- length(mypops)
		mylocs	<- vector()
		for (i in c(1:length(popnames)))
			{
			mypop		<- popnames[i]
			temppop		<- indstemp$pop[indstemp$filter]
			mylocs[i]	<- which(temppop==mypop)[1]-0.5
			}
		mylocs2	<- mylocs[2:length(mylocs)]
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Relatedness.plink.persample.pdf",width=14,height=10)}	
			if(export=="pdf"){pdf("Relatedness.plink.persample.pdf",width=14,height=10)}
			if(export=="png"){png("Relatedness.plink.persample.png",width=14,height=720)}
			if(export=="wmf"){win.metafile("Relatedness.plink.persample.wmf",width=14,height=10)}
			}
		par(mfrow=c(npops,1),mar=c(0.5,5,0.5,0.5),oma=c(5,1,3,2),cex.lab=2.5,cex.main=2.5)
		for(j in c(1:npops))
			{
			mypop	<- mypops[j]
			plot(c(1:5),c(1:5),main="",xlim=c(0.5,ninds+0.5),col="white",ylim=c(min(ibd$PI_HAT),max(ibd$PI_HAT)),xaxt="n",xlab="",ylab="")
			for (i in c(1:ninds))
				{
				myind	<- myinds[i]
				mynr	<- myindnrs[i]
				mypop2	<- mypops2[i] 
				mycol	<- mycols[i]
				myibd	<- ibd[(ibd$IID1==myind|ibd$IID2==myind),]
				myibd	<- myibd[(myibd$FID1==mypop&myibd$FID2==mypop2)|(myibd$FID1==mypop2&myibd$FID2==mypop),]
				boxplot(myibd$PI_HAT[!is.na(myibd$PI_HAT)],at=i,add=TRUE,names=mynr,col=mycol,border=mycol,ylab="",yaxt='n')
				}
			abline(v=mylocs2,lwd=1)
			if(npops>5)
				{
				mtext(shortpop[j],side=4,line=1,cex=1.5)
				}else{
				mtext(popnames[j],side=4,line=1,cex=1.5)
				}
			if(j==1)
				{
				if(npops>5)
					{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)
					}else{
					mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)
					}
				}
			}
		mtext("proportion IBD",side=2,line=-2,outer=TRUE,cex=2)
		axis(side=1,at=seq(1,ninds),labels=myindnrs,lty=1,las=1,mgp=c(3,1,0),cex=0.75,las=2)
		mtext("Individuals",side=1,line=3,outer=TRUE,cex=2)
		if(!is.null(export)){dev.off()}
		}
	# matrix:
	if(infile2present)
		{
		infilepopnames	<- unique(c(as.vector(ibd2$FID1),as.vector(ibd2$FID2)))
		if(any(!infilepopnames%in%popnames))
			{
			cat(paste("ERROR: Population names in FID1 and FID2 columns of the file '",infile2,"' do not correspond with population names in inds dataset.",sep=""),sep="\n")
			return(cat("Please rerun PLINK on dataset currently used by SambaR, or alternatively edit population names in the input file.",sep="\n"))
			}
		cat("Plotting matrix...",sep="\n")
		myscores					<- ibd2$PI_HAT
		myscores[is.na(myscores)]	<- 0	# This is necessary to circumvent errors when running plot_indmatrix()
		plot_indmatrix(export="pdf",inputvalues=myscores,popnames=mysambar$populations,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="Relatedness (pi_hat)",plotprefix="Relatedness.plink.matrix",currentdir=TRUE)	
		}
	cat("File(s) called 'Relatedness.plink' has/have been exported to the directory:",sep="\n")
	cat(mysambar$QCdir,sep="\n")
	setwd(mysambar$inputdatadir)
	}

ReadGRMBin<-function(prefix, AllN=F, size=4)
	{
	sum_i			<- function(i){return(sum(1:i))}
	BinFileName		<- paste(prefix,".grm.bin",sep="")
	NFileName		<- paste(prefix,".grm.N.bin",sep="")
	IDFileName		<- paste(prefix,".grm.id",sep="")
	id 				<- read.table(IDFileName)
	n				<- dim(id)[1]
	BinFile			<- file(BinFileName, "rb");
	grm				<- readBin(BinFile, n=n*(n+1)/2, what=numeric(0), size=size)
	NFile			<- file(NFileName, "rb");
	if(AllN==T)
		{
		N			<- readBin(NFile, n=n*(n+1)/2, what=numeric(0), size=size)
		}else{
		N			<- readBin(NFile, n=1, what=numeric(0), size=size)
		i			<- sapply(1:n, sum_i)
		return(list(diag=grm[i], off=grm[-i], id=id, N=N))
		}
	}	

# requires ReadGRMBin
# Note that GCTA needs to be run on all individuals, also once not retained by SambaR	
do_gctamatrix<-function(gctaprefix=NULL,use_currentdir=FALSE,legendcex=2.5)
	{
	# This function expects as input the base name of gcta output files.
	# 3 input files expected, ending on .grm.bin, .grm.id, grm.N.bin
	if(is.null(gctaprefix))
		{
		return(cat("ERROR: provide a name to gctaprefix argument (i.e. base name of input files). Default is NULL.",sep="\n"))
		}
	if(!use_currentdir)
		{
		setwd(mysambar$inputfilesdir)
		}
	cat("Searching for input files in directory:",sep="\n")
	cat(getwd(),sep="\n")
	cat("If you want to search within the working directory, set the flag currentdir to TRUE.",sep="\n")
	gctadata 						<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
	#mymatrix[upper.tri(mymatrix)] 	<- gctadata$off
	#mynames 						<- as.character(gctadata$id[,2])
	#mynames2 						<- gsub(".verysens.q20.1hit.conc","",mynames)
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
		if(!dir.exists("Kinship"))
			{
			if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
			dir.create(file.path(kinshipdir))
			mysambar$kinshipdir	<<- kinshipdir
			setwd(kinshipdir)
			}else{
			setwd(kinshipdir)
			if(!silent){cat("Overwriting results in directory:",sep="\n")}
			cat(getwd(),sep="\n")	
			}
		}
	plot_indmatrix(export="pdf",inputvalues=gctadata$off,popnames=mysambar$populations,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="Relatedness",plotprefix="GCTAmatrix",currentdir=TRUE)	
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}

plot_indmatrix<-function(export=NULL,indsfilter=TRUE,inputvalues=NULL,popnames=mysambar$populations,n_bins=5,mybreaks=NULL,legpos_x=0.1,legpos_y=0.45,leg_cex=2.5,matcol="orange",plotprefix="indmatrix",miss_labels=FALSE,currentdir=TRUE,plottitle="",silent=TRUE,perpop=TRUE,sub_title=NULL,make_global=FALSE)
	{
	# This function expects as input a vector with values for all pairwise comparisons between all individuals in the order 1-2,1-3,1-4,2-3,2-4,3-4 as example for a dataset of 4 individuals.
	# So: a vector with values for pairwise comparisons between retained individuals will lead to errors.
	if(is.null(inputvalues))
		{
		return(cat("ERROR: provide an input vector to inputvalues argument. Default is NULL.",sep="\n"))
		}
	# metapop:
	indstemp				<- inds
	nind					<- nrow(indstemp)
	npairwise				<- (nind*(nind-1))/2 
	if(length(inputvalues)!=npairwise)
		{
		cat(paste("ERROR: expected a vector of length ",npairwise,".",sep=""),sep="\n")
		return(cat(paste("Observed length of inputvalues vector is ",length(inputvalues),".",sep=""),sep="\n"))
		}
	myindmatrix 			<- matrix(NA,nrow=nind,ncol=nind)
	tempmatrix				<- myindmatrix
	tempmatrix[lower.tri(tempmatrix)]		<- round(inputvalues,3)
	myindmatrix								<- t(tempmatrix) 
	mynames2				<- as.character(inds$nr)							
	colnames(myindmatrix)	<- mynames2
	rownames(myindmatrix)	<- mynames2
	if(make_global){indmatrix_1	<<- myindmatrix}
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(myindmatrix,na.rm=TRUE),1)
	if(max(myindmatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(myindmatrix,na.rm=TRUE),1)
		}
	if(is.null(mybreaks))
		{
		binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
		mybreaks	<- seq(mymin,mymax,binsize)
		}
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	inds_all			<- inds_reordered
	inds_all$filter		<- TRUE
	# 09-03-2020: this doesn't do the job properly:
	# myindmatrix_reordered<- myindmatrix[order(indstemp$pop),order(indstemp$pop)]
	# 09-03-2020: instead:
	indmatrix_3			<- myindmatrix[order(indstemp$pop),order(indstemp$pop)]
	#indmatrix_4		<- t(myindmatrix)
	indmatrix_4			<- t(indmatrix_3)
	if(make_global){indmatrix_3	<<- indmatrix_3}
	if(make_global){indmatrix_4	<<- indmatrix_4}
	indmatrix_3[is.na(indmatrix_3)&upper.tri(indmatrix_3)] <- indmatrix_4[!is.na(indmatrix_4)&upper.tri(indmatrix_4)]
	indmatrix_3[lower.tri(indmatrix_3)]	<- NA
	myindmatrix_reordered<- indmatrix_3
	if(make_global){indmatrix_2	<<- myindmatrix_reordered}
	#
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=myindmatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.no_axis",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex,subtitle=sub_title)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=myindmatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.indnr",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)		
	if(miss_labels)
		{
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=myindmatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,misslabels=TRUE,exportname=paste(plotprefix,"metapop.miss",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
		}
	if(indsfilter)
		{
		# filtered:
		indstemp		<- inds[inds$filter,]
		inds_all		<- indstemp[order(indstemp$pop),]						
		indfiltermat	<- myindmatrix[inds$filter,inds$filter]	
		indmatrix_3		<- indfiltermat[order(indstemp$pop),order(indstemp$pop)]
		indmatrix_4		<- t(indmatrix_3)
		indmatrix_3[is.na(indmatrix_3)&upper.tri(indmatrix_3)] <- indmatrix_4[!is.na(indmatrix_4)&upper.tri(indmatrix_4)]
		indmatrix_3[lower.tri(indmatrix_3)]	<- NA
		indfiltermat	<- indmatrix_3
		#indfiltermat	<- myindmatrix_reordered[inds_reordered$filter,inds_reordered$filter]
		#inds_all		<- inds_reordered[inds_reordered$filter,]
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=indfiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.filter.no_axis",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=indfiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.filter.indr",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
		if(miss_labels)
			{
			do_heatmap(export_type=export,nbins=n_bins,mymatrix=indfiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,misslabels=TRUE,exportname=paste(plotprefix,"metapop.filter.miss",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
			}
		#
		# for each population:
		if(perpop)
			{
			if(!silent){cat("Generating matrices for each population separately...",sep="\n")}
			for (mypop in popnames)
				{
				if(!silent){cat(mypop,sep="\n")}
				popfilter		<- inds$filter&inds$pop==mypop
				npopind			<- length(popfilter[popfilter])
				if(npopind<2)
					{
					if(!silent){cat("Less than 2 retained individuals. Omitting matrix.",sep="\n")}
					}else{
					popmatrix		<- myindmatrix[popfilter,popfilter]
					indspop			<- inds[popfilter,]
					do_heatmap(export_type=export,nbins=n_bins,mymatrix=popmatrix,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
					do_heatmap(export_type=export,nbins=n_bins,mymatrix=popmatrix,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,mypop,"indnr",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
					if(miss_labels)
						{
						do_heatmap(export_type=export,nbins=n_bins,mymatrix=popmatrix,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,misslabels=TRUE,exportname=paste(plotprefix,mypop,"miss",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
						}
					}
				}
			}
		}
	if(!is.null(export)&!silent)
		{
		cat("Matrix heatmaps have been exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(!silent)	
		{
		cat("Note that the position and size of the legend can be editted with the 'legpos_x', 'legpos_y' and 'leg_cex' arguments. The number of bins can be editted with the 'n_bins' argument.",sep="\n")
		cat("The colour tone of the matrix can be editted with the argument 'matcol'. Default is 'orange'.",sep="\n")
		}
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}

# requires ReadGRMBin:
# 02-12-2019: assumes all individuals are included
# 31-01-2020: I edited some lines, not sure if it works (better) now
# 09-03-2020: depreciated. Use do_gctamatrix instead.
do_gctamatrix_feb2020<-function(export=NULL,gctaprefix=NULL,inputvalues=NULL,popnames=mysambar$populations,n_bins=5,currentdir=FALSE,legpos_x=0.1,legpos_y=0.35,matcol="orange",plotprefix="GCTAmatrix")
	{
	if(is.null(inputvalues))
		{
		if(is.null(gctaprefix))
			{
			return(cat("ERROR: provide a name to gctaprefix argument (i.e. base name of input files). Default is NULL.",sep="\n"))
			}
		if(!currentdir)
			{
			setwd(mysambar$inputfilesdir)
			}
		cat("Searching for input files in directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("If you want to search within the working directory, set the flag currentdir to TRUE.",sep="\n")
		gctadata 		<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
		}
	# metapop:
	indstemp		<- inds
	nind			<- nrow(indstemp)
	mymatrix 		<- matrix(NA,nrow=nind,ncol=nind)
	if(is.null(inputvalues))
		{
		mymatrix[upper.tri(mymatrix)] 	<- gctadata$off
		mynames 						<- as.character(gctadata$id[,2])
		mynames2 						<- gsub(".verysens.q20.1hit.conc","",mynames)
		}else{
		mymatrix[upper.tri(mymatrix)] 	<- round(inputvalues,3)
		mynames2						<- as.character(inds$nr)							
		}
	gctamatrix				<- mymatrix
	colnames(gctamatrix)	<- mynames2
	rownames(gctamatrix)	<- mynames2
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(gctamatrix,na.rm=TRUE),1)
	if(max(gctamatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(gctamatrix,na.rm=TRUE),1)
		}
	binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
	mybreaks	<- seq(mymin,mymax,binsize)
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	gctamatrix_reordered<- gctamatrix[order(indstemp$pop),order(indstemp$pop)]
	inds_all			<- inds_reordered
	inds_all$filter		<- TRUE
	#
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.no_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.with_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	# filtered:
	gctafiltermat	<- gctamatrix_reordered[inds_reordered$filter,inds_reordered$filter]
	inds_all		<- inds_reordered[inds_reordered$filter,]
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.filter.no_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.filter.with_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	#
	# for each population:
	for (mypop in popnames)
		{
		gctapop		<- gctamatrix[inds$filter&inds$pop==mypop,inds$filter&inds$pop==mypop]
		indspop		<- inds[inds$filter&inds$pop==mypop,]
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,mypop,"with_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		}
	if(!is.null(export))
		{
		cat("Matrix heatmaps have been exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	cat("Note that the position of the legend can be editted with the 'legpos_x' and 'legpos_y'. Default is respectively 0.1 and 0.35.",sep="\n")
	cat("The colour tone of the matrix can be editted with the argument 'matcol'. Default is 'orange'.",sep="\n")
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}

# requires ReadGRMBin:
# 02-12-2019: assumes all individuals are included
do_gctamatrix_old<-function(export=NULL,gctaprefix=NULL,popnames=mysambar$populations,n_bins=5,currentdir=FALSE,legpos_x=0.1,legpos_y=0.35,matcol="orange")
	{
	if(is.null(gctaprefix))
		{
		return(cat("ERROR: provide a name to gctaprefix argument (i.e. base name of input files). Default is NULL.",sep="\n"))
		}
	if(!currentdir)
		{
		setwd(mysambar$inputfilesdir)
		}
	gctadata 		<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
	# metapop:
	nind			<- nrow(inds)
	indstemp		<- inds
	indstemp$filter	<- TRUE
	mymatrix 		<- matrix(NA,nrow=nind,ncol=nind)
	mymatrix[upper.tri(mymatrix)] <- gctadata$off
	gctamatrix		<- mymatrix
	mynames 		<- as.character(gctadata$id[,2])
	mynames2 		<- gsub(".verysens.q20.1hit.conc","",mynames)
	colnames(gctamatrix)	<- mynames2
	rownames(gctamatrix)	<- mynames2
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(gctamatrix,na.rm=TRUE),1)
	if(max(gctamatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(gctamatrix,na.rm=TRUE),1)
		}
	binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
	mybreaks	<- seq(mymin,mymax,binsize)
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	gctamatrix_reordered<- gctamatrix[order(indstemp$pop),order(indstemp$pop)]
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=FALSE,exportname="GCTAmatrix.metapop.no_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=TRUE,exportname="GCTAmatrix.metapop.with_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	# filtered:
	gctafiltermat	<- gctamatrix_reordered[inds_reordered$filter,inds_reordered$filter]
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=FALSE,exportname="GCTAmatrix.metapop.filter.no_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=TRUE,exportname="GCTAmatrix.metapop.filter.with_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	#
	# for each population:
	for (mypop in popnames)
		{
		gctapop		<- gctamatrix[inds$filter&inds$pop==mypop,inds$filter&inds$pop==mypop]
		indspop		<- inds[inds$filter&inds$pop==mypop,]
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste("GCTAmatrix",mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste("GCTAmatrix",mypop,"with_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		}
	if(!is.null(export))
		{
		cat("Matrix heatmaps have been exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	cat("Note that the position of the legend can be editted with the 'legpos_x' and 'legpos_y'. Default is respectively 0.1 and 0.35.",sep="\n")
	cat("The colour tone of the matrix can be editted with the argument 'matcol'. Default is 'orange'.",sep="\n")
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}
		

# End of kinship analyses
##############################################################################################################








###############################################################################################################
# Population demography analyses

stairway_addgeo<-function()
        {
        #Flooding of Doggerland:
        polygon(x=c(6200,6500,6500,6200),y=c(100,100,200000,200000),col="grey60",border=NA)
        #Younger Dryas:
        polygon(x=c(11700,12900,12900,11700),y=c(100,100,200000,200000),col="grey55",border=NA)
        #LGM:
        polygon(x=c(16000,31000,31000,16000),y=c(100,100,200000,200000),col="grey50",border=NA)
        }

addlabels<-function(yaxis=TRUE)
        {
		axis(1, at=c(0,100,1000,10000,100000),labels=c(0,0.1,1,10,100),las=1)
		if(yaxis)
                {
                axis(2, at=c(0,1000,2000,3000,4000,5000,10000,20000,30000,40000,50000),labels=c(0,1,2,3,4,5,10,20,30,40,50),las=1)
                }
        }

# The next function depends on addgeo and addlabels
# It expects to find within the Demography directory files outputted by the Stairway_plot executable, one for each of your population.
# These files should have as prefix the name of your population (as defined in the populations vector) and as suffix: '.final.summary'. 

run_plotstairway<-function(mu_rate="2.5e-8",Gtime="20",x_range=c(100,100000),add_settings=TRUE,exporttype="pdf",pop_names=mysambar$populations,my_colours=mysambar$mycolours,my_suffix=NULL,add_glacials=FALSE)
	{
	setwd(mysambar$demographydir)
	if(is.null(my_suffix))
		{
		my_suffix	<- "final.summary" 
		}
	for (i in c(1:length(pop_names)))
		{
		# read data:
		mypop		<- pop_names[i]
		myfile		<- paste(mypop,my_suffix,sep=".")
		if(!file.exists(myfile))
			{
			cat(paste("ERROR: SambaR couldn't find the file ",myfile,". It expects to find this file within the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			cat("The file names should be your population name (as currently defined in SambaR) and the suffix defined by the my_suffix flag, seperated by a period (.).",sep="\n")
			cat("If my_suffix is set to NULL (default), SambaR expects the suffix to be 'final.summary'.",sep="\n")
			cat("By default, SambaR expects to find input files for all these populations:",sep="\n")
			cat(mysambar$populations,sep="\n")
			cat("By default, it assigns the following colours:",sep="\n")
			cat(mysambar$mycolours[1:length(pop_names)],sep="\n")
			return(cat("You can exclude one or more populations by defining the desired populations and colours with the 'pop_names' and 'my_colours' flags.",sep="\n"))
			}
		}
	plotstairway(logscale="",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="x",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="y",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="xy",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	# grayscale:
	plotstairway(logscale="",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="x",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="y",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="xy",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	}
	
plotstairway<-function(u_rate="2.5e-8",gen_time="20",mysuffix=NULL,grayscale=FALSE,logscale="xy",addsettings=TRUE,popnames=mysambar$populations,export=NULL,addglacials=FALSE,mycolours=mysambar$mycolours,xrange=NULL)
	{
	# Note: u_rate and gen_time are just used as label. They don't affect the plot itself. 
	# This function expects to find inputfiles subdirectory output from stairwayplot software:	
	if(grayscale)
		{
		mycolours=rep("grey70",length(mysambar$populations))
		}
	setwd(mysambar$demographydir)
	if(is.null(mysuffix))
		{
		mysuffix	<- "final.summary" 
		}
	mylist			<<- list()
	mymaxall		<- 0
	myminall		<- 100000
	for (i in c(1:length(popnames)))
		{
		# read data:
		mypop		<- popnames[i]
		myfile		<- paste(mypop,mysuffix,sep=".")
		#cat(myfile,sep="\n")
		if(!file.exists(myfile))
			{
			cat(paste("ERROR: SambaR couldn't find the file ",myfile,". It expects to find this file within the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			cat("Replace or rename your files.",sep="\n")
			cat("The file names should be your popname (as currently defined in SambaR) followed by the suffix defined by the mysuffix flag.",sep="\n")
			return(cat("If mysuffix is set to NULL (default), SambaR expects the suffix to be 'final.summary'.",sep="\n"))
			}
		mylist[[i]] <<- read.table(paste(mypop,mysuffix,sep="."),header=TRUE)
		mymax		<- max(mylist[[i]]$Ne_97.5.)
		mymaxall	<- ifelse(mymax>mymaxall,mymax,mymaxall)
		mymin		<- min(mylist[[i]]$Ne_2.5.)
		myminall	<- ifelse(mymin<myminall,mymin,myminall)
		}
	npops		<- length(popnames)
	# linear scale or log scale?
	if(logscale=="y"|logscale=="")
        	{
			if(!is.null(xrange))
				{
				cat(paste("Using",xrange[1],"and",xrange[2],"as minimum and maximum values for the x axis.",sep=" "),sep="\n")
				myxaxis	<- xrange 				
				}else{
				cat("No range of x-axis defined for non-logarithmic x-axis.",sep="\n")
				cat("Defaults to xmin = 500 and xmax = 35000.",sep="\n")
				cat("Use xrange flag (i.e. xrange=c(500,35000)) to adjust.",sep="\n")
				myxaxis	<- c(500,35000)
				}
			}else{
        	if(!is.null(xrange))
				{
				cat(paste("Using",xrange[1],"and",xrange[2],"as minimum and maximum values for the x axis.",sep=" "),sep="\n")
				myxaxis	<- xrange 				
				}else{
				cat("No range of x-axis defined for logarithmic x-axis.",sep="\n")
				cat("Defaults to xmin = 500 and xmax = 35000.",sep="\n")
				cat("Use xrange flag (i.e. xrange=c(500,35000)) to adjust.",sep="\n")
				myxaxis	<- c(500,35000)
				}
		   	}
	myymax	<- mymaxall
	myymin	<- ifelse((logscale=="x"|logscale==""),0,ifelse(myminall<1000,1000,myminall))
	#
	# Plot:
	graphics.off()
	if(!is.null(export))
		{
		mywidth		<- npops*5.5
		mywidth2	<- npops*550
		mystring	<- ifelse(logscale=="xy","log_xy",ifelse(logscale=="x","log_x",ifelse(logscale=="y","log_y","linear")))
		mycolset	<- ifelse(grayscale,"grayscale","colour")
		if(export=="eps"){postscript(paste("stairwayplot",mystring,mycolset,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		if(export=="pdf"){pdf(paste("stairwayplot",mystring,mycolset,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		if(export=="png"){png(paste("stairwayplot",mystring,mycolset,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste("stairwayplot",mystring,mycolset,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		}
	par(mfrow=c(1,length(popnames)),cex.axis=2.5,cex.lab=2,oma=c(2,6,2,2),mar=c(4,1,4,0))
	for (i in c(1:length(popnames)))
		{
		# first create plot outline:
		plot(mylist[[1]]$year,mylist[[1]]$Ne_97.5,type="l",log=logscale,xlab="",ylab="Ne (1k individuals)",las=1,yaxt="n",xaxt="n",col="white",main=NULL,xlim=myxaxis,ylim=c(myymin,myymax))
		mypop		<- popnames[i]
		if(i==1)
			{
			mtext("Time (kya)",side=1,cex=2.5,outer=TRUE)
			mtext("Ne (1k individuals)",2,line=4,cex=2.5)
			#mtext("Historic effective population sizes",cex=1.25,side=3,line=-1,outer=TRUE)
			if(addsettings)
				{
				mtext(paste("Generation time =",gen_time,"years; Mutation rate =",u_rate,"(per site per generation)",sep=" "),line=-2,outer=TRUE,cex=2.5)
				}
			#addlabels()
			if(logscale=="y"|logscale=="xy")
				{
				#axis(2, at=c(0,1000,2000,3000,4000,5000,10000,20000,30000,40000,50000),labels=c(0,1,2,3,4,5,10,20,30,40,50),las=1)
				if(max(mylist[[i]]$Ne_87.5,na.rm=TRUE)<2000)
					{
					cat("Using smaller y-scale.",sep="\n")
					axis(2, at=c(0,100,200,500,1000,2000),labels=c(0,0.1,0.2,0.5,1,2),las=1)
					}else{
					cat("Using larger y-scale.",sep="\n")
					axis(2, at=c(0,500,1000,2500,5000,10000,25000,50000),labels=c(0,0.5,1,2.5,5,10,25,50),las=1)
					}
				}else{
				ystep	<- ifelse(myymax>20000,ifelse(myxaxis[2]>50000,25000,10000),5000)
				xlabels	<- seq(0,myymax,ystep)
				axis(2,at=xlabels,labels=xlabels/1000,las=1)
				}
			}
		#addlabels(yaxis=FALSE)
		if(logscale=="y"|logscale=="")
        	{
			xstep	<- ifelse(myxaxis[2]>20000,ifelse(myxaxis[2]>50000,25000,10000),5000)
			xlabels	<- seq(0,myxaxis[2],xstep)
			axis(1,at=xlabels,labels=xlabels/1000)
			}else{
			axis(1, at=c(0,100,1000,10000,100000),labels=c(0,0.1,1,10,100),las=1)
			}
		if(addglacials)
			{
			stairway_addgeo()
			}
		# now add data:
		polygon(x=c(mylist[[i]]$year,rev(mylist[[i]]$year)),y=c(mylist[[i]]$Ne_2.5,rev(mylist[[i]]$Ne_97.5)),col=mycolours[i],border=NA) 
		points(mylist[[i]]$year,mylist[[i]]$Ne_median,type="l",lwd=1)
		points(mylist[[i]]$year,mylist[[i]]$Ne_87.5,type="l",lty=3,lwd=1)
		points(mylist[[i]]$year,mylist[[i]]$Ne_12.5,type="l",lty=3,lwd=1)
		mtext(mypop,side=3,line=-3,cex=2.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat(paste("A file called 'stairwayplot.",mystring,"' has been exported to a the 'Demography' directory.",sep=""),sep="\n")
		}
	setwd(mysambar$inputdatadir)
	}
	
# End of population demography analyses 
###############################################################################################################

	
	


###############################################################################################################
# Selection analyses

# Another not explored option, for phased data I suppose: R package rEHH
selectionanalyses<-function(export="pdf",do_meta=TRUE,plothisto=TRUE,dopiechart=TRUE,signlevel=0.05,do_pairwise=FALSE,do_pheno=FALSE,onlypooled=TRUE,add_bayescan=FALSE,bayescanFDR=0.01,overwrite_bayescan=FALSE,phenolabels=c("pheno1","pheno2"),do_pcadapt=TRUE,do_outflank=TRUE,do_fsthet=FALSE,bayescan_mapfile=NULL,silent=TRUE,pcadaptped=FALSE,overwriteped=TRUE,do_thin=FALSE,gwdsbinsize=1000000,my_correction="bonferroni",doplotvenn=TRUE,authors=NULL,species=NULL,selclaim=NULL,demography=NULL,ngenerations=NULL,geneflow=NULL,datainfo=NULL,controldata=FALSE,logp_max=NULL,export_data=FALSE)
	{
	if(!silent){cat("Checking settings...",sep="\n")}
	mysambar$pcadapt_error<<-FALSE
	if(do_meta)
		{
		if(!do_pcadapt)
			{
			return(cat("ERROR: The flag 'do_pcadapt' should be set to TRUE if the flag do_meta is set to TRUE.",sep="\n"))
			}
		}
	if(!is.null(my_correction))
		{
		if(my_correction!="holm"&my_correction!="bonferroni"&my_correction!="BH")
			{
			return(cat("ERROR: my_correction should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}
		}
	if(do_pheno)
		{
		if(!is.logical(inds$type))
			{
			return(cat("ERROR: column inds$type is not a logical vector (i.e. TRUE or FALSE values).",sep="\n"))
			}else{
			if(length(as.vector(unique(inds$type)))!=2)
				{
				return(cat("ERROR: number of classes defined in inds$type column does not equal 2.",sep="\n"))
				}
			}
		}
	if(!silent){cat("Checking input data...",sep="\n")}
	# my_correction can be 'holm', 'bonferroni', and 'BH' (Benjamini-Hochberg) or NULL (default)
	# if NULL, selection scans will be run with a correction method which have proved to give best results in the past
	#
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		# This would lead to error message: Error in 1:nLoc(x) : NA/NaN argument.
		# a quick and dirty way of working around this would be to type:
		# inds$filter[is.na(inds$filter)]	<- FALSE
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Checking pcadapt installation...",sep="\n")}
	if(do_pcadapt)
		{
		if("pcadapt" %in% rownames(installed.packages()) == FALSE)
			{
			cat("ERROR: The package 'pcadapt' is not installed on your computer. You have two options:",sep="\n")
			cat("Option 1: run selectionanalyses without pcadapt by setting the do_pcadapt flag to false, i.e.: selectionanalyses(do_pcadapt=FALSE).",sep="\n")
			return(cat("Option 2: try to install pcadapt 4.1.0 by running: getpackages(do_pcadapt=TRUE).",sep="\n"))
			}else{
			if(packageDescription("pcadapt")$Version!="4.1.0"&pcadaptped)
				{
				cat("ERROR: SambaR needs pcadapt version 4.1.0. You have another version of pcadapt installed on your computer. You have two options:",sep="\n")
				cat("Option 1: run selectionanalyses without pcadapt by setting the do_pcadapt flag to false, i.e.: selectionanalyses(do_pcadapt=FALSE).",sep="\n")
				return(cat("Option 2: try to install pcadapt 4.1.0 by running: getpackages(do_pcadapt=TRUE).",sep="\n"))
				}
			if("pcadapt" %in% (.packages()) == FALSE)
				{
				cat("Loading pcadapt...",sep="\n")
				library("pcadapt")
				}
			}
		}
	if(!silent){cat("Checking OutFLANK installation...",sep="\n")}
	if(do_outflank)
		{
		if("OutFLANK" %in% rownames(installed.packages()) == FALSE)
			{
			cat("ERROR: the package 'OutFLANK' is not installed on your computer. You have two options:",sep="\n")
			cat("Option 1: run selectionanalyses without pcadapt by setting the do_outflank flag to false, i.e.: selectionanalyses(do_outflank=FALSE).",sep="\n")
			return(cat("Option 2: try to install OutFLANK by running: getpackages(do_github=TRUE).",sep="\n"))
			}else{
			if("OutFLANK" %in% (.packages()) == FALSE)
				{
				cat("Loading OutFLANK...",sep="\n")
				library("OutFLANK")
				}
			}
		}
	# check whether bayescan output files are provided if needed:
	setwd(mysambar$inputfilesdir)
	mybayefiles <- list.files(pattern = "\\.bayescanout.fst.txt$")
	if(length(mybayefiles)<1&add_bayescan)
		{
		cat("ERROR: the inputfiles directory does not contain files with the extension 'bayescanout.fst'.",sep="\n")
		return(cat("Either set the flag 'add_bayescan' to FALSE or place bayescan output files in the inputfiles directory (see Sambar manual for more details).",sep="\n"))
		}
	#
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	#
	setwd(mysambar$selectiondir)
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	if(!silent){cat("run_locusWCfst",sep="\n")}
	run_locusWCfst(doplot=FALSE,silent=silent)	# in case calcdistance() hasn't been executed yet.
	if(do_meta)
		{
		metapopdir		<- paste(mysambar$selectiondir,"metapop",sep="/")
		setwd(mysambar$selectiondir)
		if(!dir.exists("metapop"))
			{
			cat("Creating output folder called 'metapop'.",sep="\n")
			dir.create(file.path(metapopdir))
			setwd(metapopdir)
			}else{
			setwd(metapopdir)
			cat("Overwriting results in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		cat("Executing selection analyses for the metapopulation.",sep="\n")
		if(do_pcadapt)
			{
			cat("Running PCadapt...",sep="\n")
			if(pcadaptped)
				{
				setwd(mysambar$inputfilesdir)			
				if(!file.exists("metapop.filter2.miss0.letter.ped")|overwriteped)
					{
					cat("Creating PED and MAP file...",sep="\n")
					exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="metapop.filter2.miss0.letter",geno_nr=FALSE,do_all=FALSE)
					}else{
					cat("WARNING: Using existing PED and MAP file...",sep="\n")
					cat("If want to create new files (e.g. because of new filter settings) set the flag 'overwriteped' of the selectionanalyses function to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")  
					}
				setwd(metapopdir)
				}
			runPCadapt(my_dataset="metapop",my_sign_level=signlevel,mycorrection=my_correction,currentdir=TRUE,importped=pcadaptped)
			if(mysambar$pcadapt_error){return(cat("Aborting selectionanalyses run because of PCadapt error.",sep="\n"))}
			}else{
			cat("Skipping PCadapt because do_pcadapt flag is set to FALSE.",sep="\n")
			}
		if(do_outflank)
			{
			cat("Running OutFLANK...",sep="\n")
			cat("If OutFLANK throws an error, set the flag do_outflank to FALSE.",sep="\n")
			setwd(metapopdir)
			runOutflank(my_dataset="metapop",my_sign_level=signlevel,mycorrection=my_correction,currentdir=TRUE)
			}
		if(do_fsthet)
			{
			setwd(mysambar$inputfilesdir)
			# Note: inputdatadir!! not inputfilesdir
			genepopfile 	<- list.files(pattern = "genepop")
			if(length(genepopfile)==0)
				{
				cat("WARNING: No file with the extension 'genepop' found in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				cat("The fsthet software needs a genepop file (same input as your ped and map file, but in different format) as input and will therefore be omitted.",sep="\n")
				setwd(metapopdir)
				#cat("Creating input file for fsthet...",sep="\n")
				#genlight2genepop(input=mygenlight,overwritefile=FALSE,snpsfilter=rep(TRUE,nrow(snps)),indsfilter=rep(TRUE,nrow(SNPS)),addcomma=TRUE,doexport=TRUE) 
				}else{
				cat("Running fsthet...",sep="\n")
				cat("Just so you know: fsthet is very slow compared to GWDS, PCadapt and OutFLANK.",sep="\n")
				cat("If you run into an error or the software takes forever, rerun the selectionanalyses function with the flag do_fsthet set to FALSE.",sep="\n")
				runfsthet(export=TRUE,dataset="metapop",reps=10,fstmethod="betahat",doanalysis=TRUE,my_sign_level=signlevel,currentdir=TRUE)
				}
			}
		setwd(metapopdir)
		cat("Generating Fdist plot...",sep="\n")
		Fdist_plot(my_dataset="metapop",showlegend=TRUE,showlabels=FALSE,exporttype="pdf",axislabels=TRUE,add_borders=FALSE,add_outliers=TRUE,dothin=TRUE)
		Fdist_plot(my_dataset="metapop",showlegend=FALSE,showlabels=FALSE,exporttype="pdf",axislabels=TRUE,add_borders=FALSE,add_outliers=FALSE,dothin=TRUE)
		# plot_scanlog(doexport="pdf",addGWDS=FALSE,addPCadapt=TRUE,add_outflank=do_outflank,addbayescan=add_bayescan,mydataset="metapop",outflankq=FALSE,markoutpheno=FALSE)
		cat("Plotting -log of locus specific p-values outputted by the selection scan(s)...",sep="\n")
		plot_scanlog(doexport="pdf",mydataset="metapop",outflankq=TRUE,markoutpheno=FALSE)
		cat("2D-plots metapop...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset="metapop",logpmax=logp_max)
		if(doplotvenn)
			{
			cat("Creating Venn diagram...",sep="\n")
			plot_venn(my_dataset="metapop")
			}else{
			cat("Skipping Venn diagram because the flag doplotvenn is set to FALSE.",sep="\n")
			}
		if(dopiechart)
			{
			cat("Creating piecharts of minor allele frequencies...",sep="\n")
			cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
			multipiemaf(my_dataset="metapop",do_export=TRUE)
			cat("Combining all test scan piecharts into one plot...",sep="\n")
			cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
			allscans_piemaf(my_dataset="metapop",do_export=TRUE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5,addtestnames=FALSE)
			}else{
			cat("Skipping piecharts because the flag 'dopiechart' is set to FALSE.",sep="\n")
			}
		cat("Writing outliers to bed files...",sep="\n")	
		writebed(my_dataset="metapop")
		cat("Writing outlier info...",sep="\n")
		outlierinfo(mydataset="metapop",control_data=controldata,my_authors=authors,my_species=species,sel_claim=selclaim,my_demo=demography,n_gen=ngenerations,my_geneflow=geneflow,data_info=datainfo)
		if(export_data)
			{
			cat("Exporting datasets...",sep="\n")
			exportneutral(my_dataset="metapop",include_gwds=FALSE,include_pcadapt=do_pcadapt,include_outflank=do_outflank,include_bayescan=add_bayescan,include_fsthet=do_fsthet)
			}
		cat("Finished all selection analyses for 'metapop'.",sep="\n")
		}
	if(do_pairwise)
		{
		cat("Executing selection analyses for all pairwise population comparisons.",sep="\n")
		run_pairwise(overwrite_ped=overwriteped,pcadapt_ped=pcadaptped,dopheno=FALSE,only_pooled=FALSE,allpairwise=TRUE,sign_level=signlevel,do_piechart=dopiechart,addbayescan=add_bayescan,bayescan_FDR=bayescanFDR,bayescan_overwrite=overwrite_bayescan,dopcadapt=do_pcadapt,dooutflank=do_outflank,dofsthet=do_fsthet,do_thinning=do_thin,bin_size=gwdsbinsize,test_correction=my_correction,plotvenn=doplotvenn,log_p_max=logp_max,myauthors=authors,myspecies=species,s_claim=selclaim,demography_model=demography,n_generations=ngenerations,with_geneflow=geneflow,data_information=datainfo,control_dataset=controldata,exportdata=export_data)						
		if(mysambar$pcadapt_error){return(cat("Aborting selectionanalyses run because of PCadapt error.",sep="\n"))}
		cat("Plotting -log p values...",sep="\n")
		multi_plot_scanlog(allpairwise=TRUE,do_export=export,outflank_q=FALSE)
		if(plothisto)
			{
			cat("Creating GWDS histograms. If you receive an error after this line, set flag plothisto to FALSE.",sep="\n")
			gwdshisto_multi(doexport=TRUE,allpairwise=TRUE)	
			}
		cat("Creating He-Fst scatterplots...",sep="\n")
		pheno_Fdist_plot(doexport=export,allpairwise=TRUE,mylabels=phenolabels)
		}
	if(do_pheno)
		{
		if(!silent){cat("Flag do_pheno is set to TRUE.",sep="\n")}
		if(is.null(inds$type))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
			}
		if(!any(inds$type))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) contains FALSE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
			}
		if(!any(inds$type==FALSE))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) contains TRUE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
			}
		poptype1	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[inds$type&inds$filter]))),collapse=".")
		poptype2	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[!inds$type&inds$filter]))),collapse=".")
		if(controldata)
			{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),"pop_control",sep=".")
			}else{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),sep=".")
			}	
		phenodir		<- paste(mysambar$selectiondir,phenodir,sep="/")
		setwd(mysambar$selectiondir)
		if(!dir.exists(phenodir))
			{
			cat("Creating output folder called 'pheno'.",sep="\n")
			dir.create(file.path(phenodir))
			setwd(phenodir)
			}else{
			setwd(phenodir)
			cat("Overwriting results in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		cat("Writing out table with binary division of populations...",sep="\n")
		phenotable	<- table(inds$pop[inds$filter&inds$pop%in%mysambar$populations],inds$type[inds$filter&inds$pop%in%mysambar$populations])
		if(any(apply(phenotable, 1, min)!=0))
			{
			return(cat("ERROR: per population, all individuals should have the same value at the 'inds$type' column (so either TRUE or FALSE). Please redefine the inds$type column or run instead the assocfisher function.",sep="\n"))
			}
		write.table(phenotable,"pheno_popdivision.txt",row.names=TRUE,col.names=TRUE,sep="\t",quote=FALSE)
		cat("Calculating minor allele frequencies for pheno...",sep="\n")
		pheno_maf(indthreshold=inds$filter)
		cat("Executing selection analyses for pheno1 against pheno2.",sep="\n")
		if(onlypooled)
			{
			cat("Because the flag onlypooled is set to TRUE, selection scans will be run for the pooled comparison only.",sep="\n")
			}else{
			cat("Because the flag onlypooled is set to FALSE, selection scans will be run for the pooled comparison as well as for pairwise comparisons.",sep="\n")
			}
		run_pairwise(overwrite_ped=overwriteped,pcadapt_ped=pcadaptped,dopheno=TRUE,only_pooled=onlypooled,sign_level=signlevel,do_piechart=dopiechart,addbayescan=add_bayescan,bayescan_FDR=bayescanFDR,bayescan_overwrite=overwrite_bayescan,dopcadapt=do_pcadapt,dooutflank=do_outflank,dofsthet=do_fsthet,bayescanmapfile=bayescan_mapfile,do_thinning=do_thin,bin_size=gwdsbinsize,test_correction=my_correction,plotvenn=doplotvenn,log_p_max=logp_max,myauthors=authors,myspecies=species,s_claim=selclaim,demography_model=demography,n_generations=ngenerations,with_geneflow=geneflow,data_information=datainfo,control_dataset=controldata,exportdata=export_data)						
		if(mysambar$pcadapt_error){return(cat("Aborting selectionanalyses run because of PCadapt error.",sep="\n"))}
		setwd(phenodir)
		if(!onlypooled)
			{
			cat("Creating Manhattan plots for all pheno comparisons showing -ln(Fisher exact test p-values)...",sep="\n")
			pheno_manhattan(doexport=export,myphenolabels=phenolabels,dothinning=do_thin,show_fisher=TRUE)
			cat("Creating Manhattan plots for all pheno comparisons showing -log(GWDS p-values)...",sep="\n")
			pheno_manhattan(doexport=export,myphenolabels=phenolabels,dothinning=do_thin,show_fisher=FALSE)
			cat("Creating histograms...",sep="\n")
			if(plothisto)
				{
				cat("Creating GWDS histograms for all pheno comparisons. If you receive an error after this line, set flag plothisto to FALSE.",sep="\n")
				gwdshisto_multi(doexport=TRUE,allpairwise=FALSE)
				}
			cat("Creating He-Fst scatterplots for all pheno comparisons...",sep="\n")	
			pheno_Fdist_plot(doexport=export,allpairwise=FALSE,mylabels=phenolabels)
			}else{
			gwdshisto(exportname="pheno")
			}
		cat("Plotting -log p values...",sep="\n")
		multi_plot_scanlog(allpairwise=FALSE,do_export=export,outflank_q=FALSE)
		Fdist_plot(my_dataset="pheno",axislabels=TRUE,add_outliers=TRUE,add_borders=TRUE,legendpheno=TRUE,exporttype="pdf")
		cat("2D-plots pheno...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset="pheno",logpmax=logp_max)
		plotpvalues(export="pdf",test1="OutFLANK",test2="rfisherGWDS",mydataset="pheno",mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL)
		if(dopiechart)
			{
			cat("Creating piecharts of minor allele frequencies...",sep="\n")
			cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
			multipiemaf(my_dataset="pheno",do_export=TRUE)
			cat("Combining all test scan piecharts into one plot...",sep="\n")
			cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
			allscans_piemaf(my_dataset="pheno",do_export=TRUE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5)
			}else{
			cat("Skipping piecharts because the flag 'dopiechart' is set to FALSE.",sep="\n")
			}
		cat("Note that outliers for pooled data (pheno1 vs pheno2) is meaningful if (and only if) populations within both groups are isolated from each other (i.e. no gene flow).",sep="\n")
		cat("Independency of populations can be inferred from output of calcdistance() and calcdiversity() function.",sep="\n")
		}
	setwd(mysambar$inputdatadir)
	cat("Set the flag 'export_data' to TRUE if you want to output PED and MAP files of neutral and outlier datasets.",sep="\n")
	# makebayenvinput()
	}

selectionstudy_workflow<-function()
	{
	# say we have 4 populations, consisting (for example) of 2 saltwater (A and B) and 2 fresh water populations (C and D)
	#
	#### 1. EXPERIMENTAL POOLED AND EXPERIMENTAL PAIRWISE COMPARISON
	# run selection analyses for true population division, both group and pheno
	inds$type<-ifelse(inds$pop=="A"|inds$pop=="B",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=TRUE)
	# this will create outlier.pheno.info.txt for pooled comparison and for each pairwise comparison outlier.pop1_pop2.pairwise.info.txt files
	# if Outflank gives an error for one of the pairwise comparisons, then run twice:
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=TRUE,do_outflank=TRUE)
	#
	#### 2. CONTROL POOLED POPULATION COMPARISON
	# run selection analyses for artificial pooled population comparison for which no shared selective pressures are to be expected
	# say 2 repeats
	inds$type<-ifelse(inds$pop=="A"|inds$pop=="C",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=TRUE,controldata=TRUE)
	inds$type<-ifelse(inds$pop=="B"|inds$pop=="C",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=TRUE,controldata=TRUE)
	# this will create outlier.pheno.pop_control.info.txt files
	#
	#### 3. CONTROL PAIRWISE POPULATION COMPARISON
	# run selection analyses for artificial pairwise population comparison for which no shared selective pressures are to be expected
	# say 2 repeats
	excludepop(mysambar$populations[mysambar$populations!="A"&mysambar$populations!="B"])
	inds$type<-ifelse(inds$pop=="C"|inds$pop=="D",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=FALSE,do_pairwise=TRUE,do_outflank=TRUE,controldata=TRUE)
	excludepop(mysambar$populations[mysambar$populations!="A"&mysambar$populations!="B"])
	inds$type<-ifelse(inds$pop=="A"|inds$pop=="B",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=FALSE,do_pairwise=TRUE,do_outflank=TRUE,controldata=TRUE)
	# this will create outlier.pheno.pop_control.info.txt file
	#
	#### 4. CONTROL INDIVIDUAL COMPARISON
	# run selection analyses for artificial division of individuals
	excludepop()
	inds$randompheno <- sample(c(TRUE,FALSE),nrow(inds),replace=TRUE)
	assocfisher(pheno="randompheno",export="pdf")
	# this will create outlier.assoc1_assoc2.txt file
	}

run_pairwise<-function(dopheno=FALSE,do_analysis=TRUE,only_pooled=FALSE,allpairwise=FALSE,sign_level=0.05,do_piechart=TRUE,pheno_labels=NULL,mylabels=NULL,popnames=mysambar$populations,addbayescan=FALSE,bayescan_FDR=0.01,bayescan_overwrite=FALSE,dopcadapt=TRUE,pcadapt_ped=FALSE,dooutflank=TRUE,dofsthet=FALSE,bayescanmapfile=NULL,overwrite_ped=FALSE,do_thinning=TRUE,bin_size=1000000,overwritebin=TRUE,log_p_max=NULL,test_correction="bonferroni",plotvenn=TRUE,myauthors=NULL,myspecies=NULL,s_claim=NULL,demography_model=NULL,n_generations=NULL,with_geneflow=NULL,data_information=NULL,control_dataset=FALSE,exportdata=FALSE)
	{
	mysambar$pcadapt_error	<<- FALSE
	if(is.null(inds$type)&!allpairwise)
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(dopheno&!"maf_pheno1"%in%colnames(snps))
		{
		pheno_maf(indthreshold=inds$filter)
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	# find all pairwise comparisons between type1 and type2:
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type&inds$filter]))
		type1		<- type1[order(type1)]
		type2		<- as.vector(unique(inds$pop[!inds$type&inds$filter]))
		type2		<- type2[order(type2)]
		allcombi	<- t(expand.grid(type1,type2))
		}
	#
	# grouping snps into bins (optionally needed to infer neutral distribution of gwds scores):
	if(do_thinning)
		{
		if("dist" %in% colnames(snps))
			{
			if("distbin"%in%colnames(snps)&!overwritebin)
				{
				cat("WARNING: Using existing position bins defined in column snps$distbin.",sep="\n")
				cat("If you want to create new position bins, set the flag overwritebin to TRUE or alternatively delete existing column.",sep="\n")
				}else{
				cat("Dividing snps into bins based on position in genome...",sep="\n")
				cat(paste("Binsize: ",bin_size," bp.",sep=""),sep="\n")
				snps$distbin	<<- NA
				mychroms		<- as.vector(unique(snps$chr))
				for(mychrom in mychroms)
					{
					#cat(mychrom,sep="\n")
					mysnpspos							<- snps$pos[snps$chr==mychrom]
					if(length(mysnpspos)>1)
						{
						mybreaks						<- seq(0,max(mysnpspos),bin_size)
						if(length(mybreaks)==1)
							{
							if(mybreaks==0)
								{
								snps$distbin[snps$chr==mychrom]<<- paste(as.character(mychrom),as.character(bin_size/2),sep="_")
								}else{
								mylabelstemp	<- mybreaks-bin_size/2
								mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
								snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
								}
							}else{
							mylabelstemp	<- mybreaks[2:length(mybreaks)]-bin_size/2
							mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
							snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
							}
						}else{
						snps$distbin[snps$chr==mychrom]	<<- paste(as.character(mychrom),as.character(mysnpspos),sep="_")
						}
					}
				cat("Selecting one snp per bin...",sep="\n")
				snps$binfilter						<<- NA
				snpstemp							<- snps[snps$filter2,]
				snps$binfilter[snps$filter2]		<<- !duplicated(snpstemp$distbin)
				snps$binfilter[is.na(snps$binfilter)]<<- FALSE
				nretained							<- nrow(snps[snps$binfilter,])
				cat(paste("Number of SNPs which will be used by GWDS to define the neutral distribution: ",nretained,".",sep=""),sep="\n")  
				}
			}else{
			cat("WARNING: No positional information. SambaR will infer neutral distribution of GWDS scores from unthinned dataset even do the flag 'dothin' is set to TRUE (default).",sep="\n")
			snps$binfilter							<<- snps$filter2
			}
		}else{
		cat("WARNING: The flag 'dothin' is set to FALSE (default is TRUE). SambaR will infer neutral distribution from unthinned dataset.",sep="\n")
		snps$binfilter								<<- snps$filter2
		}
	#	
	## pairwise comparisons:
	ncombi		<- ncol(allcombi)
	if(!only_pooled)
		{
		for(my_i in c(1:ncombi))
			{
			mypop_1		<- allcombi[1,my_i]
			mypop_2		<- allcombi[2,my_i]
			my_pops		<- c(mypop_1,mypop_2)
			my_pops		<- my_pops[order(my_pops)]
			my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
			cat(" ",sep="\n")
			cat(my_pair,sep="\n")
			#
			pairwisedir	<- paste(mysambar$selectiondir,my_pair,sep="/")
			setwd(mysambar$selectiondir)
			if(!dir.exists(my_pair))
				{
				cat(paste("Creating output folder called ",my_pair,".",sep=""),sep="\n")
				dir.create(file.path(pairwisedir))
				setwd(pairwisedir)
				}else{
				setwd(pairwisedir)
				cat("Overwriting results in directory:",sep="\n")
				cat(getwd(),sep="\n")	
				}
			#
			indselect	<- inds$filter&(inds$pop==allcombi[1,my_i]|inds$pop==allcombi[2,my_i])
			combiname	<- paste(my_pair,"filter2.miss0.letter",sep=".")
			cat("Running genome wide differentiation scan (GWDS)...",sep="\n")
			gwdsfisher(my_dataset=my_pair,my_sign_level=sign_level,dothin=do_thinning,binsize=bin_size,mycorrection=test_correction)
			cat("Creating Manhattan plot showing -ln(Fisher exact test p-values)...",sep="\n")
			gwdsmanhattan(my_dataset=my_pair,showfisher=TRUE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
			cat("Creating Manhattan plot showing -log(GWDS p-values)...",sep="\n")
			gwdsmanhattan(my_dataset=my_pair,showfisher=FALSE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
			if(dopcadapt)
				{
				# 28_10_2021: until now data was exported to ped and then imported with read.pcadapt function
				# However, this is not necessary, because read.pcadapt also accepts existing r objects
				if(pcadapt_ped)
					{
					# if importing data via ped-file
					cat("Checking if inputfiles for PCadapt are present...",sep="\n")
					setwd(mysambar$inputfilesdir)
					if(file.exists(paste(combiname,"ped",sep=".")))
						{
						if(!overwrite_ped)
							{
							cat(paste("WARNING: Using existing PED and MAP files (prefix: ",combiname,") in the inputfiles directory.",sep=""),sep="\n")
							cat("If these files have been generated using different filter settings than the current filter settings, you will encounter an error when running PCadapt.",sep="\n")
							cat("If want to create new files (e.g. because of new filter settings) set the flag 'overwriteped' of the selectionanalyses function to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")  
							}else{
							cat("Overwriting existing PED and MAP files...",sep="\n")
							exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)
							}
						}else{
						cat("Creating new PED and MAP files...",sep="\n")
						exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)		
						}
					setwd(pairwisedir)
					}
				cat("Running PCadapt...",sep="\n")
				runPCadapt(K=2,popnames=c(mypop_1,mypop_2),my_dataset=my_pair,my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE,importped=pcadapt_ped)
				if(mysambar$pcadapt_error){return(cat("Aborting run_pairwise run because of PCadapt error.",sep="\n"))}
				}else{
				cat("Skipping PCadapt because dopcadapt flag is set to FALSE.",sep="\n")
				}
			if(dooutflank)
				{
				cat("Running OutFLANK...",sep="\n")
				cat("If OutFLANK throws an error, set the flag do_outflank to FALSE.",sep="\n")
				setwd(pairwisedir)
				runOutflank(indselection=indselect,my_dataset=my_pair,my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE)
				}
			setwd(pairwisedir)
			if(addbayescan)
				{
				cat("Obtaining Bayescan results...",sep="\n")
				getbayescan(export="pdf",FDR=bayescan_FDR,my_dataset=my_pair,inputmapfile=bayescanmapfile,baye_overwrite=bayescan_overwrite)
				setwd(pairwisedir)
				}
			if(dofsthet)
				{
				setwd(mysambar$inputdatadir)
				# Note: inputdatadir!! not inputfilesdir
				genepopfile 	<- list.files(pattern = "genepop")
				if(length(genepopfile)==0)
					{
					cat("WARNING: No file with extension 'genepop' found in the directory:",sep="\n")
					cat(getwd(),sep="\n")
					cat("The fsthet software needs a genepop file as input and will therefore be omitted.",sep="\n")
					setwd(pairwisedir)
					# This did not work because genepop file generated by SambaR was not accepted by fsthet.
					#cat("Creating input file for fsthet...",sep="\n")
					#genlight2genepop(input=mygenlight,overwritefile=FALSE,snpsfilter=rep(TRUE,nrow(snps)),indsfilter=rep(TRUE,nrow(SNPS)),addcomma=TRUE,doexport=TRUE) 
					}else{
					cat("Running fsthet...",sep="\n")
					cat("Just so you know: fsthet is very slow compared to GWDS, PCadapt and OutFLANK.",sep="\n")
					cat("If you run into an error or the software takes forever, rerun the selectionanalyses function with the flag do_fsthet set to FALSE.",sep="\n")
					setwd(pairwisedir)
					runfsthet(export=TRUE,dataset=my_pair,reps=10,fstmethod="betahat",doanalysis=TRUE,my_sign_level=sign_level)
					}
				setwd(pairwisedir)
				}
			if(do_piechart)
				{
				cat("Creating piecharts...",sep="\n")
				cat("If you receive an error after this line, set the flag do_piechart (or dopiechart if running selectionanalyses function) to FALSE.",sep="\n")
				multipiemaf(my_dataset=my_pair,do_export=TRUE)
				cat("If you receive an error after this line, set the flag do_piechart (or dopiechart if running selectionanalyses function) to FALSE.",sep="\n")
				cat("Combining all test scan piecharts into one plot...",sep="\n")
				cat("If you receive an error after this line, set the flag do_piechart (or dopiechart if running selectionanalyses function) to FALSE.",sep="\n")
				allscans_piemaf(my_dataset=my_pair,do_export=TRUE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5)
				}else{
				cat("Skipping piecharts because the flag 'do_piechart' is set to FALSE.",sep="\n")
				}
			setwd(pairwisedir)
			if(plotvenn)
				{
				cat("Creating Venn diagram...",sep="\n")
				plot_venn(my_dataset=my_pair)
				}else{
				cat("Skipping Venn diagram because the flag plotvenn is set to FALSE.",sep="\n")
				}
			cat("2D-plots pairwise comparison...",sep="\n")
			multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset=my_pair,logpmax=log_p_max)
			plotpvalues(export="pdf",test1="OutFLANK",test2="rfisherGWDS",mydataset=my_pair,mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL)
			cat("Writing outliers to bed files...",sep="\n")
			writebed(my_dataset=my_pair)
			cat("Writing outlier info...",sep="\n")
			outlierinfo(mydataset=my_pair,my_authors=myauthors,my_species=myspecies,sel_claim=s_claim,my_demo=demography_model,n_gen=n_generations,my_geneflow=with_geneflow,data_info=data_information,control_data=control_dataset)
			if(exportdata)
				{
				cat("Exporting datasets...",sep="\n")
				exportneutral(my_dataset=my_pair,include_gwds=TRUE,include_pcadapt=dopcadapt,include_outflank=dooutflank,include_bayescan=addbayescan,include_fsthet=dofsthet)
				}
			}
		}
	## pooled comparison:
	if(dopheno)
		{
		cat(" ",sep="\n")
		cat("pheno1_pheno2 (pooled data)",sep="\n")
		poptype1	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[inds$type&inds$filter]))),collapse=".")
		poptype2	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[!inds$type&inds$filter]))),collapse=".")
		if(control_dataset)
			{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),"pop_control",sep=".")
			}else{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),sep=".")
			}
		phenodir		<- paste(mysambar$selectiondir,phenodir,sep="/")	
		setwd(mysambar$selectiondir)
		if(!dir.exists(phenodir))
			{
			cat("Creating output folder called 'pheno'.",sep="\n")
			dir.create(file.path(phenodir))
			setwd(phenodir)
			}else{
			setwd(phenodir)
			cat("Overwriting results in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		locusWCfst(my_dataset="pheno",do_plot=FALSE)
		cat("Running genome wide differentiation scan (GWDS)...",sep="\n")
		gwdsfisher(my_dataset="pheno",my_sign_level=sign_level,dothin=do_thinning,binsize=bin_size,mycorrection=test_correction)
		cat("Creating Manhattan plot showing -ln(Fisher exact test p-values)...",sep="\n")
		gwdsmanhattan(my_dataset="pheno",showfisher=TRUE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
		cat("Creating Manhattan plot showing -log(GWDS p-values)...",sep="\n")
		gwdsmanhattan(my_dataset="pheno",showfisher=FALSE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
		if(dopcadapt)
			{
			if(pcadapt_ped)
				{
				# 28_10_2021: until now data was exported to ped and then imported with read.pcadapt function
				# However, this is not necessary, because read.pcadapt also accepts existing r objects
				cat("Checking if inputfiles for PCadapt are present...",sep="\n")
				setwd(mysambar$inputfilesdir)
				if(file.exists("pheno.filter2.miss0.letter.ped"))
					{
					if(!overwrite_ped)
						{
						cat(paste("WARNING: Using existing PED and MAP files (prefix: 'pheno.filter2.miss0.letter') in the inputfiles directory.",sep=""),sep="\n")
						cat("If these files have been generated using different filter settings than the current filter settings, you will encounter an error when running PCadapt.",sep="\n")
						cat("If want to create new files (e.g. because of new filter settings) set the flag 'overwriteped' of the selectionanalyses function to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")  
						}else{
						cat("Overwriting existing PED and MAP files...",sep="\n")
						exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.miss0.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)
						}
					}else{
					cat("Creating new PED and MAP files...",sep="\n")
					exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.miss0.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)		
					}
				setwd(phenodir)
				}
			cat("Running PCadapt...",sep="\n")
			# Here there are two options: run PCadapt with K = 2 (because two phenotypes) or with K equalling number of populations. 
			runPCadapt(K=2,popnames=mysambar$populations,my_dataset="pheno",my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE,importped=pcadapt_ped)	# K equalling 2
			if(mysambar$pcadapt_error){return(cat("Aborting run_pairwise run because of PCadapt error.",sep="\n"))}
			#runPCadapt(popnames=mysambar$populations,my_dataset="pheno")		# K equalling number of populations
			}else{
			cat("Skipping PCadapt because dopcadapt flag is set to FALSE.",sep="\n")
			}
		setwd(phenodir)
		if(dooutflank)
			{
			cat("Running OutFLANK...",sep="\n")
			cat("If OutFLANK throws an error, set the flag do_outflank to FALSE.",sep="\n")
			setwd(phenodir)
			runOutflank(indselection=inds$filter,my_dataset="pheno",popcolumn=inds$type,my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE)
			}
		setwd(phenodir)
		if(addbayescan)
			{
			cat("Obtaining Bayescan results...",sep="\n")
			getbayescan(export="pdf",FDR=bayescan_FDR,my_dataset="pheno",inputmapfile=bayescanmapfile,baye_overwrite=bayescan_overwrite)
			}
		setwd(phenodir)
		if(dofsthet)
			{
			setwd(mysambar$inputdatadir)
			# Note: inputdatadir!! not inputfilesdir
			genepopfile 	<- list.files(pattern = "genepop")
			if(length(genepopfile)==0)
				{
				cat("WARNING: No file with extension 'genepop' found in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				cat("The fsthet software needs a genepop file (same input as your ped and map file, but in different format) as input and will therefore be omitted.",sep="\n")
				setwd(mysambar$selectiondir)
				#cat("Creating input file for fsthet...",sep="\n")
				#genlight2genepop(input=mygenlight,overwritefile=FALSE,snpsfilter=rep(TRUE,nrow(snps)),indsfilter=rep(TRUE,nrow(SNPS)),addcomma=TRUE) 
				}else{
				cat("Running fsthet...",sep="\n")
				cat("Just so you know: fsthet is very slow compared to GWDS, PCadapt and OutFLANK.",sep="\n")
				cat("If you run into an error or the software takes forever, rerun the selectionanalyses function with the flag do_fsthet set to FALSE.",sep="\n")
				runfsthet(export=TRUE,dataset="pheno",reps=10,fstmethod="betahat",doanalysis=TRUE,phenonames=pheno_labels,my_sign_level=sign_level)
				}
			}
		setwd(phenodir)
		cat("Creating Venn diagram...",sep="\n")
		if(plotvenn)
			{
			cat("Creating Venn diagram...",sep="\n")
			plot_venn(my_dataset="pheno")
			}else{
			cat("Skipping Venn diagram because the flag plotvenn is set to FALSE.",sep="\n")
			}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		cat("Writing outliers to bed files...",sep="\n")
		writebed(my_dataset="pheno")
		cat("Writing outlier info...",sep="\n")
		outlierinfo(mydataset="pheno",my_authors=myauthors,my_species=myspecies,sel_claim=s_claim,my_demo=demography_model,n_gen=n_generations,my_geneflow=with_geneflow,data_info=data_information,control_data=control_dataset)
		if(exportdata)
			{
			cat("Exporting datasets...",sep="\n")
			exportneutral(my_dataset="pheno",include_gwds=TRUE,include_pcadapt=dopcadapt,include_outflank=dooutflank,include_bayescan=addbayescan,include_fsthet=dofsthet)
			}
		#cat("Plotting overlap between comparisons...",sep="\n")
		#multioverlap_approach(doexport="pdf",popnames=mysambar$populations,pmax=11,silent=TRUE,pheno_label=paste(pheno_labels,collapse="_"))
		}
	}

# 15-10-2020: this function can be used to create binary population divisions other than true binary division
allcontrol<-function(ntrue=3,maxcomp=5,popnames=mysambar$populations)
	{
	if(!"type"%in%colnames(inds))
		{
		return(cat("ERROR: define inds$type column with true binary division of populations.",sep="\n"))
		}
	poptype1			<- which(mysambar$populations%in%as.vector(unique(inds$pop[inds$type])))
	#
	mypops				<- c(1:length(popnames))
	allcombi			<- combn(mypops,ntrue)
	boolvec				<- apply(allcombi, 2, function(x) all(x == poptype1))
	allcombi			<- allcombi[,!boolvec]
	if(ncol(allcombi)>maxcomp)
		{
		allcombi		<<- allcombi[,sample(1:ncol(allcombi),maxcomp,replace=FALSE)]
		}
	}

# this function extracts all outlierinfo files present in subdirectories
run_getoutlierinfo<-function(my_dir=NULL,silent=TRUE)
	{
	if(is.null(my_dir))
		{
		return(cat("ERROR: define a directory to the my_dir flag.",sep="\n"))
		}
	if(file.exists(my_dir))
		{
		setwd(my_dir)
		}else{
		cat("ERROR: Non-existing directory specified to my_dir flag:",sep="\n")
		return(cat(my_dir,sep="\n"))	
		}
	mydatatypes				<- c('pooled','pooled_control','pairwise','pairwise_control','ind_control')
	outlierfileslist		<<- list()
	outlierdflist			<<- list()
	for(typenr in c(1:5))
		{
		getoutlierinfo(mydir=my_dir,selectall=FALSE,silent=silent,skipdata=TRUE,datatype=mydatatypes[typenr])
		outlierfileslist[[typenr]]	<<- filenames
		if(!getinfoerror)
			{
			outlierdflist[[typenr]]	<<- outlierdf_temp 
			}else{
			outlierdflist[[typenr]]	<<- NULL
			}
		}
	names(outlierdflist)	<<- mydatatypes
	names(outlierfileslist)	<<- mydatatypes
	#alloutliersdf			<<- rbind(pooleddf,pooledcontroldf,pairwisedf,pairwisecontroldf,indcontroldf)
	alloutliersdf			<<- do.call(rbind,outlierdflist)
	cat("The names of the input files are stored in a list object called 'outlierfileslist'.",sep="\n") 
	cat("All data has been stored in a dataframe called 'alloutliersdf'.",sep="\n") 
	mydatatypes	<- c('pooled','pooled_control','pairwise','pairwise_control','ind_control')
	if(any(!mydatatypes%in%alloutliersdf$datatype))
		{
		cat("WARNING: not all datatypes included. Missing:",sep="\n")
		cat(mydatatypes[!mydatatypes%in%alloutliersdf$datatype],sep="\n")
		}
	#
	# uniform distribution of p-values?
	alloutliersdf$gwds_p	<<- 10^(-alloutliersdf$rfisherGWDSlogp)
	alloutliersdf$gwds_padj	<<- NA
	for(j in c(1:nrow(alloutliersdf)))
		{
		alloutliersdf$gwds_padj[j]	<<- p.adjust(alloutliersdf$gwds_p[j],method="bonferroni",n=alloutliersdf$nsnps[j])
		}
	hist(alloutliersdf$gwds_padj[alloutliersdf$dataset=="pheno"&alloutliersdf$rfisherGWDS==TRUE])
	}

getoutlierinfo<-function(mydir=NULL,selectall=FALSE,silent=TRUE,skipdata=TRUE,datatype="pooled",checkclass=FALSE)
	{
	# datatype can be 'pooled', 'pooled_control', 'pairwise', 'pairwise_control', and 'ind_control'
	# file_extensions are "pheno.info.txt","pheno.pop_control.pooled.info.txt","pairwise.info.txt","pop_control.pairwise.info.txt","assoc1_assoc2.info.txt"
	#
	if(is.null(mydir))
		{
		return(cat("ERROR: define a directory to the mydir flag.",sep="\n"))
		}
	getinfoerror	<<- FALSE
	if(!silent){cat("Setting path defined to mydir as working directory...",sep="\n")}
	if(file.exists(mydir))
		{
		setwd(mydir)
		}else{
		cat("ERROR: Non-existing directory specified to mydir flag:",sep="\n")
		return(cat(mydir,sep="\n"))	
		}
	if(datatype!="pooled"&&datatype!="pooled_control"&&datatype!="pairwise"&&datatype!="pairwise_control"&&datatype!="ind_control")
		{
		cat(paste("ERROR: the flag datatype is currently set to: ",datatype,".",sep=""),sep="\n") 
		return(cat("The flag datatype should be set either to 'pooled', 'pooled_control', 'pairwise', 'pairwise_control', and 'ind_control'.",sep="\n"))  	
		}
	if(!silent){cat("Searching for files within subdirectories...",sep="\n")}
	if(datatype=="pooled")
		{
		cat(" ",sep="\n")
		cat("POOLED",sep="\n")
		cat("Datatype is set to 'pooled'. Importing outlierinfo files called 'myoutliers.GWDSorOutFLANK.pheno.info.txt'.",sep="\n")
		filenames		<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.pheno.info.txt",recursive = TRUE)
		filenames		<- filenames[!grepl("pop_control",filenames)]
		}
	if(datatype=="pooled_control")
		{
		cat(" ",sep="\n")
		cat("POOLED_CONTROL",sep="\n")
		cat("Datatype is set to 'pooled_control'. Importing outlierinfo files called 'myoutliers.GWDSorOutFLANK.pheno.pop_control.info.txt'...",sep="\n")
		filenames		<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.pheno.pop_control.pooled.info.txt",recursive = TRUE)
		}
	if(datatype=="pairwise")
		{
		cat(" ",sep="\n")
		cat("PAIRWISE",sep="\n")
		cat("Datatype is set to 'pairwise'. Importing outlierinfo files which do not contain the string 'pop_control' and which end on 'pairwise.info.txt'...",sep="\n")
		filenames		<- list.files(mydir,pattern=glob2rx("myoutliers.GWDSorOutFLANK*pairwise.info.txt"),recursive=TRUE)
		filenames		<- filenames[!grepl("pop_control",filenames)]
		}
	if(datatype=="pairwise_control")
		{
		cat(" ",sep="\n")
		cat("PAIRWISE_CONTROL",sep="\n")
		cat("Datatype is set to 'pairwise_control'. Importing outlierinfo files which end on 'pop_control.pairwise.info.txt'...",sep="\n")
		filenames		<- list.files(mydir,pattern=glob2rx("myoutliers.GWDSorOutFLANK*pop_control.pairwise.info.txt"),recursive=TRUE)
		}
	if(datatype=="ind_control")
		{
		cat(" ",sep="\n")
		cat("IND_CONTROL",sep="\n")
		cat("Datatype is set to 'ind_control'. Importing outlierinfo files called 'myoutliers.GWDSorOutFLANK.assoc1_assoc2.info.txt'.",sep="\n")
		filenames		<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.assoc1_assoc2.info.txt",recursive = TRUE)
		}
	nfiles			<- length(filenames)
	if(!silent){cat(paste("Importing ",nfiles," file(s)...",sep=""),sep="\n")}
	filenames		<<- filenames
	if(!silent){cat("File name(s):",sep="\n")}
	inputdatalist 	<<- lapply(filenames,function(x)
								{
								cat(x,sep="\n")
								read.table(x,header=TRUE)
								})
	inputdatalist2	<<- list()
	if(!silent){cat("Subselecting columns...",sep="\n")}
	if(selectall)
		{
		cat("Selecting all columns...",sep="\n")
		mycolumns	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		mycolnames	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		}else{
		cat("Selecting essential columns only...",sep="\n")
		if(datatype=="ind_control")
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p_assoc1_assoc2","rfisherGWDSlogp_assoc1_assoc2","OutFLANKlogp_assoc1_assoc2","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			# 08-02-2021: Use the following line if necessary (if outlier files have been generated with an old version of SambaR which labelled columns of indcontrol outlierinfo files incorrectly):
			#mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p","rfisherGWDSlogp","OutFLANKlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		if(datatype=="pooled"||datatype=="pooled_control")	
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","OutFLANKlogp_pheno","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p","rfisherGWDSlogp","OutFLANKlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		if(datatype=="pairwise"||datatype=="pairwise_control")	
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p","rfisherGWDSlogp","OutFLANKlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		}
	if(!silent){cat("Adding columns OutFLANK and PCadapt if absent...",sep="\n")}
	for(i in c(1:length(inputdatalist)))
		{
		if(!silent){cat(i,sep="\n")}
		mydf		<- inputdatalist[[i]]
		if(!"OutFLANK"%in%colnames(mydf))
			{
			mydf$OutFLANK						<- "error"
			}
		if(!"OutFLANKlogp"%in%colnames(mydf))
			{
			mydf$OutFLANKlogp					<- "error"
			}
		if(!"n_OutFLANK_adjacent"%in%colnames(mydf))
			{
			mydf$n_OutFLANK_adjacent			<- as.integer(0)
			}
		if(!"n_GWDS_adjacent"%in%colnames(mydf))
			{
			mydf$n_GWDS_adjacent				<- as.integer(0)
			}
		if(!"PCadapt"%in%colnames(mydf))
			{
			mydf$PCadapt						<- "error"
			}
		if(datatype=="pairwise"||datatype=="pairwise_control")	
			{
			if(!"OutFLANKlogp_pairwise"%in%colnames(mydf))
				{
				mydf$OutFLANKlogp_pairwise			<- NA
				}
			}
		if(datatype=="pooled"||datatype=="pooled_control")	
			{
			if(!"OutFLANKlogp_pheno"%in%colnames(mydf))
				{
				mydf$OutFLANKlogp_pheno				<- NA
				}
			}
		if(datatype=="ind_control")	
			{
			if(!"OutFLANKlogp_assoc1_assoc2"%in%colnames(mydf))
				{
				mydf$OutFLANKlogp_assoc1_assoc2		<- NA
				}
			}
		if(any(mydf$n_GWDS_adjacent=="de_novo",na.rm=TRUE))			{mydf$n_GWDS_adjacent		<- as.integer(0)}
		if(any(mydf$n_OutFLANK_adjacent=="de_novo",na.rm=TRUE))		{mydf$n_OutFLANK_adjacent	<- as.integer(0)}
		mydf$chr	<- as.character(mydf$chr)
		mydf$name	<- as.factor(mydf$name)
		mybool		<- mycolumns%in%colnames(mydf)
		#
		if(any(!mybool))
			{
			mycolumns2	<- mycolumns[!mybool]
			if(!skipdata)
				{
				cat(paste("ERROR: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				return(cat("Set the flag 'skipdata' to TRUE in order to continue with next dataset.",sep="\n")) 
				}else{
				cat(paste("WARNING: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				cat("The flag skipdata is set to TRUE. Omitting dataset.",sep="\n")
				inputdatalist2[[i]]	<<- NA
				}
			}else{
			if(!silent){cat("All columns present.",sep="\n")}
			inputdatalist2[[i]]		<<- mydf[,mycolumns]
			if(checkclass)
				{
				exp_class	<- c("logical","logical","character","integer","factor","factor","logical","character","character","numeric","numeric","numeric","integer","integer","integer","integer","integer","integer","integer","numeric","numeric")
				obs_class	<- as.vector(unlist(lapply(inputdatalist2[[i]],class)))
				if(any(exp_class!=obs_class))
					{
					return(cat("ERROR: unexpected classes.",sep="\n"))
					}
				}
			}
		}
	# remove skipped dataframes and then combine:	
	if(!silent){cat("Removing skipped datasets from list...",sep="\n")}
	inputdatalist3	<<- inputdatalist2[lapply(inputdatalist2,length)>1] 
	if(length(inputdatalist3)==0)
		{
		return(cat("ERROR: No data to combine. Perhaps set the flag skipdata to FALSE?",sep="\n"))
		}
	#
	if(!silent){cat("Combining dataframes from list into data frame 'outlierdf'...",sep="\n")}
	outlierdf				<- do.call(rbind,inputdatalist3)
	if(!silent){cat("Assigning column names to 'outlierdf' dataframe...",sep="\n")}
	colnames(outlierdf)		<- mycolnames
	outlierdf$outlierscore	<- outlierdf$rfisherGWDSlogp/outlierdf$bonf
	outlierdf$datatype		<- datatype
	outlierdf_temp			<<- outlierdf
	#
	if(!silent){cat("Returning dataframes...",sep="\n")}
	if(datatype=="pooled")
		{
		pooleddf			<<- outlierdf
		cat("All results stored in dataframe called 'pooleddf'.",sep="\n")
		}
	if(datatype=="pooled_control")
		{
		pooledcontroldf		<<- outlierdf
		cat("All results stored in dataframe called 'pooledcontroldf'.",sep="\n")
		}
	if(datatype=="pairwise")
		{
		pairwisedf			<<- outlierdf
		cat("All results stored in dataframe called 'pairwisedf'.",sep="\n")
		}	
	if(datatype=="pairwise_control")
		{
		pairwisecontroldf	<<- outlierdf
		cat("All results stored in dataframe called 'pairwisecontroldf'.",sep="\n")
		}	
	if(datatype=="ind_control")
		{
		indcontroldf		<<- outlierdf
		cat("All results stored in dataframe called 'indcontroldf'.",sep="\n")
		}
	}	

# 15-10-2020: this function can be used to collect all selection scan results (generated for all SNP datasets stored in specified folder)
getoutlierinfo_old<-function(mydir="C:/Users/Menno_de_Jong/Documents/SNPdatasets",selectall=FALSE,silent=TRUE,skipdata=TRUE,do_control=FALSE)
	{
	if(do_control)
		{
		cat("Importing outlierinfo files containing 'assoc1_assoc2' string...",sep="\n")
		filenames		<<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.assoc1_assoc2*",recursive = TRUE)
		}else{
		cat("Importing outlierinfo files containing 'assoc1_assoc2' string...",sep="\n")
		filenames		<<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.pheno*",recursive = TRUE)
		}
	inputdatalist 	<<- lapply(filenames,function(x)read.table(x,header=TRUE))
	inputdatalist2	<<- list()
	if(selectall)
		{
		cat("Selecting all columns...",sep="\n")
		mycolumns	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		mycolnames	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		}else{
		cat("Selection essential columns only...",sep="\n")
		if(do_control)
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p_assoc1_assoc2","rfisherGWDSlogp_assoc1_assoc2","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_ind1","n_ind2","He","Fst")
			}else{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","bonf","nsnps","n_GWDS","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		}
	for(i in c(1:length(inputdatalist)))
		{
		if(!silent){cat(i,sep="\n")}
		mydf		<- inputdatalist[[i]]
		if(!"OutFLANK"%in%colnames(mydf))
			{
			mydf$OutFLANK	<- "error"
			}
		if(!"PCadapt"%in%colnames(mydf))
			{
			mydf$PCadapt	<- "error"
			}
		if(!"PCadapt"%in%colnames(mydf))
			{
			mydf$PCadapt	<- "error"
			}
		mybool		<- mycolumns%in%colnames(mydf)
		if(any(!mybool))
			{
			mycolumns2	<- mycolumns[!mybool]
			if(!skipdata)
				{
				cat(paste("ERROR: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				return(cat("Set the flag 'skipdata' to TRUE in order to continue with next dataset.",sep="\n")) 
				}else{
				cat(paste("WARNING: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				cat("The flag skipdata is set to TRUE. Omitting dataset.",sep="\n")
				inputdatalist2[[i]]	<<- NA
				}
			}else{
			if(!silent){cat("All columns present.",sep="\n")}
			inputdatalist2[[i]]		<<- mydf[,mycolumns]
			}
		}
	# remove skipped dataframes and then combine:	
	if(!silent){cat("Removing skipped datasets from list...",sep="\n")}
	inputdatalist3	<<- inputdatalist2[lapply(inputdatalist2,length)>1] 
	if(!silent){cat("Combining dataframes into one data frame...",sep="\n")}
	if(do_control)
		{
		controldf				<<- do.call(rbind,inputdatalist3)
		colnames(controldf)		<<- mycolnames
		controldf$outlierscore	<<- controldf$rfisherGWDSlogp/controldf$bonf
		cat("All results stored in dataframe called 'controldf'.",sep="\n")
		}else{
		outlierdf				<<- do.call(rbind,inputdatalist3)
		colnames(outlierdf)		<<- mycolnames
		outlierdf$outlierscore	<<- outlierdf$rfisherGWDSlogp/outlierdf$bonf
		cat("All results stored in dataframe called 'outlierdf'.",sep="\n")
		}
	}	

outlierboxplot<-function()
	{
	perdataset	<- alloutliersdf[,c("dataset","bonf","nsnps","n_GWDS","n_OutFLANK","n_ind1","n_ind2","datatype")]
	perdataset	<- perdataset[!duplicated(perdataset),]
	#
	par(mfrow=c(1,2))
	# number of outliers:
	boxplot(perdataset$n_GWDS/perdataset$nsnps*100~perdataset$datatype,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Proportion of outliers (%)",las=1)
	stripchart(n_GWDS/nsnps*100~datatype,data=perdataset,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)	
	# p-values for GWDS outliers:
	alloutliers2df	<- alloutliersdf[alloutliersdf$rfisherGWDS,]
	boxplot(alloutliers2df$outlierscore~alloutliers2df$datatype,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Outlier score",las=1)
	stripchart(outlierscore~datatype,data=alloutliers2df,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
	}

outlierboxplot_old<-function()
	{
	combineddf	<<- rbind(outlierdf,controldf)
	combineddf	<<- combineddf[!is.na(combineddf$dataset),]
	perdataset	<<- combineddf[,c("dataset","bonf","nsnps","n_GWDS","n_OutFLANK","n_ind1","n_ind2")]
	perdataset	<<- perdataset[!duplicated(perdataset),]
	#
	par(mfrow=c(1,2))
	# number of outliers:
	boxplot(perdataset$n_GWDS/perdataset$nsnps*100~perdataset$dataset,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Proportion of outliers (%)",las=1)
	stripchart(n_GWDS/nsnps*100~dataset,data=perdataset,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)	
	# p-values:
	combined2df	<<- combineddf[combineddf$rfisherGWDS,]
	boxplot(combined2df$outlierscore~combined2df$dataset,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Outlier score",las=1)
	stripchart(outlierscore~dataset,data=combined2df,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
	}


calcNI<-function(indmiss=0.25)
	{
	#inds$type<-ifelse(inds$pop=="polar",TRUE,FALSE)
	if(is.null(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(!any(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) contains FALSE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
		}
	if(!any(inds$type==FALSE))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) contains TRUE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
		}
	if(!"maf_pheno"%in%colnames(snps))
		{
		pheno_maf(indthreshold=indsmiss)	
		}
	#
	# polymorphic sites:
	Ps1	<- nrow(snps[snps$maf_pheno1>0&snps$maf_pheno2==0&snps$class=="intergenic"&snps$filter,])
	Ps2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2>0&snps$class=="intergenic"&snps$filter,])
	Ps	<- Ps1+Ps2
	Pn1	<- nrow(snps[snps$maf_pheno1>0&snps$maf_pheno2==0&snps$class!="intergenic"&snps$filter,])
	Pn2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2>0&snps$class!="intergenic"&snps$filter,])
	Pn	<- Pn1+Pn2
	# fixed differences:
	Ds1	<- nrow(snps[snps$maf_pheno1==1&snps$maf_pheno2==0&snps$class=="intergenic"&snps$filter,])
	Ds2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2==1&snps$class=="intergenic"&snps$filter,])
	Ds	<- Ds1 + Ds2
	Dn1	<- nrow(snps[snps$maf_pheno1==1&snps$maf_pheno2==0&snps$class!="intergenic"&snps$filter,])
	Dn2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2==1&snps$class!="intergenic"&snps$filter,])
	Dn	<- Dn1 + Dn2
	# 
	P_dnds	<- Pn/Ps
	D_dnds	<- Dn/Ds							
	NI		<- P_dnds/D_dnds					# neutrality index: Is same as: NI<-(Ds*Pn)/(Dn*Ps)		# odds ratio (OR) of the MK table
	# McDonald and Kreitman (1991) argued that if mutations in N sites are simply drifting, they should have equal probabilities of fixation/loss and equal fixation time as mutations in synonomous sites, and hence:
	# P_dnds == D_dnds
	# NI	= 1
	# Because mutations under positive selection fixate quickly, positive selection on N mutations would result in: 
	# P_dnds< D_dnds
	# NI	< 1
	# Purifying selection on N mutations means that few N mutations will fixate, resulting in excess of Pn over Dn, and hence will result in: 
	# P_dnds> D_dnds
	# NI	> 1
	#
	DoS 	<- Dn/(Dn + Ds) - Pn/(Pn + Ps)		# direction of selection
	# From: Stoletzki et al, 2011, Estimation of the Neutrality Index
	#
	# proportion of adaptive substitutions: α = 1 - (Sfix*Npoly)/(Nfix*Spoly) = 1 - neutrality index
	myalpha	<- 1 - (Ds*Pn)/(Dn*Ps)
	#
	# distribution of fitness effect:
	table(snps$impact[snps$class!="intergenic"])
	}

# this function is to do a control run on a random binary division of individuals
# There shouldn't be any outliers, as individuals are randomly sampled from all populations, and hence we know there is no association between group division and selection pressure
randomassoc<-function(dopcadapt=FALSE)
	{
	#inds$randompheno	<<- sample(c(TRUE,FALSE),nrow(inds),TRUE)
	# 03_10_2021: changed method of random sampling:
	inds$randompheno	<<- ifelse(runif(nrow(inds))<0.5,TRUE,FALSE)
	runOutflank(export=TRUE,my_dataset="assoc1_assoc2",popcolumn=inds$randompheno,mycorrection="holm")
	if(dopcadapt)
		{
		#pcadapt not made for this, so excluding
		setwd(mysambar$inputfilesdir)
		genlight2ped(popvec=c("pop1","pop2")[as.factor(inds$randompheno)],snpsfilter=snps$filter2,indsfilter=inds$filter,exportname="assoc1_assoc2.filter2.miss0.letter",genonumber=FALSE,miss_char="0") 
		runPCadapt(K=2,popnames=mysambar$populations,my_dataset="assoc1_assoc2",mycorrection="holm")
		}
	assocfisher(pheno="randompheno",export="pdf")
	plot_scanlog(doexport="pdf",mydataset="assoc1_assoc2",outflankq=FALSE,markoutpheno=FALSE)
	plotpvalues(export="pdf",test1="OutFLANK",test2="rfisherGWDS",mydataset="assoc1_assoc2",mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL)
	outlierinfo(mydataset="assoc1_assoc2")
	}

outlierinfo<-function(popnames=mysambar$populations,mydataset="pheno",control_data=FALSE,silent=TRUE,my_authors=NULL,my_species=NULL,sel_claim=NULL,my_demo=NULL,n_gen=NULL,my_geneflow=NULL,data_info=NULL,myround=4)
	{
	# sel_claim: do the authors claim evidence for selection? e.g. string could be yes or no, or positive or negative
	# 
	if(mydataset=="meta")
		{
		mydataset	<- "metapop"
		cat("Specified mydataset is 'meta'. Assuming user means 'metapop'.",sep="\n")
		}
	file_extension	<- ifelse(!control_data,ifelse(mydataset!="pheno"&mydataset!="assoc1_assoc2"&mydataset!="metapop","pairwise.info.txt","info.txt"),ifelse(mydataset=="pheno","pop_control.pooled.info.txt","pop_control.pairwise.info.txt"))
	if(!silent){cat("Selecting outlier SNPs...",sep="\n")}
	mycolname	<- paste("out",mydataset,sep="_")
	mycolnrs	<- grep(mycolname,colnames(snps))
	if(length(mycolnrs)>0)
		{
		if(!silent){cat("Information present.",sep="\n")}
		booldf			<- snps[,grep(mycolname,colnames(snps))]
		}else{
		return(cat(paste("ERROR: no column names in snps dataset which include the string ",mycolname,".",sep=""),sep="\n")) 
		}
	if(is.null(dim(booldf)))
		{
		booldf			<- data.frame("V1"=booldf)
		mycolname2		<- names(snps)[grep(mycolname,colnames(snps))]
		mycolname2		<<- mycolname2
		colnames(booldf)<- mycolname2
		}
	if(paste("OutFLANK",mydataset,sep="_")%in%colnames(snps))
		{
		myoutflank		<- snps[,grep(paste("OutFLANK",mydataset,sep="_"),colnames(snps))]
		booldf$OutFLANK	<- myoutflank
		rle_output		<- rle(myoutflank)
		noutflank		<- sum(rle_output$lengths[rle_output$values==TRUE])
		if(max(snps$pos,na.rm=TRUE)<25000)	# arbitrary threshold
			{
			noutflankadjacent	<- "de_novo"
			}else{
			noutflankadjacent	<- sum(rle_output$lengths[rle_output$values==TRUE&rle_output$lengths>1])
			}
		}else{
		noutflank			<- NA
		noutflankadjacent	<- NA
		}
	mynames			<- colnames(booldf)
	mynames			<- gsub(paste("out_",mydataset,sep=""),"",mynames)
	mynames			<- gsub("rfisher","rfisherGWDS",mynames)
	colnames(booldf)			<- mynames
	if(!silent){mybooldf		<<- booldf}
	if(ncol(booldf)>1)
		{
		if(!silent){cat("More than one column.",sep="\n")}
		if(any(as.vector(apply(booldf,1,any))))
			{
			if(!silent){cat("Outliers detected.",sep="\n")}
			outpresent		<- TRUE
			outbool2df		<- booldf[as.vector(apply(booldf,1,any)),]
			myloci			<- as.vector(snps$name[as.vector(apply(booldf,1,any))])
			}else{
			if(!silent){cat("No outliers.",sep="\n")}
			outpresent		<- FALSE
			myloci			<- as.vector(snps$name[1])
			}
		}else{
		if(!silent){cat("One column.",sep="\n")}
		boolvec			<- booldf[,1]
		if(any(boolvec))
			{
			if(!silent){cat("Outliers detected.",sep="\n")}
			outpresent		<- TRUE
			myloci			<- as.vector(snps$name[boolvec])
			n_out			<- length(boolvec[boolvec])
			outbool2df		<- data.frame("rfisherGWDS"=rep(TRUE,n_out))
			}else{
			if(!silent){cat("No outliers.",sep="\n")}
			outpresent		<- FALSE
			myloci			<- as.vector(snps$name[1])
			outbool2df		<- data.frame("rfisherGWDS"=rep(FALSE,1))
			}
		}
	if(!silent){cat("Subsetting snps dataframe...",sep="\n")}
	infodf				<- snps[snps$name%in%myloci,c("chr","pos","name","filter2")]
	if(!outpresent)
		{
		infodf			<- data.frame("chr"=NA,"pos"=NA,"name"=NA)
		}
	infodf$dataset		<- mydataset
	infodf$indmaxmiss	<- mysambar$indmissfilter
	infodf$snpmaxmiss	<- mysambar$snpmissfilter
	infodf$snphefilter	<- mysambar$hefilter
	infodf$snpdepthfilter<-mysambar$snpdepthfilter
	infodf$snpminmac	<- mysambar$min_mac
	if(!silent){infodftemp	<<- infodf}
	if(!is.null(my_species)&!is.null(my_authors))
		{
		studydf				<- data.frame("authors"=my_authors,"species"=my_species)
		studydf$selclaim	<- ifelse(is.null(sel_claim),NA,sel_claim)
		studydf$demography	<- ifelse(is.null(my_demo),NA,my_demo)
		studydf$ngen		<- ifelse(is.null(n_gen),NA,n_gen)
		studydf$geneflow	<- ifelse(is.null(my_geneflow),NA,my_geneflow)
		studydf$info		<- ifelse(is.null(data_info),NA,data_info)
		infodf				<- cbind(studydf,infodf)		
		}else{
		studydf				<- data.frame("authors"=NA,"species"=NA,"selclaim"=NA,"demography"=NA,"ngen"=NA,"geneflow"=NA,"info"=NA)
		infodf				<- cbind(studydf,infodf)
		}
	#
	if(!silent){cat("Adding info...",sep="\n")}
	if(!silent){outbool2dftemp	<<- outbool2df}
	if(outpresent)
		{
		if(nrow(infodf)>1)
			{
			if(!silent){cat("Out NOT present and more than 1 row.",sep="\n")}
			info2df				<- cbind(infodf,outbool2df)
			}else{
			if(!silent){cat("Out NOT present and 1 row only.",sep="\n")}
			# 15-10-2021: make the following edit:
			#myboolvec		 	<- setNames(TRUE,"rfisherGWDS")
			myboolvec			<- apply(booldf,2,any)
			info2df				<- c(infodf,myboolvec)
			}
		}else{
		if(!silent){cat("Out present. Adding columns to info2df...",sep="\n")}
		info2df				<- infodf
		info2df$rfisherGWDS	<- FALSE
		info2df$OutFLANK	<- FALSE
		info2df$PCadapt		<- FALSE
		}
	if(!silent){cat("Adding MAF and HWE statistics...",sep="\n")}
	popmafdf		<- round(snps[snps$name%in%myloci,grep("maf_",colnames(snps))],myround)
	info2df			<- cbind(info2df,popmafdf)
	info2df$HWE		<- snps$HWE[snps$name%in%myloci]
	info2df$HWEchi2	<- round(snps$HWEchi2[snps$name%in%myloci],myround)
	info2df$Hdeficit<- snps$Hdeficit[snps$name%in%myloci]
	if(!silent){info2dftemp	<<- info2df}
	#
	# in case no outliers:
	if(!silent){cat("Creating info dataframe in case of no outliers...",sep="\n")}
	info7df					<- info2df[1,]
	info7df[1,]				<- NA
	info7df$authors			<- info2df$authors[1]
	info7df$species			<- info2df$species[1]
	info7df$selclaim		<- info2df$selclaim[1]
	info7df$geneflow		<- info2df$geneflow[1]
	info7df$dataset			<- info2df$dataset[1]		
	info7df$indmaxmiss		<- info2df$indmaxmiss[1]	
	info7df$snpmaxmiss		<- info2df$snpmaxmiss[1]	
	info7df$snphefilter		<- info2df$snphefilter[1]	
	info7df$snpdepthfilter	<- info2df$snpdepthfilter[1]
	info7df$snpminmac		<- info2df$snpminmac[1]
	if(!silent){info7dftemp	<<- info7df}
	#
	if(mydataset!="metapop")
		{
		if(!silent){cat("not metapop",sep="\n")}
		mycolname	<- paste("rfisherlog_p",mydataset,sep="_")
		mycolname2	<- paste("rfisherGWDSlogp",mydataset,sep="_")
		mycolname3	<- paste("OutFLANKlogp",mydataset,sep="_")
		outflankpresent	<- mycolname3%in%colnames(snps)
		if(outflankpresent)
			{
			mycolnrs	<- c(grep(mycolname,colnames(snps)),grep(mycolname2,colnames(snps)),grep(mycolname3,colnames(snps)))
			}else{
			mycolnrs	<- c(grep(mycolname,colnames(snps)),grep(mycolname2,colnames(snps)))
			}
		if(!silent){cat("creating logpdf dataset",sep="\n")}
		if(!silent){booltemp 	<<- booldf }
		if(!silent){outbool2temp<<- outbool2df }
		if(!silent){colnrstemp	<<- mycolnrs }
		if(ncol(booldf)>1)
			{
			if(outpresent)
				{
				if(!silent){cat("More than 1 column and out present.",sep="\n")}
				logpdf		<- round(snps[as.vector(apply(booldf,1,any)),mycolnrs],myround)	# or outbooldf?
				if(!silent){logpdftemp	<<- logpdf }
				if(mydataset!="pheno"&mydataset!="assoc1_assoc2")
					{
					if(outflankpresent)
						{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise")
						}else{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise")
						}
					}
				}else{
				if(!silent){cat("More than 1 column and out NOT present.",sep="\n")}
				logpdf		<- data.frame("rfisherlog_p"=NA,"rfisherGWDSlogp"=NA,"OutFLANKlogp"=NA)
				}
			}else{
			if(outpresent)
				{
				if(!silent){cat("1 column only and out present.",sep="\n")}
				logpdf		<- round(snps[boolvec,mycolnrs],myround)
				if(mydataset!="pheno"&mydataset!="assoc1_assoc2")
					{
					if(outflankpresent)
						{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise")
						}else{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise")
						}
					}
				}else{
				if(!silent){cat("1 column only and out NOT present.",sep="\n")}
				logpdf		<- data.frame("rfisherlog_p"=NA,"rfisherGWDSlogp"=NA,"OutFLANKlogp"=NA)
				}
			}
		if(!silent){cat("Checking if only 1 outlier...",sep="\n")}
		nsnps			<- nrow(snps[snps$filter2,])
		if(!is.data.frame(logpdf))	# if only 1 outlier, and 1 only selection scan
			{
			logpdf		<- data.frame("rfisherGWDSlogp"=logpdf)
			}
		logpdf$bonf		<- round(-log10(0.05/nsnps),myround)
		logpdf$nsnps	<- nsnps
		#
		if(!silent){cat("selecting GWDS outliers",sep="\n")}
		mygwdsout		<- snps[,grep(paste("rfisherout",mydataset,sep="_"),colnames(snps))]
		rle_output		<- rle(mygwdsout)
		ngwdsout		<- sum(rle_output$lengths[rle_output$values==TRUE])
		if(max(snps$pos,na.rm=TRUE)<2500)	# arbitrary threshold
			{
			ngwdsadjacent	<- "de_novo"
			}else{
			ngwdsadjacent	<- sum(rle_output$lengths[rle_output$values==TRUE&rle_output$lengths>1])
			}
		if(!silent){cat("Adding GWDS info...",sep="\n")}
		logpdf$n_GWDS 			<- ngwdsout
		logpdf$n_GWDS_adjacent	<- ngwdsadjacent
		logpdf$n_OutFLANK		<- noutflank
		logpdf$n_OutFLANK_adjacent<- noutflankadjacent
		#
		if(!silent){cat("combining into info3df...",sep="\n")}
		info3df				<- cbind(info2df,logpdf) 
		# info file in case no outliers:
		#		
		if(mydataset=="pheno")
			{
			if(!silent){cat("pheno",sep="\n")}
			info3df$pop1	<- NA
			info3df$pop2	<- NA
			info3df$pheno1	<- paste(as.vector(unique(inds$pop[inds$type&inds$filter])),collapse="_")
			info3df$pheno2	<- paste(as.vector(unique(inds$pop[!inds$type&inds$filter])),collapse="_")
			info3df$n_ind1	<- length(inds$type[inds$type&inds$filter])
			info3df$n_ind2	<- length(inds$type[!inds$type&inds$filter])
			#
			info3df$He		<- round(snps$WeirHe_pheno[snps$name%in%myloci],myround)
			info3df$Fst		<- round(snps$WeirFst_pheno[snps$name%in%myloci],myround)
			}else{
			if(!silent){cat("not pheno",sep="\n")}
			mypop1			<- strsplit(mydataset, "_")[[1]][1]
			mypop2			<- strsplit(mydataset, "_")[[1]][2]
			info3df$pop1	<- mypop1
			info3df$pop2	<- mypop2
			info3df$pheno1	<- NA
			info3df$pheno2	<- NA
			if(mydataset=="assoc1_assoc2")
				{
				info3df$n_ind1	<- nrow(inds[inds$randompheno&inds$filter,])
				info3df$n_ind2	<- nrow(inds[!inds$randompheno&inds$filter,])
				}else{
				info3df$n_ind1	<- unique(inds$pop_ninds[inds$pop==mypop1&inds$filter])
				info3df$n_ind2	<- unique(inds$pop_ninds[inds$pop==mypop2&inds$filter])
				}
			#
			hetemp			<- snps[,colnames(snps)==paste("WeirHe",mydataset,sep="_")]
			fsttemp			<- snps[,colnames(snps)==paste("WeirFst",mydataset,sep="_")]
			info3df$He		<- round(hetemp[snps$name%in%myloci],myround)
			info3df$Fst		<- round(fsttemp[snps$name%in%myloci],myround)
			}
		if(!silent){info3dftemp	<<- info3df}
		#
		if(!silent){cat("Creating info6df...",sep="\n")}
		info6df					<- info3df[1,]
		info6df[1,]				<- NA
		info6df$authors			<- info3df$authors[1]
		info6df$species			<- info3df$species[1]
		info6df$selclaim		<- info3df$selclaim[1]
		info6df$geneflow		<- info3df$geneflow[1]
		info6df$dataset			<- info3df$dataset[1]		
		info6df$indmaxmiss		<- info3df$indmaxmiss[1]	
		info6df$snpmaxmiss		<- info3df$snpmaxmiss[1]	
		info6df$snphefilter		<- info3df$snphefilter[1]	
		info6df$snpdepthfilter	<- info3df$snpdepthfilter[1]
		info6df$snpminmac		<- info3df$snpminmac[1]
		info6df$bonf			<- info3df$bonf[1]
		info6df$nsnps			<- info3df$nsnps[1]
		info6df$n_GWDS			<- info3df$n_GWDS[1]
		info6df$n_GWDS_adjacent	<- info3df$n_GWDS_adjacent[1] 	
		info6df$n_OutFLANK		<- info3df$n_OutFLANK[1]	
		info6df$n_OutFLANK_adjacent	<- info3df$n_OutFLANK[1]
		info6df$pop1			<- info3df$pop1[1]
		info6df$pop2			<- info3df$pop2[1]	
		info6df$pheno1			<- info3df$pheno1[1]	
		info6df$pheno2			<- info3df$pheno2[1]	
		info6df$n_ind1			<- info3df$n_ind1[1]	
		info6df$n_ind2			<- info3df$n_ind2[1]
		if(!silent){info6dftemp	<<- info6df}
		#
		if(!silent){cat("Creating info4df and info5df...",sep="\n")}
		if(outpresent)
			{
			if(!"rfisherGWDS"%in%colnames(info3df))
				{
				info3dftemp		<<- info3df
				return(cat("ERROR: column 'rfisherGWDS' missing.",sep="\n"))
				}
			if(!is.logical("rfisherGWDS"%in%colnames(info3df)))
				{
				return(cat("ERROR: 'rfisherGWDS' is not logical.",sep="\n"))
				}
			if(any(info3df$rfisherGWDS,na.rm=TRUE))
				{
				info4df		<- info3df[info3df$rfisherGWDS,]
				}else{
				info4df		<- info6df
				}
			if(paste("OutFLANK",mydataset,sep="_")%in%colnames(snps))
				{
				if(any(info3df$rfisherGWDS|info3df$OutFLANK,na.rm=TRUE))
					{
					info5df		<- info3df[info3df$rfisherGWDS|info3df$OutFLANK,]
					}else{
					info5df		<- info6df
					}
				}else{
				if(any(info3df$rfisherGWDS,na.rm=TRUE))
					{
					info5df		<- info3df[info3df$rfisherGWDS,]
					}else{
					info5df		<- info6df
					}
				}
			}else{
			info4df		<- info6df
			info5df		<- info6df
			}
		write.table(info3df,paste("myoutliers",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		write.table(info4df,paste("myoutliers.GWDS",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		write.table(info5df,paste("myoutliers.GWDSorOutFLANK",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		}else{
		if(outpresent)
			{
			write.table(info2df,paste("myoutliers",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
			}else{
			write.table(info7df,paste("myoutliers",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
			}
		}
	cat("Txt-file(s) with outlier info written to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}

allscans_piemaf<-function(my_dataset="pheno",do_export=FALSE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5,addtestnames=FALSE)
	{
	if(my_dataset=="meta")
		{
		my_dataset	<- "metapop"
		cat("Specified my_dataset is 'meta'. Assuming user means 'metapop'.",sep="\n")
		}
	if(!silent){cat("Selecting outlier SNPs...",sep="\n")}
	mycolname	<- paste("out",my_dataset,sep="_")
	if(!mycolname%in%colnames(snps))
		{
		booldf			<- snps[,grep(mycolname,colnames(snps))]
		}else{
		return(cat(paste("ERROR: no column in snps dataset present called ",mycolname,".",sep=""),sep="\n")) 
		}
	if(is.null(dim(booldf)))
		{
		booldf			<- data.frame("V1"=booldf)
		mycolname2		<- names(snps)[grep(mycolname,colnames(snps))]
		mycolname2		<<- mycolname2
		colnames(booldf)<- mycolname2
		}
	if(paste("OutFLANK",my_dataset,sep="_")%in%colnames(snps))
		{
		myoutflank		<- snps[,grep(paste("OutFLANK",my_dataset,sep="_"),colnames(snps))]
		booldf$OutFLANK	<- myoutflank
		}
	mynames			<- colnames(booldf)
	mynames			<- gsub(paste("out_",my_dataset,sep=""),"",mynames)
	mynames			<- gsub("rfisher","rfisherGWDS",mynames)
	colnames(booldf)<- mynames
	#booldf			<<- booldf
	if(ncol(booldf)>1)
		{
		if(!silent){cat("More than one column.",sep="\n")}
		outbooldf		<- booldf[,as.vector(apply(booldf,2,any))]
		outbool2df		<- booldf[as.vector(apply(booldf,1,any)),]
		myloci			<- as.vector(snps$name[as.vector(apply(booldf,1,any))])
		}else{
		if(!silent){cat("One column.",sep="\n")}
		outbooldf		<- any(booldf[,1])
		outbool2df		<- booldf[,1]
		myloci			<- as.vector(snps$name[as.vector(outbooldf)])
		}
	if(length(myloci)==0){return(cat("No outliers. Skipping.",sep="\n"))}
	#
	if(!silent){cat("Preparing plot...",sep="\n")}
	npops		<- length(popnames)
	ntests		<- ncol(outbool2df)
	nloci		<- nrow(outbool2df)
	mytests		<- colnames(outbool2df)
	scancols	<- c("blue","darkgreen","red","darkorchid4","orange")
	myscans		<- c("rfisherGWDS","PCadapt","bayescan","Fsthet","OutFLANK")
	#
	if(nloci>200)
		{
		cat("More than 200 outlier loci. Sambar will plot first 200 outlier only.",sep="\n")
		myloci	<- myloci[1:200]
		nloci	<- 200
		}
	if(!silent){cat("Opening pdf device...",sep="\n")}
	if(do_export)
		{
		if(addlocinames)
			{
			plotname<-	paste("piechart.mafperpop.allscans",my_dataset,"loci_names.pdf",sep=".")
			}else{
			plotname<-	paste("piechart.mafperpop.allscans",my_dataset,"pdf",sep=".")
			}
		if(nloci>1)
			{
			pdf(plotname,height=npops*ntests*2+3,width=nloci*2+4)
			}else{
			pdf(plotname,height=npops*ntests*2+3,width=nloci*4+4)
			}
		}
	if(!silent){cat("Creating plot...",sep="\n")}
	layout(matrix(c(1:(npops*nloci*ntests)),npops*ntests,nloci,byrow=FALSE))
	if(addtestnames)
		{
		par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,6.5))
		}else{
		par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,2))
		}
	for(k in c(1:nloci))
		{
		mylocus	<- myloci[k] 
		if(!silent){cat(mylocus,sep="\n")}
		for(m in c(1:ntests))
			{
			mytest	<- mytests[m]
			mycol	<- scancols[myscans==mytest]
			if(!silent){cat(mytest,sep="\n")}
			if(!silent){cat(mycol,sep="\n")}
			for (j in c(1:npops))
				{
				mypop		<- popnames[j]
				if(!silent){cat(mypop,sep="\n")}
				nind		<- nrow(inds[inds$filter&inds$pop==mypop,])
				popmiss		<- snps[snps$name==mylocus,paste("miss",mypop,sep="_")]
				if(outbool2df[k,m])
					{
					if(popmiss<1&nind>0)		
						{
						popmaf		<- snps[snps$name==mylocus,paste("maf",mypop,sep="_")]
						nallelles	<- round((2*nind)*(1-popmiss))
						popminor	<- round(nallelles*popmaf)
						popmajor	<- nallelles-popminor
						pie(c(popminor,popmajor),labels=NA,main=NA,col=c("grey50",mycol),border=NA)
						}else{
						# if no data available for population:
						pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="grey50")
						}
					}else{
					pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="white")
					}
				if(j==1&m==1&addlocinames)
					{
					mtext(side=3,mylocus,las=2,cex=2,line=-0.5)
					}
				if(k==1)
					{
					mtext(side=2,mypop,cex=pop_cex,las=1,line=0.5)
					}
				}
			}
		}
	if(addtestnames)
		{
		# if only 3 (without outflank):
		#mtext(text="Bayescan",side=4,line=4,at=0,adj=0,cex=5.5)
		#mtext(text="PCadapt",side=4,line=4,at=7.5,adj=0,cex=5.5)
		#mtext(text="GWDS",side=4,line=4,at=15.5,adj=0,cex=5.5)
		mtext(text="OutFLANK",side=4,line=4,at=-0.5,adj=0,cex=5.5)
		mtext(text="PCadapt",side=4,line=4,at=7.5,adj=0,cex=5.5)
		mtext(text="GWDS",side=4,line=4,at=15.5,adj=0,cex=5.5)
		mtext(text="Bayescan",side=4,line=4,at=22.25,adj=0,cex=5.5)
		}
	if(do_export){dev.off()}
	}

multipiemaf<-function(my_dataset="pheno",do_export=TRUE)
	{
	if(paste("bayescanlogq",my_dataset,sep="_")%in%colnames(snps))
		{
		cat("Including Bayescan...",sep="\n")
		bayescanlogq		<- snps[,grep(paste("bayescanlogq",my_dataset,sep="_"),colnames(snps))]
		snps$Bayescantemp	<<- bayescanlogq
		#colnames(logp)[colnames(logp)=="Bayescan"]		<- paste("bayescanlogp",my_dataset,sep="_")
		colnames(snps)[colnames(snps)=="Bayescantemp"]	<<- paste("bayescanlogp",my_dataset,sep="_")
		snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		}
	mytests		<- colnames(snps)[grep(paste("logp",my_dataset,sep="_"),colnames(snps))]
	mytests		<- gsub(paste("logp",my_dataset,sep="_"),"",mytests)
	scancols	<- c("blue","darkgreen","red","darkorchid4","orange")
	myscans		<- c("rfisherGWDS","PCadapt","bayescan","Fsthet","OutFLANK")
	for(mytest in mytests)
		{
		cat(mytest,sep="\n")
		scancol	<- scancols[myscans==mytest] 
		#cat(scancol,sep="\n")
		piemaf(export=do_export,popnames=mysambar$populations,mycol=scancol,myscan=mytest,mydataset=my_dataset)
		}
	}
	
piemaf<-function(export=FALSE,popnames=mysambar$populations,mycol="blue",myscan="rfisherGWDS",mydataset="pheno",silent=TRUE)
	{
	if(mydataset=="meta")
		{
		mydataset	<- "metapop"
		cat("Specified mydataset is 'meta'. Assuming user means 'metapop'.",sep="\n")
		}
	if(myscan=="OutFLANK")
		{
		mycolumn<- unlist(snps[,paste(myscan,"_",mydataset,sep="")])
		}else{
		if(myscan=="rfisherGWDS")
			{
			mycolumn<- unlist(snps[,paste("rfisherout_",mydataset,sep="")])
			}else{
			mycolumn<- unlist(snps[,paste(myscan,"out_",mydataset,sep="")])
			}
		}
	myloci	<- as.vector(snps$name[mycolumn&snps$filter2])	
	#myloci	<<- myloci
	if(length(myloci)==0)
		{
		return(cat("No outliers. Skipping piecharts.",sep="\n"))
		}
	nloci	<- length(myloci)
	if(nloci>200)
		{
		cat("More than 200 outlier loci. Sambar will plot first 200 outlier only.",sep="\n")
		myloci	<- myloci[1:200]
		nloci	<- 200
		}
	if(!silent){cat(paste("nloci: ",nloci,".",sep=""),sep="\n")}
	if(mydataset!="pheno"&mydataset!="metapop")
		{
		pop1	<- strsplit(mydataset, "_")[[1]][1]
		pop2	<- strsplit(mydataset, "_")[[1]][2]
		popnames<- c(pop1,pop2)
		}
	npops	<- length(popnames)
	if(export)
		{
		plotname<-	paste("piechart.mafperpop",myscan,mydataset,"pdf",sep=".")
		if(nloci>1)
			{
			pdf(plotname,height=npops*2+3,width=nloci*2+4)
			}else{
			pdf(plotname,height=npops*2+3,width=nloci*4+4)
			}
		}
	layout(matrix(c(1:(npops*nloci)),npops,nloci,byrow=FALSE))
	par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,2))
	for(k in c(1:nloci))
		{
		mylocus	<- myloci[k] 
		#cat(mylocus,sep="\n")
		for (j in c(1:npops))
			{
			mypop		<- popnames[j]
			if(!silent){cat(mypop,sep="\n")}
			nind		<- nrow(inds[inds$filter&inds$pop==mypop,])
			popmiss		<- snps[snps$name==mylocus,paste("miss",mypop,sep="_")]
			if(popmiss<1&nind>0)		
				{
				popmaf		<- snps[snps$name==mylocus,paste("maf",mypop,sep="_")]
				nallelles	<- round((2*nind)*(1-popmiss))
				popminor	<- round(nallelles*popmaf)
				popmajor	<- nallelles-popminor
				pie(c(popminor,popmajor),labels=NA,main=NA,col=c("grey50",mycol),border=NA)
				}else{
				# if no data available for population:
				pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="grey50")
				}
			if(j==1)
				{
				mtext(side=3,mylocus,las=2,cex=2,line=-0.5)
				}
			if(k==1)
				{
				mtext(side=2,mypop,cex=3.5,las=1,line=0.5)
				}
			}
		}
	if(export){dev.off()}
	}
	
runfsthet<-function(export=FALSE,dataset=NULL,my_sign_level=0.05,reps=10,fstmethod="betahat",doanalysis=TRUE,phenonames=NULL,currentdir=FALSE,do_overwrite=TRUE)
	{
	current_dir	<- getwd()
	# dataset should be NULL, pop1_pop2, or meta.
	#
	# 4 options for fstmethod:
	# - For Wright's Fst: fst, FST, Fst
	# - For a variance-based Fst (beta): var, VAR, Var
	# - For Cockerham and Weir's Theta: theta, Theta, THETA	# no shark fin, mostly negative values
	# - For Beta-hat (LOSITAN): betahat, Betahat, BETAHAT	# shark fin
	#
	if(doanalysis)
		{
		setwd(mysambar$inputdatadir)
		# sambarfunction_selection:
		##### SELECTION ANALYSES #####
		# sambarfunction_selection:
		### FstHet:
		# sambarfunction_selection:
		if(is.null(mysambar$gpop)|do_overwrite)
			{
			genepopfile 	<- list.files(pattern = "genepop")
			if(length(genepopfile)==0)
				{
				cat("ERROR: No file with extension 'genepop' found in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				return(cat("The fsthet software needs a genepop file as input. Operation halted.",sep="\n"))
				}
			if(length(genepopfile)>1)
				{	
				cat("WARNING: SambaR found multiple files with the string 'genepop' in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				return(cat("Only keep the file which should be used as input and try again.",sep="\n"))
				}
			# sambarfunction_selection:
			gpop			<- my.read.genepop(genepopfile)
			gpop2			<- gpop[order(gpop$ind.names),]
			mysambar$gpop	<<- gpop2
			cat("Genepop file stored at mysambar$gpop.",sep="\n")
			}else{
			cat("WARNING: Using genepop file stored at mysambar$gpop.",sep="\n")
			gpop2			<- mysambar$gpop
			}
		#
		gpop_ninds		<- length(gpop2$ind.names)
		ninds			<- nrow(inds)
		nindsfilter		<- nrow(inds[inds$filter,])
		#
		cat(paste("Number of individuals in genepop file: ",gpop_ninds,".",sep=""),sep="\n")
		if(gpop_ninds!=ninds)
			{
			if(gpop_ninds!=nindsfilter)
				{
				return(cat("ERROR: number of samples in genepop file does not correspond with number of samples in inds dataframe (nor total, nor retained). Not running FstHet analyses.",sep="\n"))
				}else{
				cat("Number of samples in genepop file corresponds with number of retained samples in inds dataframe.",sep="\n")
				}
			}else{
			cat("Number of samples in genepop file corresponds with total number of samples in inds dataframe. Subselecting...",sep="\n")
			indstemp	<- inds[order(as.character(inds$name)),]
			gpop2		<- gpop2[order(as.character(gpop2$ind.names)),]
			#
			indnames	<- as.character(indstemp$name)
			gpopnames	<- as.character(gpop2$ind.names)
			mybool		<- indnames==gpopnames
			#
			if(any(!mybool))
				{
				indnames	<<- indnames
				gpopnames	<<- gpopnames
				mybool		<<- mybool
				return(cat("Sample names in input genepop file do not correspond with names of retained samples in inds dataframe. Aborting. Type indnames, gpopnames and mybool for further details.",sep="\n"))
				}
			gpop2	<- gpop2[indstemp$filter,]
			}
		#
		gpop2		<- gpop2[order(as.character(gpop2$ind.names)),]
		indstemp	<- inds[inds$filter,]
		indstemp	<- indstemp[order(as.character(indstemp$name)),]
		indnames	<- as.character(indstemp$name)
		gpopnames	<- as.character(gpop2$ind.names)
		mybool		<- indnames==gpopnames
		#
		if(any(!mybool))
			{
			indnames	<<- indnames
			gpopnames	<<- gpopnames
			mybool		<<- mybool
			return(cat("Sample names in input genepop file do not correspond with names of retained samples in inds dataframe. Aborting. Type indnames, gpopnames and mybool for further details.",sep="\n"))
			}
		#
		if(!is.null(dataset))
			{
			if(dataset=="pheno")
				{
				if(!"type"%in%colnames(indstemp))
					{
					return(cat("Dataset set to 'pheno' but no column 'inds$type'. Define the column inds$type and try again. See SambaR manual for more details.",sep="\n"))
					}
				if(is.null(phenonames))
					{
					mytypes		<- c("pheno1","pheno2")
					}else{
					mytypes		<- phenonames
					}
				mylabel			<- "pheno"
				cat(paste("Starting fsthet analyses for comparison between ",mytypes[1]," and ",mytypes[2],".",sep=""),sep="\n")
				gpop2$popinfo	<- as.character(indstemp$type)
				gpop3			<- gpop2[indstemp$filter,]
				}else{
				if(dataset=="metapop")
					{
					cat("SambaR will run fsthet on entire dataset (i.e. metapop: all populations combined).",sep="\n")
					gpop2$popinfo	<- indstemp$pop	
					gpop3			<- gpop2
					mylabel			<- "metapop"
					}else{
					mypop1			<- strsplit(dataset, "[_]")[[1]][1]
					mypop2			<- strsplit(dataset, "[_]")[[1]][2]
					mylabel			<- dataset
					cat(paste("Starting fsthet analyses for comparison between ",mypop1," and ",mypop2,".",sep=""),sep="\n")
					gpop2$popinfo	<- as.character(indstemp$pop)	# fsthet crashes if popinfo column consists of factors
					gpop3			<- gpop2[indstemp$filter&(indstemp$pop==mypop1|indstemp$pop==mypop2),]
					}
				}
			}else{
			cat("No dataset defined. SambaR will run fsthet on entire dataset (i.e. metapop: all populations combined).",sep="\n")
			gpop2$popinfo	<- as.character(indstemp$pop)	# fsthet crashes if popinfo column consists of factors	
			gpop3			<- gpop2
			mylabel			<- "metapop"
			}
		if(currentdir)
			{
			setwd(current_dir)
			}else{
			setwd(mysambar$selectiondir)
			}
		nind	<- nrow(gpop3)
		cat(paste("Input dataset contains",nind,"individuals which passed filter settings as defined with the filterdata() function.",sep=" "),sep="\n")
		cat(paste("The number of bootstrap replicates (defined with the 'reps' argument) is set to ",reps,". Default is 10.",sep=""),sep="\n")
		cat("Starting 'fsthet' analysis now. This analysis may take a while.",sep="\n")
		if(export)
			{
			plotname		<- paste("fsthet",fstmethod,mylabel,"pdf",sep=".")
			pdf(plotname)
			}
		gpop3				<<- gpop3
		# sambarfunction_selection:
		fsthetout			<- fhetboot(gpop3,fst.choice=fstmethod,alpha=my_sign_level,nreps=reps)
		if(export)
			{
			dev.off()
			cat(paste("A file called '",plotname,"' has been written to the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")	
			}
		fsthetout$locus		<- substring(fsthetout$Locus, 2)
		cat("Output of fsthet software is stored in a dataframe called 'fsthetout'.",sep="\n")
		}else{
		if(!is.null(dataset))
			{
			if(dataset=="pheno")
				{
				mytypes			<- unique(indstemp$type)
				mylabel			<- "pheno"
				}else{
				mylabel			<- dataset
				}
			}else{
			mylabel			<- "metapop"
			}
		}
	#
	# remove snps which occur on same position in genome:
	setwd(mysambar$inputdatadir)
	if(file.exists("removedloci.txt"))
		{
		removed			<- read.table("removedloci.txt",header=TRUE)
		fsthetout$bool	<- fsthetout$locus%in%removed$name
		fsthetout		<- fsthetout[!fsthetout$bool,]
		}
	if(currentdir)
		{
		setwd(current_dir)
		}else{
		setwd(mysambar$selectiondir)
		}
	#
	# add results to snps dataframe:
	snpstemp	<- snps[order(snps$name),]
	fsttemp		<- fsthetout[order(fsthetout$locus),]
	if(any(snpstemp$name!=fsttemp$locus))
		{
		return(cat("ERROR: order of snp names in genepop file does not correspond with order in snps dataframe.",sep="\n"))
		}
	snpstemp$fsthetlogp	<- NULL
	snpstemp$fsthetout	<- NULL
	snpstemp$fsthetlogp	<- -log10(fsttemp$P.value)
	outliers			<- fsttemp$P.value<(my_sign_level/nrow(fsttemp))
	snpstemp$fsthetout	<- outliers
	noutliers			<- length(outliers[outliers])
	cat(paste("Found ",noutliers," outlier(s).",sep=""),sep="\n")
	names(snpstemp)[names(snpstemp) == "fsthetlogp"] 	<- paste("fsthetlogp",mylabel,sep = "_")
	names(snpstemp)[names(snpstemp) == "fsthetout"] <- paste("fsthetout",mylabel,sep = "_")
	#
	# reorder:
	snps				<<- snpstemp[order(snpstemp$chr,as.numeric(snpstemp$pos)),]
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after reordering, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	cat("Columns 'fsthetlogp' and 'fsthetout' have been added to the snps dataframe.",sep="\n")
	}
		
plot_diagram<-function(export=NULL,mycol="grey80")
	{
	#install.packages('diagram')
	#library('diagram')
	my_text_size 		<- 1.5
	segment_size		<- 0.08
	width_height_ratio	<- 2.5
	xvector				<- c(rep(0.75,3),rep(0.25,2))
	yvector				<- c(0.125,0.375,0.75,0.25,0.75)
	pos					<- cbind(xvector,yvector)
	my_label			<- c("founder_2\n(Barff)", "founder_1\n(Busen)", "both founders\n(Busen & Barff)","source\n(Norway)","source\n(Norway)")
	# plot:
	graphics.off()	
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Approach.diagram.pdf",onefile=FALSE)}
		if(export=="emf"){emf("Approach.diagram.emf")}
		}
	openplotmat()
	plot(pos,xlim=c(0,1),ylim=c(0,1),type='n',xaxt='n',yaxt='n',ann=FALSE,bty='n')
	straightarrow (from = pos[1, ], to = pos[4, ],arr.pos=1)
	straightarrow (from = pos[2, ], to = pos[4, ],arr.pos=1)
	straightarrow (from = pos[3, ], to = pos[5, ],arr.pos=1)
	for(i in c(1:length(my_label)))
		{
		textrect(mid = pos[i,], shadow.size = 0, radx = segment_size*width_height_ratio, rady = segment_size, lab = my_label[i], cex = my_text_size, box.col = mycol)
		}
	text(x=0.5,y=0.9,labels="pooled approach",cex=1.5,font=2)
	text(x=0.5,y=0.5,labels="pairwise approach",cex=1.5,font=2)
	if(!is.null(export)){dev.off()}
	}

pheno_Fdist_plot<-function(doexport=NULL,allpairwise=FALSE,popnames=mysambar$populations,addoutliers=TRUE,mylabels=NULL,outlier_cex=2)
	{
	npops			<- length(mysambar$populations)
	if(npops==1)
		{
		return(cat("ERROR: only one population specified.",sep="\n"))
		}
	if(npops==2)
		{
		return(cat("WARNING: only two populations specified. Not creating combined figure of Fdist plots.",sep="\n"))
		}
	popsubset		<- as.vector(which(table(inds$pop[inds$filter])==0))
	if(length(popsubset)>0)
		{
		popnames		<- popnames[-(popsubset)]
		}
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		ncombi		<- ncol(allcombi)
		ntiles		<- ncombi
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type&inds$filter]))
		type2		<- as.vector(unique(inds$pop[(!inds$type)&inds$filter]))
		allcombi	<- t(expand.grid(type1,type2))		
		ncombi		<- ncol(allcombi)
		ntiles		<- ncombi+1
		# don't add pheno in this case (because already incorporated below)
		}
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plotname	<- ifelse(allpairwise,"Fdist_outliers_allpairwise","Fdist_outliers_allpheno")
		if(doexport=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		if(doexport=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=(ncombi+1)*400,height=500)}
		if(doexport=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		}
	par(mfrow=c(1,ntiles),oma=c(5,6,1,1),mar=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)	
	if(!allpairwise)
		{
		#cat("pheno",sep="\n")
		Fdist_plot(my_dataset="pheno",axislabels=FALSE,my_labels=mylabels,add_outliers=addoutliers,outliercex=outlier_cex,add_borders=TRUE,legendpheno=TRUE)
		}
	for(my_i in c(1:ncombi))
		{
		#cat(my_i,sep="\n")
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		#cat(my_pair,sep="\n")
		if(!paste("WeirHe",my_pair,sep="_")%in%colnames(snps))
			{
			cat(paste("WARNING: snps dataframe does not contain a column with Weir He scores for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}else{
			y_ax	<- ifelse(allpairwise&my_i==1,'s','n')
			if(addoutliers)
				{
				Fdist_plot(my_dataset=my_pair,axislabels=FALSE,y_axis=y_ax,add_outliers=TRUE,outliercex=outlier_cex,add_borders=TRUE)
				}else{
				Fdist_plot(my_dataset=my_pair,axislabels=FALSE,y_axis=y_ax,add_outliers=FALSE,outliercex=outlier_cex,add_borders=TRUE)
				}
			}
		}
	mtext("Weir & Cockerham (1987) Fst", side = 2, cex = 2, line = 3,outer=TRUE)
	mtext("Weir & Cockerham (1987) He", side = 1, cex = 2, line = 3,outer=TRUE)
	if(!is.null(doexport)){dev.off()}
	}

pheno_manhattan<-function(doexport=NULL,allpairwise=FALSE,popnames=mysambar$populations,myphenolabels=c("pheno1","pheno2"),dothinning=FALSE,markoutpheno=TRUE,show_fisher=TRUE)
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		}
	ncombi		<- ncol(allcombi)
	if(ncombi==1)
		{
		return(cat("ERROR: only 1 comparison to consider. Not creating 'Manhattan_GWDS_allpheno_fisherlogp' plot.",sep="\n"))
		}
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plot_name	<- ifelse(show_fisher,"Manhattan_GWDS_allpheno_fisherlogp","Manhattan_GWDS_allpheno_gwdslogp")  
		if(doexport=="eps"){postscript(paste(plot_name,"eps",sep="."),family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		if(doexport=="pdf"){pdf(paste(plot_name,"pdf",sep="."),family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		if(doexport=="png"){png(paste(plot_name,"png",sep="."),family=mysambar$myfont,width=1200,height=(ncombi+1)*250)}
		if(doexport=="wmf"){win.metafile(paste(plot_name,"wmf",sep="."),family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		}
	par(mfrow=c((ncombi+1),1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,1.5),cex.axis=2,cex.lab=2.5)
	gwdsmanhattan(my_dataset="pheno",showfisher=show_fisher,my_labels=myphenolabels,myxaxis='n',addlab=FALSE,dothin=dothinning)
	if(markoutpheno)
		{
		rfisheroutliers	<- snps$rfisherout_pheno
		gwdsoutnr		<- which(rfisheroutliers&snps$filter2)
		if(length(gwdsoutnr)>0){abline(v=gwdsoutnr,col="grey")}
		}
	for(my_i in c(1:ncombi))
		{
		my_xaxis	<- ifelse(my_i==ncombi,'s','n')
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		if(paste("rfisherGWDSlogp",my_pair,sep="_")%in%colnames(snps))
			{
			gwdsmanhattan(my_dataset=my_pair,showfisher=show_fisher,myxaxis=my_xaxis,dothin=dothinning)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		if(markoutpheno)
			{
			if(length(gwdsoutnr)>0){abline(v=gwdsoutnr,col="grey")}
			}
		}
	if(show_fisher)
		{
		mtext("-ln(Fisher exact test p-value)",side=2,line=0.75,cex=2.5,outer=TRUE)
		}else{
		mtext("-log10(GWDS p-value)",side=2,line=0.5,cex=2.75,outer=TRUE)
		}
	mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
	if(!is.null(doexport))
		{
		dev.off()	
		cat("Manhattan plot exported to the directory.",sep="\n")
		cat(getwd(),sep="\n")
		}
	}	

ils<-function()
	{
	macmatrix			<- snps[,c("mac_ABCa","mac_ABCcoast","mac_polar","mac_Black")]
	macmatrix			<- t(macmatrix)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	}

# GWDS (Fisher test)
# This function is not as fast as plink. If you have millions of snps, probs better to use plink.
# comparison of output:
# my R function:	0.1374497 0.0000000 0.3262634 0.5235213	1.9187528
# plink:			0.1374247 0.0000000 0.3262843 0.5235732	1.9186842 		
# odds ratios are different though.	
	
gwdsfisher<-function(my_dataset="pheno",my_sign_level=0.05,pheno=inds$type,binsize=1000000,overwrite_bin=FALSE,dothin=FALSE,make_global=FALSE,mycorrection=NULL,wingwds=FALSE)
	{
	if(is.null(mycorrection))
		{
		cat("No multiple testing correction method specified. Defaulting to using bonferroni correction.",sep="\n")
		}else{
		if(mycorrection!="holm"&mycorrection!="bonferroni"&mycorrection!="BH")
			{
			return(cat("ERROR: mycorrection should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}else{
			cat(paste("Using ",mycorrection," method to correct for multiple testing.",sep=""),sep="\n")
			}
		# 16-06-2021: added following lines because I don't see how to adjust p-values using a thinned subset (as it looks at entire distribution of p-values)
		if(dothin)
			{
			cat("WARNING: because the flag 'dothin' is set to TRUE, the correction method will be the Bonferroni correction, even if another method has been specified.",sep="\n")  
			mycorrection	<- NULL
			}
		}
	#
	# This function expects as input for my_dataset either the string 'pheno' or strings defining two populations separated by underscore (e.g. 'pop1_pop2') 
	#
	### OPTIONAL THINNING
	if(dothin)
		{
		# 15-10-2021: added following line:
		cat("WARNING: flag dothin is set to TRUE. The use of the thinning option is discouraged.",sep="\n")
		if("dist" %in% colnames(snps))
			{
			if("distbin"%in%colnames(snps)&!overwrite_bin)
				{
				cat("WARNING: Using existing position bins defined in column snps$distbin.",sep="\n")
				cat("If you want to create new position bins, set the flag overwrite_bin to TRUE or alternatively delete existing column.",sep="\n")
				}else{
				cat("Dividing snps into bins based on position in genome...",sep="\n")
				snps$distbin	<<- NA
				mychroms		<- as.vector(unique(snps$chr))
				for(mychrom in mychroms)
					{
					#cat(mychrom,sep="\n")
					mysnpspos							<- snps$pos[snps$chr==mychrom]
					if(length(mysnpspos)>1)
						{
						mybreaks						<- seq(0,max(mysnpspos),binsize)
						if(length(mybreaks)==1)
							{
							if(mybreaks==0)
								{
								snps$distbin[snps$chr==mychrom]<<- paste(as.character(mychrom),as.character(binsize/2),sep="_")
								}else{
								mylabelstemp	<- mybreaks-binsize/2
								mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
								snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
								}
							}else{
							mylabelstemp	<- mybreaks[2:length(mybreaks)]-binsize/2
							mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
							snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
							}
						}else{
						snps$distbin[snps$chr==mychrom]	<<- paste(as.character(mychrom),as.character(mysnpspos),sep="_")
						}
					}
				cat("Selecting one snp per position bin.",sep="\n")
				snps$binfilter						<<- NA
				snpstemp							<- snps[snps$filter2,]
				snps$binfilter[snps$filter2]		<<- !duplicated(snpstemp$distbin)
				snps$binfilter[is.na(snps$binfilter)]<<- FALSE
				nretained							<- nrow(snps[snps$binfilter,])
				cat(paste("Number of SNPs which will be used to define the neutral distribution: ",nretained,".",sep=""),sep="\n")  
				}
			}else{
			cat("WARNING: No positional information. SambaR will infer neutral distribution from unthinned dataset even do the flag 'dothin' is set to TRUE (default).",sep="\n")
			snps$binfilter							<<- snps$filter2
			}
		}else{
		cat("The flag 'dothin' is set to FALSE (default). SambaR will infer neutral distribution from unthinned dataset.",sep="\n")
		snps$binfilter								<<- snps$filter2
		}
	#
	##### EXTRACT MINOR AND MAJOR ALLELE COUNTS ####
	if(my_dataset=="pheno")
		{
		popfilter	<- rep(TRUE,nrow(inds))
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		popfilter	<- inds$pop==pop_1|inds$pop==pop_2
		}
	#
	# For phenotype 1:
	# number of minor alleles per locus:
	if(my_dataset=="pheno")
		{
		indfilter		<- inds$filter&popfilter&pheno
		}else{
		indfilter		<- inds$filter&popfilter&inds$pop==pop_1
		}
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for inds$pheno==TRUE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor1			<- as.vector(glSum(mygenlight[indfilter,]))
	major1			<- nonmisscount-minor1
	#
	# For phenotype 2:
	if(my_dataset=="pheno")
		{
		indfilter		<- inds$filter&popfilter&!pheno
		}else{
		indfilter		<- inds$filter&popfilter&inds$pop==pop_2
		}
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for inds$pheno==FALSE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor2			<- as.vector(glSum(mygenlight[indfilter,]))
	major2			<- nonmisscount-minor2	
	#
	##### CALCULATE FISHER EXACT TEST P-VALUES #####
	snps$rfisherlog_p	<<-	NULL
	snps$rfisherout		<<- NULL
	macmatrix			<- rbind(major1,minor1,major2,minor2)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	snps$rfisherlog_p	<<- -log(rfisherp)
	snps$rfisherlog_p[snps$rfisherlog_p<0.0001]	<<- 0	# 10-11-2019: to avoid negative or infinitely small values
	if(make_global)
		{
		macmatrix			<<- t(macmatrix)
		plist				<<- plist
		rfisherp			<<- rfisherp
		}
	#
	##### FIT EXPONENTIAL DISTRIBUTION #####
	cat("Fitting exponential distribution...",sep="\n")
	# we assume that the distribution of the logp values fit an exponential distribution.
	if(dothin)
		{
		mylogpvalues		<- snps$rfisherlog_p[snps$filter2&snps$binfilter]
		}else{
		mylogpvalues		<- snps$rfisherlog_p[snps$filter2]
		}
	mynsnps				<- length(mylogpvalues)
	mynsnps2			<- nrow(snps[snps$filter2,])
	cat(paste("Number of SNPs used to infer neutral distribution: ",mynsnps," out of ",mynsnps2,".",sep=""),sep="\n")
	mymean				<- mean(mylogpvalues)	
	myrate				<- 1/mymean
	#
	# bonferroni correction:
	# 21-07-2020: out of use: mybonf<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
	# 17-06-2021: out of use: mybonf<- 1-(my_sign_level/(length(mylogpvalues)))			
	# 17-06-2021: back to use (I realized that otherwise all what thinning does is decreasing number of SNPs and thereby relaxing the Bonferroni treshold, which is undesirable): 
	mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))				
	myvalue				<- qexp(mybonf,myrate)
	#
	##### CALCULATE GWDS P-VALUES #####
	cat("Testing which loci are outliers using Bonferroni correction...",sep="\n")
	# Now we have deduced the neutral distribution and defined a threshold, we can mark snps as outliers: 
	gwds_pvalues		<- 1-pexp(snps$rfisherlog_p,myrate)
	if(any(gwds_pvalues==0&!is.na(gwds_pvalues))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
	snps$rfisherGWDSlogp<<- ifelse(gwds_pvalues==0&!is.na(gwds_pvalues),20,-log10(gwds_pvalues))	# 04-09-2020: if p-values == 0, setting log10(p-value) to 20.
	snps$rfisherout		<<-	snps$rfisherlog_p>myvalue
	#
	if(is.null(mycorrection))
		{
		cat(paste("Threshold Fisher exact test log p-value: ",round(myvalue,2),".",sep=""),sep="\n")
		}else{
		# 02-08-2020: adjust p-values rather than the threshold value.
		# This way different multiple test correction methods can be used (i.e. not only Bonferroni, but also Benjamini-Hochberg and the Holm correction)
		# this will overwrite the snps$rfisherout
		cat(paste("Correcting GWDS p-values using the ",mycorrection," method.",sep=""),sep="\n")
		snps$rfisherGWDS_padj							<<- NA
		snps$rfisherGWDS_padj[snps$filter2]				<<- p.adjust(gwds_pvalues[snps$filter2],method=mycorrection)
		snps$rfisherout									<<-	snps$rfisherGWDS_padj<=my_sign_level
		snps$rfisherout[is.na(snps$rfisherout)]			<<- FALSE	
		names(snps)[names(snps) == "rfisherGWDS_padj"] 	<<- paste("rfisherGWDS_padj",my_dataset,sep = "_")
		}
	noutliers			<- nrow(snps[snps$rfisherout&snps$filter2,])
	cat(paste("Found",noutliers,"outlier loci.",sep=" "),sep="\n")
	#
	if(wingwds)
		{
		# 16-10-2021: not useful because gwds-scores are distributed non-randomly due to linkage
		##### INFER MULTI-LOCUS NEUTRAL DISTRIBUTION ####
		# expected random distribution:
		multip				<- vector()
		for(j in c(1:mynsnps2))
			{
			# product does not fit exponential distribution 
			# multip[j]		<- prod(sample(exp(-snps$rfisherlog_p[snps$filter2]),3,replace=FALSE),na.rm=TRUE)
			multip[j]		<- mean(sample(exp(-snps$rfisherlog_p[snps$filter2]),3,replace=FALSE),na.rm=TRUE)
			}
		simwinlogp			<- -log(multip)
		multimean			<- mean(simwinlogp)	
		multirate			<- 1/multimean
		multibonf			<- 1-(my_sign_level/mynsnps2)				
		multivalue			<- qexp(multibonf,multirate)
		# empirical distribution:
		winfisherlogp		<- rollapply(snps$rfisherlog_p,3,mean,by=1,na.rm=TRUE)
		snps$winfisherlogp	<<- c(snps$rfisherlog_p[1],winfisherlogp,snps$rfisherlog_p[length(snps$rfisherlog_p)])
		# assign p-values:
		wingwdspvalues		<- 1-pexp(snps$winfisherlogp,myrate)
		snps$winGWDSlogp	<<- ifelse(wingwdspvalues==0&!is.na(wingwdspvalues),20,-log10(wingwdspvalues))
		snps$winGWDSout		<<-	snps$winfisherlogp>multivalue
		}
	#
	##### FINALIZE OUTPUT COLUMNS #####
	if(any(is.infinite(snps$rfisherlog_p)))		{cat("WARNING: infinite values present in fisher exact test results. Replacing with NA.",sep="\n")}
	if(any(is.infinite(snps$rfisherGWDSlogp)))	{cat("WARNING: infinite values present in GWDS p-values. Replacing with NA.",sep="\n")}
	snps$rfisherlog_p[is.infinite(snps$rfisherlog_p)]		<<- NA
	snps$rfisherGWDSlogp[is.infinite(snps$rfisherGWDSlogp)]	<<- NA
	#
	# rename columns:
	names(snps)[names(snps) == "rfisherlog_p"] 	<<- paste("rfisherlog_p",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherOR"] 	<<- paste("rfisherOR",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherout"] 	<<- paste("rfisherout",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherGWDSlogp"]<<- paste("rfisherGWDSlogp",my_dataset,sep = "_")
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

gwdshisto_multi<-function(doexport=FALSE,allpairwise=FALSE,popnames=mysambar$populations,bin_width=1,chi_threshold=2000,silent=TRUE)
	{
	mychilist		<- list()
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		ncombi		<- ncol(allcombi)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		ncombi		<- ncol(allcombi)+1
		}
	for(k in c(1:ncombi))
		{
		graphics.off()
		if(k==ncombi&!allpairwise)
			{
			my_dataset	<- "pheno"
			mypop_1		<- "pheno1"
			mypop_2		<- "pheno2"
			}else{
			mypop_1		<- allcombi[1,k]
			mypop_2		<- allcombi[2,k]
			my_pops		<- c(mypop_1,mypop_2)
			my_pops		<- my_pops[order(my_pops)]
			my_dataset	<- paste(my_pops[1],my_pops[2],sep="_")
			}
		if(!silent){cat(my_dataset,sep="\n")}
		if(paste("rfisherlog_p",my_dataset,sep="_")%in%colnames(snps))
			{
			mylogp		<- snps[,paste("rfisherlog_p",my_dataset,sep="_")]
			if(length(table(mylogp))==1)
				{
				cat(paste("WARNING: no variation in fisher test logp values for population pair ",mypop_1," and ",mypop_2,". Omitting histogram.",sep=""),sep="\n")
				mychilist[[k]]		<<- data.frame("mychi"=NA,"mydf"=NA,"mychiout"=NA,"dataset"=my_dataset)
				}else{
				if(doexport){pdf(paste("GWDS.histo",my_dataset,"pdf",sep="."),width=10,height=6)}
				par(oma=c(2.5,3,0,0))
				gwdshisto(myinput=mylogp,myxaxt='s',binwidth=bin_width,chithreshold=chi_threshold)
				mtext(my_dataset,side=3,line=-1,cex=1.5)
				mtext("Frequency",side=2,line=4,cex=2)
				mtext("-log(pvalue)",side=1,line=2.5,cex=2)
				if(doexport){dev.off()}
				mysambar$mychidf$dataset	<<- my_dataset 
				mychilist[[k]]				<- mysambar$mychidf
				}
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	if(doexport)
		{
		cat("Histograms with fitted curves have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(length(mychilist)>1)
		{
		mychidf 	<- do.call("rbind",mychilist)
		write.table(mychidf,"GWDS.histo.goodness_of_fit.txt",row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		cat("File 'GWDS.histo.goodness_of_fit.txt' with chi-squared values for goodness of fit written to directory:",sep="\n")
		cat(getwd(),sep="\n")
		if(any(mychidf$chi2>chi_threshold))
			{
			fileConn	<- file("GWDS.WARNING.txt")
			writeLines(c("IMPORTANT WARNING: for one or more pairwise comparisons, a low goodness of fit was observed between observed and fitted distribution (see file 'GWDS.histo.goodness_of_fit.txt').",
			paste("Preferably this value should be below ",chi_threshold," (rough guideline).",sep=""),
			"As a result, the output might be unreliable. Please observe the output plots with caution before drawing any conclusions.",
			""),fileConn)
			close(fileConn)
			}
		}
	}	
		
gwdshisto<-function(myinput=snps$rfisherlog_p_pheno,nbreaks=100,binwidth=1,myxaxt='s',chithreshold=2000,exportname=NULL,ymax=NULL,silent=FALSE,dofilter=TRUE)
	{
	if(dofilter)
		{
		mylogscores	<- myinput[snps$filter2&!is.na(myinput)]	
		}else{
		mylogscores	<- myinput[!is.na(myinput)]
		}
	if(length(table(mylogscores))==1)
		{
		cat(paste("WARNING: no variation in fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
		}		
	nloci		<- length(mylogscores)
	mycurve		<- rexp(n=nloci,rate=1/mean(mylogscores))		# expected distribution
	mymax		<- 1.2*max(c(mylogscores,mycurve),na.rm=TRUE)
	mybreaks	<- seq(0,mymax,binwidth)
	if(!is.null(exportname))
		{
		pdf(paste("GWDS.histo",exportname,"pdf",sep="."))
		}
	if(is.null(ymax))
		{
		myobs		<- hist(mylogscores,freq=FALSE,breaks=mybreaks,col="grey",las=1,main="",xlab="",ylab="",cex.axis=1.5,xaxt=myxaxt)
		}else{
		myobs		<- hist(mylogscores,freq=FALSE,breaks=mybreaks,col="grey",las=1,main="",xlab="",ylab="",cex.axis=1.5,xaxt=myxaxt,ylim=c(0,2))
		}
	#
	# add fitted distribution and corresponding curve:
	mydensity	<- density(mycurve)
	myfit		<- hist(mycurve,breaks=mybreaks,freq=FALSE,add=TRUE,col=rgb(1,0,0,1/6))
	lines(mydensity$x,mydensity$y,col="red",lwd=2)
	legend("topright",legend=c("observed","fitted"),fill=c("grey","red"),bty='n',cex=1.5)
	if(!is.null(exportname)){dev.off()}
	#
	# test goodness of fit:
	myobs		<- round(myobs$density*nloci)
	myfit		<- round(myfit$density*nloci)
	mytable		<- cbind(myobs,myfit)
	mytable		<- mytable[rowSums(mytable)!=0,]
	options(warn=-1)
	mychiout	<- chisq.test(mytable)
	options(warn=0)
	mychi		<- round(mychiout[[1]],2)
	mydf		<- mychiout[[2]]
	myp			<- round(mychiout[[3]],5)
	mychi2df	<- data.frame("chi2"=mychi,"df"=mydf,"pvalue"=myp)
	mysambar$mychidf	<<- mychi2df 
	if(mychi>=chithreshold)
		{
		cat("WARNING: low goodness of fit between observed and fitted distribution.",sep="\n")
		cat(paste("Chi-squared value for goodness of fit: ",mychi,".",sep=""),sep="\n")
		cat(paste("Preferably this value should be below ",chithreshold,".",sep=""),sep="\n")
		}
	if(!is.null(exportname))
		{
		write.table(mychi2df,paste("GWDS.histo.goodness_of_fit",exportname,"txt",sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		cat("File 'GWDS.histo.goodness_of_fit.txt' with chi-squared values for goodness of fit written to directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}
	
# first execute gwdsfisher 
gwdsmanhattan<-function(my_dataset="pheno",showfisher=TRUE,my_sign_level=0.05,dothin=FALSE,exporttype=NULL,mycolours=c("black","red","orange"),mycex=1,mycexout=1.5,my_labels=NULL,myxaxis='s',addpairwiseout=FALSE,addlab=FALSE,popcex=1.25,addaxis2=TRUE,silent=TRUE)
	{
	#if(any(nchar(my_labels)>6))
	#	{
	#	my_labels<-substr(my_labels,1,6)
	#	}
	# rather than black we can also use: mycolours=c("#99CCFF","red","orange")
	# input vectors:
	if(!silent){cat("Extracting p-values from SNP dataset...",sep="\n")}
	if(showfisher)
		{
		#cat("Plotting -ln(Fisher exact test p-values)...",sep="\n")
		mylogp				<- snps[,paste("rfisherlog_p",my_dataset,sep="_")]
		mylogp2				<- snps[,paste("rfisherGWDSlogp",my_dataset,sep="_")]
		if(!any(mylogp2!=0,na.rm=TRUE))
			{
			cat("All GWDS log(p-values) equal to 0. Not adding to Manhattan plot.",sep="\n")
			}
		}else{
		#cat("Plotting -log(GWDS p-values)...",sep="\n")
		mylogp				<- snps[,paste("rfisherGWDSlogp",my_dataset,sep="_")]
		mylogp2				<- snps[,paste("rfisherlog_p",my_dataset,sep="_")]
		if(!any(mylogp!=0,na.rm=TRUE))
			{
			return(cat("All GWDS log(p-values) equal to 0. Not creating Manhattan plot.",sep="\n"))
			}
		}
	if(!silent)
		{
		mylogtemp	<<- mylogp
		mylogtemp2	<<- mylogp2
		}
	mylogp[is.infinite(mylogp)]		<- NA
	mylogp2[is.infinite(mylogp2)]	<- NA
	myfisherout			<- snps[,paste("rfisherout",my_dataset,sep="_")]
	# bonferroni threshold:
	mymean				<- mean(mylogp[snps$filter2])	
	myrate				<- 1/mymean
	if(!dothin)
		{
		mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
		mybonf2				<- my_sign_level/(nrow(snps[snps$filter2,]))
		}else{
		mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
		mybonf2				<- my_sign_level/(nrow(snps[snps$filter2,]))
		# 17-06-2021: replaced lines below with lines above, for reasons explained in gwdsfisher plot.
		# mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2&snps$binfilter,])))
		# mybonf2			<- my_sign_level/(nrow(snps[snps$filter2&snps$binfilter,]))
	}
	if(showfisher)
		{
		myvalue				<- qexp(mybonf,myrate)
		myvalue2			<- -log10(mybonf2)
		}else{
		myvalue				<- -log10(mybonf2)
		myvalue2			<- qexp(mybonf,myrate)
		}
	# find maximum logp value for all comparisons (pooled and pairwise):
	if(!silent){cat("Defining y-limit...",sep="\n")}
	if(addpairwiseout)
		{
		if(showfisher)
			{
			mylogpdf			<- snps[, grep('^rfisherlog_p', names(snps))] 
			mymax				<- 1.1*max(mylogpdf)
			}else{
			mylogpdf			<- snps[, grep('^rfisherGWDSlogp', names(snps))] 
			mymax				<- 1.1*max(myvalue)
			if(mymax<(1.1*max(mylogpdf)))
				{
				mymax		<- 1.1*max(mylogpdf)
				}
			}
		myoutdf				<- snps[, grep('^rfisherout', names(snps))]
		myoutallvec			<- apply(myoutdf,1,any)
		myoutother			<- myoutallvec&(!myfisherout)
		}else{
		if(showfisher)
			{
			mymax			<- 1.1*max(mylogp[snps$filter2],na.rm=TRUE)	
			}else{
			mymax			<- 1.1*max(myvalue)
			if(mymax<(1.1*max(mylogp[snps$filter2])))
				{
				mymax		<- 1.1*max(mylogp[snps$filter2])
				}
			}
		}
	# define plot colours:
	if(!silent){cat("Creating plot...",sep="\n")}
	myfishercol			<- mycolours[as.factor(myfisherout)]
	#outvectors			<- names(snps)[grepl("rfisherout",names(snps))]
	# plot:
	snpnumber			<- c(1:nrow(snps))
	if(!is.null(exporttype))
		{
		if(showfisher)
			{
			plotname		<- paste("Manhattan_GWDS_fisherlogp",my_dataset,sep="_")
			}else{
			plotname		<- paste("Manhattan_GWDS_gwdslogp",my_dataset,sep="_")
			}
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=15,height=5)}
		if(addlab)
			{
			par(oma=c(0,1,0,2.5),cex.axis=1.5)
			}else{
			par(oma=c(0,1,0,1.5),cex.axis=1.5)
			}
		}
	plot(snpnumber[snps$filter2],mylogp[snps$filter2],col=mycolours[1],cex=mycex,ylim=c(0,mymax),pch=16,ylab="",xlab="",main="",xaxt=myxaxis,las=1)
	if(addpairwiseout)
		{
		points(snpnumber[myoutother&snps$filter2],mylogp[myoutother&snps$filter2],col=mycolours[3],cex=mycexout,pch=16)
		}
	points(snpnumber[myfisherout&snps$filter2],mylogp[myfisherout&snps$filter2],col=mycolours[2],cex=mycexout,pch=16)
	segments(x0=0,y0=myvalue,x1=nrow(snps),y1=myvalue,lty=2,lwd=1,col="grey")
	if(!silent){cat("Adding dataset labels...",sep="\n")}
	if(my_dataset=="pheno")
		{
		if(!is.null(my_labels))
			{
			mtext(paste(my_labels[1],"vs",my_labels[2],sep=" "),side=4,cex=1.25,line=1.5)
			}else{
			if(addlab)
				{
				mtext("typeA vs typeB",side=3,cex=1.25,line=1.5)
				}else{
				mtext("typeA vs typeB",side=4,cex=1.25,line=1.5)
				}
			}
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		if(addlab)
			{
			mtext(paste(pop_1,"vs",pop_2,sep=" "),side=3,cex=popcex,line=1.5)
			}else{
			mtext(paste(pop_1,"vs",pop_2,sep=" "),side=4,cex=popcex,line=1.5)
			}
		}
	if(!silent){cat("Adding axis labels...",sep="\n")}
	if(addlab)
		{
		mtext("SNP index",side=1,cex=2,line=3)
		if(showfisher)
			{
			mtext("-ln(Fisher p-value)",side=2,cex=2,line=3.5)
			}else{
			mtext("-log10(GWDS p-value)",side=2,cex=2,line=3.5)
			}
		if(addaxis2&any(mylogp2!=0,na.rm=TRUE))
			{
			par(new=TRUE)
			y2max	<- 1.1*max(mylogp2[snps$filter2],na.rm=TRUE)
			y2range	<- c(0,y2max)
			y2sub	<- head(mylogp2[snps$filter2],5)
			plot(c(0,0,0),col="black",yaxt='n',xaxt='n',ylab="",xlab="",xaxt='n',ylim=y2range)
			#segments(x0=0,y0=myvalue2,x1=nrow(snps),y1=myvalue,lty=2,lwd=1,col="grey")
			if(showfisher)
				{
				mtext("-log10(GWDS p-value)",side=4,cex=2,line=3.5)
				}else{
				mtext("-ln(Fisher p-value)",side=4,cex=2,line=3.5)
				}
			axis(side=4,las=1)
			}
		}
	if(!is.null(exporttype)){dev.off()}
	}

runPCadapt<-function(K=NULL,my_sign_level=0.05,popnames=mysambar$populations,my_dataset="metapop",currentdir=FALSE,mycorrection="holm",store_adjusted=FALSE,importped=FALSE)
	{
	# my correction can be 'holm', 'bonferroni', and 'BH' (Benjamini-Hochberg) or NULL (default)
	# if NULL, this function will use the holm correction (because I found this gives the best results)
	if(is.null(mycorrection))
		{
		cat("No multiple testing correction method specified. Defaulting to using holm correction.",sep="\n")
		mycorrection	<- "holm"
		}else{
		if(mycorrection!="holm"&mycorrection!="bonferroni"&mycorrection!="BH")
			{
			return(cat("ERROR: mycorrection should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}else{
			cat(paste("Using ",mycorrection," method to correct for multiple testing.",sep=""),sep="\n")
			}
		}
	cat(paste("Specified dataset: ",my_dataset,".",sep=""),sep="\n")
	cat(paste("Specified significance threshold: ",my_sign_level,".",sep=""),sep="\n")
	if(is.null(K))
		{
		npops		<- length(popnames)
		cat("WARNING: K not defined. Assuming K equals length of input vector to popnames flag (default input vector is mysambar$populations).",sep="\n")
		}else{
		npops		<- K
		cat(paste("Using predefined K of ",npops,".",sep=""),sep="\n")
		}
	setwd(mysambar$inputfilesdir)
	# sambarfunction_selection:
	### PCadapt:
	if(importped)
		{
		# 28_10_2021: until now data was exported to ped and then imported with read.pcadapt function
		# However, this is not necessary, because read.pcadapt also accepts existing r objects
		# The option to export/import ped is still available (assuming the installation of an old version of pcadapt (4.1)), but is now by default disabled.
		#
		cat("Importing ped-file...",sep="\n")
		# sambarfunction_selection:
		myinput		<- paste(my_dataset,"filter2.miss0.letter.ped",sep=".")
		# sambarfunction_selection:
		x			<- read.pcadapt(myinput,type="ped")
		nrsnps_exp	<- nrow(snps[snps$filter2,])
		nrsnps_obs	<- attr(x,"p")
		if(nrsnps_exp!=nrsnps_obs)
			{
			cat("ERROR: number of lines in PED file does not correspond with expected number (i.e. nrow(snps[snps$filter2,])).",sep="\n")
			cat("Are the PED/MAP files perhaps generated with different filter settings than the current filter settings?",sep="\n")
			cat("If so, rerun the selectionanalyses function with the flag 'overwriteped' set to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")
			mysambar$pcadapt_error	<<- TRUE
			return(cat(" ",sep="\n"))
			}else{
			mysambar$pcadapt_error	<<- FALSE
			}
		}else{
		cat("Converting directly from genlight...",sep="\n")
		genomat		<- as.matrix(mygenlight[inds$filter,snps$filter2])		
		x			<- read.pcadapt(genomat,type="lfmm")
		# x			<- read.pcadapt(genomat,type.out="matrix",type="lfmm")		# PCadapt versions more recent than 4.1.0 give warning: In read.pcadapt(genomat, type.out = "matrix", type = "lfmm") : Argument 'type.out' is not used with matrices.
		# class(genomat) returns "matrix" "array"
		# This leads to the warning messages:
		# 1: In if (class(input) == "character") { :
		# the condition has length > 1 and only the first element will be used
		# 2: In if (class(input) %in% c("matrix", "data.frame", "array")) { :
		# the condition has length > 1 and only the first element will be used
		}
	#
	# sambarfunction_selection:
	z			<- pcadapt(x,K=npops)
	# optional graphs (not insightful for main conclusion):
	# plot(z,option="qqplot",threshold=0.1)
	# hist(z$pvalues,xlab="p-values",main=NULL,breaks=50)
	# plot(z,option="stat.distribution")
	# 
	# sambarfunction_selection:
	padj 			<- p.adjust(z$pvalues,method=mycorrection)
	myoutliers 		<- which(padj<my_sign_level)
	if(store_adjusted)
		{
		pcadaptlogp	<- -log10(padj) 
		}else{
		pcadaptlogp	<- -log10(z$pvalues)
		}
	if(any(is.infinite(pcadaptlogp))){cat("WARNING: Infinite PCadapt log10(p-values) detected. Replacing with NA.",sep="\n")}
	pcadaptlogp[is.infinite(pcadaptlogp)]	<- NA
	noutliers		<- length(myoutliers)
	## store outliers (TRUE/FALSE) in snps dataset:
	# remove previous results, if present
	if(!is.null(snps$PCadaptoutlier))
		{
		snps$PCadaptoutlier	<<- NULL
		}
	#outtemp		<- snps[snps$filter2,]
	if(importped)
		{
		myinput2				<- paste(my_dataset,"filter2.miss0.letter.map",sep=".")
		mymapfile				<- read.table(myinput2)
		mymapfile$V1			<- NULL
		mymapfile$V3			<- NULL
		mymapfile$V4			<- NULL
		mymapfile$PCadaptoutlier<- TRUE			# we set all to true because in following step we select outlier loci only)
		colnames(mymapfile)[1]	<- "name"
		}else{
		mymapfile				<- snps[snps$filter2,c("name","pos")]
		mymapfile$pos			<- NULL
		mymapfile$PCadaptoutlier<- TRUE			# we set all to true because in following step we select outlier loci only)
		}
	outtemp2		<- mymapfile[myoutliers,]
	outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
	#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
	#outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
	outtemp4		<- outtemp3[order(outtemp3$nr_neworder),]	# 24_11_2020
	outtemp4$PCadaptoutlier[is.na(outtemp4$PCadaptoutlier)]<-FALSE
	if(any(outtemp4$name!=snps$name))
		{
		cat("ERROR: something went wrong whilst reordering the data. Contact developer of SambaR.",sep="\n")
		}
	snps			<<- outtemp4
	# change column name:
	mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
	cat(paste("PCadapt detected ",noutliers," outlier loci using the ",mycorrection," method correction for multiple testing.",sep=""),sep="\n")
	names(snps)[names(snps) == "PCadaptoutlier"] <<- mycolumnname
	cat(paste("Outliers are marked as TRUE in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
	## store pcadapt -logp scores in snps dataset:
	if(!is.null(snps$PCadaptlogp))
		{
		snps$PCadaptlogp			<<- NULL
		}
	snps$PCadaptlogp				<<- NA
	#pcadaptlogp						<<- pcadaptlogp
	if(length(pcadaptlogp)!=nrow(snps[snps$filter2,]))
		{
		return(cat("ERROR: number of SNPs in the pcadapt input/output does not correspond with number of snps defined by snps$filter2 column. Halting execution. Potential solution: set overwriteped flag of the selectionanalyses function to TRUE.",sep="\n"))
		}
	snps$PCadaptlogp[snps$filter2]	<<- pcadaptlogp		# 27-09-2019: snps$filter2 or snps$filter?
	mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
	names(snps)[names(snps) == "PCadaptlogp"] <<- mycolumnname
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	cat(paste("PCadapt -log(p) values are stored in the ",mycolumnname," column in the snps dataframe.",sep=""),sep="\n")
	}


runPCadapt_old<-function(K=NULL,my_sign_level=0.05,popnames=mysambar$populations,my_dataset="metapop",currentdir=FALSE,do_plot=FALSE,mycorrection="holm")
	{
	cat("PCadapt will be run using 3 methods for multiple testing correction: Bonferroni, Benjamini-Hochberg, and Holm.",sep="\n")
	cat(paste("The",mycorrection,"method will eventually be used."),sep="\n")
	cat("To use another correction method, change the input to the mycorrection flag.",sep="\n")
	#
	if(is.null(K))
		{
		npops		<- length(popnames)
		cat("WARNING: K not defined. Assuming K equals length of input vector to popnames flag (default input vector is mysambar$populations).",sep="\n")
		}else{
		npops		<- K
		cat(paste("Using predefined K of ",npops,".",sep=""),sep="\n")
		}
	if(!currentdir){setwd(mysambar$inputfilesdir)}
	myinput		<- paste(my_dataset,"filter2.miss0.letter.ped",sep=".")
	x			<- read.pcadapt(myinput,type="ped")
	nrsnps_exp	<- nrow(snps[snps$filter2,])
	nrsnps_obs	<- attr(x,"p")
	if(nrsnps_exp!=nrsnps_obs)
		{
		cat("ERROR: number of lines in PED file does not correspond with expected number (i.e. nrow(snps[snps$filter2,])).",sep="\n")
		cat("Are the PED/MAP files perhaps generated with different filter settings than the current filter settings?",sep="\n")
		return(cat("If so, recreate the PED/MAP files and try again.",sep="\n"))
		}
	z			<- pcadapt(x,K=npops)
	# optional graphs (not insightful for main conclusion):
	# plot(z,option="qqplot",threshold=0.1)
	# hist(z$pvalues,xlab="p-values",main=NULL,breaks=50)
	# plot(z,option="stat.distribution")
	# we do both bonferroni_correction and Bennjamini-Hochberg (BH) correction:
	for (my_k in c(1:1))
		{
		if(my_k==1){padj 	<- p.adjust(z$pvalues,method="bonferroni")}
		if(my_k==2){padj	<- p.adjust(z$pvalues,method="BH")}		
		if(my_k==3){padj	<- p.adjust(z$pvalues,method="holm")}
		myoutliers 		<- which(padj<my_sign_level)
		pcadaptlogp		<- -log(padj) 
		pcadaptlogp		<<- pcadaptlogp
		noutliers		<- length(myoutliers)
		## store outliers (TRUE/FALSE) in snps dataset:
		# remove previous results, if present
		if(!is.null(snps$PCadaptoutlier))
			{
			snps$PCadaptoutlier	<<- NULL
			}
		#outtemp		<- snps[snps$filter2,]
		myinput2		<- paste(my_dataset,"filter2.miss0.letter.map",sep=".")
		mymapfile		<- read.table(myinput2)
		mymapfile$V1	<- NULL
		mymapfile$V3	<- NULL
		mymapfile$V4	<- NULL
		mymapfile$PCadaptoutlier<- TRUE
		colnames(mymapfile)[1]	<- "name"
		outtemp2		<- mymapfile[myoutliers,]
		outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
		#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
		outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
		outtemp4$PCadaptoutlier[is.na(outtemp4$PCadaptoutlier)]<-FALSE
		# just to check:
		# mymapfile		<<- mymapfile
		# outtemp2		<<- outtemp2
		# outtemp3		<<- outtemp3
		# outtemp4		<<- outtemp4
		if(any(outtemp4$name!=snps$name))
			{
			cat("ERROR: something went wrong whilst reordering the data. Contact developer of SambaR.",sep="\n")
			}
		snps			<<- outtemp4
		# change column name:
		if(my_k==1)
			{
			if(mycorrection=="bonferroni")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_bonf",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the Bonferroni method correction for multiple testing.",sep=" "),sep="\n")
			}
		if(my_k==2)
			{
			if(mycorrection=="BH")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_BH",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the Benjamini-Hochberg procedure correction for multiple testing.",sep=" "),sep="\n")
			}
		if(my_k==3)
			{
			if(mycorrection=="holm")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_holm",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the holm correction for multiple testing.",sep=" "),sep="\n")
			}
		names(snps)[names(snps) == "PCadaptoutlier"] <<- mycolumnname
		cat(paste("Outliers are marked as TRUE in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
		## store pcadapt -logp scores in snps dataset:
		if(!is.null(snps$PCadaptlogp))
			{
			snps$PCadaptlogp			<<- NULL
			}
		snps$PCadaptlogp				<<- NA
		pcadaptlogp						<<- pcadaptlogp
		if(length(pcadaptlogp)!=nrow(snps[snps$filter2,]))
			{
			return(cat("ERROR: number of SNPs in the pcadapt input/output does not correspond with number of snps defined by snps$filter2 column. Halting execution. Potential solution: set overwriteped flag of the selectionanalyses function to TRUE.",sep="\n"))
			}
		snps$PCadaptlogp[snps$filter2]	<<- pcadaptlogp		# 27-09-2019: snps$filter2 or snps$filter?
		# change column name:
		if(my_k==1)
			{
			if(mycorrection=="bonferroni")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_bonf",my_dataset,sep="_")
				}
			}
		if(my_k==2)
			{
			if(mycorrection=="BH")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_BH",my_dataset,sep="_")
				}
			}
		if(my_k==3)
			{
			if(mycorrection=="holm")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_holm",my_dataset,sep="_")
				}
			}
		names(snps)[names(snps) == "PCadaptlogp"] <<- mycolumnname
		snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		cat(paste("PCadapt -log(p) values are stored in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
		}
	if(!currentdir){setwd(mysambar$selectiondir)}
	if(do_plot)
		{
		pdf(paste("PCadapt",my_dataset,"pdf"),width=18,height=9)
		par(mfrow=c(2,1))
		plot(snps$PCadaptlogp_BH_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		mtext("Benjamini-Hochberg pvalues",side=2,line=2.5,cex=2)
		points(c(1:nrow(snps))[snps$PCadaptout_BH_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_BH_pheno],col="blue",pch=16,cex=1.5)
		points(c(1:nrow(snps))[snps$PCadaptout_holm_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_holm_pheno],col="darkgreen",pch=16,cex=1.5)	
		points(c(1:nrow(snps))[snps$PCadaptout_bonf_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_bonf_pheno],col="red",cex=1.5,pch=16)
		legend("topleft",legend=c("Bonferroni outliers","holm outliers","Benjamini-Hochberg outliers"),fill=c("red","darkgreen","blue"),bty='n',cex=1.5)
		plot(snps$PCadaptlogp_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		mtext("Bonferroni pvalues",side=2,line=2.5,cex=2)
		points(c(1:nrow(snps))[snps$PCadaptout_BH_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_BH_pheno],col="blue",pch=16,cex=1.5)
		points(c(1:nrow(snps))[snps$PCadaptout_holm_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_holm_pheno],col="darkgreen",pch=16,cex=1.5)	
		points(c(1:nrow(snps))[snps$PCadaptout_bonf_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_bonf_pheno],col="red",cex=1.5,pch=16)
		plot(snps$PCadaptlogp_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		dev.off()
		}
	}

runOutflank<-function(indselection=inds$filter,export=TRUE,my_sign_level=0.05,my_dataset="metapop",popcolumn=inds$pop,myloci=snps$name[snps$filter2],mycorrection=NULL,domerge=TRUE,silent=TRUE,store_adjusted=FALSE,right_trim=0.95,no_balancing=TRUE,currentdir=FALSE)
	{
	current_dir	<- getwd()
	if(exists("P1"))
		{
		P1	<<- NULL
		}
	if(exists("outflankinput"))
		{
		outflankinput	<<- NULL
		}
	if(is.null(mycorrection))
		{
		cat("No multiple testing correction method specified. Defaulting to using q-value.",sep="\n")
		}else{
		if(mycorrection!="holm"&mycorrection!="bonferroni"&mycorrection!="BH")
			{
			return(cat("ERROR: mycorrection should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}else{
			cat(paste("Using ",mycorrection," method to correct for multiple testing.",sep=""),sep="\n")
			}
		}
	cat(paste("Specified dataset: ",my_dataset,".",sep=""),sep="\n")
	cat(paste("Specified significance threshold: ",my_sign_level,".",sep=""),sep="\n")
	cat(paste("Specified right_trim threshold: ",right_trim,". This means that whilst inferring the null Fst distribution, the SNPs with the top ",(1-right_trim)*100," percent Fst values will be ignored.",sep=""),sep="\n")
	cat(paste("Number of individuals: ",length(indselection[indselection]),".",sep=""),sep="\n")
	tempname				<- paste("OutFLANK",my_dataset,sep="_")
	tempname2				<- paste("OutFLANKlogp",my_dataset,sep="_")
	tempname3				<- paste("OutFLANKlogq",my_dataset,sep="_")
	if(tempname %in% colnames(snps))
		{
		snps[,tempname]	<<- NULL
		}
	if(tempname2 %in% colnames(snps))
		{
		snps[,tempname2]	<<- NULL
		}
	if(tempname3 %in% colnames(snps))
		{
		snps[,tempname3]	<<- NULL
		}
	#
	# Optionally fst distribution plots will be exported.
	# 19-01-2020: snps$filter2 contains !snps$polyfilter. Non-polymorphic loci result in errors.
	# sambarfunction_selection:
	### OutFLANK:
	# sambarfunction_selection:
	mymatrix					<- as.matrix(mygenlight[indselection,snps$filter2])	
	mymatrix[is.na(mymatrix)] 	<- 9
	# sambarfunction:
	outflankinput				<- MakeDiploidFSTMat(SNPmat=mymatrix,locusNames=myloci,popNames=popcolumn[indselection])
	if(!silent)
		{
		cat("passed MakeDiploidFstMat",sep="\n") 
		mymatrix		<<- mymatrix
		outflankinput	<<- outflankinput
		}
	#
	## Calibrating the null distribution of fst-values.
	# To do so we need a pruned dataset.
	# According to the manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
	# We assume that less than 5 percent are outliers (or other value specified by right_trim):
	# sambarfunction_selection:
	mymean				<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
	# sambarfunction_selection:
	myrate				<- 1/mymean
	# sambarfunction_selection:
	myvalue				<- qexp(right_trim,myrate)
	# sambarfunction_selection:
	prunevector			<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
	if(!silent)
		{
		cat("passed prunevector",sep="\n")
		prunevector		<<- prunevector
		} 
	# 12-10-2019: I used the above settings for the simulations, but this might be incorrect to do it this way.
	# Because in the function below OutFLANK trims 5 percent of top values and 5 percent of bottom values, so it is double. 
	# sambarfunction_selection:
	nrsamples			<- length(inds$pop[indselection])
	# sambarfunction_selection:
	npops				<- length(as.vector(unique(inds$pop[indselection])))
	# sambarfunction_selection:
	myfstmax			<- round(max(outflankinput$FSTNoCorr[prunevector],na.rm=TRUE),3)
	cat(paste("Highest Fst-value of pruned dataset: ", myfstmax,".",sep=""),sep="\n")
	if(!myfstmax<=0.99)
		{
		# This is to prevent the error:
		# ERROR: The largest FST in the trimmed set must be < 1. Please use a larger RightTrimFraction.
		# Error in !data$OutlierFlag : invalid argument type
		cat("Fst of pruned dataset ranges until 1. SambaR will not run OutFLANK and assume there are no outliers.",sep="\n")
		snps$OutFLANK		<<- FALSE
		snps$OutFLANKlogp	<<- 0
		snps$OutFLANKlogq	<<- 0
		colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
		}else{
		# NumberOfSamples is number of populations:
		# sambarfunction_selection:
		out_trim 			<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=npops,qthreshold=0.05,Hmin = 0.1)
		if(!silent){cat("passed OutFLANK",sep="\n")} 
		if(export)
			{
			if(!currentdir)
				{
				current_dir	<- mysambar$selectiondir
				setwd(current_dir)
				}
			if(dir.exists("OutFlankplots"))
				{
				setwd(file.path(current_dir,"OutFlankplots"))
				}else{
				dir.create(file.path(current_dir,"OutFlankplots"))
				setwd(file.path(current_dir,"OutFlankplots"))
				}
			pdf(paste("Outflank.fstdistribution",my_dataset,"pdf",sep="."))
			OutFLANKResultsPlotter(out_trim)
			dev.off()
			pdf(paste("Outflank.pvalues.righttail",my_dataset,"pdf",sep="."))
			hist(out_trim$results$pvaluesRightTail,main="",xlab="pvalues right tail",ylab="Frequency")
			dev.off()
			setwd(current_dir)
			}
		#
		## So now we have estimated neutral mean FST and df using the pruned dataset (snps$filter).
		# So now we can go back and calculate P-values and q-values for all loci.
		# sambarfunction_selection:
		P1 <- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar = out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = 0.05, Hmin=0.1)
		if(!silent){cat("pOutlierFinderChiSqNoCorr",sep="\n")} 
		#
		## Outliers?
		P1$negativelogp			<- -log10(P1$pvalues)
		P1$negativelogq			<- -log10(P1$qvalues)
		myfstmean				<- mean(P1$FST,na.rm=TRUE)
		P1$OutlierFlag_ALL		<- P1$qvalues<my_sign_level
		if(no_balancing)
			{
			cat("Because the flag 'no_balancing' is set to TRUE, SNPs putatively under balancing selection will be ignored.",sep="\n") 
			P1$OutlierFlag			<- P1$OutlierFlag_ALL&P1$FST>myfstmean
			}else{
			cat("Because the flag 'no_balancing' is set to FALSE, SNPs putatively under balancing selection will be included.",sep="\n") 
			P1$OutlierFlag			<- P1$OutlierFlag_ALL
			}
		if(!is.null(mycorrection))
			{
			cat(paste("Using the ",mycorrection," method to corrected p-values (rather than q-values (default)) to score outliers.",sep=""),sep="\n")
			P1$pvalues_adj		<- p.adjust(P1$pvalues,method=mycorrection) 
			P1$OutlierFlag_ALL	<- P1$pvalues_adj<my_sign_level
			if(no_balancing)
				{
				P1$OutlierFlag		<- P1$OutlierFlag_ALL&P1$FST>myfstmean
				}else{
				P1$OutlierFlag		<- P1$OutlierFlag_ALL
				}
			if(store_adjusted)
				{
				if(any(P1$pvalues_adj==0&!is.na(P1$pvalues_adj))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
				P1$negativelogp	<- ifelse(P1$pvalues_adj==0&!is.na(P1$pvalues_adj),20,-log10(P1$pvalues_adj))
				}else{
				if(any(P1$pvalues==0&!is.na(P1$pvalues_adj))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
				P1$negativelogp	<- ifelse(P1$pvalues==0&!is.na(P1$pvalues),20,-log10(P1$pvalues))
				}
			}
		if(any(is.infinite(P1$negativelogp))){cat("WARNING: Infinite OutFLANK log10(p-values) detected. Replacing with NA.",sep="\n")}
		P1$negativelogp[is.infinite(P1$negativelogp)]	<- 20
		P1$OutlierFlag[is.na(P1$OutlierFlag)]			<- FALSE
		noutliers_all			<- nrow(P1[P1$OutlierFlag_ALL&!is.na(P1$OutlierFlag_ALL),])
		noutliers				<- nrow(P1[P1$OutlierFlag&!is.na(P1$OutlierFlag),])
		cat(paste("OutFLANK detected",noutliers_all,"outlier SNPs (also including SNPs which might not have passed the filter settings).",sep=" "),sep="\n")
		cat(paste("Of these,",noutliers,"are supposedly under positive selection (rather than balancing selection).",sep=" "),sep="\n")
		if(export)
			{
			setwd(file.path(current_dir,"OutFlankplots"))
			pdf(paste("Outflank.outliers",my_dataset,"pdf",sep="."))
			#plot(P1$He[snps$filter2],P1$FST[snps$filter2],pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			plot(P1$He,P1$FST,pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			points(P1$He[P1$OutlierFlag],P1$FST[P1$OutlierFlag],pch=19,col="#336633")
			dev.off()			
			setwd(current_dir)
			}
		outtemp2		<- P1[,c("LocusName","OutlierFlag","negativelogp","negativelogq")]
		if(domerge)
			{
			# Merging keeps on returning errors (more rows than expected), so by default I choose for the more time consuming alternative option.
			colnames(outtemp2)<- c("name",tempname,tempname2,tempname3)
			outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
			if(nrow(outtemp3)!=nrow(snps))
				{
				return(cat("ERROR: number of rows in merged dataset does not correspond with number of rows of snps dataframe. Contact developer of SambaR.",sep="\n"))
				}
			#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
			#outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
			#outtemp4		<- outtemp3[order(outtemp3$chr,outtemp3$pos),]
			outtemp4		<- outtemp3[order(outtemp3$nr_neworder),]	# 23_11_2020
			if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
				{	
				outtemp2	<<- outtemp2
				outtemp3	<<- outtemp3
				outtemp4	<<- outtemp4
				return(cat("ERROR: after reordering (in order to incorporate OutFLANK results in snps dataframe) column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}
			snps			<<- outtemp4
			}else{
			cat("Adding results to the snps dataframe using a slow method. This will take a while...")
			snps$OutFLANK		<<- NA
			snps$OutFLANKlogp	<<- NA
			snps$OutFLANKlogq	<<- NA
			for(i in c(1:nrow(outtemp2)))
				{
				if(i%%5000==0){cat(i,sep="\n")}
				mylocus			<- outtemp2$LocusName[i]
				if(mylocus%in%snps$name)
					{
					snps$OutFLANK[snps$name==mylocus]		<<- outtemp2$OutlierFlag[i]
					snps$OutFLANKlogp[snps$name==mylocus]	<<- outtemp2$negativelogp[i]
					snps$OutFLANKlogq[snps$name==mylocus]	<<- outtemp2$negativelogq[i]
					}
				}
			colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
			}
		# replace NAs with FALSE:
		mycolumn					<- snps[,paste("OutFLANK",my_dataset,sep="_")]
		mycolumn[is.na(mycolumn)]	<- FALSE
		snps[,paste("OutFLANK",my_dataset,sep="_")]	<<- mycolumn
		cat(paste("Outliers, if present, are marked as TRUE in the",tempname,"column in the snps dataframe.",sep=" "),sep="\n")
		cat("Negative log of the pvalues and qvalues are saved as well.",sep="\n")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

runOutflank_old<-function(indselection=inds$filter,export=TRUE,my_sign_level=0.05,my_dataset="metapop",popcolumn=inds$pop,myloci=snps$name[snps$filter2],q_value=FALSE,domerge=TRUE,silent=TRUE)
	{
	#
	tempname				<- paste("OutFLANK",my_dataset,sep="_")
	tempname2				<- paste("OutFLANKlogp",my_dataset,sep="_")
	tempname3				<- paste("OutFLANKlogq",my_dataset,sep="_")
	if(tempname %in% colnames(snps))
		{
		snps[,tempname]	<<- NULL
		}
	if(tempname2 %in% colnames(snps))
		{
		snps[,tempname2]	<<- NULL
		}
	if(tempname3 %in% colnames(snps))
		{
		snps[,tempname3]	<<- NULL
		}
	#
	# Optionally fst distribution plots will be exported.
	mymatrix					<- as.matrix(mygenlight[indselection,snps$filter2])	# 19-01-2020: snps$filter2 contains !snps$polyfilter. Non-polymorphic loci result in errors.
	mymatrix[is.na(mymatrix)] 	<- 9
	outflankinput				<- MakeDiploidFSTMat(SNPmat=mymatrix,locusNames=myloci,popNames=popcolumn[indselection])
	if(!silent)
		{
		cat("passed MakeDiploidFstMat",sep="\n") 
		mymatrix		<<- mymatrix
		outflankinput	<<- outflankinput
		}
	#
	## Calibrating the null distribution of fst-values.
	# To do so we need a pruned dataset.
	# According to the manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
	# We assume that less than 5 percent are outliers:
	mymean				<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
	myrate				<- 1/mymean
	myvalue				<- qexp(0.95,myrate)
	prunevector			<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
	if(!silent)
		{
		cat("passed prunevector",sep="\n")
		prunevector		<<- prunevector
		} 
	# 12-10-2019: I used the above settings for the simulations, but this might be incorrect to do it this way.
	# Because in the function below OutFLANK trims 5 percent of top values and 5 percent of bottom values, so it is double. 
	nrsamples			<- length(inds$pop[indselection])
	npops				<- length(as.vector(unique(inds$pop[indselection])))
	myfstmax			<- max(outflankinput$FSTNoCorr[prunevector],na.rm=TRUE)
	if(myfstmax==1)
		{
		# This is to prevent the error:
		# ERROR: The largest FST in the trimmed set must be < 1. Please use a larger RightTrimFraction.
		# Error in !data$OutlierFlag : invalid argument type
		cat("Fst of pruned dataset ranges until 1. SambaR will not run OutFLANK and assume there are no outliers.",sep="\n")
		snps$OutFLANK		<<- FALSE
		snps$OutFLANKlogp	<<- 0
		snps$OutFLANKlogq	<<- 0
		colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
		}else{
		# NumberOfSamples is number of populations:
		out_trim 			<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=npops,qthreshold=0.05,Hmin = 0.1)
		if(!silent){cat("passed OutFLANK",sep="\n")} 
		if(export)
			{
			setwd(mysambar$selectiondir)
			if(file.exists("OutFlankplots"))
				{
				setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
				}else{
				dir.create(file.path(mysambar$selectiondir,"OutFlankplots"))
				setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
				}
			pdf(paste("Outflank.fstdistribution",my_dataset,"pdf",sep="."))
			OutFLANKResultsPlotter(out_trim)
			dev.off()
			pdf(paste("Outflank.pvalues.righttail",my_dataset,"pdf",sep="."))
			hist(out_trim$results$pvaluesRightTail,main="",xlab="pvalues right tail",ylab="Frequency")
			dev.off()
			setwd(mysambar$selectiondir)
			}
		#
		## So now we have estimated neutral mean FST and df using the pruned dataset (snps$filter).
		# So now we can go back and calculate P-values and q-values for all loci.
		P1 <- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar = out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = 0.05, Hmin=0.1)
		if(!silent){cat("pOutlierFinderChiSqNoCorr",sep="\n")} 
		#
		## Outliers?
		P1$negativelogp			<- -log(P1$pvalues)
		P1$negativelogq			<- -log(P1$qvalues)
		if(!q_value)
			{
			cat("Using holm corrected p-values rather than q-values (default) to score outliers.",sep="\n")
			P1$pvalues_holm		<- p.adjust(P1$pvalues,method="holm") 
			P1$OutlierFlag		<- P1$pvalues_holm<my_sign_level
			P1$negativelogp		<- -log(P1$pvalues_holm)
			}
		P1$OutlierFlag[is.na(P1$OutlierFlag)]	<- FALSE
		#noutliers				<- nrow(P1[P1$OutlierFlag&snps$filter2&!is.na(P1$OutlierFlag),])
		noutliers				<- nrow(P1[P1$OutlierFlag&!is.na(P1$OutlierFlag),])
		#P1						<<- P1
		cat(paste("OutFLANK detected",noutliers,"outlier loci.",sep=" "),sep="\n")
		if(export)
			{
			setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
			pdf(paste("Outflank.outliers",my_dataset,"pdf",sep="."))
			#plot(P1$He[snps$filter2],P1$FST[snps$filter2],pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			plot(P1$He,P1$FST,pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			points(P1$He[P1$OutlierFlag],P1$FST[P1$OutlierFlag],pch=19,col="#336633")
			dev.off()			
			setwd(mysambar$selectiondir)
			}
		outtemp2		<- P1[,c("LocusName","OutlierFlag","negativelogp","negativelogq")]
		if(domerge)
			{
			# Merging keeps on returning errors (more rows than expected), so by default I choose for the more time consuming alternative option.
			colnames(outtemp2)<- c("name",tempname,tempname2,tempname3)
			outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
			#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
			outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
			#outtemp4		<- outtemp3[order(outtemp3$chr,outtemp3$pos),]
			if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
				{	
				outtemp2	<<- outtemp2
				outtemp3	<<- outtemp3
				outtemp4	<<- outtemp4
				return(cat("ERROR: after reordering column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}
			snps			<<- outtemp4
			}else{
			cat("Adding results to the snps dataframe using a slow method. This will take a while...")
			snps$OutFLANK		<<- NA
			snps$OutFLANKlogp	<<- NA
			snps$OutFLANKlogq	<<- NA
			for(i in c(1:nrow(outtemp2)))
				{
				if(i%%5000==0){cat(i,sep="\n")}
				mylocus			<- outtemp2$LocusName[i]
				if(mylocus%in%snps$name)
					{
					snps$OutFLANK[snps$name==mylocus]		<<- outtemp2$OutlierFlag[i]
					snps$OutFLANKlogp[snps$name==mylocus]	<<- outtemp2$negativelogp[i]
					snps$OutFLANKlogq[snps$name==mylocus]	<<- outtemp2$negativelogq[i]
					}
				}
			colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
			}
		# replace NAs with FALSE:
		mycolumn					<- snps[,paste("OutFLANK",my_dataset,sep="_")]
		mycolumn[is.na(mycolumn)]	<- FALSE
		snps[,paste("OutFLANK",my_dataset,sep="_")]	<<- mycolumn
		cat(paste("Outliers, if present, are marked as TRUE in the",tempname,"column in the snps dataframe.",sep=" "),sep="\n")
		cat("Negative log of the pvalues and qvalues are saved as well.",sep="\n")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

multi_plot_scanlog<-function(popnames=mysambar$populations,allpairwise=FALSE,do_export=NULL,outflank_q=FALSE,silent=TRUE)
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		plot_scanlog(doexport=do_export,outflankq=outflank_q,mydataset="pheno")
		}
	#allcombitemp	<<- allcombi
	ncombi		<- ncol(allcombi)	
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_data_set	<- paste(my_pops[1],my_pops[2],sep="_")
		if(paste("rfisherGWDSlogp",my_data_set,sep="_")%in%colnames(snps))
			{
			if(!silent){cat(my_data_set,sep="\n")}
			plot_scanlog(doexport=do_export,outflankq=outflank_q,mydataset=my_data_set,silent=silent)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	}

# Note: if OutFLANK p-values are determined based on q-value, possibly some neutral SNPs which have a higher p-value than SNPs marked as outlier 
plot_scanlog<-function(doexport=NULL,outflankq=FALSE,mydataset=NULL,markoutpheno=TRUE,silent=TRUE)
	{
	if(is.null(mydataset))
		{
		return(cat("ERROR: Specify an input dataset!",sep="\n"))
		}
	# This function plots negative logs of pvalues of GWDS and PCadapt, and qvalues of OutFLANK and optionally Bayescan
	snpcolnames		<- names(snps)
	alloci			<- c(1:nrow(snps))
	# GWDS:
	mycolumn		<- paste("rfisherout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		myGWDSlog		<- snps[,paste("rfisherGWDSlogp",mydataset,sep="_")]
		myGWDSout		<- snps[,paste("rfisherout",mydataset,sep="_")]
		}else{
		myGWDSlog		<- rep(NA,nrow(snps))
		myGWDSout		<- rep(NA,nrow(snps))
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		myPCadaptlog	<- snps[,paste("PCadaptlogp",mydataset,sep="_")]
		myPCadaptout	<- snps[,paste("PCadaptout",mydataset,sep="_")]
		}else{
		myPCadaptlog	<- rep(NA,nrow(snps))
		myPCadaptout	<- rep(NA,nrow(snps))
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		if(outflankq)
			{
			myOutFLANKlog	<- snps[,paste("OutFLANKlogq",mydataset,sep="_")]
			}else{
			myOutFLANKlog	<- snps[,paste("OutFLANKlogp",mydataset,sep="_")]
			}
		myOutFLANKout	<- snps[,paste("OutFLANK",mydataset,sep="_")]
		}else{
		myOutFLANKlog	<- rep(NA,nrow(snps))
		myOutFLANKout	<- rep(NA,nrow(snps))
		}
	# Bayescan:
	mycolumn		<- paste("bayescanout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		myBayescanlog	<- snps[,paste("bayescanlogq",mydataset,sep="_")]
		myBayescanout	<- snps[,paste("bayescanout",mydataset,sep="_")]
		}else{
		myBayescanlog	<- rep(NA,nrow(snps))
		myBayescanout	<- rep(NA,nrow(snps))
		}
	# fsthet:
	mycolumn		<- paste("fsthetout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		myfsthetlog		<- snps[,paste("fsthetlogp",mydataset,sep="_")]
		myfsthetout		<- snps[,paste("fsthetout",mydataset,sep="_")]
		}else{
		myfsthetlog		<- rep(NA,nrow(snps))
		myfsthetout		<- rep(NA,nrow(snps))
		}
	mylogvaluesdf		<- as.data.frame(cbind(myBayescanlog,myfsthetlog,myGWDSlog,myOutFLANKlog,myPCadaptlog))
	colnames(mylogvaluesdf)	<- c("Bayescan","Fsthet","GWDS","OutFLANK","PCadapt")
	myoutdf				<- as.data.frame(cbind(myBayescanout,myfsthetout,myGWDSout,myOutFLANKout,myPCadaptout))
	colnames(myoutdf)	<- c("Bayescan","Fsthet","GWDS","OutFLANK","PCadapt")
	# myoutdf				<<- myoutdf
	if(!silent){mylogvaluesdf	<<- mylogvaluesdf}
	mylogmax			<- max(mylogvaluesdf,na.rm=TRUE)
	#
	mytests				<- as.vector(which(colSums(is.na(myoutdf))<nrow(myoutdf)))
	mytestnames			<- colnames(myoutdf)[mytests]
	myoutdf				<- myoutdf[,colSums(is.na(myoutdf))<nrow(myoutdf)]
	myoutdf				<- as.data.frame(myoutdf)
	colnames(myoutdf)	<- mytestnames
	mylogvaluesdf			<- mylogvaluesdf[,colSums(is.na(mylogvaluesdf))<nrow(mylogvaluesdf)]
	mylogvaluesdf			<- as.data.frame(mylogvaluesdf)
	colnames(mylogvaluesdf)	<- mytestnames
	#	
	graphics.off()	
	ntiles				<- ncol(myoutdf)
	if(!is.null(doexport))
		{
		outputfile		<- paste("Selectionscan.logpvalues",mydataset,sep=".")
		if(doexport=="pdf"){pdf(paste(outputfile,"pdf",sep="."),height=ntiles*2+3,width=14)}
		}
	par(mfrow=c(ntiles,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	for(j in c(1:ntiles))
		{
		#if(!silent){cat(j,sep="\n")}
		mylogvalues	<- mylogvaluesdf[,j]
		myoutliers	<- myoutdf[,j]
		myymax		<- ifelse(!is.null(mylogmax),max(mylogvalues[is.finite(mylogvalues)],na.rm=TRUE),mylogmax)
		myymax		<- ifelse(myymax<1,1,myymax)
		myylim		<- c(0,myymax)
		myxaxt		<- ifelse(j==ntiles,'s','n')
		plot(alloci[snps$filter2],mylogvalues[snps$filter2],xaxt=myxaxt,ylab="",pch=16,ylim=myylim,las=1)
		if(markoutpheno)
			{
			rfisheroutliers	<- snps[,paste("rfisherout",mydataset,sep="_")]
			gwdsoutnr		<- which(rfisheroutliers&snps$filter2)
			abline(v=gwdsoutnr,col="grey")
			}
		if(length(myoutliers[myoutliers])>0)
			{
			points(alloci[myoutliers&snps$filter2],mylogvalues[myoutliers&snps$filter2],col="red",pch=16)
			}
		mylabel		<- mytestnames[j]
		mtext(mylabel,side=4,line=1.5,cex=1.75)
		mtext("-log(test statistic)",side=2,line=0.5,cex=2.5,outer=TRUE)
		mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
		}
	if(!is.null(doexport))
		{
		dev.off()
		cat(paste("A file called",outputfile,"has been exported.",sep=" "),sep="\n")
		}
	}

writebed<-function(my_dataset="pheno")
	{
	if(paste("bayescanout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("bayescanout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("Bayescanoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("PCadaptout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("PCadaptout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("PCadaptoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("OutFlank",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("OutFlank",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("OutFlankoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("rfisherout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("rfisherout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("GWDSoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	cat("BED-files with outliers have been written to the selection subdirectory",sep="\n")
	}

# this function can not be in exportsambarfiles(), because at that stage pheno has not been defined yet. 	
createbayescaninput<-function(allpairwise=FALSE,baye_overwrite=FALSE,popnames=mysambar$populations)
	{
	if(is.null(inds$type)&!allpairwise)
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		combinames	<- paste(allcombi[1,],allcombi[2,],sep="_")
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		combinames	<- paste(allcombi[1,],allcombi[2,],sep="_")
		}
	ncombi			<- ncol(allcombi)
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		mypop_1		<- my_pops[1]
		mypop_2		<- my_pops[2]
		indselect	<- inds$filter&(inds$pop==mypop_1|inds$pop==mypop_2)
		combiname	<- paste(combinames[my_i],"filter2.letter",sep=".")
		exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)
		}
	if(!allpairwise)
		{
		cat("pheno1_pheno2 (pooled data)",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)
		}
	}	

getbayescan<-function(FDR=0.01,export=NULL,my_dataset=NULL,use_merge=TRUE,inputmapfile=NULL,baye_overwrite=FALSE,silent=FALSE,dolog10=TRUE,my_qmax=NULL,my_fstmax=NULL)
	{
	# the Bayescan output file consists of the following columns: 
	# 1. The index of the locus corresponding to the index in the input file.
	# 2. The Bayesian posterior probability for the model including selection. 
	#	 E.g. p=0.75 means that the selection and neutral models have probabilities of 0.75 and 0.25, hence Bayes factor (BF) or odds ratio (OR) is 3 (0.75/0.25). Ergo, selection model is 3x more likely than neutral model. 
	#	 E.g. p=0.95 means that the selection and neutral models have probabilities of 0.95 and 0.05, hence Bayes factor (BF) or odds ratio (OR) is 19 (0.95/0.05). Ergo, selection model is 19x more likely than neutral model.
	#	 E.g. p=0.999 means that the selection and neutral models have probabilities of 0.999 and 0.001, hence Bayes factor (BF) or odds ratio (OR) is 999 (0.999/0.001). Ergo, selection model is 999x more likely than neutral model.
	# 	 E.g. p=0.1 means that the selection and neutral models have probabilities of 0.1 and 0.9, hence Bayes factor (BF) or odds ratio (OR) is 0.11 (0.1/0.9). Ergo, selection model is 10x LESS likely than neutral model.
	# 3. The logarithm of Posterior Odds (Bayes factor) to base 10 for the model including selection. Note that this value is arbitrarily fixed to 1000 when the posterior probability is 1 (should be infinity).
	#	 E.g. for p=0.75, BF=3, and log10(BF)=0.47
	#	 E.g. for p=0.95, BF=19, and log10(BF)=1.28
	#	 E.g. for p=0.999, BF=999, and log10(BF)=3
	#	 E.g. for p=0.1, BF=0.11, and log10(BF)=-0.96
	#	 According to Jeffrey's model of interpreting odds ratios, evidence can be interpreted as follows:
	#	 BF			log10(BF)	Jeffrey's interpretation
	#	 1-3		0-0.5		(barely) worth mentioning
	#	 3-10		0.5-1		substantial		
	#	 10-32		1-1.5		strong
	#	 32-100		1.5-2		very strong
	#	 100-inf	2-inf		decisive
	# 4. The q-value for the model including selection.
	#	 A bit of explanation: 
	#	 Recall that a p-value of 0.05 implies a chance of 5% of false positives. Say we have a dataset of 50000 SNPs, just by chance we expect 2500 SNPs with a p-value below 0.05.
	#	 A q-value of 0.05, in contrast, implies that 5% of all SNPs with a q-value equal or lower than 0.05, are false positives. Say there are 100 SNPs with a q-value below 0.05, 5 SNPs are expected to be false positives. 
	#	 In other words: a q-value denotes the false discovery rate (FDR).
	# 	 So how do get from a p-value to a q-value? In essence, a q-value is an adjusted p-value, like a Bonferroni adjusted p-value.
	#	 A (or the?) method used to correct p-values to q-values is the Benjamini-Hochberg correction. The function is like this: 
	#	 q-value = p-value*N/k
	#	 in which N is the total number of p-values, and k is the rank of this particular p-value (i.e. which indicates how many SNPs with lower p-values the dataset contains.)
	# 	 E.g.: in a dataset of 4 SNPs with p-values 0.01, 0.05, 0.1, 0.5, we get:
	#	 p-value	rank	N	q-value (=FDR)
	#	 0.5		4		4	0.5
	# 	 0.1		3		4	0.10*4/3 = 0.13
	#	 0.05		2		4	0.05*4/2 = 0.1
	#	 0.01		1		4	0.01*4/1 = 0.04
	# 	 Why does this simple formula indeed show FDR? Because:
	#	 The numerator 'p-value*N' (in short: pN) gives expected number of false positives if the p-value would be the significance threshold.
	#	 The denominator 'k' gives the actual number of SNPs with p-values below this threshold.
	# 	 The ratio therefore shows the false discovery rate. In case of k>pN, there are more SNPs with p-values below the threshold, than expected. The excess likely represents true outliers.
	#	 Note however that the output of p.adjust(prob,method="BH") differs from Bayescan q-value estimates.
	# 5. The estimated alpha coefficient indicates the strength and direction of selection. A positive value of alpha suggests diversifying selection, whereas negative values suggest balancing or purifying selection.
	# 6. The FST coefficient averaged over populations. In each population FST is calculated as the posterior mean using model averaging.
	#
	# IMPORTANT NOTE:
	# Bayescan logp values displayed by SambaR are -log10(1-prob) values, in which prob denotes Bayesian posterior probabilities of selection model.
	# These scores are normally not displayed, and just reflect the preference of the developer of SambaR.
	#
	if(is.null(my_dataset))
		{
		return(cat("ERROR: please specify a dataset to the my_dataset flag.",sep="\n"))
		}else{
		cat(paste("Specified dataset (my_dataset flag): ",my_dataset,".",sep=""),sep="\n")
		}
	cat(paste("False discovery rate is set to:",FDR,sep=" "),sep="\n")
	tempname	<- paste("bayescanout",my_dataset,sep="_")
	if(tempname%in%colnames(snps)&!baye_overwrite)
		{
		if(!silent){cat("Bayescan outlier column already present. Bayescan results will not be added. To force overwrite, set baye_overwrite to TRUE.",sep="\n")}
		tempname2	<- paste("bayescanlogq",my_dataset,sep="_")
		mylogqscores<- snps[,which(names(snps) == tempname2)]
		myqscores	<- 10^(-mylogqscores)
		bayeout		<- myqscores<FDR&!is.na(myqscores)
		noutliers	<- length(which(bayeout))
		snps[,which(names(snps) == tempname)]	<<- bayeout 
		}else{
		setwd(mysambar$inputfilesdir)
		if(is.null(inputmapfile))
			{
			mapfile	<- paste(my_dataset,"filter2.miss0.letter.map",sep=".")
			}else{
			mapfile	<- inputmapfile
			}
		if(!file.exists(mapfile))
			{
			cat(paste("ERROR: the inputfiles directory does not contain a file called ",mapfile,". Path to inputfiles directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}else{
			y		<- read.table(mapfile)	# mapfile used when converting ped/map to geste/bayescan.
			}
		myloci		<- y$V2
		# import bayescan results: 
		bayescanfile		<- paste(my_dataset,"bayescanout.fst.txt",sep=".")
		if(!file.exists(bayescanfile))
			{
			cat(paste("ERROR: the inputfiles directory does not contain a file called ",bayescanfile,". Path to inputfiles directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}else{
			x		<- read.table(bayescanfile) 
			bayescan_data	<<- x
			}
		if(nrow(x)!=nrow(y))
			{
			cat(paste("ERROR: Number of rows in '",mapfile,"' file does not correspond with number of rows in '",bayescanfile,"'.",sep=""),sep="\n") 
			cat("From which PED and MAP file did you convert your data to the Bayescan input file?",sep="\n") 
			return(cat("Store the MAP file in the inputfiles directory, and rerun the getbayescan function by full name of the MAP file to the 'inputmapfile'.",sep="\n"))
			}
		x$name			<- myloci
		x$bayescanout	<- x$qval<FDR
		noutliers		<- length(which(x$bayescanout))
		if(dolog10)
			{
			x$bayescanlogp	<- -log10(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log10(x$qval)
			}else{
			x$bayescanlogp	<- -log(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log(x$qval)
			}
		# add to snps dataframe:
		if(!use_merge|!is.null(inputmapfile))
			{
			# Not using merge (i.e. this for loop) returns NA values for non-outliers for bayescanlogq, so not an option really.
			#outtemp2			<- x[x$bayescanout,c("name","bayescanout","bayescanlogq")]		
			outtemp2			<- x[,c("name","bayescanout","bayescanlogq","bayescanlogp","log10.PO.")]	
			snps$bayescanout	<<- FALSE
			snps$bayescanlogq	<<- NA
			snps$bayescanlogp	<<- NA
			snps$bayescanlogBF	<<- NA
			for(j in 1:nrow(outtemp2))
				{
				mylocus	<- as.vector(outtemp2$name[j])
				myout	<- as.vector(outtemp2$bayescanout[j])
				mylogq	<- as.vector(outtemp2$bayescanlogq[j])
				mylogp	<- as.vector(outtemp2$bayescanlogp[j])
				mylogBF	<- as.vector(outtemp2$log10.PO.[j])
				#cat(mylocus,sep="\n")
				#snps$bayescanout[snps$name==mylocus]	<<- TRUE
				snps$bayescanout[snps$name==mylocus]	<<- myout
				snps$bayescanlogq[snps$name==mylocus]	<<- mylogq
				snps$bayescanlogp[snps$name==mylocus]	<<- mylogp
				snps$bayescanlogBF[snps$name==mylocus]	<<- mylogBF
				}
			}else{
			# Rather than for loop, we could also use merge function, which is faster:
			if(!is.null(snps$bayescanout))
				{
				snps$bayescanout	<<- NULL
				}
			if(!is.null(snps$bayescanlogq))
				{
				snps$bayescanlogq	<<- NULL
				}
			if(!is.null(snps$bayescanlogp))
				{
				snps$bayescanlogp	<<- NULL
				}
			if(!is.null(snps$bayescanlogBF))
				{
				snps$bayescanlogBF	<<- NULL
				}
			outtemp2	<- x[,c("name","alpha","bayescanout","bayescanlogq","bayescanlogp","log10.PO.")]
			names(outtemp2)[which(names(outtemp2)=="alpha")]	<- "bayescanalpha"
			names(outtemp2)[which(names(outtemp2)=="log10.PO.")]<- "bayescanlogBF"
			outtemp3 	<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
			outtemp4	<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
			outtemp4$bayescanout[is.na(outtemp4$bayescanout)]	<- FALSE
			if(length(colnames(as.matrix(mygenlight)))!=length(outtemp4$genlightname))
				{
				return(cat("ERROR: Number of columns of genlight object does not correspond with number of rows bayescan file.",sep="\n"))
				}
			if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
				{	
				outtemp3	<<- outtemp3
				outtemp4	<<- outtemp4
				return(cat("ERROR: after reordering column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}	
			snps		<<- outtemp4
			}
		# export pdf:
		setwd(mysambar$selectiondir)
		if(!silent){cat("Plotting Bayescan qvalue plot...",sep="\n")}
		if(!is.null(export))
			{
			plotname	<- paste("Bayescanplot",my_dataset,"FDR",FDR,sep="_")
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
			}
		par(cex.lab=2,cex.axis=2)
		my_qmax		<- ifelse(is.null(my_qmax),4,my_qmax)
		my_fstmax	<- ifelse(is.null(my_fstmax),0.4,my_fstmax)
		my_qmin		<- ifelse(min(-log10(x$qval))>=0,0,min(-log10(x$qval)))
		plot(-log10(x$qval),x$fst,xlab="-log10(qvalue)",ylab="",pch=16,xlim=c(my_qmin,my_qmax),ylim=c(0,my_fstmax))
		points(-log10(x$qval)[x$qval<FDR],x$fst[x$qval<FDR],col="red",pch=16)
		abline(v=-log10(FDR),lty=2)	
		mtext(side=2,"Fst",cex=2,line=2.5)
		mtext(side=3,my_dataset,cex=2,line=0.5)
		legend("topleft",lty=2,legend=paste("FDR = ",FDR),bty='n',cex=2)
		if(!is.null(export)){dev.off()}
		#
		if(!is.null(export))
			{
			plotname	<- paste("Bayescanplot2",my_dataset,"FDR",FDR,sep="_")
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
			}
		par(cex.lab=2,cex.axis=2)
		plot(x$alpha,-log10(x$qval),xlab="alpha",ylab="",pch=16)
		points(x$alpha[x$qval<FDR],-log10(x$qval)[x$qval<FDR],col="red",pch=16)
		abline(h=-log10(FDR),lty=2)	
		mtext(side=2,"-log10(qvalue)",cex=2,line=2.5)
		mtext(side=3,my_dataset,cex=2,line=0.5)
		legend("topleft",lty=2,legend=paste("FDR = ",FDR),bty='n',cex=2)
		if(!is.null(export)){dev.off()}
		#
		if(!silent){cat("Plotting Bayescan qvalue plot with various threshold...",sep="\n")}
		if(!is.null(export))
			{
			plotname	<- paste("Bayescanplot2_multiFDR",my_dataset,sep="_")
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
			}
		par(cex.lab=2,cex.axis=2)
		plot(x$alpha,-log10(x$qval),xlab="alpha",ylab="",pch=16,ylim=c(my_qmin,my_qmax))
		points(x$alpha[x$qval<0.05],-log10(x$qval)[x$qval<0.05],col="grey",pch=16)
		points(x$alpha[x$qval<0.02],-log10(x$qval)[x$qval<0.02],col="darksalmon",pch=16)
		points(x$alpha[x$qval<0.01],-log10(x$qval)[x$qval<0.01],col="red",pch=16)
		abline(h=-log10(0.01),lty=3)	
		abline(h=-log10(0.02),lty=2)
		abline(h=-log10(0.05),lty=1)
		mtext(side=2,"-log10(qvalue)",cex=2,line=2.5)
		mtext(side=3,my_dataset,cex=2,line=0.5)
		legend("topleft",lty=c(3,2,1),legend=c("FDR = 0.01","FDR = 0.02","FDR = 0.05"),bty='n',cex=2)
		if(!is.null(export)){dev.off()}
		#	
		# rename:
		tempname	<- paste("bayescanout",my_dataset,sep="_")
		tempname2	<- paste("bayescanlogq",my_dataset,sep="_")
		tempname3	<- paste("bayescanalpha",my_dataset,sep="_")
		tempname4	<- paste("bayescanlogp",my_dataset,sep="_")
		tempname5	<- paste("bayescanlogBF",my_dataset,sep="_")
		names(snps)[names(snps) == "bayescanout"] 	<<- tempname
		names(snps)[names(snps) == "bayescanlogq"] 	<<- tempname2
		names(snps)[names(snps) == "bayescanalpha"] <<- tempname3
		names(snps)[names(snps) == "bayescanlogp"] 	<<- tempname4
		names(snps)[names(snps) == "bayescanlogBF"] <<- tempname5
		snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		cat("Columns 'bayescanout_dataset','bayescanlogq_dataset', 'bayescanlogp_dataset', 'bayescanlogBF_dataset' and 'bayescanalpha_dataset' have been added to the snps dataframe.",sep="\n")
		if(!is.null(export))
			{
			cat("Plots have been exported to the selection directory.",sep="\n")
			}
		}
	cat(paste("A FDR of ",FDR," results in ",noutliers," outliers.",sep=""),sep="\n",spec_min=0.999)
	}

# 15-11-2019: currently applicable to reindeer dataset only		
exp_nout<-function(export="pdf",bayescanfile=NULL,nloci=60000,nsel=1000,comp_nr=3,spec_min=0.9995,my_datasets=c("Barff_Norway","Busen_Norway","pheno"),bayescanFDR=0.01)
	{
	mytestscores	<- mysambarsim$mytestscores				
	mytestscores2	<- mysambarsim$mytestscores2
	if(!exists("snps"))
		{
		return(cat("ERROR: no SNPs dataframe.",sep="\n"))
		}
	if(!"Barff"%in%mysambar$population2)
		{
		return()
		}
	# testspec		<- c(0.9998,0.99995,1,0.9996)	# Bayescan, GWDS, OutFLANK, PCadapt
	# Barff_Norway	<- c(0,7,0,35)					
	# Busen_Norway	<- c(12,0,0,16)
	# pheno			<- c(13,3,0,25)
	# Barff_Norway	<- c(6,5,0,13)
	# Busen_Norway	<- c(0,2,0,41)
	# pheno			<- c(10,3,0,15)
	# points(testspec*100,Barff_Norway,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	# points(testspec*100,Busen_Norway,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	# points(testspec*100,pheno,col=c("red","blue","orange","darkgreen"),pch=16,cex=2)
	#
	#
	cat("Extracting from SNPs dataset number of observed outliers per selection scan...",sep="\n")
	ndatasets			<- length(my_datasets)
	mymatrix			<- matrix(NA,ncol=ifelse(!is.null(bayescanfile),4,3),nrow=ndatasets) 
	rownames(mymatrix)	<- my_datasets
	if(!is.null(bayescanfile))
		{
		colnames(mymatrix)		<- c("GWDS","OutFLANK","PCadapt","Bayescan")
		mycols					<- c("blue","orange","darkgreen","darkred")
		}else{
		colnames(mymatrix)		<- c("GWDS","OutFLANK","PCadapt")
		mycols					<- c("blue","orange","darkgreen")
		}
	for (k in c(1:ndatasets))
		{
		my_dataset	<- my_datasets[k]
		cat(paste("Dataset: ",my_dataset,".",sep=""),sep="\n")
		snpcolnames				<- names(snps)
		# GWDS:
		mycolumn				<- paste("rfisherout",my_dataset,sep="_")
		if(mycolumn%in%snpcolnames)		
			{
			outfilter			<- snps[,mycolumn]
			mymatrix[k,1]		<- nrow(snps[outfilter&snps$filter2,])
			}else{
			return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan GWDS.",sep="\n"))  
			}
		# OutFLANK:
		mycolumn				<- paste("OutFLANK",my_dataset,sep="_")
		if(mycolumn%in%snpcolnames)		
			{
			outfilter			<- snps[,mycolumn]
			mymatrix[k,2]		<- nrow(snps[outfilter&snps$filter2,])
			}else{
			return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan OutFLANK.",sep="\n"))  
			}
		# PCadapt:
		mycolumn				<- paste("PCadaptout",my_dataset,sep="_")
		if(mycolumn%in%snpcolnames)		
			{
			outfilter			<- snps[,mycolumn]
			mymatrix[k,3]		<- nrow(snps[outfilter&snps$filter2,])
			}else{
			return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan PCadapt.",sep="\n"))  
			}
		if(!is.null(bayescanfile))
			{
			# bayescan:
			mycolumn			<- paste("bayescanout",my_dataset,sep="_")
			if(mycolumn%in%snpcolnames)		
				{
				outfilter		<- snps[,mycolumn]
				mymatrix[k,4]	<- nrow(snps[outfilter&snps$filter2,])
				}else{
				return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan Bayescan.",sep="\n"))  
				}
			}
	 	}
	#
	cat("Extracting specificity of selection scans from simulation output...",sep="\n")
	if(is.null(bayescanfile))
		{
		cat("Not including Bayescan.",sep="\n")
		testspec		<- c(mytestscores2$gwds_specificity[3],mytestscores2$OutFLANK_specificity[3],mytestscores2$PCadapt_specificity[3])
		}else{
		cat("Including Bayescan output...",sep="\n")
		getbayescansim(bayescanfile=bayescanfile,FDR=bayescanFDR)
		cat(paste("Specified number of SNPs: ",nloci,".",sep=""),sep="\n")
		cat(paste("Specified number of adaptive SNPs: ",nsel,".",sep=""),sep="\n")
		neutralnr		<- nloci-nsel
		retainednr		<- round(neutralnr*mytestscores$retained_neutral[3])
		bayescanspec	<- 1-length(which(simbayescan$bayescanout[1:neutralnr]))/retainednr
		testspec		<- c(mytestscores2$gwds_specificity[comp_nr],mytestscores2$OutFLANK_specificity[comp_nr],mytestscores2$PCadapt_specificity[comp_nr],bayescanspec)
		}
	#
	mymatrix	<<- mymatrix
	mytestspec	<<- testspec
	#
	# outline of plot:
	nloci	<- nrow(snps[snps$filter2,])
	spec_min<- ifelse(spec_min<min(testspec),spec_min,min(testspec)-0.0002)
	spec	<- seq(1,spec_min,-0.0001)			# specificity
	nout	<- (1-spec)*nloci					# number of outliers
	#
	cat("Plotting number of observed outliers per selection scan (in empirical SNP dataset) against specificity of selection scan (estimate based on simulations).",sep="\n") 
	setwd(mysambar$selectiondir)
	if(!is.null(export))
		{
		plotname		<- ifelse(is.null(bayescanfile),"Expected_falsepositives","Expected_falsepositives_withbayescan")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=8,width=8)}
		}
	par(mar=c(5,5.5,3,1.5))
	plot(spec*100,nout,type='l',lwd=1.5,xlab="",ylab="",cex.axis=2,las=1)
	mypch	<- ifelse(rownames(mymatrix)=="pheno",16,1)
	for (k in c(1:ncol(mymatrix)))
		{
		mycol	<- mycols[k]
		points(rep(testspec[k]*100,nrow(mymatrix)),mymatrix[,k],col=mycol,pch=mypch,cex=3)
		}
	mtext(side=1,"Specificity (%)",cex=2.5,line=3)
	mtext(side=2,"Number of outlier SNPs",cex=2.5,line=3.5)
	mtext(side=3,paste(nloci,"SNPs",sep=" "),line=0.5,cex=2.5)
	if(!is.null(bayescanfile))
		{
		legend("topright",legend=c("Bayescan","GWDS","OutFLANK","PCadapt"),fill=c("darkred","blue","orange","darkgreen"),bty='n',cex=2.5)
		}else{
		legend("topright",legend=c("GWDS","OutFLANK","PCadapt"),fill=c("blue","orange","darkgreen"),bty='n',cex=2.5)
		}
	legend("right",legend=c("pooled","pairwise"),pch=c(16,1),bty='n',cex=2.5)
	if(!is.null(export))
		{
		dev.off()
		cat("Plot called 'Expected_falsepositives.pdf' has been written to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 15-11-2019: currently applicable to reindeer dataset only	
multioverlap_approach_old<-function(doexport=NULL,add_numbers=FALSE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Overlap.approaches.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpoverlap_approach(mycomparison=1,mylog="",addnumbers=add_numbers)
	plotpoverlap_approach(mycomparison=2,mylog="",addnumbers=add_numbers)
	plotpoverlap_approach(mycomparison=3,mylog="",addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}		

multioverlap_approach<-function(doexport=NULL,popnames=mysambar$populations,pmax=11,pheno_label=NULL,silent=TRUE)
	{
	mycomparisonslog<- colnames(snps)[grep("rfisherGWDSlogp_",colnames(snps))]
	if(length(mycomparisonslog)<2)
		{
		return(cat("Only 1 comparison detected in snps dataframe. Omitting 'Overlap_between_comparisons' plot.",sep="\n")) 
		}
	mycomparisons	<- gsub("rfisherGWDSlogp_","",mycomparisonslog)
	combitable		<- combn(mycomparisons,m=2)
	ncombi			<- ncol(combitable)
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plotname	<- "Overlap_between_comparisons"
		if(doexport=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=ncombi*4,height=4)}
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=ncombi*4,height=4)}
		if(doexport=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=ncombi*400,height=400)}
		if(doexport=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=ncombi*4,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	for(combinr in c(1:ncombi))
		{
		mypair		<- paste(combitable[1,combinr]," vs ",combitable[2,combinr],sep="")
		if(!silent){cat(mypair,sep="\n")}
		mypair		<- paste(combitable[1,combinr],combitable[2,combinr],sep=",")
		myapproach1	<- combitable[1,combinr]
		myapproach2	<- combitable[2,combinr]
		plotpoverlap_approach(approach1=myapproach1,approach2=myapproach2,phenolabel=pheno_label)
		}
	if(!is.null(doexport)){dev.off()}
	}

plotpoverlap_approach<-function(approach1=NULL,approach2=NULL,mycex=1,pmax=11,phenolabel=NULL)
	{
	if(is.null(approach1)|is.null(approach2))
		{
		return(cat("ERROR: provide input string (either 'pheno' or name of pairwise comparison) to approach1 and approach2 flags.",sep="\n"))    
		}
	mylog1		<- snps[snps$filter2,paste("rfisherGWDSlogp",approach1,sep="_")]
	mylog2		<- snps[snps$filter2,paste("rfisherGWDSlogp",approach2,sep="_")]
	myout1		<- snps[snps$filter2,paste("rfisherout",approach1,sep="_")]
	myout2		<- snps[snps$filter2,paste("rfisherout",approach2,sep="_")]
	#
	mybonf		<- -log10(0.05/nrow(snps[snps$filter2,]))
	mylim		<- c(0,pmax)
	#
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=mylim,ylim=mylim,col="grey50",las=1)
	points(mylog1[myout1|myout2],mylog2[myout1|myout2],cex=mycex,col="orange",pch=16)
	if("rfisherout_pheno"%in%colnames(snps))
		{
		outpheno	<- snps$rfisherout_pheno[snps$filter2]
		points(mylog1[outpheno],mylog2[outpheno],cex=mycex,col="red",pch=16)
		}
	mylabel1	<- ifelse(approach1=="pheno"&!is.null(phenolabel),phenolabel,approach1)
	mylabel2	<- ifelse(approach2=="pheno"&!is.null(phenolabel),phenolabel,approach2)
	mtext(mylabel1,side=1,cex=1.5,line=3)
	mtext(mylabel2,side=2,cex=1.5,line=3)
	abline(v=mybonf,lty=2)
	abline(h=mybonf,lty=2)
	}

# 15-11-2019: currently applicable to reindeer dataset only	
plotpoverlap_approach_old<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE,pmax=11)
	{
	mybonf		<- -log10(0.05/nrow(snps[snps$filter,]))
	mylim		<- c(0,pmax)
	if(mycomparison==1)
		{
		mylog1	<- snps$rfisherGWDSlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "Founder vs Source"
		mylog2	<- snps$rfisherGWDSlogp_Busen_Norway
		myout2	<- snps$rfisherout_Busen_Norway
		mytest2	<- "Busen vs Norway"
		}
	if(mycomparison==2)
		{
		mylog1	<- snps$rfisherGWDSlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "Founder vs Source"
		mylog2	<- snps$rfisherGWDSlogp_Barff_Norway
		myout2	<- snps$rfisherout_Barff_Norway
		mytest2	<- "Barff vs Norway"
		}
	if(mycomparison==3)
		{
		mylog1	<- snps$rfisherGWDSlogp_Busen_Norway
		myout1	<- snps$rfisherout_Busen_Norway
		mytest1	<- "Busen vs Norway"
		mylog2	<- snps$rfisherGWDSlogp_Barff_Norway
		myout2	<- snps$rfisherout_Barff_Norway
		mytest2	<- "Barff vs Norway"
		}
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',xlim=mylim,ylim=mylim)
	points(mylog1[snps$rfisherout_pheno],mylog2[snps$rfisherout_pheno],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	#mymin1	<- min(mylog1[myout1])
	#mymin2	<- min(mylog2[myout2])
	abline(v=mybonf,lty=2)
	abline(h=mybonf,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- 0
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- nrow(snps)-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
			if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

multiplotp<-function(doexport=NULL,add_numbers=FALSE,my_dataset="pheno",silent=TRUE,no_outflank=FALSE,mytests=NULL,logpmax=11,n_sample=NULL)
	{
	logp 			<- snps[,grep(paste("logp",my_dataset,sep="_"),colnames(snps))]
	# 28-08-2020: the following lines are not needed anymore after I added some commands to the getbayescan function which include bayescan p-values to snps dataframe (rather than q-values only)
	#if(!paste("bayescanlogp",my_dataset,sep="_")%in%colnames(snps))
	#	{
	#	if(paste("bayescanlogq",my_dataset,sep="_")%in%colnames(snps))
	#		{
	#		if(!silent){cat("Renaming within SNPs dataframe Bayescan q-value to Bayescan p-value.",sep="\n")}
	#		logp$Bayescan		<- snps[,grep(paste("bayescanlogq",my_dataset,sep="_"),colnames(snps))]
	#		snps$Bayescantemp	<<- logp$Bayescan
	#		colnames(logp)[colnames(logp)=="Bayescan"]		<- paste("bayescanlogp",my_dataset,sep="_")
	#		colnames(snps)[colnames(snps)=="Bayescantemp"]	<<- paste("bayescanlogp",my_dataset,sep="_")
	#		snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	#		}else{
	#		cat("Bayescan q-values not present.",sep="\n")
	#		}
	#	if(!silent){cat("Renamed column with Bayescan q-values already present.",sep="\n")}
	#	}
	if(is.null(dim(logp)))
		{
		return(cat("Executed one selection scan (not multiple selection scans). Skipping 2D plots.",sep="\n"))
		}
	logp		<- logp[,order(colnames(logp))]
	if(!silent){mylogp	<<- logp}
	if(is.null(mytests))
		{
		mytests		<- colnames(logp)
		mytests		<- gsub(paste("logp",my_dataset,sep="_"),"",mytests)
		if(no_outflank)
			{
			mytests	<- mytests[mytests!="OutFLANK"] 
			}
		}
	combitable	<- combn(mytests,m=2)
	# easier to compare if PCadapt is on y-axis and GWDS on x-axis:
	compnr		<- which(combitable[1,]=="PCadapt"&combitable[2,]=="rfisherGWDS")
	if(length(compnr)==1)
		{
		combitable[1,compnr]	<- "rfisherGWDS"
		combitable[2,compnr]	<- "PCadapt"
		}
	ncombi		<- ncol(combitable)
	if(is.null(logpmax))
		{
		logpmax		<- max(logp,na.rm=TRUE)
		}
	if(!silent){cat(paste("Y-axis limit: ",logpmax,sep=""),sep="\n")}
	if(!is.null(doexport))
		{
		plotname<-paste("Selectionscan.logpvalues.2D",my_dataset,sep=".")
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=ncombi*4+1,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	for(j in c(1:ncombi))
		{
		test_1	<- combitable[1,j]
		test_2	<- combitable[2,j]
		if(!silent){cat(paste(test_1," vs ",test_2,sep=""),sep="\n")}
		plotpvalues(test1=test_1,test2=test_2,mydataset=my_dataset,mycex=1,addnumbers=FALSE,pmax=logpmax,nsample=n_sample)
		}
	if(!is.null(doexport))
		{
		dev.off()
		cat(paste("A file called '",plotname,"' has been written to the directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		}
	}	
	
plotpvalues<-function(export=NULL,test1="OutFLANK",test2="rfisherGWDS",mydataset=NULL,mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL,nsample=NULL)
	{
	if(is.null(mydataset))
		{
		return(cat("ERROR: Please provide input to the mydataset flag (i.e. pop1_pop2 or pheno).",sep="\n"))
		}
	# Note: displayed thresholds are either Bonferroni corrected thresholds, or or Bayes factor of 50 (10^1.7) in the case of Bayescan.
	# This are not necessarily the thresholds used when running the selection scans.
	# Also note that Bayescan p-values are different Bayesian posterior probabilities, and can not be directly compared to the frequentist p-values of the other tests, which display probabilities that SNPs are drawn from the null distribution. 
	test1string	<- paste(paste(test1,"logp",sep=""),mydataset,sep="_")
	if(!test1string%in%colnames(snps))
		{
		return(cat(paste("ERROR: scores for ",test1," not present in SNPs dataframe.",sep=""),sep="\n"))
		}else{
		mylog1	<- snps[,paste(paste(test1,"logp",sep=""),mydataset,sep="_")]
		}
	if(test1=="OutFLANK")
		{
		myout1	<- snps[,paste(test1,mydataset,sep="_")]
		}else{
		if(test1=="rfisherGWDS")
			{
			myout1	<- snps[,paste(paste("rfisher","out",sep=""),mydataset,sep="_")]
			}else{
			myout1	<- snps[,paste(paste(test1,"out",sep=""),mydataset,sep="_")]
			}
		}
	mytest1	<- ifelse(test1=="rfisherGWDS","GWDS",test1)
	#
	test2string	<- paste(paste(test2,"logp",sep=""),mydataset,sep="_")
	if(!test1string%in%colnames(snps))
		{
		return(cat(paste("ERROR: scores for ",test2," not present in SNPs dataframe.",sep=""),sep="\n"))
		}else{
		mylog2	<- snps[,paste(paste(test2,"logp",sep=""),mydataset,sep="_")]
		}
	if(test2=="OutFLANK")
		{
		myout2	<- snps[,paste(test2,mydataset,sep="_")]
		}else{
		if(test2=="rfisherGWDS")
			{
			myout2	<- snps[,paste(paste("rfisher","out",sep=""),mydataset,sep="_")]
			}else{
			myout2	<- snps[,paste(paste(test2,"out",sep=""),mydataset,sep="_")]
			}
		}
	mytest2	<- ifelse(test2=="rfisherGWDS","GWDS",test2)
	#
	if(test1=="bayescan")
		{
		mymin1	<- 1.7	# arbitrary: 10^1.7 = 50x more likely
		}else{
		mymin1	<- -log10(0.05/nrow(snps[snps$filter2,]))
		}
	if(test2=="bayescan")
		{
		mymin1	<- 1.7	# arbitrary: 10^1.7 = 50x more likely
		}else{
		mymin2	<- -log10(0.05/nrow(snps[snps$filter2,]))
		}
	if(is.null(pmax))
		{
		pmax1	<- max(c(mylog1[is.finite(mylog1)&!is.na(mylog1)],mylog2[is.finite(mylog2)&!is.na(mylog2)]))
		pmax2	<- 1.1*-log10(0.05/nrow(snps[snps$filter2,]))
		pmax	<- ifelse(pmax1<pmax2,pmax2,pmax1)
		}
	if(!silent)
		{
		mylog1temp	<<- mylog1
		mylog2temp	<<- mylog2
		pmaxtemp	<<- pmax
		}
	if(!is.null(export))
		{
		plotname<-paste("Selectionscan.logpvalues.2D",mydataset,mytest1,mytest2,sep=".")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=4,width=4)}
		par(mar=c(1,1,1,1),oma=c(2.5,2.5,0,0))
		}
	if(!is.null(nsample))
		{
		sampleset	<- sample(c(1:length(mylog1)),nsample)
		plot(mylog1[sampleset],mylog2[sampleset],pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		}else{
		plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		}
	points(mylog1[myout1],mylog2[myout1],cex=mycex,col="red",pch=16)
	points(mylog1[myout2],mylog2[myout2],cex=mycex,col="red",pch=16)
	myxline	<- ifelse(!is.null(export),2.5,3.5)
	myyline	<- ifelse(!is.null(export),2,3.5)
	mtext(mytest1,side=1,cex=1.5,line=myxline)
	mtext(mytest2,side=2,cex=1.5,line=myyline)
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		cat("Adding numbers...",sep="\n")
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	if(!is.null(export)){dev.off()}
	}	

# depreciated on 14-11-2019:	
multiplotp_old<-function(doexport=NULL,add_numbers=TRUE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Testlogvalues.2D.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpvalues_old(mycomparison=1,mylog="",addnumbers=add_numbers)
	plotpvalues_old(mycomparison=2,mylog="y",addnumbers=add_numbers)
	plotpvalues_old(mycomparison=3,mylog="y",addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}
	
# depreciated on 14-11-2019:	
plotpvalues_old<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE)
	{
	if(mycomparison==1)
		{
		mylog1	<- snps$rfisherlog_p_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "GWDS"
		myxlim	<- c(0,100)
		mylog2	<- snps$bayescanlogq_pheno
		myout2	<- snps$bayescanout_pheno
		mytest2	<- "Bayescan"
		myylim	<- c(0,10) 
		}
	if(mycomparison==2)
		{
		mylog1	<- snps$rfisherlog_p_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "GWDS"
		myxlim	<- c(0,100)
		mylog2	<- -log10(p.adjust(10^-snps$PCadaptlogp_pheno,method="bonf"))
		#mylog2	<- -log(p.adjust(10^-snps$PCadaptlogp_pheno,method="holm"))
		myout2	<- snps$PCadaptout_pheno
		mytest2	<- "PCadapt"
		myylim	<- c(0.01,100)
		}
	if(mycomparison==3)
		{
		mylog1	<- snps$bayescanlogq_pheno
		myout1	<- snps$bayescanout_pheno
		mytest1	<- "Bayescan"
		myxlim	<- c(0,10)
		mylog2	<- -log10(p.adjust(10^-snps$PCadaptlogp_pheno,method="bonf"))
		#mylog2	<- -log(p.adjust(10^-snps$PCadaptlogp_pheno,method="holm"))
		myout2	<- snps$PCadaptout_pheno
		mytest2	<- "PCadapt"
		myylim	<- c(0.01,100)
		}
	mylog1[mylog1<0.01]	<- 0.01
	mylog2[mylog2<0.01]	<- 0.01
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',ylim=myylim,xlim=myxlim)
	points(mylog1[snps$rfisherout_pheno],mylog2[snps$rfisherout_pheno],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	if(mycomparison==1|mycomparison==2)
		{
		mymin1	<- 44
		}else{
		mymin1	<- min(mylog1[myout1])
		}
	mymin2	<- min(mylog2[myout2])
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

plot_venn<-function(my_dataset="pheno1_pheno2",export=TRUE,mysmall=1,silent=TRUE)
	{
	if(!silent){cat(my_dataset,sep="\n")}
	snpcolnames		<- names(snps)
	# GWDS:
	mycolumn		<- paste("rfisherout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		gwdsout		<- snps$name[outfilter]
		if(any(is.na(gwdsout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		gwdsout		<- snps$name[FALSE]
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		pcadaptout	<- snps$name[outfilter]	
		if(any(is.na(pcadaptout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		pcadaptout	<- snps$name[FALSE]
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		outflankout	<- snps$name[outfilter]
		if(any(is.na(outflankout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		outflankout	<- snps$name[FALSE]
		}
	# bayescan:
	mycolumn		<- paste("bayescanout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		bayescanout	<- snps$name[outfilter]
		if(any(is.na(bayescanout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		bayescanout	<- snps$name[FALSE]
		}
	# Fsthet:
	mycolumn		<- paste("fsthetout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		fsthetout	<- snps$name[outfilter]
		if(any(is.na(fsthetout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		fsthetout	<- snps$name[FALSE]
		}
	# plot:
	if(length(bayescanout)>1|length(gwdsout)>1|length(pcadaptout)>1|length(outflankout)>1|length(fsthetout)>1)
		{
		if(export){pdf(paste("venn",my_dataset,"pdf",sep="."),height=6,width=8)}
		baye		<- paste("bayescanout",my_dataset,sep="_")
		fsthet		<- paste("fsthetout",my_dataset,sep="_")
		outfla		<- paste("OutFLANK",my_dataset,sep="_")
		pcout		<- paste("PCadaptout",my_dataset,sep="_")
		if(pcout%in%snpcolnames)
			{
			if(outfla%in%snpcolnames)
				{
				if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","orange","darkorchid4"),col=c("darkred","blue","darkgreen","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","orange","darkorchid4"),col=c("darkred","darkgreen","orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","orange"),col=c("darkred","blue","darkgreen","orange"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","orange"),col=c("darkred","darkgreen","orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","orange","darkorchid4"),col=c("blue","darkgreen","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","orange","darkorchid4"),col=c("darkgreen","orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","orange"),col=c("blue","darkgreen","orange"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","orange"),col=c("darkgreen","orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}else{	# IF NOT OUTFLANK
						if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","darkorchid4"),col=c("darkred","blue","darkgreen","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","darkorchid4"),col=c("darkred","darkgreen","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen"),col=c("darkred","blue","darkgreen"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen"),col=c("darkred","darkgreen"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","darkorchid4"),col=c("blue","darkgreen","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","darkorchid4"),col=c("darkgreen","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen"),col=c("blue","darkgreen"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen"),col=c("darkgreen"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}
			}else{ 	# IF NOT PCADAPT
			if(outfla%in%snpcolnames)
				{
				if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","orange","darkorchid4"),col=c("darkred","blue","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","orange","darkorchid4"),col=c("darkred","orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","orange"),col=c("darkred","blue","orange"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","orange"),col=c("darkred","orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","orange","darkorchid4"),col=c("blue","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("orange","darkorchid4"),col=c("orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","orange"),col=c("blue","orange"),margin=0.1)
						}else{
						# this will lead to errors:
						v1 <- venn.diagram(list(OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("orange"),col=c("orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}else{	# IF NOT OUTFLANK
						if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkorchid4"),col=c("darkred","blue","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkorchid4"),col=c("darkred","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue"),col=c("darkred","blue"),margin=0.1)
						}else{
						# this will lead to errors:
						v1 <- venn.diagram(list(Bayescan=bayescanout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred"),col=c("darkred"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkorchid4"),col=c("blue","darkorchid4"),margin=0.1)
						}else{
						# This will lead to errors:
						v1 <- venn.diagram(list(fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkorchid4"),col=c("darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						# This will lead to errors:
						v1 <- venn.diagram(list(GWDS=gwdsout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue"),col=c("blue"),margin=0.1)
						#}else{
						#v1 <- venn.diagram(list(PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen"),col=c("darkgreen"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}
			}
		if(export){dev.off()}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		}else{
		cat("No outliers. Skipping Venn diagram.",sep="\n")
		}
	}

# Create input for bayenv:
makebayenvinput<-function(popnames=mysambar$populations,type=FALSE)
	{
	# execute analysis:
	if(type)
		{
		if(length(popnames)!=length(unique(inds$type3)))
			{
			cat("Length of popnames does not correspond to expected number of population names")
			}
		}
	bayenvinput			<<- matrix(ncol=(length(popnames)),nrow=2*nrow(snps[snps$filter&snps$minorcount>0,]))
	for (i in (1:length(popnames)))
		{
		if(type)
			{
			tempgenlight<- mygenlight[inds$filter&inds$type3==popnames[i],snps$filter&snps$minorcount>0]
			}else{
			tempgenlight<- mygenlight[inds$filter&inds$pop==popnames[i],snps$filter&snps$minorcount>0]
			}
		misscount		<- glNA(tempgenlight,alleleAsUnit=FALSE)
		nonmissallelecount 	<- 2*(nInd(tempgenlight)-misscount)
		minorcount		<- as.vector(glSum(tempgenlight))
		majorcount		<- nonmissallelecount-minorcount	
		z 			<- c(rbind(minorcount,majorcount))
		bayenvinput[,i]		<<- z 
		colnames(bayenvinput)	<<- popnames
		}
	# Export:
	write.table(bayenvinput,"Bayenvinput.metapop.txt",col.names=FALSE,row.names=FALSE,sep="\t")
	}	
	
# depends on function windowfst()
peakvalley<-function(myxby=5,my_lwd=2,mychrom=25,myregion=NULL,mywidth=20,add_legend=TRUE,export=FALSE,excludeoutliers=FALSE)
	{
	# myregion is vector which start and end in kB
	mypositions	<- snps$pos[snps$rfisherout_pheno]/1000000
	setwd(mysambar$selectiondir)
	if(export&excludeoutliers){pdf(paste("Peakvalley",(paste("chrom",mychrom,sep="")),(paste(mywidth,"snpsperwindow.excludingoutliers",sep="")),"pdf",sep="."),width=12,height=7)}
	if(export&(!excludeoutliers)){pdf(paste("Peakvalley",(paste("chrom",mychrom,sep="")),(paste(mywidth,"snpsperwindow.withoutliers",sep="")),"pdf",sep="."),width=12,height=7)}
	par(mfrow=c(2,1),mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,4,2),cex.axis=1.5)
	if(excludeoutliers)
		{
		mysnpselection	<- snps$filter2&(!snps$rfisherout_pheno)
		}else{
		mysnpselection	<- snps$filter2
		}
	windowfst(chrom=mychrom,width=mywidth,snpselection=mysnpselection,addlegend=add_legend,xrange=c(0,40000000),selectcombi=c(2,3),yrange=c(0,0.25),xby=myxby,xaxislabels=FALSE,addchrom=FALSE,mylwd=my_lwd,region=myregion)	
	abline(v=mypositions,lty=2)
	windowfst(chrom=mychrom,width=mywidth,snpselection=mysnpselection,addlegend=add_legend,xrange=c(0,40000000),selectcombi=1,yrange=c(0,0.3),xby=myxby,addchrom=FALSE,mylwd=my_lwd,region=myregion)
	abline(v=mypositions,lty=2)
	mtext("Position along chromosome (Mb)",side=1,line=2.5,outer=TRUE,cex=2)
	mtext("WC Fst",side=2,line=1.25,outer=TRUE,cex=2)
	mtext(paste("Chromosome",mychrom,sep=" "),side=3,line=0.5,outer=TRUE,cex=2)
	if(export){dev.off()}
	setwd(mysambar$inputdatadir)
	}

# plot location of genes on scaffold/contig/chromosome:	
multiplotscaffold<-function(my_bed=NULL,doexport=FALSE,background_pop=NULL,x_range=NULL,y_loc=c(0.4,0.65))
	{
	if(is.null(my_bed))
		{
		return(cat("Input file to my_bed argument is missing.",sep="\n"))
		}
	mygenes				<- read.table(my_bed,header=FALSE)
	colnames(mygenes)	<- c("chr","startbp","endbp","feature")
	mygenes				<<- mygenes
	for(mycontig in mygenes$chr)
		{
		plotscaffold(export=doexport,scaffold=mycontig,backgroundpop=background_pop,mybed=my_bed,xrange=NULL,yloc=y_loc)
		}
	}
	
plotscaffold<-function(export=FALSE,scaffold="scaffold1947_size412474",backgroundpop=NULL,mybed=NULL,popnames=mysambar$populations,xrange=NULL,yloc=c(0.4,0.65))
	{
	setwd(mysambar$selectiondir)
	npop	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npop]
	if(!is.null(backgroundpop))
		{
		otherpops	<- popnames[popnames!=backgroundpop]
		othercols	<- mycols[popnames!=backgroundpop]
		backgroundcol<- mycols[popnames==backgroundpop]
		mycols		<- c(backgroundcol,othercols)
		popnames	<- c(backgroundpop,otherpops)
		}
	plotname<- paste("MAF",scaffold,"pdf",sep=".")
	if(is.null(xrange)){xrange=c(min(snps$pos[snps$chr==scaffold]),max(snps$pos[snps$chr==scaffold]))}
	xrange	<- xrange/1000
	xrange	<<- xrange
	if(export)
		{
		pdf(plotname,width=10,height=5)
		}
	par(mar=c(5,5,1,1))
	for(p in c(1:npop))
		{
		mypop	<- popnames[p]
		mycol	<- mycols[p]
		mypopmaf<- snps[,paste("maf",mypop,sep="_")]
		if(p==1)
			{
			plot(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],type='l',col="white",ylim=c(0,1),xlim=xrange,lwd=1,ylab="MAF",xlab="Position (kb)",pch=16,las=1,cex.axis=1.5,cex.lab=2)
			mycol2<-adjustcolor(mycol,alpha.f = 0.3) 
			polygon(c(snps$pos[snps$chr==scaffold]/1000,rev(snps$pos[snps$chr==scaffold]/1000)),c(rep(0,length(mypopmaf[snps$chr==scaffold])),rev(mypopmaf[snps$chr==scaffold])),col=mycol2,border=NA)
			points(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],col=mycol,pch=16)
			points(snps$pos[snps$chr==scaffold&snps$rfisherout_pheno]/1000,mypopmaf[snps$chr==scaffold&snps$rfisherout_pheno]+0.025,col="black",pch=8,cex=1.25)
			}else{
			points(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],col=mycol,lwd=1.5,pch=16,type='b')
			}
		}
	mtext(side=3,scaffold,line=-1.5,cex=1.5)	
	legend("topright",legend=popnames,fill=mycols,cex=1.5,bty='n')
	if(!is.null(mybed))
		{
		mygenes				<- read.table(mybed,header=FALSE,sep="\t")
		colnames(mygenes)	<- c("chr","startbp","endbp","feature")
		mygenes				<- mygenes[mygenes$chr==scaffold,]
		mygenes$overlap		<- 1000000
		if((nrow(mygenes))>1)
			{
			for(j in c(2:nrow(mygenes))){mygenes$overlap[j]<-mygenes$startbp[j]-mygenes$startbp[j-1]}
			}
		mygenes$overlap2	<-ifelse((abs(mygenes$overlap))<5000,FALSE,TRUE)
		if(any(mygenes$overlap2))
			{
			text(mygenes$feature[mygenes$overlap2],x=mygenes$startbp[mygenes$overlap2]/1000,y=yloc[1],srt=90,adj=0)
			if(any(!mygenes$overlap2))
				{
				text(mygenes$feature[!mygenes$overlap2],x=mygenes$startbp[!mygenes$overlap2]/1000,y=yloc[2],srt=90,adj=0)
				}
			}
		}
	if(export){dev.off()}
	}

	
# End of selection analyses 
###############################################################################################################







###############################################################################################################
# Association analysis

# depends on locusWCfst:
assocfisher<-function(pheno=NULL,my_sign_level=0.05,export=NULL,mylabels=c("control","affected"))
	{
	setwd(mysambar$selectiondir)
	# pheno should be name of column in inds dataframe
	if(is.null(pheno))
		{
		return(cat("ERROR: define input to pheno flag (name of a column in the inds dataframe containing binary division (e.g. TRUE/FALSE, or male/female)).",sep="\n"))
		}
	if(!pheno%in%colnames(inds))
		{
		return(cat("ERROR: input to pheno flag should be the name of a column in the inds dataframe.",sep="\n"))
		}
	mypheno		<- inds[inds$filter,pheno]
	mylevels	<- unique(mypheno[!is.na(mypheno)])
	if(length(mylevels)!=2)
		{
		return(cat("ERROR: pheno should contain 2 levels. Not more, not less.",sep="\n"))
		}
	mypheno2	<- inds[,pheno]
	phenobool	<- ifelse(mypheno2==mylevels[1],TRUE,FALSE)
	ninds1		<- nrow(inds[inds$filter&phenobool,])
	ninds2		<- nrow(inds[inds$filter&(!phenobool),])
	cat(paste("Number of retained individuals group 1: ", ninds1,".",sep=""),sep="\n") 
	cat(paste("Number of retained individuals group 2: ", ninds2,".",sep=""),sep="\n") 
	if(ninds1==0|ninds2==0)
		{
		return(cat("ERROR: Both groups should contain at least one individual.",sep="\n")) 
		}
	#
	cat("Extracting minor allele frequencies...",sep="\n")
	snps$maf_assoc1 	<<- glMean(mygenlight[inds$filter&phenobool,])
	snps$maf_assoc2 	<<- glMean(mygenlight[inds$filter&!phenobool,])
	#
	cat("Calculation locus specific He and Fst...",sep="\n")
	locusWCfst(my_dataset="assoc1_assoc2",mycol="grey",do_plot=TRUE)
	#
	cat("Executing Fisher exact tests...",sep="\n")
	# For phenotype 1:
	indfilter	<- inds$filter&phenobool
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for pheno==TRUE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor1			<- as.vector(glSum(mygenlight[indfilter,]))
	major1			<- nonmisscount-minor1
	# For phenotype 2:
	indfilter		<- inds$filter&!phenobool
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for pheno==FALSE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor2			<- as.vector(glSum(mygenlight[indfilter,]))
	major2			<- nonmisscount-minor2	
	#
	snps$assoclogp		<<-	NULL
	snps$assocout		<<- NULL
	macmatrix			<- rbind(major1,minor1,major2,minor2)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	snps$assoclogp		<<- -log(rfisherp)
	snps$assoclogp[snps$assoclogp<0.0001]	<<- 0	# 10-11-2019: to avoid negative or infinitely small values
	#
	cat("Testing which loci are outliers using Bonferroni correction...",sep="\n")
	# we apply the bonferroni correction and assume that the distribution of the logp values fit an exponential distribution
	mymean				<- mean(snps$assoclogp[snps$filter2])	
	myrate				<- 1/mymean
	mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
	myvalue				<- qexp(mybonf,myrate)
	snps$assocout		<<-	snps$assoclogp>myvalue
	noutliers2			<- nrow(snps[snps$assocout,])
	noutliers			<- nrow(snps[snps$assocout&snps$filter2,])
	cat(paste("Found",noutliers2,"outlier loci, of which",noutliers,"passed filter settings.",sep=" "),sep="\n")
	#
	gwds_pvalues		<- 1-pexp(snps$assoclogp,myrate)
	if(any(gwds_pvalues==0&!is.na(gwds_pvalues))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
	snps$assocGWDSlogp	<<- ifelse(gwds_pvalues==0&!is.na(gwds_pvalues),20,-log10(gwds_pvalues))	# 04-09-2020: if p-values == 0, setting log10(p-value) to 20.
	# rename columns:
	names(snps)[names(snps) == "assoclogp"] 	<<- paste("rfisherlog_p","assoc1","assoc2",sep = "_")
	names(snps)[names(snps) == "assocGWDSlogp"] <<- paste("rfisherGWDSlogp","assoc1","assoc2",sep = "_")
	names(snps)[names(snps) == "assocout"] 		<<- paste("rfisherout","assoc1","assoc2",sep = "_")
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	cat("Creating Fdist plot...",sep="\n")
	Fdist_plot(my_dataset="assoc1_assoc2",showlabels=TRUE,exporttype=export,axislabels=TRUE,add_borders=TRUE,add_outliers=TRUE,y_axis='s',x_axis='s',my_labels=mylabels,dothin=TRUE,silent=TRUE)
	}	

runRDA<-function(export="pdf",legendpos="topleft",envfile="ENVDATAr5noBSCLEAN_MJ.txt",myrepos='http://cran.us.r-project.org',doall=FALSE)
	{
	if("psych" %in% rownames(installed.packages()) == FALSE) {install.packages('psych',repos=myrepos)}
	if("vegan" %in% rownames(installed.packages()) == FALSE) {install.packages('vegan',repos=myrepos)}
	if("vegan"%in%(.packages()) == FALSE) {library(vegan)}
	if("psych"%in%(.packages()) == FALSE) {library(psych)}
	# Set the working directory
	setwd(mysambar$inputdatadir)
	#
	# get imputed dataset:
	if(is.null(mysambar$imputedmatrix))
		{
		sambarimpute()
		}
	if(doall)
		{
		gen.imp			<- mysambar$imputedmatrix[,snps$filter]
		}else{
		gen.imp			<- mysambar$imputedmatrix[inds$filter,snps$filter]
		}
	rownames(gen.imp)	<- as.character(rownames(gen.imp))
	genimp				<<- gen.imp[order(rownames(gen.imp)),]
	#
	# read environmental data:
	setwd(mysambar$inputdatadir)
	cat("Reading envfile (file with environmental data) from:",sep="\n")
	cat(getwd(),sep="\n")
	env.data 				<- read.table(file = envfile, header = T, na.strings = NA)
	env.data$individual 	<- as.character(env.data$individual)
	envdata					<<- env.data[order(env.data$individual),]
	if(!identical(rownames(genimp),envdata$individual))
		{
		return(cat("ERROR: sample names in environmental data file do not correspond with sample names in inds dataframe.",sep="\n"))
		}
	#
	# variables correlated?
	# pairs.panels(Ocean.Data[,4:5], scale=T,las=2,hist.col="blue")
	#
	cat("Executing RDA analysis.",sep="\n")	
	myrda 	<<- rda(genimp ~ SST + salinity, data=envdata, scale=T)
	cat("Stored RDA output in 'myrda'. Generating plot...",sep="\n")	
	#
	# Make the RDA plots
	if(!is.null(export))
		{
		setwd(mysambar$selectiondir)
		if(export=="eps"){postscript("RDA.1_2.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("RDA.1_2.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("RDA.1_2.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("RDA.1_2.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	eco 	<- as.factor(envdata$population)		# 10-11-2021: added 'as.factor()'
	bg		<- mysambar$mycolours
	par(cex.axis=2.5,mar=c(5,5,1,1))
	plot(myrda, type="n", scaling=3, xlab="", ylab = "")
	mtext(side=1,"RDA 1", line=3.5, cex = 3)
	mtext(side=2,"RDA 2", line=2.75, cex = 3)
	points(myrda, display="species",pch=16,cex=0.75,col="gray30",scaling=3)
	points(myrda, display="sites",pch=21,cex=3,col="gray30",scaling=3,bg=bg[eco])
	legend(legendpos,legend=levels(eco), bty="n", col="gray30", pch=21, cex=3, pt.bg=bg)
	text(myrda, scaling=3, display="bp", col="darkorange", cex=2.75)
	if(!is.null(export))
		{
		dev.off()
		cat("RDA plot has been exported to the Selection directory.",sep="\n")
		setwd(mysambar$inputdatadir)
		}
	cat("Because data imputing has a stochastic component, the plot will look different if you rerun the importdata function.",sep="\n")
	}

# End of association analyses 	
###############################################################################################################











###############################################################################################################
# Data management and generally used functions

do_heatmap<-function(export_type=NULL,masklower=TRUE,nbins=NULL,mymatrix=nei,my_inds=inds,my_snps=snps,my_col="orange",exportname="mymatrix",mytitle=NULL,addlegend=TRUE,myBreaks=NULL,addlab=TRUE,misslabels=FALSE,legposx=0.1,legposy=0.5,legcex=2.5,subtitle=NULL)
		{
		# This plot will use all data in mymatrix input.
		# It assumes that nrow(mymatrix) and ncol(mymatrix) corresponds with nrow(my_inds[my_inds$filter,])
		if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages('gplots',repos=myrepos)}
		library(gplots)
		if(masklower)
			{
			mymatrix[lower.tri(mymatrix, diag = FALSE)]<-NA
			}
		# create colours:
		if(is.null(myBreaks))
			{
			floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
			ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
			mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
			if(max(mymatrix,na.rm=TRUE)==1)
				{
				mymax	<- 1
				}else{
				mymax	<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
				}
			binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
			myBreaks	<- seq(mymin,mymax,binsize)
			}
		mycolfunc 	<- colorRampPalette(c("white",my_col))
		myColours	<- c(mycolfunc(length(myBreaks)-1))
		myinds		<- my_inds$nr[my_inds$filter]
		ninds		<- ncol(mymatrix)
		mypopcols	<- my_inds$popcol[my_inds$filter]
		# cat(ninds,sep="\n")
		# cat(length(mypopcols),sep="\n")
		# plot:
		graphics.off()
		if(!is.null(export_type))
			{
			# if many samples, not all sample labels are shows. Increase to show. 
			if(addlab)
				{
				if(ninds<100)
					{
					mysize	<- 10
					mysize2	<- 720
					}else{
					mysize	<- ninds*0.1
					mysize2	<- ninds*7.2
					}
				}else{
				mysize	<- 10
				mysize2	<- 720
				}
			if(export_type=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
			if(export_type=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
			if(export_type=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
			if(export_type=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
			}
		if(addlab)
			{
			if(misslabels)
				{
				axislabels	<- round(my_inds$miss[my_inds$filter],3)
				}else{
				axislabels	<- my_inds$nr[my_inds$filter]
				}
			if(ninds<100)
				{
				mycex	<- 0.75
				}else{
				mycex	<- 0.5
				}
			heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=axislabels,labCol=axislabels,cexRow=mycex,cexCol=mycex,key=FALSE,Rowv=NA,Colv=NA,
			scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
			if(misslabels)
				{
				if(ninds<100)
					{
					mtext("sample miss", side = 1, cex = 1.5, line = 4)
					mtext("sample miss", side = 4, cex = 1.5, line = 1)
					}
				}else{
				if(ninds<100)
					{
					mtext("sample nr", side = 1, cex = 1.5, line = 4)
					mtext("sample nr", side = 4, cex = 1.5, line = 1)
					}
				}
			}else{
			heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,
			Colv=NA,scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
			}
		if(!is.null(mytitle)&!addlab){mtext(mytitle, side = 3, line = 1, cex = 3)}
		if(!is.null(subtitle)&!addlab){mtext(subtitle, side = 3, line = 0, cex = 2)}
		# legend:
		if(addlegend&!addlab)
			{
			mylimits	<- paste("[",round(heatpos$colorTable$low,3),",",round(heatpos$colorTable$high,3),")",sep="")
			legend(x=legposx,y=legposy,legend=mylimits,fill=myColours,bty='n',cex=legcex)
			}
		if(!is.null(export_type)){dev.off()}
		}	

genlight2DNAbin<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,exportname="filtereddata.diploid.fa",quiet=FALSE) 
	{
  	cat("Converting from genlight to DNAbin format...",sep="\n")
	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	genot2			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	minor		<- in_snps$minor[snpsfilter]
	major		<- in_snps$major[snpsfilter]
	# We first convert to diploid genotype score matrix:
	for (j in c(1:ncol(x))) 
		{
    	maj			<- major[j]
    	min			<- minor[j]
    	g			<- x[,j]
     	g[is.na(g)]	<- paste("N")  				
    	g[g==0]		<- paste(maj,maj,sep="") 			 
    	g[g==1]		<- paste(min,maj,sep="") 		
    	g[g==2]		<- paste(min,min,sep="") 		
    	genot[,j]	<- g
		}
	# Next we convert to diploid sequences:
	for (j in c(1:ncol(x))) 
		{
		g					<- genot[,j]
		g[g=="11"] 			<- "A"
        g[g=="22"]  		<- "C"
		g[g=="33"]			<- "G"
		g[g=="44"]  		<- "T"
		g[g=="12"|g=="21"] 	<- "M"		
       	g[g=="13"|g=="31"]	<- "R"		
		g[g=="14"|g=="41"] 	<- "W"		
        g[g=="23"|g=="32"]  <- "S"		
		g[g=="24"|g=="42"]	<- "Y"		
		g[g=="34"|g=="43"]  <- "K"		
		genot2[,j]			<- g
		}
	mydnabin			<<- as.DNAbin(genot2)
	rownames(mydnabin)	<<- in_inds$name[indsfilter]
	mysambar$mydnabin	<<- mydnabin
	cat("Genotypes converted to sequences, stored as an DNAbin object called 'mydnabin' (and also stored under mysambar$mydnabin).",sep="\n")
	if(export)
		{
		exportname2		<- paste(mysambar$inputfilesdir,exportname,sep="/")
		cat(file=exportname2,paste(paste0(">",rownames(mydnabin)),sapply(mydnabin, paste, collapse=""), sep="\n"), sep="\n")
		if(!quiet)
			{
			cat(paste("Fasta file has been written to", exportname, sep =" "),sep="\n")
			}
		}
	}	

# 01-12-2021:
DNAbin2genlight<-function(mydnabin=mysambar$mydnabin)
	{
	if(is.null(mydnabin))
		{
		return(cat("ERROR: specified dnabin object (to mydnabin argument) not found.",sep="\n")) 
		}
	x				<- toupper(as.character(mydnabin))
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	snpnames		<- paste("SNP",c(1:ncol(x)),sep="")
	#
	# find out major and minor allele:
	cat("Determining alleles...",sep="\n")
	mydf			<- as.data.frame(matrix(NA,nrow=ncol(x),ncol=11))
	colnames(mydf)	<- c("a","c","g","t","m","r","w","s","y","k","INDEL")
	for (j in c(1:ncol(x))) 
		{
		g				<- x[,j]
		mydf[j,1]		<- length(g[g=="A"])
		mydf[j,2]		<- length(g[g=="C"])
		mydf[j,3]		<- length(g[g=="G"])
		mydf[j,4]		<- length(g[g=="T"])
		mydf[j,5]		<- length(g[g=="M"])
		mydf[j,6]		<- length(g[g=="R"])
		mydf[j,7]		<- length(g[g=="W"])
		mydf[j,8]		<- length(g[g=="S"])
		mydf[j,9]		<- length(g[g=="Y"])
		mydf[j,10]		<- length(g[g=="K"])
		mydf[j,11]		<- length(g[g=="-"])	# INDEL
		}
	# M = AC
	# R = AG
	# W = AT
	# S = CG
	# Y = CT
	# K = GT
	mydf2				<- data.frame("A"=mydf$a+mydf$m+mydf$r+mydf$w,"C"=2*mydf$c+mydf$m+mydf$s+mydf$y,"G"=2*mydf$g+mydf$r+mydf$s+mydf$k,"T"=2*mydf$t+mydf$w+mydf$y+mydf$k)
	nalleles			<- apply(mydf2,1,FUN=function(x) length(which(x!=0)) )
	mybool				<- nalleles<=2
	mybool2				<- nalleles==2
	if(all(mybool))
		{
		if(all(mybool2))
			{
			cat("All sites are biallelic.",sep="\n")
			}else{
			cat("All sites are either monomorphic or biallelic.",sep="\n")
			}
		}else{
		nmulti	<- length(mybool[!mybool])
		nsites	<- length(mybool)
		cat(paste("WARNING: ",nmulti," multi-allelic sites found (out of ",nsites," in total). These sites will be excluded from the genlight object.",sep=""),sep="\n")
		if(nmulti==nsites)
			{
			return(cat("ERROR: all sites are multi-allelic. Not converting to genlight.",sep="\n"))
			}
		mydf	<- mydf[mybool,]
		mydf2	<- mydf2[mybool,]
		x		<- x[,mybool]
		genot	<- genot[,mybool]
		snpnames<- snpnames[mybool]
		}
	#
	cat("Determining minor and major alleles...",sep="\n")
	majorvec			<- c("A","C","G","T")[apply(mydf2,1,which.max)]
	mydf3				<- mydf2[,c("T","G","C","A")]		# reverse order, because in case maximum value is represented by two rather than one column, which.max returns first occurence.
	mydf3[mydf3==0]		<- 1000								# this enables to find minor.allele (assuming that no minor allele is represented by 1000 copies or more)
	minorvec			<- c("T","G","C","A")[apply(mydf3,1,which.min)]
	#
	# next convert to genlight:	
	cat("Converting to genlight...",sep="\n")
	cat("WARNING: if present, indels (-), will be converted to NA-values.",sep="\n")
	for (j in c(1:ncol(x))) 
		{
		g						<- x[,j]
		mymajor					<- majorvec[j]
		myminor					<- minorvec[j]
		g[g==mymajor&!is.na(g)] <- "0"
		g[g==myminor&!is.na(g)] <- "2"
       	g[(g=="M"|g=="R"|g=="W"|g=="S"|g=="Y"|g=="K")&!is.na(g)] 	<- "1"
       	g[g=="N"]				<- NA
		g[g=="-"]				<- NA
		genot[,j]				<- g
		}
	mygeno						<- as.data.frame(genot)
	rownames(mygeno)			<- rownames(x)
	colnames(mygeno)			<- snpnames
	mygl						<<- as.genlight(mygeno)
	mygl@loc.all				<<- paste(majorvec,minorvec,sep="/")
	mygl@other[[1]]				<<- majorvec
	mygl@other[[2]]				<<- minorvec
	cat("Data has been stored in a genlight object called 'mygl'.",sep="\n")
	cat("Vectors listing the major and minor alleles are stored at mygl@other[[1]] and mygl@other[[2]].",sep="\n")   
	}

genlight2structure<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname=NULL,quiet=FALSE,popasfirstcolumn=TRUE) 
	{
  	cat("Converting from genlight to structure format...",sep="\n")
	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x)*2)
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	minor		<- in_snps$minor[snpsfilter]
	major		<- in_snps$major[snpsfilter]
	for (j in c(1:ncol(x))) 
		{
    	maj					<- major[j]
    	min					<- minor[j]
    	g					<- x[,j]
    	allele1				<- rep(NA,nrow(x))
		allele2				<- rep(NA,nrow(x))
		allele1[is.na(g)]	<- -9
		allele2[is.na(g)]	<- -9
	   	allele1[g==0]		<- maj
		allele2[g==0]		<- maj			 
    	allele1[g==1]		<- maj
		allele2[g==1]		<- min	
    	allele1[g==2]		<- min 
		allele2[g==2]		<- min 		
    	genot[,j*2-1]		<- allele1
		genot[,j*2]			<- allele2
		}
  	if(popasfirstcolumn)
		{
		strufile		<- cbind(pop=(in_inds$pop[indsfilter]),sample=indNames(input[indsfilter,]),as.data.frame(genot))
		}else{
		strufile		<- cbind(sample=indNames(input[indsfilter,]),pop=(in_inds$pop[indsfilter]),as.data.frame(genot))
		}
	# add column names:
	lociname1		<- snps$name[snps$filter]
	lociname1		<- paste(lociname1,"1",sep="_")
	lociname2		<- snps$name[snps$filter]
	lociname2		<- paste(lociname2,"2",sep="_")
	locnames		<- c(rbind(lociname1,lociname2))
	if(popasfirstcolumn)
		{
		colnames(strufile)	<- c("pop","sample",locnames)
		}else{
		colnames(strufile)	<- c("sample","pop",locnames)
		}
	mysambar$mystructure <<- strufile
	if(!quiet)
		{
		cat("Structure format has been saved in mysambar$mystructure.",sep="\n")
		}
	if(!is.null(exportname))
		{
		# Export:
		cat("Exporting structure file...",sep="\n")
		exportname2		<- paste(exportname,"stru",sep = ".")
		exportname3		<- paste(mysambar$inputfilesdir,exportname2,sep="/")
		write.table(strufile,file=exportname3,sep="\t",row.names=FALSE,col.names=TRUE,quote=FALSE)
		if(!quiet)
			{
			cat(paste("Structure file has been written to", exportname3, sep =" "),sep="\n")
			}
		}
	}	
	
# Export to ped and map
genlight2ped<-function(input=mygenlight,in_snps=snps,in_inds=inds,popvec=NULL,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="filtered.data",pheno=NULL,genonumber=TRUE,quiet=FALSE,silent=TRUE,miss_char="0",use_tab=TRUE) 
	{
	# miss_char can be 'N' or '0'
	# Input should be a genlight object
	# 03-04-2020: because I ran into an error I added the line:
	# snpsfilter		<- snpsfilter&in_snps$minor!="0"&in_snps$major!="0"&in_snps$minor2!="N"&in_snps$major2!="N"
	# 19-07-2020: If I include the line above, I get the error:
	# Error in 1:nLoc(x) : NA/NaN argument
	#
	# We are going to convert this genlight object input file into a matrix with 0,1,2 or NA-values:
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
  	# Now we are ready to create our PED-file, starting with an empty matrix:
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
  	rownames(genot)	<- rownames(x)
  	colnames(genot)	<- colnames(x)
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	if(!silent){cat("Creating vectors of minor and major alleles...",sep="\n")}
	if(genonumber)
		{
		minor		<- in_snps$minor[snpsfilter]
		major		<- in_snps$major[snpsfilter]
		missing		<- as.character(0)
		}else{
		minor		<- in_snps$minor2[snpsfilter]
		major		<- in_snps$major2[snpsfilter]
		missing		<- miss_char					# 08-02-2020: changed from as.character(0) to "N". # 11-03-2020: this gives an error with PCadapt, which expects '0'. Decided to make two output files. 
		}
	if(genonumber)
		{
		if(any(is.na(minor)))
			{
			return(cat("ERROR: NA's in snps$minor column.",sep="\n"))
			}
		if(any(is.na(major)))
			{
			return(cat("ERROR: NA's in snps$major column.",sep="\n"))
			}
		}else{
		if(any(minor=="NA"))
			{
			return(cat("ERROR: NA's in snps$minor column.",sep="\n"))
			}
		if(any(major=="NA"))
			{
			return(cat("ERROR: NA's in snps$major column.",sep="\n"))
			}
		}
	if(!silent){cat("Creating genot matrix...",sep="\n")}
	for (j in c(1:ncol(genot))) 
		{
    	g			<- x[,j]
    	maj			<- as.character(major[j])
    	min			<- as.character(minor[j])
    	g[is.na(g)]	<- paste(missing,missing,sep=" ")  				
    	g[g==0]		<- paste(maj,maj,sep=" ") 			 
    	g[g==1]		<- paste(min,maj,sep=" ") 		
    	g[g==2]		<- paste(min,min,sep=" ") 		
    	genot[,j]	<- g
  		}
  	pedfiledata<-as.data.frame(genot)
	if(!silent){genottemp	<<- genot}
	#
	if(is.null(popvec))
		{
		popvec		<- in_inds$pop[indsfilter]
		}else{
		popvec		<- popvec[indsfilter]
		}
	# Include additional information to pedfile:
	if(!silent){cat("Creating ped file...",sep="\n")}
	if(is.null(pheno))	
		{
		pedfile		<-cbind(FID=popvec,IID=indNames(input[indsfilter,]),PAT=0,MAT=0,SEX=0,PHENOTYPE=-9,pedfiledata)
		}else{
		pedfile		<-cbind(FID=popvec,IID=indNames(input[indsfilter,]),PAT=0,MAT=0,SEX=0,PHENOTYPE=pheno[indsfilter],pedfiledata)
		}
	# pedfile		<<- pedfile
	# Next create the MAP-file:
	# if(any(names(snps) == "chr"))
	#{
	if(!silent){cat("Creating map file...",sep="\n")}
	if(is.factor(in_snps$name))
		{
		locus_names	<- in_snps$name
		}else{
		if(is.integer(in_snps$name)|is.character(in_snps$name))
			{
			# 15-07-2020: is.integer: to avoid error: Error in as.character.factor(in_snps$name) : attempting to coerce non-factor
			# 19-08-2020: is.character: to avoid error: Error in as.character.factor(in_snps$name) : attempting to coerce non-factor
			locus_names	<- in_snps$name
			}else{
			locus_names	<- as.character.factor(in_snps$name)
			}
		}
	mapfile		<- data.frame("chr"=(as.vector(in_snps$chr[snpsfilter])),"name"=locus_names[snpsfilter],"gd"=0,"pos"=in_snps$pos[snpsfilter])
	# Finally, export the files:
	if(use_tab)
		{
		mysep <- c("\t")
		}else{
		mysep <- c(" ")
		}
	write.table(pedfile,file=paste(exportname,"ped",sep = "."),sep=mysep,na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	write.table(mapfile,file=paste(exportname,"map",sep = "."),sep=mysep,na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	if(!quiet)
		{
		path1<- paste(getwd(),exportname,sep="/")
		cat(paste("PED and MAP files have been written to", path1, sep =" "),sep="\n")
		}
	}

exportneutral<-function(my_dataset="pheno",silent=TRUE,include_gwds=TRUE,include_pcadapt=TRUE,include_outflank=TRUE,include_bayescan=FALSE,include_fsthet=FALSE,current_dir=FALSE,export_outlier=TRUE,export_neutral=TRUE)
	{
	currentdir	<- getwd()
	if(!current_dir)
		{
		setwd(mysambar$inputfilesdir)
		}
	if(!silent){cat(my_dataset,sep="\n")}
	snpcolnames		<- names(snps)
	# GWDS:
	mycolumn		<- paste("rfisherout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_gwds)		
		{
		gwdsout		<- snps[,mycolumn]
		gwdsout2	<- gwdsout
		if(any(is.na(gwdsout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_gwds){cat("WARNING: column with GWDS outlier info not present in snps dataframe.",sep="\n")}
		gwdsout		<- rep(FALSE,nrow(snps))
		gwdsout2	<- rep(TRUE,nrow(snps))
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_pcadapt)		
		{
		pcadaptout	<- snps[,mycolumn]
		pcadaptout2	<- pcadaptout
		if(any(is.na(pcadaptout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_pcadapt){cat("WARNING: column with PCadapt outlier info not present in snps dataframe.",sep="\n")}
		pcadaptout	<- rep(FALSE,nrow(snps))
		pcadaptout	<- rep(TRUE,nrow(snps))
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_outflank)		
		{
		outflankout	<- snps[,mycolumn]
		outflankout2<- outflankout	
		if(any(is.na(outflankout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_outflank){cat("WARNING: column with OutFLANK outlier info not present in snps dataframe.",sep="\n")}
		outflankout	<- rep(FALSE,nrow(snps))
		outflankout2<- rep(TRUE,nrow(snps))
		}
	# bayescan:
	mycolumn		<- paste("bayescanout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_bayescan)		
		{
		bayescanout	<- snps[,mycolumn]
		bayescanout2<- bayescanout
		if(any(is.na(bayescanout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_bayescan){cat("WARNING: column with Bayescan outlier info not present in snps dataframe.",sep="\n")}
		bayescanout	<- rep(FALSE,nrow(snps))
		bayescanout2<- rep(TRUE,nrow(snps))
		}
	# Fsthet:
	mycolumn		<- paste("fsthetout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_fsthet)		
		{
		fsthetout	<- snps[,mycolumn]
		fsthetout2	<- fsthetout
		if(any(is.na(fsthetout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_fsthet){cat("WARNING: column with FstHet outlier info not present in snps dataframe.",sep="\n")}
		fsthetout	<- rep(FALSE,nrow(snps))
		fsthetout2	<- rep(TRUE,nrow(snps))
		}
	outdf	<<- cbind(gwdsout,pcadaptout,outflankout,bayescanout,fsthetout)
	outdf2	<<- cbind(gwdsout2,pcadaptout2,outflankout2,bayescanout2,fsthetout2)
	if(!any(outdf))
		{
		return(cat("No outliers present. Not possible to split dataset in neutral and outlier SNPs. Not exporting files.",sep="\n"))
		}
	outfilter		<- apply(outdf,1,any)
	outfilter2		<- apply(outdf2,1,all)
	outlierfilter	<- snps$filter&outfilter		# union
	outlierfilter2	<- snps$filter&outfilter2		# intersect (overlap)
	#
	# outliers of all selection scans:
	if(export_outlier)
		{
		cat("Exporting dataset with all outlier SNPs marked by at least one selection scan, in PED and MAP format...",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=outlierfilter,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.allscans",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
		if(any(outlierfilter2))
			{
			cat("Exporting dataset with outlier SNPs marked by all (used) selection scans, in PED and MAP format...",sep="\n")
			exportdata(indsfilter=inds$filter,snpsfilter=outlierfilter2,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.overlap",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}else{
			cat("No SNP has been marked by all outlier scans.",sep="\n")
			}
		# outliers of individual selection scans:
		if(any(gwdsout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&gwdsout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.GWDS",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(pcadaptout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&pcadaptout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.PCadapt",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(outflankout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&outflankout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.OutFLANK",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(bayescanout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&bayescanout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.Bayescan",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(fsthetout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&fsthetout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.FstHet",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		}
	#
	if(export_neutral)
		{
		neutralfilter	<- snps$filter&(!outfilter)
		cat("Exporting dataset with neutral SNPs in PED and MAP format...",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=neutralfilter,popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.allscans",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
		#
		if(any(gwdsout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!gwdsout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.GWDS",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(pcadaptout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!pcadaptout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.PCadapt",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(outflankout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!outflankout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.OutFLANK",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(bayescanout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!bayescanout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.Bayescan",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		if(any(fsthetout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!fsthetout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.FstHet",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE)
			}
		}
	setwd(currentdir)
	}


# this function exports PED and MAP files for all populations separately and for all pops combined:
# depends on function 'genlight2ped':
exportdata<-function(indsfilter=inds$filter,snpsfilter=snps$filter,popnames=mysambar$populations,export_name="filter1",geno_nr=TRUE,quiet2=FALSE,do_all=TRUE,do_pheno=FALSE,misschar="0",silent=TRUE)
	{ 
	if(do_all)
		{
		exportnametemp	<- paste("metapop",export_name,sep=".")
		}else{
		exportnametemp	<- export_name
		}
	genlighttemp		<- mygenlight[indsfilter,snpsfilter]
	snpstemp			<- snps[snpsfilter,]
	indstemp			<- inds[indsfilter,]
	if(do_pheno)
		{
		indstemp$pop	<- indstemp$type
		}
	if(!silent)
		{
		cat("Exporting...",sep="\n")
		snpstemp		<<- snpstemp
		indstemp		<<- indstemp
		genlighttemp	<<- mygenlight
		}
	genlight2ped(genonumber=geno_nr,exportname=exportnametemp,input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),quiet=quiet2,miss_char=misschar)
	if(do_all)
		{
		for (mypop in popnames)
			{
			genlighttemp	<- mygenlight[inds$pop==mypop&indsfilter,snpsfilter]
			snpstemp		<- snps[snpsfilter,]
			indstemp		<- inds[inds$pop==mypop&indsfilter,]
			exportnametemp	<- paste(mypop,export_name,sep=".")
			genlight2ped(genonumber=geno_nr,exportname=exportnametemp,input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),quiet=quiet2,miss_char=misschar)
			}
		}
	}

# Export to Treemix input:
exporttreemix<-function(snpsfilter=snps$filter,exportname="Treemixinput.snpsfilter.txt")
	{
	cat("Creating input for Treemix...",sep="\n")
	mydf				<- snps[snpsfilter, grep("ac_", colnames(snps))]
	alldf				<- mydf[,c(TRUE,FALSE)]
	minordf				<- mydf[,c(FALSE,TRUE)]
	majordf				<- alldf-minordf
	#
	alldf				<- alldf[,order(colnames(alldf))]
	minordf				<- minordf[,order(colnames(minordf))]
	majordf				<- majordf[,order(colnames(majordf))]	
	#
	popnames			<- mysambar$populations2
	npops				<- length(popnames)
	colnames(alldf)		<- popnames
	colnames(minordf)	<- popnames 
	colnames(majordf)	<- popnames
	alldf2				<- alldf
	#
	for(k in c(1:npops))
		{
		alldf2[,k]		<- paste(majordf[,k],minordf[,k],sep=",")	
		}
	alldf2				<- alldf2[,colnames(alldf2)%in%mysambar$populations]
	write.table(alldf2,exportname,sep=" ",quote=FALSE,row.names=FALSE)
	cat("Treemix input file (unzipped) has been exported to the directory:...",sep="\n")
	cat(getwd(),sep="\n")
	}

# Export to Immanc format:
genlight2immanc<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="Bayesassinput.immanc.txt",quiet=FALSE) 
	{
	# immanc format:
	# Ind1 	pop1	locus1	allele1	allele2
	# Ind2 	pop1	locus1	allele1	allele2
	# Ind3 	pop1	locus1	allele1	allele2
	# Ind1 	pop1	locus2	allele1	allele2
	# Ind2 	pop1	locus2	allele1	allele2
	# Ind3 	pop2	locus2	allele1	allele2
	# etc.
	#
	# example for 3 individuals (from 2 pop) and 2 loci:
	# Ind374	North	15	2	2
	# Ind375	SouthWest	15	1	2
	# Ind376	SouthWest	15	1	1
	# Ind374	North	16	2	2
	# Ind375	SouthWest	16	1	2
	# Ind376	SouthWest	16	1	1
	#
	# Consider that the genlight code means the following:
	# genlight	allele1	allele2
	# 0 	= 	1 		1		
	# 1 	= 	1 		2		
	# 2 	= 	2 		2
	#
	# To change the genlight format in a code for the first allele, we only have to change the code for homozygous major: 
	g1				<- as.matrix(input[indsfilter,snpsfilter])
	g1[g1==0]		<- 1		
	g1[is.na(g1)]	<- 0		# missing data coded as 0
	allele1			<- as.vector(unlist(g1))		
	#
	# second allele:
	# To change the genlight format in a code for the second allele, we have to change the code for homozygous major as well as for heterozygous:
	g2				<- as.matrix(input[indsfilter,snpsfilter]) 
	g2[g2==1]		<- 2
	g2[g2==0]		<- 1
	g2[is.na(g2)]	<- 0		# missing data coded as 0
	allele2			<- as.vector(unlist(g2))
	#
	# create dataframe:
	mysnps			<- snps$name[snpsfilter]
	nsnps			<- length(mysnps)
	myinds			<- inds[indsfilter,c("name","pop")]
	ninds			<- nrow(myinds)
	mysnps2			<- rep(mysnps,each=ninds)
	myinds2			<- coredata(myinds)[rep(seq(nrow(myinds)),nsnps),]
	myoutput		<<- as.data.frame(cbind(myinds2,mysnps2,allele1,allele2))
	# export:
	write.table(myoutput,exportname,sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	if(!quiet)
		{
		path1	<- paste(getwd(),exportname,sep="/")
		cat(paste("Bayesass input (immanc format) has been written to", path1, sep =" "),sep="\n")
		}
	}

# This function converts everything to 01 and/or 02, regardless of actual allele.
genlight2genepop<-function(input=mygenlight,overwritefile=FALSE,snpsfilter=snps$filter,indsfilter=inds$filter,group1="pheno",group2="pheno",addcomma=TRUE,exportsubset=FALSE) 
	{
	# Input should be a genlight object.
	if(!is.null(mysambar$genepop)&!overwritefile)
		{
		cat("WARNING: using existing genepop dataframe saved at mysambar$genepop.",sep="\n")
		cat("If you want to generate a new dataframe, set flag overwritefile to TRUE.",sep="\n")
		g1			<- mysambar$genepop
		}else{
		cat("Converting genlight to genepop object...")
		g1			<- as.data.frame(input[,snpsfilter])
		# indicate whether allele1 and allele2 are major (1) or minor allele (2):
		g1[g1==0]	<- "0101"
		g1[g1==1]	<- "0102"
		g1[g1==2]	<- "0202"
		mygenepop		<<- g1
		mysambar$genepop<<- g1
		}
	#
	mysnpnames		<- as.vector(snps$name[snpsfilter])
	setwd(mysambar$inputfilesdir)
	if(exportsubset)
		{
		if(group1=="pheno")
			{
			cat("Dividing into pheno1 and pheno2...",sep="\n") 
			gsub1	<- g1[indsfilter&inds$type==TRUE,]
			gsub2	<- g1[indsfilter&inds$type==TRUE,]
			}else{
			cat("Dividing into pheno1 and pheno2...",sep="\n") 
			gsub1	<- g1[indsfilter&inds$pop==group1,]
			gsub2	<- g1[indsfilter&inds$pop==group2,]
			}
		if(addcomma)
			{
			#rownames(g1)<- paste(rownames(g1),",",sep="\t")
			rownames(gsub1)<- paste(rownames(gsub1),",",sep="")
			rownames(gsub2)<- paste(rownames(gsub2),",",sep="")
			}
		if(doexport)
			{
			mysnpnames		<- as.vector(snps$name[snpsfilter])
			if(group1=="pheno")
				{
				myfilename		<- "pheno.mygenepop"
				}else{
				myfilename		<- paste(group1,group2,"genepop",sep="_")
				}
			cat("# Genepop file generated by SambaR\n", file=myfilename)
			cat(mysnpnames, file=myfilename, append=TRUE, sep=",")
			cat("\npop\n", file=myfilename, append=TRUE)
			write.table(gsub1, file=myfilename, append=TRUE, sep="\t",col.names=FALSE,quote=FALSE)
			cat("pop\n", file=myfilename, append=TRUE)
			write.table(gsub2, file=myfilename, append=TRUE, sep="\t",col.names=FALSE, quote=FALSE)
			}
		cat(paste("Genepop file called '",myfilename,"' exported to the directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		}else{
		myfilename		<- "all.genepop"
		cat("# Genepop file generated by SambaR\n", file=myfilename)
		cat(mysnpnames, file=myfilename, append=TRUE, sep=",")
		cat("\npop\n", file=myfilename, append=TRUE)
		write.table(g1, file=myfilename, append=TRUE, sep="\t",col.names=FALSE,quote=FALSE)
		cat(paste("Genepop file called '",myfilename,"' exported to the directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		}
	}

listobjects<-function()
	{
	myobjectnames	<- ls(envir = .GlobalEnv)
	myobjects		<- lapply(X=myobjectnames,FUN=get)
	myboolvec		<- vector()	
	for(k in c(1:length(myobjects)))
		{
		myboolvec[k]<- !is.function(myobjects[[k]])
		}
	myobjectnames2<-myobjectnames[myboolvec]
	cat(paste(myobjectnames2,collapse=","),sep="\n")
	}

# from inds, snps and mygenlight to sambar list:
backupdata<-function(myprefix=NULL,overwrite=FALSE)
	{
	if(is.null(myprefix))
		{
		cat("ERROR: You have to provide a prefix.",sep="\n")
		}else{
		if(exists(myprefix)&!overwrite)
			{
			return(cat(paste("ERROR: there is already an object called '",myprefix,"'. Please choose another name to save your data or set the flag 'overwrite' to TRUE.",sep=""),sep="\n"))
			}
		myglobal	<- globalenv()
		mylist		<- mysambar
		mylist$inds	<- inds
		mylist$snps	<- snps
		mylist$genlight	<- mygenlight
		assign(myprefix,mylist,envir=myglobal)
		cat(paste("A back up of your data objects has been stored in a list object called:", myprefix,sep=" "),sep="\n")
		}
	}

# from sambar list to inds, snps and mygenlight:
getdata<-function(myprefix=NULL,silent=TRUE,do_check=TRUE)
	{
	if(is.null(myprefix))
		{
		cat("ERROR: You have to provide a prefix.",sep="\n")
		}else{
		if(!silent){cat("Creating a list of available SambaR datasets...",sep="\n")}
		if(do_check)
			{
			# which mysambar lists available?
			myobjectnames<- ls(envir = .GlobalEnv)
			myobjects	<- lapply(X=myobjectnames,FUN=get)
			myboolvec	<- vector()
			for(k in c(1:length(myobjects)))
				{
				myboolvec[k]<- is.list(myobjects[[k]])
				}
			mylistnames<- myobjectnames[myboolvec]
			mylists		<- myobjects[myboolvec]
			myboolvec	<- vector()
			for(k in c(1:length(mylists)))
				{
				#cat(k,sep="\n")
				mylist			<- mylists[[k]]
				myboolvec[k] 	<- "inds" %in% names(mylist)
				}
			mysambarlists	<- mylistnames[myboolvec]
			mysambarlists	<- mysambarlists[mysambarlists!="mysambar"]
			if(length(mysambarlists)==0)
				{
				mysambarlists	<- "none"
				}
			#
			if(!exists(myprefix))
				{
				cat("ERROR: Object with specified name does not exist.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(!silent){cat("Object present.",sep="\n")}
			myobject	<- get(myprefix)
			if(!is.list(myobject))
				{
				cat("ERROR: Specified object is not a list object.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(!silent){cat("Object is a list.",sep="\n")}		
			mylist		<- get(myprefix)
			if(!"inds" %in% names(mylist))
				{
				cat("ERROR: Specified object is a list, but not a SambaR list object.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(myprefix=="mysambar")
				{
				cat("ERROR: It is not possible to select 'mysambar'.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(!silent){cat("Object is a SambaR list.",sep="\n")}		
			}
		myglobal	<- globalenv()
		mylist		<- get(myprefix,envir=myglobal)
		inds		<<- mylist$inds
		snps		<<- mylist$snps
		mygenlight	<<- mylist$genlight
		mylist$snps	<- "snps"
		mylist$inds	<- "inds"
		mylist$genlight	<- "genlight"
		mysambar	<<- mylist
		cat("Data has been loaded to inds, snps and mygenlight objects.",sep="\n")
		setwd(mysambar$inputdatadir)
		cat("Working directory has been set to:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		}
	}

# Exlude certain individuals from subsequent analyses:
subset_pop<-function(include_pops=NULL)
	{
	if(is.null(include_pops))
		{
		cat("ERROR: provide an input vector to the 'include_pops' argument. E.g.:",sep="\n")
		cat('popsubset(include_pops=c("popname1","popname2","etc"))',sep="\n")
		return(cat("This input vector should contain the names of the populations you want to select.",sep="\n"))
		}
	cat("Subselecting populations. Note that this function should be executed after the filterdata() function, not before!",sep="\n")
	if(any(!include_pops%in%mysambar$populations))
		{
		return(cat("ERROR: one or more population names not found in existing dataset.",sep="\n"))
		}
	mybool					<- mysambar$populations%in%include_pops
	mysambar$populations	<<- mysambar$populations[mybool]
	mysambar$mycolours		<<- mysambar$mycolours[mybool]	
	mysambar$mycolours2		<<- mysambar$mycolours
	mybool2					<- inds$pop%in%include_pops
	inds$filter				<<- inds$filter&mybool2
	#
	# Screen info:
	snpstemp				<- snps[,paste("maf",include_pops,sep="_")]
	mafsum					<- rowSums(snpstemp)
	npoly					<- length(mafsum[mafsum>0])
	nind					<- nrow(inds[inds$filter,])
	cat("Done. Individuals which don't belong to populations defined in the include_pops argument, will be excluded from subsequent analyses.",sep="\n")
	cat(paste("This smaller dataset contains ",nind," retained individuals and ",npoly," polymorphic sites.",sep=""),sep="\n")
	cat("Don't run the filterdata() function, because this will partially undo the changes. To undo the changes, rerun the importdata() function.",sep="\n")
	#table(inds$pop,inds$filter)
	}
	
# create a targetted subset of SNP dataset:
subselectdata<-function(snp_names=NULL,name2=TRUE,name3=FALSE)
	{
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	#
	if(is.null(snp_names))
		{
		return(cat("ERROR: no snpnames provided to snp_names argument.",sep="\n"))
		}	
	if(name2)
		{
		myselection		<- snps$name2%in%snp_names
		}else{
		if(name3)
			{
			myselection		<- snps$name3%in%snp_names
			}else{
			myselection		<- snps$name%in%snp_names
			}
		}
	nhits			<- length(myselection[myselection])
	cat(paste("Found",nhits,"snps",sep=" "),sep="\n")
	if(nhits==0)
		{
		return(cat("0 hits. Subsetting aborted.",sep="\n"))
		}
	matrixtemp		<- as.matrix(mygenlight)[,myselection]
	snpstemp		<- snps[myselection,]
	# create sambar list:
	# sambar list:
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Subset",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambarsubset			<<- list()
	mysambarsubset[[1]]		<<- mysambar$populations
	mysambarsubset[[2]]		<<- inds
	mysambarsubset[[3]]		<<- snpstemp
	mysambarsubset[[4]]		<<- as.genlight(matrixtemp)
	mysambarsubset[[5]]		<<- inputdatadir
	mysambarsubset[[6]]		<<- sambardir
	mysambarsubset[[7]]		<<- QCdir
	mysambarsubset[[8]]		<<- structuredir
	mysambarsubset[[9]]		<<- divergencedir
	mysambarsubset[[10]]	<<- diversitydir
	mysambarsubset[[11]]	<<- demographydir
	mysambarsubset[[12]]	<<- selectiondir
	mysambarsubset[[13]]	<<- inputfilesdir
	mysambarsubset[[14]]	<<- "sans"
	mysambarsubset[[17]]	<<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
	mysambarsubset[[18]]	<<- geomapsdir
	names(mysambarsubset)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambarsubset$populations2		<<- mysambarsubset$populations	# needed for excludepop()
	mysambarsubset$mycolours2		<<- mysambarsubset$mycolours	# needed for excludepop()
	mysambarsubset$defaultcolours	<<- defaultcolours
	mysambarsubset$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambarsubset$datasource		<<- "subselectdata"
	cat("Data subset has been stored in a list object called 'mysambarsubset'.",sep="\n")
	cat("You can load the data by typing: getdata('mysambarsubset').",sep="\n")
	cat("However, before loading make sure to first backup original dataset using the backupdata()-function.",sep="\n")
	cat("Also note: the information in snps and inds data is still based on entire dataset, not on subset.",sep="\n")
	cat("Therefore, after loading run the filterdata(), findstructure(), calcdistance() and calcdiversity() functions again.",sep="\n")
	}	
	
# create a random subset of SNP dataset (subset can be based on snps and/or inds):
subsampledata<-function(nrinds=NULL,nrsnps=NULL,exportprefix=NULL,remove_stats=TRUE,popcolours=NULL)
	{
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	#
	if(is.null(nrinds)&is.null(nrsnps))
		{
		return(cat("ERROR: how many individuals (nrinds) and how many loci (nrsnps) should be subsampled?",sep="\n"))
		}
	if(!is.null(nrinds))
		{
		indstemp1	<- inds[inds$filter,]
		indstemp2	<- c(1:nrow(indstemp1))
		indstemp3	<- sample(indstemp2,nrinds,replace = FALSE)
		indstemp3	<- indstemp3[order(indstemp3)]
		indstemp	<- indstemp1[indstemp3,]
		}else{
		indstemp	<- inds
		indstemp3	<- c(1:nrow(indstemp))
		}
	if(!is.null(nrsnps))
		{
		snpstemp1	<- snps[snps$filter,]
		snpstemp2	<- c(1:nrow(snpstemp1))
		snpstemp3	<- sample(snpstemp2,nrsnps,replace = FALSE)
		snpstemp3	<- snpstemp3[order(snpstemp3)]
		snpstemp	<- snpstemp1[snpstemp3,]
		}else{
		snpstemp	<- snps[snps$filter,]
		snpstemp3	<- c(1:nrow(snpstemp))
		}
	#
	# subsample genlight:
	if(!is.null(nrsnps)&(!is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[inds$filter,snps$filter]
		}
	if(!is.null(nrsnps)&(is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[,snps$filter]
		}
	if(is.null(nrsnps)&(!is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[inds$filter,]
		}
	matrixtemp		<- matrixtemp[indstemp3,snpstemp3]
	genlighttemp	<- as.genlight(matrixtemp)
	if(remove_stats)
		{
		indstemp	<- indstemp[,c("name","pop","pop2","nr","popcol","meandepth","name2")]
		snpstemp	<- snpstemp[,c("chr","name","morgan","pos","minor","major","minor2","major2","stackID","stackbp","readpos","sameread","name2","placed","autosomal","dist","dist2","samepos","uniqpos","meandepth","depthfilter","poly")]
		}
	#
	# sambar list:
	setwd(mysambar$inputdatadir)
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Subsetdata",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	# store in list called mysambarsubset: 
	mysambarsubset				<<- list()
	populationstemp				<- as.vector(unique(indstemp$pop))
	mysambarsubset$populations	<<- populationstemp
	mysambarsubset$inds			<<- indstemp
	mysambarsubset$snps			<<- snpstemp
	mysambarsubset$genlight		<<- genlighttemp
	mysambarsubset[[5]]			<<- inputdatadir
	mysambarsubset[[6]]			<<- sambardir
	mysambarsubset[[7]]			<<- QCdir
	mysambarsubset[[8]]			<<- structuredir
	mysambarsubset[[9]]			<<- divergencedir
	mysambarsubset[[10]]		<<- diversitydir
	mysambarsubset[[11]]		<<- demographydir
	mysambarsubset[[12]]		<<- selectiondir
	mysambarsubset[[13]]		<<- inputfilesdir
	mysambarsubset[[14]]		<<- "sans"
	if(is.null(popcolours))
		{
		mysambarsubset[[17]]	<<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
		}else{
		mysambarsubset[[17]]	<<- popcolours
		}
	mysambarsubset[[18]]	<<- geomapsdir
	names(mysambarsubset)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambarsubset$populations2		<<- mysambarsubset$populations	# needed for excludepop()
	mysambarsubset$mycolours2		<<- mysambarsubset$mycolours	# needed for excludepop()
	mysambarsubset$defaultcolours	<<- defaultcolours
	mysambarsubset$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambarsubset$datasource		<<- "subsampledata"
	#
	cat("Data subset has been stored in a list object called 'mysambarsubset'.",sep="\n")
	cat("You can load the data by typing: getdata('mysambarsubset').",sep="\n")
	cat("However, before loading make sure to first backup original dataset using the backupdata()-function.",sep="\n")
	#
	# optionally export:
	if(!is.null(exportprefix))
		{
		setwd(inputdatadir)
		genlight2ped(input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),exportname=exportprefix) 
		}
	}

#be sure to first back up your data using the backupdata function
dummydata<-function(nind=2,nsnp=4,q=0.15,popname="pop1",popcol="blue",mygeno=NULL,major=1,minor=4,colourvector=NULL,mafvec=NULL)
	{
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours
		}
	# q = minor allele freq
	# myprobs = probability of occurence of homo_major, hetero, hetero_minor
	myprobs			<- c((1-q)^2,2*(1-q)*q,(q^2))
	#
	# snps:
	snpnr			<- c(1:nsnp)
	snpname			<- paste("snp",snpnr,sep="")
	snps			<<- as.data.frame(cbind(snpnr,snpname))
	colnames(snps)	<<- c("nr","name")
	snps$chr		<<- "dummy_chr1"
	snps$pos		<<- snpnr
	snps$miss		<<- 0
	snps$misscount_pop1								<<- 0
	names(snps)[colnames(snps)=="misscount_pop1"]	<<- paste("misscount",popname,sep="_")
	snps$filter		<<- TRUE
	snps$uniqpos	<<- TRUE
	snps$polyfilter	<<- TRUE
	snps$depthfilter<<- TRUE
	snps$nr_neworder<<- c(1:nrow(snps))
	# inds:
	indnr			<- c(1:nind)
	indname			<- paste("ind",indnr,popname,sep="")	
	inds			<<- as.data.frame(cbind(indnr,indname))
	colnames(inds)	<<- c("nr","name")
	inds$pop		<<- popname
	inds$pop2		<<- popname
	inds$popcol		<<- popcol
	inds$miss		<<- 0
	inds$filter		<<- TRUE
	inds$nsites2	<<- nsnp
	#
	# genlight:
	if(is.null(mafvec))
		{
		if(!is.null(mygeno))
			{
			mymatrix 			<- matrix(mygeno,nrow=nind,ncol=nsnp,byrow=FALSE)
			}else{
			mymatrix			<- matrix(NA,nrow=nind,ncol=nsnp) 
			for (i in c(1:nsnp))
				{
				mymatrix[,i]	<- sample(c(0,1,2),nind,replace=TRUE,prob=myprobs)
				}
			}
		}else{
		cat("Generating snp data from input maf-vector.",sep="\n")
		mymatrix				<- matrix(NA,nrow=nind,ncol=nsnp) 
		for (i in c(1:nsnp))
			{
			q					<- mafvec[i]
			myprobs				<- c((1-q)^2,2*(1-q)*q,(q^2))
			mymatrix[,i]		<- sample(c(0,1,2),nind,replace=TRUE,prob=myprobs)
			}
		}
	rownames(mymatrix)			<- inds$name
	colnames(mymatrix)			<- snps$name
	mygenlight					<<- as.genlight(mymatrix)
	# add info on minor allele to snps data frame:
	misscount					<- glNA(mygenlight,alleleAsUnit=FALSE)
	snps$nonmissallelecount 	<<- 2*nInd(mygenlight)-misscount
	inds$filter					<<- TRUE
	snps$filter					<<- TRUE
	snp_maf(popnames=popname,indthreshold=0.2)
	snps$minor					<<- minor
	snps$major					<<- major
	snps$minor2					<<- c("A","C","G","T")[minor]
	snps$major2					<<- c("A","C","G","T")[major]
	# sambar list:
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Dummydata",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- popname
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	mysambar[[17]]	<<- colourvector
	mysambar[[18]]	<<- inputfilesdir
	names(mysambar)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$populations2	<<- mysambar$populations	# needed for excludepop()
	mysambar$mycolours2		<<- mysambar$mycolours		# needed for excludepop()
	mysambar$defaultcolours	<<- defaultcolours
	mysambar$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambar$datasource		<<- "dummydata"
	#
	cat("New inds, snps and genlight objects have been created.",sep="\n")
	}	

# cbind two genlight objects (assuming same individuals)
glmerge<-function(mygl)
	{
	simgl				<- glSim(nrow(mygl),n.snp.nonstruc=10000,ploidy=2)
	indNames(simgl)		<- indNames(mygl)
	pop(simgl)			<- pop(mygl)
	locNames(simgl)		<- locNames(mygl)
	combigl				<- cbind(mygl,simgl)
	}

# Find overlap between two datasets (stored as sambar list objects)	
findoverlap<-function(mylist1=NULL,mylist2=NULL,mycolours=NULL,silent=TRUE,combine_divstats=FALSE,myworkdir=NULL,do_continue=FALSE)
	{
	#
	if(is.null(myworkdir))
		{
		cat("The user did not define a path to the 'myworkdir' flag. Assuming that a new directory called 'Combined_dataset' (to store the new SambaR output) of the combined dataset should be created in the current working directory:",sep="\n")
		inputdatadir		<- getwd()
		cat(inputdatadir,sep="\n")
		if(!do_continue)
			{
			return(cat("If this is correct, set the flag do_continue to TRUE. If not, define the desired directory to the myworkdir flag, or alternative change working directory.",sep="\n"))
			}
		inputdatadir		<- paste(inputdatadir,"Combined_data",sep="/")
		}else{
		if(!dir.exists(myworkdir))
			{
			cat("Directory specified to the myworkdir does not exist.",sep="\n")
			}else{
			inputdatadir	<- myworkdir
			cat("The SambaR directory of the combined dataset will be created in the directory (specified to the 'myworkdir' flag):",sep="\n")
			cat(inputdatadir,sep="\n")
			if(!do_continue)
				{
				return(cat("If this is correct, set the flag do_continue to TRUE. Specify another directory to the myworkdir flag, or alternative change working directory.",sep="\n"))
				}
			inputdatadir	<- paste(inputdatadir,"Combined_data",sep="/")
			}
		}
	# Note: provide input to mylist1 and mylist2 without quotes
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(mycolours))
		{
		return(cat("ERROR: You have to provide the colours of all populations to combine, in alphabetical order of population names",sep="\n"))
		}
	ncolours					<- length(mycolours)
	### rename datasets:
	mydataset1.snps				<- mylist1$snps
	mydataset1.inds				<- mylist1$inds
	mydataset1.genlight			<- mylist1$genlight
	mydataset1.populations		<- mylist1$populations
	mydataset2.snps				<- mylist2$snps
	mydataset2.inds				<- mylist2$inds
	mydataset2.genlight			<- mylist2$genlight
	mydataset2.populations		<- mylist2$populations
	#
	if(any(!colnames(as.matrix(mydataset1.genlight))==mydataset1.snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column for dataset1. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mydataset2.genlight))==mydataset2.snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column for dataset2. Contact developer of SambaR.",sep="\n"))
		}
	# combine populations vectors:
	if(!silent){cat("Combine population vectors.",sep="\n")}
	populationscombi		<- as.vector(unique(c(mydataset1.populations,mydataset2.populations)))
	populationscombi		<- populationscombi[order(populationscombi)]
	if(length(populationscombi)!=ncolours)
		{
		return(cat("ERROR: Number of colours does not match overall number of populations in both datasets.",sep="\n"))
		}
	# How many individuals?
	n_ind1						<- nrow(mylist1$inds)
	n_ind2						<- nrow(mylist2$inds)
	n_both						<- n_ind1+n_ind2
	cat(paste("Dataset 1 contains",n_ind1,"individuals.",sep=" "),sep="\n")
	cat(paste("Dataset 2 contains",n_ind2,"individuals.",sep=" "),sep="\n")
	cat(paste("Combined dataset will contain",n_both,"individuals.",sep=" "),sep="\n")
	#
	indnames1				<- as.character(mydataset1.inds$name)
	indnames2				<- as.character(mydataset2.inds$name)
	if(any(indnames1%in%indnames2))
		{
		cat("ERROR: the two datasets contain one or more samples with the same name, which is not allowed.")
		cat("The findoverlap function is designed to merge datasets containing different individuals.",sep="\n")
		return(cat("If the individuals are different but one or more happen to have the same name, please renames these individuals before running the findoverlap function.",sep="\n"))
		}
	popnames1				<- as.character(mydataset1.inds$pop)
	popnames2				<- as.character(mydataset2.inds$pop)
	if(any(popnames1%in%popnames2))
		{
		cat("ERROR: the two datasets contain one or more populations with the same name, which can causes problems when running the findoverlap function.")
		return(cat("Please rename these populations before running the findoverlap function.",sep="\n"))
		}
	#
	cat("Searching for SNPs present in both datasets...",sep="\n")
	### find overlapping snps (snps which occur in both datasets)
	snpstemp1				<- mydataset1.snps[mydataset1.snps$uniqpos,c("chr","pos")]
	snpstemp2				<- mydataset2.snps[mydataset2.snps$uniqpos,c("chr","pos")]	
	snpstemp1_name			<- mydataset1.snps[mydataset1.snps$uniqpos,c("chr","pos","name")]
	snpstemp2_name			<- mydataset2.snps[mydataset2.snps$uniqpos,c("chr","pos","name")]	
	chroms					<- as.vector(unique(snpstemp2$chr))
	common					<- list()
	howmany					<- vector()
	for (i in c(1:length(chroms)))
		{ 
		chro				<- chroms[i]
		temp1				<- snpstemp1$pos[snpstemp1$chr==chro]
		temp2				<- snpstemp2$pos[snpstemp2$chr==chro]	
		temp3				<- intersect(temp1,temp2)
		common[[i]]			<- temp3
		howmany[i]			<- length(temp3)
		}
	names(common)			<- chroms
	#sum(howmany)
	#
	### select the overlapping snps:
	mychroms				<- rep(chroms,howmany)
	mypos					<- unlist(common,use.names=FALSE)
	myoverlap				<- cbind(mychroms,mypos)
	myoverlap				<- as.data.frame(myoverlap)
	myoverlap				<<- myoverlap
	n_overlap				<- nrow(myoverlap)
	if(n_overlap>0)
		{
		cat(paste("Found",n_overlap,"SNPs shared between both datasets.",sep=" "),sep="\n")
		cat("Creating new dataset with shared SNPs...",sep="\n")
		}else{
		return(cat("The datasets don't have any loci in common. No new output files will be created.",sep="\n"))
		}
	### integrate boolean column (overlap yes or no) into input snp datasets:
	# into the first:
	snps					<- snpstemp1[,c("chr","pos")]
	snps$overlap			<- rep(NA,nrow(snps))
	for (i in c(1:nrow(myoverlap))) 
		{
		mychrom				<- as.vector(myoverlap$mychrom[i])
		mypos				<- as.numeric(as.vector(myoverlap$mypos[i]))
		snps$overlap[snps$chr==mychrom&snps$pos==mypos]<-TRUE	 
		}
	snps$overlap[is.na(snps$overlap)]<-FALSE
	snps$uniq				<- rep(NA,nrow(snps))
	for(j in c(1:nrow(snps)))
		{
		if(j==1)
			{
			snps$uniq[j]	<- TRUE
			}else{
			prevchrom		<- snps$chr[j-1]
			prevpos			<- snps$pos[j-1]
			currentchrom	<- snps$chr[j]
			currentpos		<- snps$pos[j]
			dupli			<- prevchrom==currentchrom&prevpos==currentpos
			snps$uniq[j]	<- ifelse(dupli,FALSE,TRUE)
			}
		}
	mygenlight				<- mydataset1.genlight[,mydataset1.snps$uniqpos]
	temp					<- as.matrix(mygenlight)
	overlap1				<- temp[,snps$overlap&snps$uniq]
	genlightpos1			<- colnames(overlap1) 
	snppos1					<- snpstemp1_name$name[snps$overlap&snps$uniq]
	# into the second:
	snps					<- snpstemp2[,c("chr","pos")]
	colnames(snps)			<- c("chr","pos")
	snps$overlap			<- rep(NA,nrow(snps))
	for (i in c(1:nrow(myoverlap))) 
		{
		mychrom				<- as.vector(myoverlap$mychrom[i])
		mypos				<- as.numeric(as.vector(myoverlap$mypos[i]))
		snps$overlap[snps$chr==mychrom&snps$pos==mypos] <-TRUE	 
		}
	snps$overlap[is.na(snps$overlap)] 	<-FALSE
	snps$uniq				<- rep(NA,nrow(snps))
	for(j in c(1:nrow(snps)))
		{
		if(j==1)
			{
			snps$uniq[j]	<- TRUE
			}else{
			prevchrom		<- snps$chr[j-1]
			prevpos			<- snps$pos[j-1]
			currentchrom	<- snps$chr[j]
			currentpos		<- snps$pos[j]
			dupli			<- prevchrom==currentchrom&prevpos==currentpos
			snps$uniq[j]	<- ifelse(dupli,FALSE,TRUE)
			}
		}
	mygenlight				<- mydataset2.genlight[,mydataset2.snps$uniqpos]
	temp					<- as.matrix(mygenlight)
	overlap2				<- temp[,snps$overlap&snps$uniq]
	genlightpos2			<- colnames(overlap2) 
	snppos2					<- snpstemp2_name$name[snps$overlap&snps$uniq]
	#
	# combine inds datasets:
	inds1					<- mydataset1.inds[,c("name","pop","popcol")]
	inds2					<- mydataset2.inds[,c("name","pop","popcol")]	
	indscombi				<- rbind(inds1,inds2)
	indscombi$nr			<- c(1:nrow(indscombi))
	indscombi$name2			<- NA
	poporder				<- as.character(unique(indscombi$pop))
	indscombi$poporder		<- factor(indscombi$pop,levels=poporder)
	#	
	if(grepl(".",as.vector(indscombi$name[1])))
		{
		for (i in c(1:nrow(indscombi)))
			{
			indscombi$name2[i]	<- strsplit(as.vector(indscombi$name[i]), "[.]")[[1]][1]
			}
		}else{
		indscombi$name2			<- substr(indscombi$name,start=1,stop=12)
		}
	for (i in c(1:nrow(indscombi))) 
		{
		indscombi$popcol[i]		<- mycolours[which(populationscombi==indscombi$pop[i])]
		}
	indscombi$pop2			<- indscombi$pop
	#
	# combine genlight objects:
	alloverlap				<- rbind(overlap1,overlap2)
	genlightcombi			<- as.genlight(alloverlap)
	# combine snp datasets:
	snpscombi				<- myoverlap
	colnames(snpscombi)		<- c("chr","pos")
	#
	# add additional columns to snps:
	snpscombi$name			<- paste(snpscombi$chr,snpscombi$pos,sep="_")
	mydataset1.snps$name2	<- paste(mydataset1.snps$chr,mydataset1.snps$pos,sep="_")
	mydataset2.snps$name2	<- paste(mydataset2.snps$chr,mydataset2.snps$pos,sep="_")
	snpstemp1				<- mydataset1.snps[mydataset1.snps$uniqpos,c("name2","minor","major")]
	snpstemp2				<- mydataset2.snps[mydataset2.snps$uniqpos,c("name2","minor","major")]
	colnames(snpstemp1)		<- c("name","minor_data1","major_data1")
	colnames(snpstemp2)		<- c("name","minor_data2","major_data2")
	merged1					<- merge(x = snpscombi, y = snpstemp1, by="name", all.x=TRUE)
	merged2					<- merge(x = merged1, y = snpstemp2, by="name", all.x=TRUE)
	snpscombi				<- merged2
	snpscombi$name			<- as.factor(snpscombi$name)
	snpscombi$uniqpos		<- TRUE			# safe to assume? needed to run filters function later.
	snpscombi$samepos		<- FALSE
	snpscombi$depthfilter	<- TRUE
	snpscombi$poly			<- TRUE
	snpscombi$placed		<- TRUE
	snpscombi$name_dataset1	<- snppos1
	snpscombi$name_dataset2	<- snppos2
	snpscombi$stackbp_dataset1	<- NA
	snpscombi$stackbp_dataset2	<- NA
	for(j in c(1:nrow(snpscombi)))
		{
		snpscombi$stackbp_dataset1[j]	<- strsplit(as.character(snpscombi$name_dataset1[j]),split='_', fixed=TRUE)[[1]][2]
		snpscombi$stackbp_dataset2[j]	<- strsplit(as.character(snpscombi$name_dataset2[j]),split='_', fixed=TRUE)[[1]][2]
		}
	snpscombi$samestackbp	<- snpscombi$stackbp_dataset1==snpscombi$stackbp_dataset2
	my_overlap				<<- data.frame("snpname1"=snppos1,"genlightname1"=genlightpos1,"snpname2"=snppos2,"genlightname2"=genlightpos2,"pos"=snpscombi$name)
	#
	# now we have to check for each locus whether the datasets had the same minor allele or whether it is reversed:
	snpscombi$minorequal	<- snpscombi$minor_data1==snpscombi$minor_data2
	snpscombi$majorequal	<- snpscombi$major_data1==snpscombi$major_data2
	snpscombi$inversed		<- (snpscombi$major_data1==snpscombi$minor_data2)&(snpscombi$minor_data1==snpscombi$major_data2)
	n_equal	 				<- nrow(snpscombi[snpscombi$minorequal&snpscombi$majorequal,])
	n_inverse				<- nrow(snpscombi[snpscombi$inversed,])
	cat(paste(n_equal," out of ",n_overlap," SNPs have corresponding minor and major alleles among the two input datasets.",sep=""),sep="\n")
	cat(paste(n_inverse," out of ",n_overlap," SNPs have inversed minor and major alleles.",sep=""),sep="\n")
	cat("Correcting for inversed minor allele frequencies...",sep="\n")
	# make a correction for inversed mafs in genlight object:
	# inversion is done for individuals of mypops2 (rather than for individuals of mypops1)
	# 03072019: to improve: inversion should be done based on which dataset is bigger. i.e. n_ind1 > nind2
	mypopmatrix 			<- as.matrix(genlightcombi[which(indscombi$pop %in% mylist2$populations),])
	otherpopsmatrix 		<- as.matrix(genlightcombi[which(indscombi$pop %in% mylist1$populations),])
	for (i in c(1:(ncol(mypopmatrix))))
		{
		if (snpscombi$inversed[i])
			{
			# edit data in genlight object:
			temp				<- mypopmatrix[,i]
			temp[temp==0]		<- 3
			temp[temp==2]		<- 0
			temp[temp==3]		<- 2
			mypopmatrix[,i]		<- temp
			}
		}
	if(!silent){cat("Recombining...",sep="\n")}
	combinedmatrix			<- rbind(mypopmatrix,otherpopsmatrix)
	genlightcombi			<- as.genlight(combinedmatrix)
	genlightcombi@pop		<- as.factor(indscombi$pop)
	snpscombi$minor			<- snpscombi$minor_data1
	snpscombi$major			<- snpscombi$major_data1
	snpscombi$minor2		<- NA
	snpscombi$major2		<- NA
	snpscombi$nr_neworder	<- c(1:nrow(snpscombi))	
	for(i in c(1:nrow(snpscombi)))
		{
		snpscombi$minor2[i]		<- c("A","C","G","T")[snpscombi$minor[i]]
		snpscombi$major2[i]		<- c("A","C","G","T")[snpscombi$major[i]]
		}
	#
	# reorder data based on individual names:
	if(!silent){cat("Reorder based on names of individuals...",sep="\n")}
	indscombi$name	<- as.character(indscombi$name)
	indscombi		<- indscombi[order(indscombi$name),]
	indscombi$nr	<- c(1:nrow(indscombi))
	# reorder genlight object based on individual names:
	matrixtemp		<- as.matrix(genlightcombi)
	tempnames		<- rownames(matrixtemp)	
	matrixtemp2		<- matrixtemp[order(tempnames),]
	genlightcombi	<- as.genlight(matrixtemp2)
	# 
	# change colnames of genlight matrix:
	if(!silent){cat("Edit snpnames in new genlight object...",sep="\n")}
	matrixtemp			<- as.matrix(genlightcombi)
	colnames(matrixtemp)<- snpscombi$name
	genlightcombi		<- as.genlight(matrixtemp)
	#
	# store objects in new Sambar list object:
	cat("Creating new sambar list and output directories...",sep="\n")
	cat("Overwriting existing mysambarcombined-list if already present.",sep="\n")
	mysambarcombined				<<- list()
	mysambarcombined$populations	<<- populationscombi
	mysambarcombined$inds			<<- indscombi
	mysambarcombined$snps			<<- snpscombi
	mysambarcombined$genlight		<<- genlightcombi 
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambarcombined[[5]]	<<- inputdatadir
	mysambarcombined[[6]]	<<- sambardir
	mysambarcombined[[7]]	<<- QCdir
	mysambarcombined[[8]]	<<- structuredir
	mysambarcombined[[9]]	<<- divergencedir
	mysambarcombined[[10]]	<<- diversitydir
	mysambarcombined[[11]]	<<- demographydir
	mysambarcombined[[12]]	<<- selectiondir
	mysambarcombined[[13]]	<<- inputfilesdir
	mysambarcombined[[14]]	<<- "sans"
	mysambarcombined[[17]]	<<- mycolours
	mysambarcombined[[18]]	<<- geomapsdir
	names(mysambarcombined)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambarcombined$populations2	<<- mysambarcombined$populations	# needed for excludepop()
	mysambarcombined$poporder		<<- mysambarcombined$populations2	# needed for excludepop()
	mysambarcombined$poporder2		<<- mysambarcombined$populations2	# needed for excludepop()
	mysambarcombined$mycolours2		<<- mysambarcombined$mycolours		# needed for excludepop()
	defaultcolours2					<- defaultcolours[!defaultcolours%in%mycolours]
	mysambarcombined$defaultcolours	<<- defaultcolours2
	mysambarcombined$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambarcombined$datasource		<<- "intersectdata"
	#
	cat("Datasets with shared loci have been written to a list object called 'mysambarcombined'.",sep="\n")
	cat("New (still empty) output folders have been created at:",sep="\n")
	cat(inputdatadir,sep="\n")
	#
	cat("Checking if the objects of the new dataset (inds,snps,genlight) correspond with each other...",sep="\n")
	if(nrow(indscombi)!=nrow(as.matrix(genlightcombi)))
		{
		ninds		<- nrow(indscombi)
		ngenlight	<- nrow(nrow(as.matrix(genlightcombi)))	
		cat("ERROR: number of rows of new inds dataframe does not correspond with number of rows of new genlight object. Contact developer of SambaR.",sep="\n")
		cat(paste("Number of individuals in new inds dataset: ",ninds,".",sep=""),sep="\n")
		cat(paste("Number of individuals in new genlight object: ",ngenlight,".",sep=""),sep="\n")
		}
	if(any(!row.names(as.matrix(genlightcombi))==as.vector(indscombi$name)))
		{
		cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n")
		return(cat("To compare both vectors, type 'rownames(as.matrix(mysambarcombined$genlight))' and 'mysambarcombined$inds$name'.",sep="\n"))
		}
	if(nrow(snpscombi)!=ncol(as.matrix(genlightcombi)))
		{
		nsnps		<- nrow(snpscombi)
		ngenlight	<- nrow(ncol(as.matrix(genlightcombi)))	
		cat("ERROR: number of rows of new snps dataframe does not correspond with number of columns of new genlight object. Contact developer of SambaR.",sep="\n")
		cat(paste("Number of snps in new snps dataset: ",ninds,".",sep=""),sep="\n")
		cat(paste("Number of snps in new genlight object: ",ngenlight,".",sep=""),sep="\n")
		}
	if(any(is.na(snpscombi$genlightname)))
		{
		cat("WARNING: NA-values in snps$genlightname column.",sep="\n")
		}
	if(any(!colnames(as.matrix(genlightcombi))==snpscombi$genlightname))
		{	
		cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n")
		return(cat("To compare both vectors, type 'colnames(as.matrix(mysambarcombined$genlight))' and 'mysambarcombined$snps$genlightname'.",sep="\n"))
		}
	cat("Everything seems fine :-)",sep="\n")
	#	
	if(combine_divstats)
		{
		cat("Combining genetic diversity scores...",sep="\n")
		# combine TajimaD scores:
		taj1	<- read.table(paste(mylist1$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),header=TRUE)
		taj2	<- read.table(paste(mylist2$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),header=TRUE)
		tajboth	<- rbind(taj1,taj2)
		tajboth <- tajboth[order(as.character(tajboth$pop)),]
		write.table(tajboth,paste(mysambarcombined$diversitydir,"TajimaD.statistics.perpop_nonsharedsnps.txt",sep="/"),row.names=FALSE,col.names=TRUE,quote=FALSE)
		# combine SFS scores:	
		if(length(mylist1$populations)>1)
			{
			sfs1	<- read.table(paste(mylist1$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=TRUE)
			}else{
			sfs1	<- read.table(paste(mylist1$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=FALSE)
			sfs1	<- as.data.frame(t(sfs1))[2,]
			colnames(sfs1)	<- c("X0.05","X0.15","X0.25","X0.35","X0.45")
			rownames(sfs1)	<- mylist1$populations
			}
		if(length(mylist2$populations)>1)
			{
			sfs2			<- read.table(paste(mylist2$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=TRUE)
			}else{
			sfs2			<- read.table(paste(mylist2$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=FALSE)
			sfs2			<- as.data.frame(t(sfs2))[2,]
			colnames(sfs2)	<- c("X0.05","X0.15","X0.25","X0.35","X0.45")
			rownames(sfs2)	<- mylist2$populations
			}
		sfsboth	<- rbind(sfs1,sfs2)
		my_pops	<- as.vector(c(mylist1$populations,mylist2$populations))
		sfsboth <- sfsboth[order(my_pops),]
		write.table(sfsboth,paste(mysambarcombined$diversitydir,"SFS.binned.percentages_nonsharedsnps.txt",sep="/"),row.names=FALSE,col.names=TRUE,quote=FALSE)
		}
	#
	# Print info on screen:
	cat("To start working with the data, type getdata('mysambarcombined') and run the filterdata() function.",sep="\n")
	cat("To see the names of the overlapping snps, type: 'my_overlap'.",sep="\n")
	}

# Add output/results from other programs to inds or snps dataframe:
# The getfrom-input should be a matrix/dataframe with one line per snp/sample.
# This function needs updating, by including 'filterdata()' function in the end 

merger<-function(addtoinds=TRUE,getfrom,idto,idfrom,newdata,removecheck=FALSE)
	{
	if(addtoinds==TRUE)
		{
		getfrom$idcheck	<- getfrom[,idfrom]
		names(getfrom)[names(getfrom) == idfrom] <- idto
		inds 		<<- merge(x = inds, y = getfrom[,c(idto,"idcheck",newdata)], by = idto, all = TRUE)
		if(removecheck)
			{
			inds$idcheck<-NULL
			}
		}else{
		getfrom$idcheck	<- getfrom[,idfrom]
		names(getfrom)[names(getfrom) == idfrom] <- idto
		snps 		<<- merge(x = snps, y = getfrom[,c(idto,newdata)], by = idto, all = TRUE)
		if(removecheck)
			{
			inds$idcheck<-NULL
			}
		}
	}

# Possibly include check:
# check	<-!is.na(inds[,idto]==inds$idcheck)
# if(any(check==FALSE))
#	{
#	print("Something seems to have gone wrong. Compare 'idcheck'-column to original identifier column.")
#	}
 

################### MANAGE PLOTS ###################

# Change colour sets:
# length of colvector should correspond to length of populations vector
editcol<-function(colvector,popnames=mysambar$populations)
	{
	mysambar$mycolours	<<- colvector
	pops<- as.character.factor(unique(inds$pop))
	for (i in (1:(length(popnames))))
		{
		for (j in (1:length(inds$pop)))
			{
			if (inds$pop[j]==pops[i])
				{
				inds$popcol[j] <<- colvector[i]
				}
			}
		}
	}

getfonts<-function(importfonts=FALSE)
	{
	if("extrafont" %in% rownames(installed.packages()) == FALSE) {install.packages("extrafont",repos=myrepos)}					# needed for 'Arial' font type in plots 
	library(extrafont)
	if(importfonts)
		{
		font_import(prompt=FALSE)
		}
	loadfonts(quiet = TRUE)											# load for PDF
	loadfonts(device = "postscript",quiet = TRUE)					# load for eps
	}







######################### RELATEDNESS ###########################

# Needs input file generated by plink -genome (with estimates of pi_hat)
relatedness<-function(infile="plink.genome",popnames=populations)
	{	
	# Read table and add a column to indicate whether individuals are from same population:
	ibd				<- read.table(infile,header=TRUE)
	ibd$samepop		<- ibd$FID1==ibd$FID2
	# Pairwise population comparisons:
	combitable		<- combn(popnames,m=2)
	# Make vector for names of between population comparisons (one way):
	combivector1		<- paste(combitable[1,],combitable[2,],sep="_")	
	# Make vector for names of between population comparisons (the other way):
	combivector2		<- paste(combitable[2,],combitable[1,],sep="_")	
	# Make vector for names of within population comparisons:
	combivector3		<- vector()
	samepopmean			<<- vector()
	diffpopmean1		<<- vector()
	diffpopmean2		<<- vector()
	for (i in (1:length(popnames)))
		{
		combivector3[i]	<- paste(popnames[i],popnames[i],sep="_")
		}
	##### Create an empty list to save results:
	results 		<<- list()
	##### How many relatives does a individual have within it's own population?
	for (i in (1:length(combivector3)))
		{
		# select all rows with pi above 0.1825 and column for samepop is TRUE:
		ibdwithin			<- ibd[ibd$PI_HAT>0.1825&ibd$samepop&ibd$FID1==popnames[i],]
		ibdwithinall		<- ibd[ibd$samepop&ibd$FID1==popnames[i],]
		samepopmean[i]		<<- mean(ibdwithinall$PI_HAT,na.rm=TRUE)
		# select columns with individual names, and sort on alphabetical and numerical order:
		relativeswithin		<- sort(c(ibdwithin$IID1,ibdwithin$IID2))
		# assign(paste("ibdwithin",popnames[i],sep="_"),relativeswithin)
		# If sample occurs more than once, it is listed more than once. To collapse, make a table (which we save):
		results[[i]]		<<- table(relativeswithin)
		}
	##### How many relatives does a sample has within any other populations?
	ibdbetween		<- ibd[ibd$PI_HAT>0.1825&ibd$samepop=="FALSE",]
	ibdbetweenall	<- ibd[ibd$samepop=="FALSE",] 
	# For one direction of pairwise comparisons (how many relatives do individuals in pop A have with pop B?)
	for (i in (1:length(combivector1)))
		{
		diffpopmean1[i]		<<- mean(ibdbetweenall$PI_HAT[ibdbetweenall$FID1==combitable[1,i]&ibdbetweenall$FID2==combitable[2,i]],na.rm=TRUE)
		relativesbetween<-c(ibdbetween$IID1[ibdbetween$FID1==combitable[1,i]&ibdbetween$FID2==combitable[2,i]],ibdbetween$IID2[ibdbetween$FID2==combitable[1,i]&ibdbetween$FID1==combitable[2,i]])
		results[[i+length(combivector3)]]	<<- table(relativesbetween)
		}
	# For the other direction of pairwise comparison (how many relatives do individuals in pop B have with pop A?)
	for (i in (1:length(combivector2)))	
		{
		diffpopmean2[i]		<<- mean(ibdbetweenall$PI_HAT[ibdbetweenall$FID1==combitable[2,i]&ibdbetweenall$FID2==combitable[1,i]],na.rm=TRUE)
		relativesbetween<-c(ibdbetween$IID1[ibdbetween$FID1==combitable[2,i]&ibdbetween$FID2==combitable[1,i]],ibdbetween$IID2[ibdbetween$FID2==combitable[2,i]&ibdbetween$FID1==combitable[1,i]])
		results[[i+length(combivector3)+length(combivector1)]]	<<- table(relativesbetween)
		}
	##### Give names to list elements:
	# This has to be after the last loop, otherwise names are overwritten.
	combivector	<- c(combivector3,combivector1,combivector2)
	list.names	<- as.list(combivector)
	names(results)	<<- list.names
	# The results output table shows for each individual (indicated by nr) how many relatives they have in the other population.   
	}


############################# PLOTS ###############################


# Boxplot sample inbreeding coefficients per population:  
F_boxplot<-function(export=FALSE,exportname="filtereddata",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	if(!(any(names(inds)=="F")))
		{
		print("This function can only be executed if the 'inds'-dataframe contains a column (called 'F') with inbreeding coefficients. This estimates can be generated with PLINK.")
		}
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"F.wmf",sep = "."))}
	graphics.off()
	boxplot(inds$F~inds$pop,na.rm=TRUE,col=unique(colourcode),ylab="Inbreeding coefficient F",xlab="Populations",frame=F)
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"F.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}


##### Functions to plot individual heterozygosities:

##### Boxplot:
He_boxplot<-function(export=FALSE,exportname="filtereddata",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	if(!(any(names(inds)=="hetero")))
		{
		print("This function can only be executed if the 'inds'-dataframe contains a column (called 'hetero') with sample heterozygosities. This estimates can be generated with the 'heterozygosities'-function.")
		}
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"Heboxplot.wmf",sep = "."))}
	graphics.off()
	boxplot(inds$hetero[inds$filter]~inds$pop[inds$filter],notch=FALSE,col=unique(colourcode),main=NULL, xlab="Populations",ylab="Sample heterozygosity") 
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"Heboxplot.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}


# Ugly plot:
##### Histogram (with optionally distinction between X-chromosome and autosomal chromosomes):
He_histo<-function(export=FALSE,exportname="mygenlight",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"indhe.wmf",sep = "."))}
	# Some prep:
	mymax	<- max(inds$hetero)
	if(max(inds$hetero)>0.5)
		{
		breakpoints<-seq(0,mymax+0.05,0.01)
		}else{
		breakpoints<-seq(0,0.5,0.01)
		}
	graphics.off()
	par(mfrow=c(1,length(popnames)),mai=c(0.75,0.75,0.125,0.25),oma=c(1,0,1,0))
	for (i in (1:length(popnames)))
		{
		hist(inds$hetero[inds$pop==popnames[i]&inds$filter],breaks=breakpoints,col=colourcode[inds$pop==popnames[i]&inds$filter],lty=0,xlim=c(0,mymax),ylim=yrange,xlab=NULL,ylab="# individuals",main=popnames[i])
		if(length(snps$chr[snps$chr=="X"])>0)
			{
			hist(inds$heteroX[inds$pop==popnames[i]&inds$filter],breaks=breakpoints,add=T,col=NULL,main=NULL,ylim=yrange,xlab=NULL,ylab=NULL)
			mtext("Individual heterozygosities for autosomal (filled bar) and X-chromosome (open bar)", side = 1, outer = TRUE,line=-1.5)
			}else{
			mtext("Individual heterozygosities", side = 1, outer = TRUE,line=-1.5)
			}
		}
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"indhe.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}

################################################################











############################### START OF SIMULATION SECTION ###############################

# Use R package 'MetaPopGen':
# Vector of number of alleles and mutation rate per locus:
runmpg<-function(do_install=FALSE,asexual=TRUE,u=1.2*10^-8,nloci=2,do_analyses=FALSE,r_rate=0.5,tmax=10,runcommands=FALSE)
	{
	# limitation: at maximum 26 loci. In reality even less, due to memory allocation error.
	if(do_install)
		{
		devtools::install_github('MarcoAndrello/MetaPopGen-2.0')
		}
	#
	# DEFINE SETTINGS:
	if(runcommands)
		{
		nloci=2;r_rate=0.5;tmax=10;u=1.2*10^-8;asexual=TRUE
		}
	ndemes		<- 3						# number of demes
	k			<- 100						# carrying capacity per deme
	n_age		<- 1						# number of age classes
	u_gen		<- u*k
	mu_vec		<- rep(u_gen,nloci)			# The mutation rate for each locus (mu)
	r_rate		<- ifelse(nloci>2,0.5,r_rate)					# The recombination rate r (has to be 0.5 in case of more than 2 loci, so assuming independence)
	mysex		<- ifelse(asexual,"monoecious","dioecious")
	nalleles	<- 2
	allele_vec	<- rep(nalleles,nloci)
	init.par 	<- initialize.multilocus(allele_vec=allele_vec,mu=mu_vec,r=r_rate,n=ndemes,z=n_age,kappa0=k,sexuality=mysex)
	#
	# edit starting frequencies:
	ngeno				<- nrow(init.par$N)
	init.par$N1[,,] 	<- 0
	init.par$N1[1,1,1] 	<- k		# deme1 (column 1)
	init.par$N1[1,2,1] 	<- k		# deme2 (column 2)
	init.par$N1[ngeno,3,1] 	<- k	# deme3 (column 3)
	#
	# survival probabilities:
	sigma 				<- array(0.75,c(init.par$m,init.par$n,init.par$z,tmax))
	name.dim 			<- dimnames(init.par$N1)
	name.dim$time 		<- c(1:tmax)
	dimnames(sigma) 	<- name.dim
	sigma				<<- sigma
	#
	# fecundities (number of gametes): 
	# Under the “fixed” option, each individual of genotype i of age x in deme j at time t produces exactly phi_F[i,j,x,t] and phi_M[i,j,x,t] gametes.
	# phi_M[i,j,x,t]: number of gametes of genotype i in deme j of age x at time t.
	phi_F 				<- array(30,c(init.par$m,init.par$n,init.par$z,tmax))
	phi_M 				<- array(100,c(init.par$m,init.par$n,init.par$z,tmax))
	dimnames(phi_F) 	<- dimnames(phi_M) <- name.dim
	#
	# migration rates:
	# in case of no migration:
	delta.ad 			<- diag(init.par$n)
	dimnames(delta.ad) 	<- list(destination=c(1:3),origin=c(1:3))
	#
	# propagule dispersal rates:
	#delta.prop 		<- matrix(c(0.9,0.4,0,0.1,0.5,0.1,0,0.1,0.9),nrow=3,ncol=3,byrow=T)
	delta.prop 			<- diag(init.par$n)
	dimnames(delta.prop)<- list(destination=c(1:3),origin=c(1:3))
	#
	# RUN SIMULATIONS:
	if(asexual)
		{
		res 			<- sim.metapopgen.monoecious.multilocus(init.par=init.par,sigma=sigma,phi_F=phi_F,phi_M=phi_M,delta.prop=delta.prop,delta.ad=delta.ad,T_max=tmax,output.var="N")
		}else{
		res 			<- sim.metapopgen.dioecious.multilocus(init.par=init.par,sigma=sigma,phi_F=phi_F,phi_M=phi_M,delta.prop=delta.prop,delta.ad=delta.ad,T_max=tmax,output.var="N")
		}
	res		<<- res
	cat("Output is stored in 'res'.",sep="\n")
	#
	# extract minor allele frequencies at last time point:
	# output structure: res$N[i,j,x,t]
	# i = genotype
	# j = deme
	# x = age_class
	# t = time_step
	#
	p			<<- matrix(NA,nrow=nloci,ncol=ndemes)
	colnames(p)	<<- paste("deme",c(1:ndemes),sep="")
	rownames(p)	<<- paste("locus",c(1:nloci),sep="")
	for (j in c(1:ndemes))
		{
		myfreqs	<- freq_alleles(res$N[,j,1,tmax],init.par)$frequencies
		p[,j]	<<- as.vector(do.call(rbind,myfreqs)[,1])
		}
	cat("Minor allele frequencies are stored in 'p'.",sep="\n")
	#
	# ANALYZE RESULTS:
	if(do_analyses)
		{
		# allele frequencies:
		# Expects a vector of allele frequencies. For example allele frequencies in deme 2, age 1 at time 5:
		freq_alleles(res$N[,2,1,5],init.par)
		#
		# genotype frequencies:
		freq_genotypes(res$N[,2,1,5],init.par)
		#
		# population differentiation:
		fst_multilocus(res$N[,,1,5],init.par)
		# 
		# See also other functions to calculate gamete frequencies (freq_gametes), observed and expected heterozygosities (het.obs and het.exp), and linkage disequilibrium (ld).
		}
	}

getsimpackages<-function ()
	{
	library(grid)
	library(gridGraphics)
	library(gridExtra)
	library(adegenet)
	library(OutFLANK) 
	library(pcadapt)
	library(gplots)
	}

fp<-function(nfp=5,nloci=1000,sigma=0.05,cum=FALSE,bonf=FALSE)
	{
	# n_fp is number of false positives
	n		<- seq(0,nloci,nloci/100)
	sigma	<- ifelse(bonf,sigma/nloci,sigma)
	if(!cum)
		{
		k			<- nfp
		pr			<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
		mytitle		<- paste("Probability of exactly",nfp,"false positives",sep=" ")
		plot(n,pr,type='l',ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		}else{
		mytitle		<- paste("Probability of maximum",nfp,"false positives",sep=" ")
		plot(n,n,ylim=c(0,1),type='l',col="white",ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		pr			<- rep(0,length(n))
		for(k in c(1:nfp))
			{
			pr_k	<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
			pr		<- pr+pr_k
			lines(n,pr_k,col="grey",lwd=2)
			}
		lines(n,pr,lwd=2)
		}
	}

fpratio<-function(fpratio=0.01,nloci=1000,sigma=0.05,cum=FALSE,bonf=FALSE,addnfp=TRUE)
	{
	# n_fp is number of false positives
	if(nloci>10000)
		{
		n	<- seq(0,nloci,nloci/100)
		}else{
		n	<- c(1:nloci)
		}
	sigma	<- ifelse(bonf,sigma/nloci,sigma)
	nfppern	<- round(fpratio*n)
	nfp		<- as.vector(unique(nfppern))
	nfp		<- nfp[2:length(nfp)]	# no zero's
	if(!cum)
		{
		k			<- nfp
		pr			<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
		mytitle		<- paste("Probability of proportion of",fpratio,"false positives",sep=" ")
		plot(n,pr,type='l',ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		if(addnfp)
			{
			par(new=TRUE)
			plot(n,nfppern,xaxt='n',yaxt='n',col="darkgrey",type='l',lty=2)
			axis(side=4)
			}
		}else{
		mytitle		<- paste("Probability of maximum proportion of",fpratio,"false positives",sep=" ")
		plot(n,n,ylim=c(0,1),type='l',col="white",ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		pr			<- rep(0,length(n))
		for(k in nfp)
			{
			pr_k	<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
			pr		<- pr+pr_k
			lines(n,pr_k,col="grey",lwd=2)
			}
		lines(n,pr,lwd=2)
		if(addnfp)
			{
			par(new=TRUE)
			plot(n,nfppern,xaxt='n',yaxt='n',col="darkgrey",type='l',lty=2)
			axis(side=4)
			}
		}
	}
	
# Execute by typing:
# outliersim()
# outliersim(nloc=10,ngen=14,nesourcepop=1000,nefounderpop1=rep(50,14),nefounderpop2=rep(60,14),nfounders=5,samplesize=30,testgeno=FALSE)

#realmean 	<- mean(snps$rfisherlogp_pheno[snps$filter2&!(snps$rfisherout_pheno)])
#realsd		<- sd(snps$rfisherlogp_pheno[snps$filter2&!(snps$rfisherout_pheno)])


# install.packages('vcd')
# library(vcd)
# install.packages('MASS')
# library(MASS)
# mylogp		<- snps$rfisherlogp_pheno[snps$filter2]
# ks.test(mylogp, "pexp",mean(mylogp))
# hist(mylogp, freq = FALSE, breaks = 100, xlim = c(0, quantile(mylogp, 0.99)))
# curve(dexp(mylogp, rate = mylogp), col = "red", add = TRUE)	# unfortunately it doesn't work

# Table with expected p-value frequencies:
# logpfreq

# To plot simulated Fisher exact test p-values:
# plot(logp[4,])

# One thing you could do is to compare the number of outliers (loci with pass a certain pvalue threshold) to the expected number.
# For this you can use another Fisher exact test, for example.
# However, this is about the expected number of outliers.
# What we want to know is: how confident can we be that our single outlier is not a false positive?

# Better therefore is to calculate the expected number of outliers per pairwise comparison.
# Then you can use this number to calculate the change it would occur in both populations at same locus.
# For example, if the outlier snp has this expected frequency in our two pairwise comparisons:
#		logp-value	freq
# Busen-Norway	18		0.02945
# Barff_Norway	12		0.00010
# Could we argue that the chance of observing this combination at least once is: 20000*0.02945*0.00010?.
# This chance by the way is 0.0589. 

# Maybe a better way forward is to look at how the signal stands out.
# e.g. if the signal wouldn't be there, what would be the next max logpvalue?
# Or: in terms of standard deviations? 
# Can we mimic a similar signal by simulating selection?
# To see what happens if every generation in both Busen and Barff the maf is multiplied by 1.1 (after random shuffling):
# outliersim(s=1.1)
# plot(logp[4,])
# logp[1:5,1990:2000]





###### User-defined function:

# These are mostly census sizes:
setsizes<-function()
	{
	popsize1	<<-c(7,10,15,25,30,35,40,80,100,200)
	popsize2	<<-rep(500,10)
	popsizeBusen<<-c(popsize1,popsize2)
	popsize1	<<-c(10,20,60,100,140,280,360,400,450,500)
	popsize2	<<-rep(500,10)
	popsizeBarff<<-c(popsize1,popsize2)
	popsizeNorway<<-rep(1000,ngen)
	# Bottlenecks should be more severe
	popsize1	<<-c(3,3,4,4,6,6,10,20,40,200)
	popsize2	<<-rep(500,10)
	popsizeBusen	<<-c(popsize1,popsize2)
	popsize1	<<-c(5,5,6,6,8,8,15,30,80,400)
	popsize2	<<-rep(500,10)
	popsizeBarff	<<-c(popsize1,popsize2)
	popsizeNorway<<-rep(1000,ngen)
	}

getsimdata<-function(n_loci=50000,n_selectedloci=1000,which_comparison=3,get_power=TRUE)
	{
	n_gen					<- 20
	selcoefvector			<- seq(0,0.2,0.025)  
	nevector				<- seq(20,200,20)
	allcombi				<- as.data.frame(expand.grid(selcoefvector,nevector, stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("s","ne")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	mean_source_maf			<- 0.15
	parallelsel				<- TRUE	
	#
	current_dir				<- getwd()
	simdata_resultslist		<<- list() 
	simdata_results			<<- matrix(NA,nrow=nruns,ncol=10)
	#
	# get files:
	for(myrun in c(1:nruns))
		{
		sel_coef				<- allcombi$s[myrun]
		ne_F					<- allcombi$ne[myrun]
		n_gen					<- 
		cat(paste(sel_coef,ne_F,sep="_"),sep="\n")
		out_dir					<- paste("Simulated",n_sourcepop,ne_F,n_gen,ne_F,n_sample,n_loci,n_selectedloci,sel_coef,"in_both",sep=".")
		my_dir					<- paste(current_dir,out_dir,sep="/")
		setwd(my_dir)
		my_file					<- paste("Simulated",n_sourcepop,ne_F,n_gen,ne_F,n_sample,n_loci,n_selectedloci,sel_coef,"bothpop.testscores2.txt",sep=".")
		simdata_table			<<- read.table(my_file,header=TRUE,row.names = 1) 
		simdata_results[myrun,]	<<- c(unlist(simdata_table[which_comparison,]),sel_coef,ne_F) 
		simdata_resultslist[[myrun]]<<- simdata_table
		setwd(current_dir)
		}
	# get power:
	if(get_power)
		{
		colnames(simdata_results)	<<- c(colnames(simdata_table),"s","ne_F")
		testlist					<<- list()
		testlist[[1]]				<<- xtabs(gwds_power ~ s + ne_F, simdata_results)
		testlist[[2]]				<<- xtabs(OutFLANK_power ~ s + ne_F, simdata_results)
		testlist[[3]]				<<- xtabs(PCadapt_power ~ s + ne_F, simdata_results)
		testlist[[4]]				<<- xtabs(gwds_specificity  ~ s + ne_F, simdata_results)
		testlist[[5]]				<<- xtabs(OutFLANK_specificity  ~ s + ne_F, simdata_results)
		testlist[[6]]				<<- xtabs(PCadapt_specificity  ~ s + ne_F, simdata_results)
		}
	# get retained selected loci:
	retainedlist					<<- list()
	retainedlist[[1]]				<<- xtabs(loss_adaptive ~ s + ne_F, simdata_results)
	retainedlist[[2]]				<<- xtabs(loss_neutral ~ s + ne_F, simdata_results)
	setwd(current_dir)
	}

venn_sim<-function(export=FALSE)
	{
	setwd("C:/Users/Tatiana/Menno/ReindeerCombined/ReinasRef/Multiplesnpsperread/Stacksrefmap/Simulation_output/80000loci/Simulated.1000.10.20.50.30.80000.1000.0.1.in_both")
	gwdsout		<- as.vector(read.table("GWDS_pheno_outliers.txt")$V1)
	pcadaptout	<- as.vector(read.table("PCadapt_pheno_outliers.txt")$V1)
	#outflankout<- as.vector(read.table("OutFLANK_pheno_outliers.txt")$V1)	# no lines to read
	outflankout	<- vector()
	bayescanout	<- as.vector(read.table("Bayescan_pheno_outliers.txt")$V1)
	selectedloci<- paste(c(79001:80000),"L",sep="")
	#
	# plot:
	if(export){pdf("venn.simulated.pdf",height=6,width=8)}
	v1 <- venn.diagram(list(selected_loci=selectedloci,Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=2,cat.cex=2,fill=c("grey70","darkred","blue","darkgreen","orange"),col=c("grey70","darkred","blue","darkgreen","orange"),margin=0.15)
	grid.newpage()
	grid.draw(v1)
	if(export){dev.off()}
	}
	
runsim_power<-function(n_gen=50,n_loci=1000,mycorr="none",n_selectedloci=100,selcoefvector=c(0.05,0.1),nevector=c(50,100),founders_nr=NULL,do_export=TRUE,dohaploid=TRUE,my_comparison=1,n_sample=30,n_sourcepop=1000,mean_source_maf=0.15,parallelsel=TRUE,show_adjusted_p=FALSE,sdiscrete=TRUE) 
	{
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	cat("###### SETTINGS WHILST RUNNING RUNSIM_POWER ######",sep="\n")
	cat(paste("  Specified number of loci: ",n_loci,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",n_selectedloci,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficients: ",paste(selcoefvector,collapse=", "),".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",n_gen,".",sep=""),sep="\n")
	cat(paste("  Specified Ne source population: ",n_sourcepop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder populations: ",paste(nevector,collapse=", "),".",sep=""),sep="\n")
	cat(paste("  When calculating FN, FP and FDR for the pooled comparison, only consider SNPs which have been retained in both populations: ",parallelsel,".",sep=""),sep="\n")
	if(is.null(founders_nr))
		{
		cat("  No bottleneck specified (flag 'founders_nr' is set to NULL).",sep="\n")
		}else{
		cat(paste("  Specified number of founders: ",founders,".",sep=""),sep="\n")
		}
	cat(paste("  Specified samplesize: ",n_sample,".",sep=""),sep="\n")
	cat(paste("  Parallel selection: ",parallelsel,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",sdiscrete,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",dohaploid,".",sep=""),sep="\n")
	#
	allcombi			<- as.data.frame(expand.grid(selcoefvector,nevector,stringsAsFactors = FALSE))
	allcombi			<- as.data.frame(expand.grid(selcoefvector,nevector,stringsAsFactors = FALSE))
	multiplescenarios	<- ifelse(nrow(allcombi)>1,TRUE,FALSE)
	colnames(allcombi)	<- c("s","ne")
    nruns				<- nrow(allcombi)
    #
    # call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("loss_adaptive","loss_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2","gwds_FDR","OutFLANK_FDR","PCadapt_FDR")
	testresults				<- as.data.frame(matrix(NA,ncol=30,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	overlapresults			<- as.data.frame(matrix(NA,ncol=3,nrow=nruns))
	colnames(overlapresults)<- c("gwds","pcadapt","outflank")
	for(myrun in c(1:nruns))
		{
		sel_coef				<- allcombi$s[myrun]
		ne_F					<- allcombi$ne[myrun]
		if(is.null(founders_nr))
			{
			founders_nr			<- ne_F
			}
		cat(" ",sep="\n")
		cat(paste(sel_coef,ne_F,mycorr,sep="_"),sep="\n")
		mysettings				<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=do_export,mycorrection=mycorr,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,nefounderpop1=ne_F,nefounderpop2=ne_F,meansourcemaf=mean_source_maf,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_haploid=dohaploid,show_adjustedp=show_adjusted_p,s_discrete=sdiscrete)
		myscores				<- mysambarsim$mytestscores2[my_comparison,]
		fdrrates				<- mysambarsim$testFDR[my_comparison,]
		testresults[myrun,]		<- c(myscores,fdrrates,mysettings)
		overlapresults[myrun,]	<- round(apply(mysambarsim$overlapdf,1,mean),2)
		}
	# return table:
	# testresults		<<- testresults
	write.table(testresults,"Power_analysis.txt",quote=FALSE)
	# heatmap:
	if(multiplescenarios)
		{
		gwdspower		<- xtabs(gwds_power ~ s + ne_F, testresults)
		gwdsspec		<- xtabs(gwds_specificity  ~ s + ne_F, testresults)
		pcadaptpower	<- xtabs(PCadapt_power ~ s + ne_F, testresults)
		pcadaptspec		<- xtabs(PCadapt_specificity  ~ s + ne_F, testresults)
		outflankpower	<- xtabs(OutFLANK_power ~ s + ne_F, testresults)
		outflankspec	<- xtabs(OutFLANK_specificity  ~ s + ne_F, testresults)
		gwdsfdr			<- xtabs(gwds_FDR ~ s + ne_F, testresults)
		pcadaptfdr		<- xtabs(PCadapt_FDR ~ s + ne_F, testresults)
		outflankfdr		<- xtabs(OutFLANK_FDR ~ s + ne_F, testresults)
		graphics.off()
		#
		if(all(dim(gwdspower)>1))
			{
			cat("Generating heatmaps showing power and specificity scores...",sep="\n")
			if(do_export){pdf("Matrix_GWDS_power.pdf")}
			make_heatmap(mymatrix=round(gwdspower,2),myBreaks=seq(0,1,0.025),mytitle="power GWDS")
			if(do_export){dev.off()}	
			if(do_export){pdf("Matrix_GWDS_specificity.pdf")}
			make_heatmap(mymatrix=round(gwdsspec,5),myBreaks=seq(0.999,1,0.00005),mytitle="specificity GWDS",note_cex=1,mycol2="darkgreen")
			if(do_export){dev.off()}
			#
			if(do_export){pdf("Matrix_PCadapt_power.pdf")}
			make_heatmap(mymatrix=round(pcadaptpower,2),myBreaks=seq(0,1,0.025),mytitle="power PCadapt")
			if(do_export){dev.off()}	
			if(do_export){pdf("Matrix_PCadapt_specificity.pdf")}
			make_heatmap(mymatrix=round(pcadaptspec,5),myBreaks=seq(0.999,1,0.00005),mytitle="specificity PCadapt",note_cex=1,mycol2="darkgreen")
			if(do_export){dev.off()}
			#
			if(do_export){pdf("Matrix_OutFLANK_power.pdf")}
			make_heatmap(mymatrix=round(outflankpower,2),myBreaks=seq(0,1,0.025),mytitle="power OutFLANK")
			if(do_export){dev.off()}	
			if(do_export){pdf("Matrix_OutFLANK_specificity.pdf")}
			make_heatmap(mymatrix=round(outflankspec,5),myBreaks=seq(0.999,1,0.00005),mytitle="specificity OutFLANK",note_cex=1,mycol2="darkgreen")
			if(do_export){dev.off()}
			}else{
			cat("Skipping heatmaps because only one value specified for either Ne or s.",sep="\n")
			}
		#
		testlist		<- list()
		testlist[[1]]	<- gwdspower 
		testlist[[2]]	<- outflankpower
		testlist[[3]]	<- pcadaptpower
		testlist[[4]]	<- gwdsspec
		testlist[[5]]	<- outflankspec	
		testlist[[6]]	<- pcadaptspec
		fdrlist			<- list()
		fdrlist[[1]]	<- gwdsfdr
		fdrlist[[2]]	<- outflankfdr
		fdrlist[[3]]	<- pcadaptfdr
		names(testlist)	<- c("gwdspower","outflankpower","pcadaptpower","gwdsspec","outflankspec","pcadaptspec")
		names(fdrlist)	<- c("gwdsfdr","outflankfdr","pcadaptfdr")
		dput(testlist,"powertable.txt")
		mysambarsim$testlist	<<- testlist
		mysambarsim$fdrlist		<<- fdrlist
		mysambarsim$powertable	<<- c(testlist,fdrlist)
		}
	print(Sys.time())
	}

runfix_multi<-function()
	{
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0)
	fix0.0	<<- mysambarsim$testlist
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0.01)
	fix0.01	<<- mysambarsim$testlist
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0.05)
	fix0.05	<<- mysambarsim$testlist
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0.1)
	fix0.1	<<- mysambarsim$testlist
	}

# depends on functions plot_retained_variation and make_heatmap
runsim_retained<-function(n_loci=1100,n_selectedloci=1000,sel_coef=0.1,sourcemafmean=NULL,ne=NULL,do_heatmap=TRUE,do_export=FALSE)
	{
	# propability of retaining a minor allele equals:
	# 1 - (probability of drawing major alleles only) =
	# 1 - ((1-maf)^(nfounders*2))
	if(is.null(sourcemafmean))
		{
		sourcemafmean		<- c(0.01,0.02,0.05,0.08,0.1,0.12,0.15,0.2,0.25,0.3,0.35,0.4)	
		}
	if(is.null(ne))
		{
		ne						<- c(1,2,5,10,20,40,60,80,100,125,150,200)
		}
	if(length(sourcemafmean)!=length(ne))
		{
		return(cat("ERROR: inputvectors to sourcemafmean and ne need to be of the same length",sep="\n"))
		}
	allcombi				<- as.data.frame(expand.grid(sourcemafmean,ne,stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("sourcemaf","ne")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	n_gen 					<- 2		# minimum is 2
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	parallelsel				<- TRUE	
	#
	# call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("retained_adaptive","retained_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2")
	testresults				<- as.data.frame(matrix(NA,ncol=27,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	for(myrun in c(1:nruns))
		{
		mean_source_maf		<- allcombi$sourcemaf[myrun]
		ne_F				<- allcombi$ne[myrun]
		cat(paste(mean_source_maf,ne_F,sep="_"),sep="\n")
		mysettings			<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=FALSE,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,meansourcemaf=mean_source_maf,sim_source=FALSE,nefounderpop1=ne_F,nefounderpop2=ne_F,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_selectionscan=FALSE,do_venn=FALSE,createplots=FALSE)
		myscores			<- mysambarsim$mytestscores[1,]
		testresults[myrun,]	<- c(myscores,mysettings)
		}
	# return table:
	testresults		<<- testresults
	write.table(testresults,"Retained_analysis.txt",quote=FALSE)
	if(do_heatmap)
		{
		# heatmap:
		retainedneutral	<<- xtabs(retained_neutral  ~ mean_maf_S + ne_F, testresults)
		graphics.off()
		make_heatmap(mymatrix=round(retainedneutral,2),myBreaks=seq(0,1,0.1),mytitle="Retained variation",note_cex=1.5,myylab="q",myxlab="Number of founders")
		testlist		<<- list()
		testlist[[1]]	<<- retainedneutral
		names(testlist)	<<- c("retainedneutral")
		}
	print(Sys.time())
	# Expected values:	
	matrix1				<- matrix(rep(sourcemafmean,length(ne)),ncol=length(ne),nrow=length(sourcemafmean),byrow=FALSE)
	matrix2				<- matrix(rep(ne,length(ne)),ncol=length(sourcemafmean),nrow=length(sourcemafmean),byrow=TRUE)	
	expretained			<<- round(1-((1-matrix1)^(2*matrix2)),2)
	colnames(expretained)<<- ne
	rownames(expretained)<<- sourcemafmean
	#
	plot_retained_variation(export=do_export)
	}

plot_retained_variation<-function(export=FALSE)
	{
	# expects to find a table called retainedneutral and a matrix called expretained, generated by runsim_retained function 
	if(export){pdf("Retainedvariation.plot.pdf")}
	nmaf		<- nrow(retainedneutral)
	mycol1		<- "grey75"
	mycol2		<- "black"
	mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
	my_colours	<- mycolfunc1(nmaf)
	ret			<- round(retainedneutral[1,],3)
	exp			<- round(expretained[1,],3)
	plot(names(ret),exp,col=my_colours[1],type='l',xlab="Number of founders",ylab="",ylim=c(0,1),cex.axis=1.5,cex.lab=2,lwd=2,log="x",main="Retained variation",cex.main=2)
	points(names(ret),ret,col=my_colours[1],lwd=2,cex=1.5)
	abline(h=1,lty=2)
	for(j in c(2:nrow(retainedneutral)))
		{
		ret		<- round(retainedneutral[j,],3)
		exp		<- round(expretained[j,],3)
		lines(names(ret),ret,col=my_colours[j],lwd=2)
		points(names(ret),ret,col=my_colours[j],lwd=2,cex=1.5)
		}
	mtext("Proportion retained alleles",side=2,line=2.5,cex=2)
	legend("bottomright",legend=rownames(retainedneutral),fill=my_colours,bty="n",cex=1.5,title="maf")
	if(export){dev.off()}
	}

# depends on plot_fixation and make_heatmap
runsim_fixation<-function(n_loci=1100,ne_F=50,n_selectedloci=1000,do_export=FALSE,n_gen=500,dohaploid=TRUE,doexport=FALSE)
	{
	# Fixation probs are a bit below expected when simulation with small Ne (like <= 10), probably because of rounding errors. 
	s_mafvector				<- c(0.05,0.1,0.15,0.2,0.25)
	selcoefvector			<- c(0,0.01,0.05,0.1)
	#
	#if(length(s_mafvector)!=length(selcoefvector))
	#	{
	#	return(cat("ERROR: vectors s_mafvector and selcoefvector need to be of the same length",sep="\n"))
	#	}
	allcombi				<- as.data.frame(expand.grid(s_mafvector,selcoefvector, stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("maf","s")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	#n_gen					<- 500	# high number to allow enough time for fixation to occur
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	parallelsel				<- TRUE	
	#
	# call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("retained_adaptive","retained_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2")
	testresults				<- as.data.frame(matrix(NA,ncol=27,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	for(myrun in c(1:nruns))
		{
		sel_coef			<- allcombi$s[myrun]
		mean_source_maf		<- allcombi$maf[myrun]
		cat(paste(sel_coef,ne_F,sep="_"),sep="\n")
		mysettings			<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=do_export,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,nefounderpop1=ne_F,nefounderpop2=ne_F,meansourcemaf=mean_source_maf,sim_source=FALSE,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_selectionscan=FALSE,do_venn=FALSE,do_haploid=dohaploid,createplots=FALSE)
		myscores			<- mysambarsim$mytestscores[1,]
		testresults[myrun,]	<- c(myscores,mysettings)
		}
	# return table:
	testresults		<<- testresults
	write.table(testresults,"Power_analysis.txt",quote=FALSE)
	# heatmap:
	fixedsel			<<- xtabs(fixed_adaptive2  ~ s + mean_maf_S, testresults)
	#retainedsel		<<- xtabs(retained_adaptive2  ~ s + mean_maf_S, testresults)
	graphics.off()
	make_heatmap(mymatrix=round(fixedsel,2),myBreaks=seq(0,1,0.1),mytitle="Fixation probability",note_cex=1.5,mycol2="darkgreen",myylab="s",myxlab="q")
	testlist			<<- list()
	testlist[[1]]		<<- fixedsel
	names(testlist)		<<- c("fixedsel")
	# calculate expected fixation:
	matrix1				<- matrix(rep(selcoefvector,length(s_mafvector)),ncol=length(s_mafvector),nrow=length(selcoefvector),byrow=FALSE)
	matrix2				<- matrix(rep(s_mafvector,length(selcoefvector)),ncol=length(s_mafvector),nrow=length(selcoefvector),byrow=TRUE)	
	expfixation			<<- round((1-exp(-2*ne_F*(matrix1+0.0001)*matrix2))/(1-exp(-2*ne_F*(matrix1+0.0001))),2)
	rownames(expfixation)<- selcoefvector
	colnames(expfixation)<- s_mafvector
	print(Sys.time())
	plot_fixation(export=do_export)
	}	

plot_fixation<-function(export=FALSE)
	{
	# expects to find a table called fixedsel and a matrix called expfixation, generated by runsim_fixation function
	if(export){pdf("Fixationprob.plot.pdf")}
	nmaf		<- nrow(fixedsel)
	mycol1		<- "grey75"
	mycol2		<- "black"
	mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
	my_colours	<- mycolfunc1(nmaf)
	fix			<- round(fixedsel[1,],3)
	exp			<- round(expfixation[1,],3)
	plot(names(fix),exp,col=my_colours[1],type='l',xlab="q",ylab="",ylim=c(0,1),cex.axis=1.5,cex.lab=2,lwd=2,main="Fixation probability",cex.main=2)
	points(names(fix),fix,col=my_colours[1],lwd=2,cex=1.5)
	for(j in c(2:nmaf))
		{
		fix		<- round(fixedsel[j,],3)
		exp		<- round(expfixation[j,],3)
		lines(names(fix),exp,col=my_colours[j],lwd=2)
		points(names(fix),fix,col=my_colours[j],lwd=2,cex=1.5)
		}
	mtext("Fixation probability",side=2,line=2.5,cex=2)
	legend("topleft",legend=rownames(fixedsel),fill=my_colours,bty="n",cex=1.5,title="s")
	if(export){dev.off()}
	}

runsim_fixationtime<-function(n_loci=1100,n_selectedloci=1000,sel_coef=0.1,maf_source=0.15,do_export=FALSE,dohaploid=TRUE,sel_discrete=TRUE)
	{
	# expected: 2/s * ln (2*Ne) generations
	ngen					<- c(25,50,100,200,500)
	ne						<- c(25,50,100,200,500)
	allcombi				<- as.data.frame(expand.grid(ngen,ne,stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("ngen","ne")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	mean_source_maf			<- maf_source
	parallelsel				<- TRUE	
	#
	# call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("retained_adaptive","retained_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2")
	testresults				<- as.data.frame(matrix(NA,ncol=27,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	for(myrun in c(1:nruns))
		{
		n_gen				<- allcombi$ngen[myrun]
		ne_F				<- allcombi$ne[myrun]
		cat(paste(sel_coef,ne_F,sep="_"),sep="\n")
		mysettings			<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=do_export,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,nefounderpop1=ne_F,nefounderpop2=ne_F,meansourcemaf=mean_source_maf,sim_source=FALSE,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_selectionscan=FALSE,do_venn=FALSE,do_haploid=dohaploid,s_discrete=sel_discrete)
		myscores			<- mysambarsim$mytestscores[1,]
		testresults[myrun,]	<- c(myscores,mysettings)
		}
	# return table:
	testresults		<<- testresults
	write.table(testresults,"Power_analysis.txt",quote=FALSE)
	# heatmap:
	retainedsel		<<- xtabs(retained_adaptive ~ gen + ne_F, testresults)
	fixedsel		<<- xtabs(fixed_adaptive2  ~ gen + ne_F, testresults)
	graphics.off()
	#make_heatmap(mymatrix=round(retainedsel,2),myBreaks=seq(0.7,1,0.025),mytitle="Retained variation",myylab="G",myxlab="Ne")
	make_heatmap(mymatrix=round(fixedsel,2),myBreaks=seq(0,0.3,0.025),mytitle="Fixation probability",note_cex=1.5,mycol2="darkgreen",myylab="G",myxlab="Ne")
	testlist		<<- list()
	testlist[[1]]	<<- retainedsel 
	testlist[[2]]	<<- fixedsel
	names(testlist)	<<- c("retainedsel","fixedsel")
	print(Sys.time())
	}	
	
make_heatmap<-function(mymatrix=myinput,export=NULL,mycol1="grey85",mycol2="red",myBreaks=seq(0,1,0.025),mytitle="Power",note_cex=1.5,my_margins=c(4.5,6),myylab="s",myxlab="Ne")
	{
	# define colour scale:
	mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
	myColours	<- c(mycolfunc1(length(myBreaks)-1))
	# plot:
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(mytitle,"pdf",sep="."))}
		if(export=="wmf"){win.metafile(paste(mytitle,"wmf",sep="."))}
		}
	heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=note_cex,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=0,key=FALSE,margins=my_margins,adjCol=c(NA,0.5),adjRow=c(0,NA),offsetRow = -0.5)
	mtext(myylab, side = 4, line = -0.5, cex = 2, las=2)
	mtext(myxlab, side = 1, line = 3.5, cex = 2)
	mtext(mytitle, side = 3, line = 1, cex = 2.5)
	if(!is.null(export)){dev.off()}
	}	

export_heatmaps_single<-function(export_type=NULL)
	{
	# export_type should be "pdf" or "wmf"
	make_heatmap(mymatrix=round(gwdspower,2),mytitle="power_GWDS",export=export_type)
	make_heatmap(mymatrix=round(gwdsspec,4),mytitle="specificity_GWDS",myBreaks=seq(0.999,1,0.00005),note_cex=1,mycol2="darkgreen",export=export_type)
	make_heatmap(mymatrix=round(outflankpower,2),mytitle="power_OutFLANK",export=export_type)
	make_heatmap(mymatrix=round(outflankspec,4),mytitle="specificity_OutFLANK",myBreaks=seq(0.999,1,0.00005),note_cex=1,mycol2="darkgreen",export=export_type)
	make_heatmap(mymatrix=round(pcadaptpower,2),mytitle="power_PCadapt",export=export_type)
	make_heatmap(mymatrix=round(pcadaptspec,4),mytitle="specificity_PCadapt",myBreaks=seq(0.999,1,0.00005),note_cex=1,mycol2="darkgreen",export=export_type)
	}

export_heatmaps_fixation<-function(export=NULL,exportname="Alltestscores",mylist=testlist,inverse=FALSE,myxlab="Ne",myylab="G")
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	# library(grid)
	# install.packages("gridGraphics")
	# library(gridGraphics)
	# library(gridExtra)
	gl <- lapply(1:length(mylist), function(i){
		mycol1		<- "grey85"
		mymatrix	<- data.matrix(mylist[[i]])
		if(inverse)
			{
			mymatrix<- 1 - mymatrix
			}
		myBreaks<-seq(0,1,0.1)
		mycol2	<- "darkgreen"
		note_cex<- 1.5
		mymatrix<- round(mymatrix,2)
		mytitle	<- "Fixation probability"
		mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
		myColours	<- c(mycolfunc1(length(myBreaks)-1))
		my_margins=c(4,4)	# under/above,right/left
		heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=note_cex,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=0,key=FALSE,margins=my_margins,adjCol=c(NA,0.5),adjRow=c(0,NA),offsetRow = -0.5)
		mtext(myylab, side = 4, line = 0.75, cex = 2, las=2)
		mtext(myxlab, side = 1, line = 3.5, cex = 2)
		mtext(mytitle, side = 3, line = 0.5, cex = 2)
		mystat		<- ifelse(i==1,"s = 0",(ifelse(i==2,"s = 0.01",ifelse(i==3,"s = 0.05","s = 0.10")))) 
		mtext(mystat, side = 2, line = 0.5, cex = 2)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=13,width=15,onefile=FALSE)}
		if(export=="png"){png(paste(exportname,"png",sep="."),height=975,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=975,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=2, clip=TRUE)	
	if(!is.null(export)){dev.off()}
	}

export_heatmaps_power<-function(export=NULL,exportname="Alltestscores",mylist=mysambarsim$testlist,inverse=FALSE,myxlab="Ne",myylab="s")
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	gl <- lapply(1:length(mylist), function(i){
		mycol1		<- "grey85"
		mymatrix	<- data.matrix(mylist[[i]])
		if(inverse)
			{
			mymatrix<- 1 - mymatrix
			}
		if(i<4)
			{
			myBreaks<- seq(0,1,0.025)
			mycol2	<- "red"
			note_cex<- 1.5
			mymatrix<- round(mymatrix,2)
			mystat	<- "power"
			}else{
			myBreaks<-seq(0.999,1,0.00005)
			mycol2	<- "darkgreen"
			note_cex<- 1
			mymatrix<- round(mymatrix,4)
			mystat	<- "specificity"
			}
		mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
		myColours	<- c(mycolfunc1(length(myBreaks)-1))
		mytitle		<- "Power"
		my_margins=c(4,5)	# under/above,right/left
		heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=note_cex,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=0,key=FALSE,margins=my_margins,adjCol=c(NA,0.5),adjRow=c(0,NA),offsetRow = -0.5)
		mtext(myylab, side = 4, line = 0.5, cex = 2, las=2)
		mtext(myxlab, side = 1, line = 3.25, cex = 2)
		mtext(mystat, side=2, line = 0.5, cex = 2)
		mytitle		<- ifelse((i+2)%%3==0,"GWDS",ifelse((i+2)%%3==1,"OutFLANK","PCadapt")) 
		mtext(mytitle, side = 3, line = 0.5, cex = 2)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=17,width=13,onefile=FALSE)}
		if(export=="png"){png(paste(exportname,"png",sep="."),height=1325,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=1325,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=2, clip=TRUE, as.table = FALSE)	
	if(!is.null(export)){dev.off()}
	}


multioverlap_approach_sim<-function(doexport=NULL,add_numbers=FALSE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Overlap_between_comparisons_simulated.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpoverlap_approach_sim(mycomparison=1,addnumbers=add_numbers)
	plotpoverlap_approach_sim(mycomparison=2,addnumbers=add_numbers)
	plotpoverlap_approach_sim(mycomparison=3,addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}	

plotpoverlap_approach_sim<-function(mycomparison=1,mycex=1,addnumbers=FALSE,pmax=11,nloci=60000,nsel=1000)
	{
	if(mycomparison==1)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[1]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[1]]
		mytest1	<- "founder1_source"
		mylog2	<- mysambarsim$gwdslognewplist[[2]]
		myout2	<- mysambarsim$gwdsoutlierslist[[2]]
		mytest2	<- "founder2_source"
		}
	if(mycomparison==2)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[1]]
		myout1	<- mysambarsim$gwdsoutlierslist[[1]]
		mytest1	<- "founder1_source"
		mylog2	<- mysambarsim$gwdslognewplist[[3]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest2	<- "bothfounders_source"
		}
	if(mycomparison==3)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[2]]
		myout1	<- mysambarsim$gwdsoutlierslist[[2]]
		mytest1	<- "founder2_source"
		mylog2	<- mysambarsim$gwdslognewplist[[3]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest2	<- "bothfounders_source"
		}
	#
	mybonf		<- -log10(0.05/length(mysambarsim$gwdslogplist[[3]]))
	mylim		<- c(0,pmax)
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=mylim,ylim=mylim,las=1,col="grey50")
	points(mylog1[nloci-nsel+1:nloci],mylog2[nloci-nsel+1:nloci],pch=16,cex=mycex,col="red")
	mtext(mytest1,side=1,cex=1.5,line=3)
	mtext(mytest2,side=2,cex=1.5,line=3)
	abline(v=mybonf,lty=2)
	abline(h=mybonf,lty=2)
	#mymin1	<- min(mylog1[myout1])
	#mymin2	<- min(mylog2[myout2])
	#abline(v=mymin1,lty=2)
	#abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
			if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

getbayescansim<-function(bayescanfile=NULL,FDR=0.01,dolog10=TRUE)
	{
	if(is.null(bayescanfile))
		{
		return(cat("ERROR: provide the name of the Bayescan output file to the bayescanfile flag.",sep="\n")) 
		}else{
		if(!file.exists(bayescanfile))
			{
			cat(paste("ERROR: file called ",bayescanfile," not found in the working directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}else{
			x			<- read.table(bayescanfile) 
			}
		x$bayescanout	<- x$qval<FDR
		noutliers		<- length(which(x$bayescanout))
		if(dolog10)
			{
			x$bayescanlogp	<- -log10(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log10(x$qval)
			}else{
			x$bayescanlogp	<- -log(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log(x$qval)
			}
		simbayescan		<<- x
		cat("Bayescan file saved as object 'simbayescan'.",sep="\n")
		}
	}

multiplotp_sim<-function(export=NULL,add_numbers=TRUE,nr_loci=1000,nr_selected=100,silent=TRUE,comp_nr=3,logpmax=11,bayescanfile=NULL,bayescanFDR=0.01)
	{
	if(!is.null(bayescanfile)){getbayescansim(bayescanfile=bayescanfile,FDR=bayescanFDR)}
	ncombi	<- ifelse(is.null(bayescanfile),3,6)
	if(!is.null(export))
		{
		plotname	<- ifelse(!is.null(bayescanfile),"Teststatistic.2D.simulated.withbayescan","Teststatistic.2D.simulated")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=ncombi*4+1,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	# what is maximum p-value? (not considering Bayescan)
	if(is.null(logpmax))
		{
		mypvalues	<-c(mysambarsim$gwdslognewplist[[comp_nr]],mysambarsim$outflanklogplist[[comp_nr]],mysambarsim$pcadaptlogplist[[comp_nr]])
		mypvalues	<- mypvalues[is.finite(mypvalues)]
		logpmax		<- max(mypvalues,na.rm=TRUE)
		}
	if(!is.null(bayescanfile))
		{
		plotpvalues_sim(mycomparison=4,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
		plotpvalues_sim(mycomparison=5,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
		plotpvalues_sim(mycomparison=6,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
		}
	plotpvalues_sim(mycomparison=1,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
	plotpvalues_sim(mycomparison=2,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
	plotpvalues_sim(mycomparison=3,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
	if(!is.null(export))
		{
		dev.off()
		cat("2D-Plot exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

plotpvalues_sim<-function(export=NULL,mycomparison=1,mycex=0.75,addnumbers=FALSE,nrloci=1000,nrselected=100,my_comp_nr=3,silent=TRUE,pmax=NULL,textcol="grey50",nsample=NULL)
	{
	# my_comp_nr defines population comparison, i.e. whether to plot output for pairwise (1 or 2) or pooled approach (3)
	# mycomparison defines selection scan comparison
	if(!silent){cat("Obtaining test results from list objects generated by outliersim function...",sep="\n")} 
	if(mycomparison==1)
		{
		mylog1	<- mysambarsim$outflanklogplist[[my_comp_nr]]
		myout1	<- mysambarsim$outflankoutlierslist[[my_comp_nr]]
		mytest1	<- "OutFLANK"
		mylog2	<- mysambarsim$pcadaptlogplist[[my_comp_nr]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[my_comp_nr]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==2)
		{
		mylog1	<- mysambarsim$outflanklogplist[[my_comp_nr]]
		myout1	<- mysambarsim$outflankoutlierslist[[my_comp_nr]]
		mytest1	<- "OutFLANK"
		mylog2	<- mysambarsim$gwdslognewplist[[my_comp_nr]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[my_comp_nr]]
		mytest2	<- "GWDS"
		}
	if(mycomparison==3)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[my_comp_nr]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[my_comp_nr]]
		mytest1	<- "GWDS"
		mylog2	<- mysambarsim$pcadaptlogplist[[my_comp_nr]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[my_comp_nr]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==4)
		{
		mylog1	<- simbayescan$bayescanlogp
		myout1	<- which(simbayescan$bayescanout)
		mytest1	<- "bayescan"
		mylog2	<- mysambarsim$outflanklogplist[[my_comp_nr]]
		myout2	<- mysambarsim$outflankoutlierslist[[my_comp_nr]]
		mytest2	<- "OutFLANK"
		}
	if(mycomparison==5)
		{
		mylog1	<- simbayescan$bayescanlogp
		myout1	<- which(simbayescan$bayescanout)
		mytest1	<- "bayescan"
		mylog2	<- mysambarsim$pcadaptlogplist[[my_comp_nr]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[my_comp_nr]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==6)
		{
		mylog1	<- simbayescan$bayescanlogp
		myout1	<- which(simbayescan$bayescanout)
		mytest1	<- "bayescan"
		mylog2	<- mysambarsim$gwdslognewplist[[my_comp_nr]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[my_comp_nr]]
		mytest2	<- "GWDS"
		}
	mylog1[is.infinite(mylog1)]	<- NA
	mylog2[is.infinite(mylog2)]	<- NA
	if(is.null(pmax))
		{
		myxmax	<- max(mylog1,na.rm=TRUE)
		myxmax	<- max(mylog2,na.rm=TRUE)
		}else{
		myxmax	<- pmax
		myymax	<- pmax
		}
	if(!silent){cat("Plotting...",sep="\n")}
	if(!is.null(export))
		{
		plotname<-paste("Selectionscan.sim.logpvalues.2D",my_comp_nr,mytest1,mytest2,sep=".")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=4,width=4)}
		par(mar=c(1,1,1,1),oma=c(2.5,2.5,0,0))
		}
	if(!is.null(nsample))
		{
		sampleset	<- sample(c(1:length(mylog1)),nsample)
		plot(mylog1[sampleset],mylog2[sampleset],pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		}else{
		plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		#plot(mylog1[1:(nrloci-nrselected)],mylog2[1:(nrloci-nrselected)],cex=1,pch=16,xlab="",ylab="",yaxt='n',xlim=c(0,myxmax),ylim=c(0,myymax))
		}
	myxline	<- ifelse(!is.null(export),2.5,3.5)
	myyline	<- ifelse(!is.null(export),2,3.5)
	mtext(mytest1,side=1,cex=1.5,line=myxline)
	mtext(mytest2,side=2,cex=1.5,line=myyline)
	axis(side=2,las=1)
	selectednr	<- nrloci-nrselected+1	
	if(!silent){cat("Adding outliers in red...",sep="\n")}
	points(mylog1[(nrloci-nrselected+1):nrloci],mylog2[(nrloci-nrselected+1):nrloci],pch=16,cex=mycex,col="red")
	if(!silent){cat("Adding threshold lines...",sep="\n")}
	mymin1		<- min(mylog1[myout1],na.rm=TRUE)
	mymin2		<- min(mylog2[myout2],na.rm=TRUE)
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		if(!silent){cat("Adding numbers...",sep="\n")}
		nout1	<- length(myout1)
		if(!silent){cat(paste("Number of outliers test 1: ",nout1,".",sep=""),sep="\n")}
		nout2	<- length(myout2)
		if(!silent){cat(paste("Number of outliers test 1: ",nout2,".",sep=""),sep="\n")}
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- nrselected-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=2.25,col=textcol)
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=2.25,col=textcol)
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=2.25,col=textcol)
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=2.25,col=textcol)
		#text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=2.25,col=textcol)
		}
	if(!is.null(export)){dev.off()}
	}
	
plotpvalues_old_sim<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE)
	{
	if(mycomparison==1)
		{
		mylog1	<- mysambarsim$gwdslogplist[[3]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest1	<- "GWDS"
		mylog2	<- bayescanlogqlist[[3]]
		myout2	<- bayescanoutlierslist[[3]]
		mytest2	<- "Bayescan"
		}
	if(mycomparison==2)
		{
		mylog1	<- mysambarsim$gwdslogplist[[3]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest1	<- "GWDS"
		mylog2	<- mysambarsim$pcadaptlogplist[[3]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[3]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==3)
		{
		mylog1	<- bayescanlogqlist[[3]] 
		myout1	<- bayescanoutlierslist[[3]]
		mytest1	<- "Bayescan"
		mylog2	<- mysambarsim$pcadaptlogplist[[3]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[3]]
		mytest2	<- "PCadapt"
		}
	mylog1[mylog1==0]	<- 0.01
	mylog2[mylog2==0]	<- 0.01
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n')
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	points(mylog1[79001:80000],mylog2[79001:80000],pch=16,cex=mycex,col="red")
	mymin1	<- min(mylog1[myout1])
	mymin2	<- min(mylog2[myout2])
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

multimafburnin<-function(mymaf_means=c(0.1,0.125,0.15,0.2),maf_vector=NULL)
	{
	# This function is to run the function mafburnin with several starting minor allele frequencies.
	if(is.null(maf_vector))
		{
		return(cat("ERROR: provide an input vector with observed locus specific minor allele frequencies (e.g. snps$maf_popname[snps$filter]) to the maf_vector flag.",sep="\n"))  
		}
	for(my_m in mymaf_means)
		{
		cat(my_m,sep="\n")
		mafburnin(nsamples=30,truedata=snps$maf_Norway[snps$filter],ngen_vec=c(100,200,300,400),export=TRUE,maf_mean=my_m,y_max=13)
		}
	}

mafburnin<-function(nsamples=30,truedata=snps$maf_Norway[snps$filter],ngen_vec=c(100,200,300,400),export=FALSE,maf_mean=0.15,y_max=13)
	{
	# Which burn-in (number of generations) needed to acquire realistic maf-distribution?
	if(is.null(truedata))
		{
		return(cat("ERROR: provide an input vector with observed locus specific minor allele frequencies to the truedata flag.",sep="\n"))  
		}
	nalleles	<- nsamples*2
	if(export)
		{
		pdf(paste("MAF",maf_mean,"burnin.pdf",sep="_"),height=10,width=10)
		}
	layout(matrix(c(1:4),2,2,byrow = TRUE))
	par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5)
	for (my_k in c(1:length(ngen_vec)))
		{
		sourcemaf	<- mafsim(nloci=10000,popsize=1000,ngens=ngen_vec[my_k],meanmaf=maf_mean)
		mysample	<- sapply(sourcemaf,function(sourcemaf){rbinom(1,nalleles,sourcemaf)})
		# plot:
		hist(truedata,freq=FALSE,main="",ylim=c(0,y_max),col="grey")
		hist(mysample/nalleles,add=TRUE,freq=FALSE,breaks=seq(0,1,0.05),col=rgb(1,0,0,1/6))
		mtext(side=3,paste("burn-in: ",ngen_vec[my_k]," ngen",sep=""),line=-2.5,cex=2)
		if(my_k==2)
			{
			legend("right",legend=c("observed","simulated"),fill=c("grey","red"),bty="n",cex=2)
			}
		}
	mtext(side=1,outer=TRUE,"Allele frequency",line=1.5,cex=2)
	mtext(side=2,outer=TRUE,"SNP density",line=1.25,cex=2)
	mtext(side=3,outer=TRUE,paste("Uniform allele frequency prior to burn-in: ",maf_mean,sep=""),line=-1,cex=2)
	if(export){dev.off()}
	}

plotfdr<-function(do_analysis=FALSE,do_export=TRUE,my_comp=1,loci_nr=10000,gen_nr=20,selected_nr=1000,vector_ne=c(20,40,60,80,100,120,160,200),founders_nr=NULL,my_ylims=NULL,samples_nr=30,selection_coefficient=0.1,sel_discrete=TRUE,dohaploidy=TRUE,myinputmatrix=NULL,plot_fdr=FALSE,add_bh=TRUE)
	{
	# note: false discovery rate does not depend on power and specificity only, but also on the proportion of adaptive loci in your dataset
	# for example: say power is 40% and specificity is 99.9%.
	# if you have 100.000 SNPs, of which 10.000 are adaptive, then false discovery rate is:
	# ((1-0.999)*90000)/(0.4*10000+((1-0.999)*90000)) = 0.022 = 2.2%
	# however, if you have 100K SNPs, of which only 10 are adaptive, then false discovery rate:
	# ((1-0.999)*90000)/(0.4*10+((1-0.999)*90000)) = 0.957 = 96%
	# therefore FDR is only informative if calculated for a range of proportions of adaptive loci 
	#
	# my_comp can be 1 (founder1 vs source), 2 (founder 2 vs source), or 3 (both founders combined vs source)
	#
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	cat("###### SETTINGS WHILST RUNNING PLOT_FDR ######",sep="\n")
	cat(paste("  Specified number of loci: ",loci_nr,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",selected_nr,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficients: ",paste(selection_coefficient,collapse=", "),".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",gen_nr,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder populations: ",paste(vector_ne,collapse=", "),".",sep=""),sep="\n")
	if(is.null(founders_nr))
		{
		cat("  No bottleneck specified (flag 'founders_nr' is set to NULL).",sep="\n")
		}else{
		cat(paste("  Specified number of founders: ",founders,".",sep=""),sep="\n")
		}
	cat(paste("  Specified samplesize: ",samples_nr,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",sel_discrete,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",dohaploidy,".",sep=""),sep="\n")
	#
	if(do_analysis&is.null(myinputmatrix))
		{
		runsim_power(n_gen=gen_nr,n_loci=loci_nr,mycorr="bonferroni",n_selectedloci=selected_nr,selcoefvector=selection_coefficient,nevector=vector_ne,do_export=TRUE,dohaploid=dohaploidy,my_comparison=my_comp,n_sample=samples_nr,sdiscrete=sel_discrete)
		bonflist	<- mysambarsim$testlist
		bonffdr		<- mysambarsim$fdrlist
		runsim_power(n_gen=gen_nr,n_loci=loci_nr,mycorr="holm",n_selectedloci=selected_nr,selcoefvector=selection_coefficient,nevector=vector_ne,do_export=TRUE,dohaploid=dohaploidy,my_comparison=my_comp,n_sample=samples_nr,sdiscrete=sel_discrete)
		holmlist	<- mysambarsim$testlist
		holmfdr		<- mysambarsim$fdrlist
		runsim_power(n_gen=gen_nr,n_loci=loci_nr,mycorr="BH",n_selectedloci=selected_nr,selcoefvector=selection_coefficient,nevector=vector_ne,do_export=TRUE,dohaploid=dohaploidy,my_comparison=my_comp,n_sample=samples_nr,sdiscrete=sel_discrete)
		bhlist		<- mysambarsim$testlist
		bhfdr		<- mysambarsim$fdrlist
		}else{
		cat("WARNING: flag do_analysis is set to FALSE and/or myinputmatrix is not set to NULL. Plotting test scores from previous simulations (i.e. objects bonflist, holmlist, bhlist, and bonffdr, holmfdr, and bhfdr).",sep="\n")
		
		}
	# plot:
	mytestscans	<- c("GWDS","OutFLANK","PCadapt")
	mytestcols	<- c("blue","orange","darkgreen")
	if(do_export)
		{
		bhlabel			<- ifelse(add_bh,"withBH","withoutBH") 
		if(plot_fdr)
			{
			plotname	<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),bhlabel,"withFDR.pdf",sep=".")
			}else{
			plotname	<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),bhlabel,"withoutFDR.pdf",sep=".")
			}
		pdf(plotname)
		}
	if(!is.null(myinputmatrix))
		{
		cat("Reading matrices defined by myinputmatrix flag.",sep="\n")
		bonfmat		<- read.table(paste(myinputmatrix,"bonferroni.txt",sep="."))
		holmmat		<- read.table(paste(myinputmatrix,"holm.txt",sep="."))
		bhmat		<- read.table(paste(myinputmatrix,"BH.txt",sep="."))
		cat("Calculating FDR for various proportions of adaptive SNPs.",sep="\n")
		# (FP*(1-p_adaptive))/ (FP*(1-p_adaptive) + ((1-FN)+p_adaptive))  
		bonfmat[10,]	<- ((1-bonfmat[4,])*900000)/(bonfmat[1,]*100000+(1-bonfmat[4,])*900000)		# 10% 
		bonfmat[11,]	<- ((1-bonfmat[5,])*900000)/(bonfmat[2,]*100000+(1-bonfmat[5,])*900000)		# 10%
		bonfmat[12,]	<- ((1-bonfmat[6,])*900000)/(bonfmat[3,]*100000+(1-bonfmat[6,])*900000)		# 10%
		#
		bonfmat[13,]	<- ((1-bonfmat[4,])*990000)/(bonfmat[1,]*10000+(1-bonfmat[4,])*990000)		# 1%
		bonfmat[14,]	<- ((1-bonfmat[5,])*990000)/(bonfmat[2,]*10000+(1-bonfmat[5,])*990000)		# 1%
		bonfmat[15,]	<- ((1-bonfmat[6,])*990000)/(bonfmat[3,]*10000+(1-bonfmat[6,])*990000)		# 1%		
		#
		bonfmat[16,]	<- ((1-bonfmat[4,])*999000)/(bonfmat[1,]*1000+(1-bonfmat[4,])*999000)		# 0.1%
		bonfmat[17,]	<- ((1-bonfmat[5,])*999000)/(bonfmat[2,]*1000+(1-bonfmat[5,])*999000)		# 0.1%
		bonfmat[18,]	<- ((1-bonfmat[6,])*999000)/(bonfmat[3,]*1000+(1-bonfmat[6,])*999000)		# 0.1%
		#
		bonfmat[19,]	<- ((1-bonfmat[4,])*999900)/(bonfmat[1,]*100+(1-bonfmat[4,])*999900)		# 0.01%
		bonfmat[20,]	<- ((1-bonfmat[5,])*999900)/(bonfmat[2,]*100+(1-bonfmat[5,])*999900)		# 0.01%
		bonfmat[21,]	<- ((1-bonfmat[6,])*999900)/(bonfmat[3,]*100+(1-bonfmat[6,])*999900)		# 0.01%
		#
		bonfmat[22,]	<- ((1-bonfmat[4,])*999990)/(bonfmat[1,]*10+(1-bonfmat[4,])*999990)			# 0.001%
		bonfmat[23,]	<- ((1-bonfmat[5,])*999990)/(bonfmat[2,]*10+(1-bonfmat[5,])*999990)			# 0.001%
		bonfmat[24,]	<- ((1-bonfmat[6,])*999990)/(bonfmat[3,]*10+(1-bonfmat[6,])*999990)			# 0.001%
		#
		for (k in c(1:nrow(bonfmat)))
			{
			bonfmat[k,]	<- ifelse(is.na(as.vector(bonfmat[k,])),0,bonfmat[k,])
			}
		}
	cat("Creating plot...",sep="\n")
	if(plot_fdr)
		{
		layout(matrix(c(1:9),nrow=3,ncol=3,byrow=TRUE))
		par(mar=c(1,2.75,1,1),oma=c(3,1.5,3,1))
		}else{
		layout(matrix(c(1:6),nrow=3,ncol=2,byrow=TRUE))
		par(mar=c(1,3,1,1),oma=c(3,1.5,3,1))
		}
	if(is.null(my_ylims))
		{
		if(add_bh)
			{
			cat("Using a relatively low lower limit of the y-axis of the specificity plot, because add_bh is set to TRUE.",sep="\n") 
			my_ylims=c(1,0.98,1)
			}else{
			cat("Using a relatively high lower limit of the y-axis of the specificity plot, because add_bh is set to FALSE.",sep="\n") 
			my_ylims=c(1,0.9996,1)
			}
		}
	if(is.null(myinputmatrix))
		{
		for (k in (1:3))
			{
			# power:
			myxaxt	<- ifelse(k==3,'s','n')
			plot(colnames(bonflist[[k]]),bonflist[[k]][1,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,my_ylims[1]),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(colnames(bonflist[[k]]),holmlist[[k]][1,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(colnames(bonflist[[k]]),bhlist[[k]][1,],type='l',lwd=2,lty=3,col=mytestcols[k])}				
			if(k==1){mtext("power",side=3,cex=1.5,line=0.5)}
			if(add_bh)
				{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')}
				}else{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm"),lty=c(1,2),cex=1.5,bty='n')}
				}
			# specificity:
			plot(colnames(bonflist[[k]]),bonflist[[k+3]][1,],type='l',lwd=2,xlab="",ylab="",ylim=c(my_ylims[2],1),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(colnames(bonflist[[k]]),holmlist[[k+3]][1,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(colnames(bonflist[[k]]),bhlist[[k+3]][1,],type='l',lwd=2,lty=3,col=mytestcols[k])}
			if(k==1){mtext("specificity",side=3,cex=1.5,line=0.5)}
			if(plot_fdr)
				{
				# FDR:
				plot(colnames(bonflist[[k]]),bonffdr[[k]][1,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,my_ylims[3]),las=1,xaxt=myxaxt,col=mytestcols[k])
				lines(colnames(bonflist[[k]]),holmfdr[[k]][1,],type='l',lwd=2,lty=2,col=mytestcols[k])
				if(add_bh){lines(colnames(bonflist[[k]]),bhfdr[[k]][1,],type='l',lwd=2,lty=3,col=mytestcols[k])}
				if(k==1){mtext("FDR",side=3,cex=1.5,line=0.5)}
				mtext(mytestscans[k],side=4,cex=1.5,line=1)
				}
			}
		}else{
		for (k in (1:3))
			{
			# power:
			myxaxt	<- ifelse(k==3,'s','n')
			plot(vector_ne,bonfmat[k,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,my_ylims[1]),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(vector_ne,holmmat[k,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(vector_ne,bhmat[k,],type='l',lwd=2,lty=3,col=mytestcols[k])}
			if(k==1){mtext("power",side=3,cex=1.5,line=0.5)}
			if(add_bh)
				{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')}
				}else{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm"),lty=c(1,2),cex=1.5,bty='n')}
				}
			#legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')
			# specificity:
			plot(vector_ne,bonfmat[k+3,],type='l',lwd=2,xlab="",ylab="",ylim=c(my_ylims[2],1),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(vector_ne,holmmat[k+3,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(vector_ne,bhmat[k+3,],type='l',lwd=2,lty=3,col=mytestcols[k])}
			if(k==1){mtext("specificity",side=3,cex=1.5,line=0.5)}
			if(add_bh)
				{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')}
				}else{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm"),lty=c(1,2,3),cex=1.5,bty='n')}
				}
			if(plot_fdr)
				{
				# FDR:
				plot(vector_ne,bonfmat[k+9,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,1),las=1,xaxt=myxaxt,col=mytestcols[k])
				lines(vector_ne,bonfmat[k+12,],type='l',lwd=2,lty=2,col=mytestcols[k])
				lines(vector_ne,bonfmat[k+15,],type='l',lwd=2,lty=3,col=mytestcols[k])
				lines(vector_ne,bonfmat[k+18,],type='l',lwd=2,lty=4,col=mytestcols[k])
				#lines(vector_ne,bonfmat[k+21,],type='l',lwd=2,lty=5,col=mytestcols[k])
				if(k==1){mtext("FDR",side=3,cex=1.5,line=0.5)}
				#if(k==1){legend("topright",legend=c("0.00001","0.0001","0.001","0.01","0.1"),lty=c(5,4,3,2,1),cex=1.25,bty='n',title="p_adaptive:")}
				if(k==1){legend("topright",legend=c("0.0001","0.001","0.01","0.1"),lty=c(4,3,2,1),cex=1.5,bty='n',title="p_adaptive:")}
				mtext(mytestscans[k],side=4,cex=1.5,line=1)
				}
			}
		}
	mtext("Ne",outer=TRUE,side=1,line=1.75,cex=1.5)
	mtext("Test performances",outer=TRUE,side=2,line=-0.25,cex=1.5)
	myapproach	<- ifelse(my_comp==3,"pooled","pairwise")
	mtext(paste("ngen: ",gen_nr,", samplesize: ",samples_nr,", s: ",selection_coefficient,", ",myapproach,sep=""),outer=TRUE,side=3,line=1.5,cex=1.25)
	if(do_export){dev.off()}
	#
	if(is.null(myinputmatrix)&do_analysis)
		{
		# store all results in one list:
		cat("Storing resulting in list object called 'mysambarsim$plotfdr_scores'.",sep="\n")
		myfinallist				<- list()
		myfinallist$bonf		<- bonflist
		myfinallist$bonffdr		<- bonffdr
		myfinallist$holm		<- holmlist
		myfinallist$holmfdr		<- holmfdr
		myfinallist$holm		<- bhlist
		myfinallist$holmfdr		<- bhfdr
		mysambarsim$plotfdr_scores	<<- myfinallist  
		#
		# or export as matrix:
		cat("Exporting matrices...",sep="\n")
		mydf			<- rbind(data.frame(do.call(rbind,bonflist)),data.frame(do.call(rbind,bonffdr)))
		rownames(mydf)	<- c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt","FDR_GWDS","FDR_OutFLANK","FDR_PCadapt")
		tablename		<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),"bonferroni.txt",sep=".")
		write.table(mydf,tablename,quote=FALSE,sep="\t",row.names=TRUE,col.names=TRUE)	
		#
		mydf			<- rbind(data.frame(do.call(rbind,holmlist)),data.frame(do.call(rbind,holmfdr)))
		rownames(mydf)	<- c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt","FDR_GWDS","FDR_OutFLANK","FDR_PCadapt")
		tablename		<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),"holm.txt",sep=".")
		write.table(mydf,tablename,quote=FALSE,sep="\t",row.names=TRUE,col.names=TRUE)	
		#
		mydf			<- rbind(data.frame(do.call(rbind,bhlist)),data.frame(do.call(rbind,bhfdr)))
		rownames(mydf)	<- c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt","FDR_GWDS","FDR_OutFLANK","FDR_PCadapt")
		tablename		<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),"BH.txt",sep=".")
		write.table(mydf,tablename,quote=FALSE,sep="\t",row.names=TRUE,col.names=TRUE)
		#
		# another way of presenting the data:
		bonfpowermat<-round(do.call("rbind",bonflist),5)
		rownames(bonfpowermat)<-c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt")
		write.table(bonfpowermat,"bonferroni_table.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
		#
		holmpowermat<-round(do.call("rbind",holmlist),5)
		rownames(holmpowermat)<-c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt")
		write.table(holmpowermat,"holm_table.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
		#
		bhpowermat<-round(do.call("rbind",bhlist),5)
		rownames(bhpowermat)<-c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt")
		write.table(bhpowermat,"bh_table.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
		}
	cat("Finished :-)",sep="\n")
	}

#outliersim(export=TRUE,nloc=10000,ngen=12000,nesourcepop=10000,nefounderpop1=5000,nefounderpop2=5000,nfounders=5000,selcoef=0.01,samplesize=30,nselectedloci=100,do_selectionscan=TRUE,do_plotpvalues=FALSE)
	
# requires functions 'getfounderpopmaf', 'mafsim' and 'getgenotypesfrommaf'	
# outputs:
# - mymafstartmatrix with maf frequencies at ngen=0, so of source pop before founder event and founder pops just after founder event
# - with allele counts after ngen generations of founderpop1, founderpop2, both founders, and source 
# - mytestscores with power and specificity of GWDS, OutFLANK and PCadapt

# The manhattan plot shows gwds scores. All SNPs above threshold are marked as outlier by GWDS. All points in green are marked by PCadapt as outliers. All points in orange are marked by Outflank as outliers.
outliersim<-function(export=TRUE,my_alpha=0.05,my_quantile=1,mycorrection="none",nloc=1000,ngen=20,ngen_before_founder=200,sim_source=TRUE,nesourcepop=1000,meansourcemaf=0.1,nefounderpop1=20,nefounderpop2=200,nfounders=10,samplesize=30,testgeno=FALSE,nselectedloci=0,selcoef=0.1,s_discrete=TRUE,parallelselection=TRUE,neutralcol="#99CCFF",do_haploid=TRUE,do_venn=TRUE,do_Fdist=TRUE,do_logplot=TRUE,do_selectionscan=TRUE,my_round=5,power_for_retained_only=FALSE,show_adjustedp=FALSE,createplots=TRUE)
	{
	if(!do_haploid)
		{
		return(cat("ERROR: currently allele frequencies can only reliably be simulated using the haploid approach. Please set the do_haploid flag to TRUE.",sep="\n")) 
		}
	if(exists("macmatrix")){macmatrix	<<- NULL}
	if(exists("simscanout")){simscanout	<<- NULL}
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	# mycorrection for multiple testing can be:
	# "none" (no correction)
	# "bonferroni"
	# "holm"
	# "BH" (Benjamini-Hochberg)
	#
	# if parallelselection=TRUE, for pooled comparisons the function will generate estimates considering only SNPs of which both alleles are retained in both founder populations. 
	# downside of setting this flag to TRUE is that then we don't see possible signals of selection in the pooled comparison resulting from selection in one population only.  
	#
	# we need to round power and specificity estimates to many decimals (default 5) in order to avoid rounding confusion. 
	#
	if(nloc-nselectedloci<100&do_selectionscan)
		{
		return(cat("Error: less than 100 neutral loci (nloc-nselectedloci). Not enough neutral loci to infer a neutral distribution.",sep="\n"))
		}
	if(nselectedloci/nloc>0.1&do_selectionscan)
		{
		return(cat("Error: More than 10 percent of loci are adaptive (nselectedloci/nloc). PCadapt won't be able to infer a neutral distribution.",sep="\n"))
		}
	if(nselectedloci>=nloc)
		{
		return(cat("Error: nselectedloci needs to be lower than nloc.",sep="\n"))
		}
	#
	cat("###### SETTINGS WHILST RUNNING OUTLIERSIM ######",sep="\n")
	cat(paste("  Specified number of loci: ",nloc,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",nselectedloci,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficient: ",selcoef,".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",ngen,".",sep=""),sep="\n")
	cat(paste("  Specified Ne source population: ",nesourcepop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 1: ",nefounderpop1,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 2: ",nefounderpop2,".",sep=""),sep="\n")
	cat(paste("  Specified number of founders: ",nfounders,".",sep=""),sep="\n")
	cat(paste("  Specified samplesize: ",samplesize,".",sep=""),sep="\n")
	cat(paste("  Parallel selection: ",parallelselection,".",sep=""),sep="\n")
	cat(paste("  Simulate source MAF: ",sim_source,".",sep=""),sep="\n")
	cat(paste("  Testgeno: ",testgeno,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",s_discrete,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",do_haploid,".",sep=""),sep="\n")
	cat(paste("  When calculating FN, FP and FDR for the pooled comparison, only consider SNPs which have been retained in both populations: ",parallelselection,".",sep=""),sep="\n")
	if(!do_haploid&s_discrete)
		{
		return(cat("Error: The flag dodiscrete is set to TRUE but the flag s_discrete is set to FALSE. The function mafsim() does not allow to simulate simulation discretely if not assuming haploidy.",'\n'))
		} 
	#
	if(export)
		{
		current_dir		<- getwd()
		if(parallelselection)
			{
			out_dir			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"in_both",sep=".")
			}else{
			out_dir			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"either",sep=".")
			}
		my_dir			<- paste(current_dir,out_dir,sep="/")
		if(!file.exists(my_dir)){dir.create(file.path(my_dir))}
		setwd(my_dir)
		}else{
		current_dir		<- getwd()
		}
	founderpopsizes		<- rbind(nefounderpop1,nefounderpop2)
	# To store results:
	genotypecounts		<- list()
	pvaluevec			<- vector()
	pvaluepairwise		<- matrix(nrow=3,ncol=nloc) 
	macmatrix			<- matrix(nrow=8,ncol=nloc)
	rownames(macmatrix)	<- c("founder1_A","founder1_a","founder2_A","founder2_a","founders_A","founders_a","source_A","source_a")
	#
	# Simulate source mafs at the time of founder event:
	if(sim_source)
		{
		# generate a natural distribution of minor allele frequencies:
		# I tried poisson function, but that doesn't produce a typical maf-distribution
		cat("###### SIMULATING MAC DISTRIBUTION OF SOURCE POPULATION PRIOR TO FOUNDER EVENT ######",sep="\n") 
		sourcemaf			<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=ngen_before_founder,meanmaf=meansourcemaf,haploid=do_haploid)
		}else{
		# generate a flat distribution of minor allele frequencies:
		sourcemaf			<- rep(meansourcemaf,nloc)
		}
	#
	# Simulate source mac and after ngen generations:
	cat("###### GENERATING MAC DISTRIBUTION OF SOURCE POPULATION AFTER N GENERATIONS ######",sep="\n")
	mymafendmatrix		<- matrix(NA,nrow=3,ncol=nloc)
	mafvec				<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=ngen,mafstartvector=sourcemaf,haploid=do_haploid)		# population allele frequencies
	macmatrix[8,]		<- sapply(mafvec,function(mafvec){rbinom(1,(2*samplesize),mafvec)})									# sample allele counts
	mymafendmatrix[3,]	<- mafvec 
	if(testgeno)
		{
		genotypecounts[[4]]<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
		}
	#
	# Simulate founder macs directly after founder event and after ngen generations:
	cat("###### GENERATING MAC DISTRIBUTION OF FOUNDER POPULATIONS AFTER FOUNDER EVENT AND AFTER N GENERATIONS ######",sep="\n")
	founderstartmatrix	<- matrix(nrow=2,ncol=nloc)
	for (k in c(1:2))
		{
		cat(paste("FOUNDER POPULATION ",k,".",sep=""),sep="\n")
		mafvec					<- getfounderpopmaf(sourcemafvector=sourcemaf,nrfounders=nfounders,nefounderpop=founderpopsizes[k,],nrloci=nloc,ngenfounder=ngen,nselectloci=nselectedloci,selc=selcoef,dohap=do_haploid,dodiscrete=s_discrete)
		mymafendmatrix[k,]		<- mafvec 																						# population allele frequencies
		macmatrix[k*2,]			<- sapply(mafvec,function(mafvec){rbinom(1,(2*samplesize),mafvec)})							# sample allele counts
		founderstartmatrix[k,]	<- mysambarsim$founderstartmaf 
		if(testgeno)
			{
			genotypecounts[[k]]<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
			}
		}
	mymafstartmatrix			<- rbind(founderstartmatrix,sourcemaf)
	rownames(mymafstartmatrix)	<- c("founderstartmaf1","founderstartmaf2","sourcestartmaf")
	sourcemaf_nonzero			<- sourcemaf>0
	#
	mysambarsim$mymafstartmatrix<<- mymafstartmatrix
	mysambarsim$mymafendmatrix	<<- mymafendmatrix
	#
	###### Execute fisher's exact test on simulated data using built-in R-function:  
	cat("###### RUNNING SELECTION SCANS ######",sep="\n")
	if(testgeno)
		{
		# if testgeno (default is FALSE), execute rfisher test on genotype counts rather than on minor allele counts
		# Combine both founder populations into one founder population:
		genotypecounts[[3]]<- genotypecounts[[1]]+genotypecounts[[2]]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons, for source against source (pointless indeed), as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(7,8,2*j-1,2*j),i],2,2,byrow=TRUE)})
			pvaluepairwise[j,]	<<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
			}
		}else{
		# Combine both founder populations into one founder population:
		macmatrix[6,]	<- macmatrix[2,]+macmatrix[4,]
		# calculate number of major alleles:
		macmatrix[1,]	<- 2*samplesize-macmatrix[2,]
		macmatrix[3,]	<- 2*samplesize-macmatrix[4,]
		macmatrix[5,]	<- 4*samplesize-macmatrix[6,]
		macmatrix[7,]	<- 2*samplesize-macmatrix[8,]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons,as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(7,8,2*j-1,2*j),i],2,2,byrow=TRUE)})
			pvaluepairwise[j,]	<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
			}
		}
	mysambarsim$macmatrix		<<- macmatrix
	# negative log of pvalues:
	logp					<- (-log(pvaluepairwise))
	rownames(logp)			<- c("F1vsS","F2vsS","FcombivsS")
	# how many (minor) alleles passed through bottleneck event?
	# adaptive loci:
	nneutralloci			<- nloc-nselectedloci
	temp					<- sourcemaf_nonzero[c(1:nneutralloci)]
	nneutralloci_nonzero	<- length(temp[temp])
	if(nneutralloci<nloc)
		{
		temp					<- sourcemaf_nonzero[c((nneutralloci+1):nloc)]
		nadaptiveloci_nonzero	<- length(temp[temp])
		retained_variation		<- apply(founderstartmatrix[,c(nneutralloci+1):nloc],2,min)>0
		retained_variation_1	<- founderstartmatrix[1,c(nneutralloci+1):nloc]>0
		retained_variation_2	<- founderstartmatrix[2,c(nneutralloci+1):nloc]>0
		nretained_select_both	<- length(retained_variation[retained_variation])
		nretained_select_1		<- length(retained_variation_1[retained_variation_1])
		nretained_select_2		<- length(retained_variation_2[retained_variation_2])
		nretained_select_either	<- length(union(which(founderstartmatrix[1,c(nneutralloci+1):nloc]>0),which(founderstartmatrix[2,c(nneutralloci+1):nloc]>0)))
		retained_both_snpid		<- nneutralloci+(intersect(which(founderstartmatrix[1,c((nneutralloci+1):nloc)]>0),which(founderstartmatrix[2,c((nneutralloci+1):nloc)]>0)))
		retained_either_snpid	<- nneutralloci+(union(which(founderstartmatrix[1,c((nneutralloci+1):nloc)]>0),which(founderstartmatrix[2,c((nneutralloci+1):nloc)]>0)))
		}else{
		retained_both_snpid		<- NULL
		retained_either_snpid	<- NULL
		}
	# neutral loci:
	retained_variation_all	<- apply(founderstartmatrix[,c(1:nneutralloci)],2,min)>0
	retained_variation_all_1<- founderstartmatrix[1,c(1:nneutralloci)]>0
	retained_variation_all_2<- founderstartmatrix[2,c(1:nneutralloci)]>0
	nretained_neutral_both	<- length(retained_variation_all[retained_variation_all])
	nretained_neutral_1		<- length(retained_variation_all_1[retained_variation_all_1])
	nretained_neutral_2		<- length(retained_variation_all_2[retained_variation_all_2])
	nretained_neutral_either<- length(union(which(founderstartmatrix[1,c(1:nneutralloci)]>0),which(founderstartmatrix[2,c(1:nneutralloci)]>0)))
	#
	# how many alleles fixated?
	mytestscores			<- matrix(NA,ncol=16,nrow=4)
	colnames(mytestscores)	<- c("retained_adaptive","retained_neutral","gwds_FN","gwds_FP","PCadapt_FN","PCadapt_FP","OutFLANK_FN","OutFLANK_FP","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected")
	rownames(mytestscores)	<- c("F1_vs_S","F2_vs_S","pooled_F_vs_S","compare_F_vs_S")
	for(i in c(1:3))
		{
		myfactor			<- ifelse(i==3,4,2)		# if pooled approach, times 4, if pairwise approach, times 2. E.g. if samplesize is 30, then in total 60 alleles per population, and 120 alleles for both founder populations combined  
		# neutral loci:
		if(nneutralloci<nloc)
			{
			mactemp			<- macmatrix[2*i,c(1:nneutralloci)]
			}else{
			mactemp			<- macmatrix[2*i,]
			}
		maftemp				<- mactemp/(samplesize*myfactor)
		mytestscores[i,10]	<- round(length(maftemp[maftemp==1])/length(maftemp),3)
		# adaptive loci:
		if(nneutralloci<nloc)
			{
			mactemp			<- macmatrix[2*i,c((nneutralloci+1):nloc)]
			}else{
			mactemp			<- 0
			}
		maftemp				<- mactemp/(samplesize*myfactor)	
		mytestscores[i,9]	<- round(length(maftemp[maftemp==1])/length(maftemp),3)
		}
	# GWDS and Manhattan plot:
	mysambarsim$gwdsoutlierslist	<<- list() 
	mysambarsim$pcadaptoutlierslist	<<- list()
	mysambarsim$outflankoutlierslist<<- list()
	mysambarsim$gwdslogplist		<<- list()
	mysambarsim$gwdslognewplist		<<- list()
	mysambarsim$pcadaptlogplist		<<- list()
	mysambarsim$outflanklogqlist	<<- list()
	mysambarsim$outflanklogplist	<<- list()
	testFDR							<- as.data.frame(matrix(NA,ncol=3,nrow=3))
	colnames(testFDR)				<- c("gwds","outflank","pcadapt")
	rownames(testFDR)				<- c("pairwise1","pairwise2","pooled")
	#
	graphics.off()
	plotname				<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"manhattan.pdf",sep=".")
	if(export){pdf(plotname,height=8,width=14)}
	par(mfrow=c(3,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	mycomparisons			<- c("F1 vs S","F2 vs S","both_F vs S")
	for(i in (c(1:3)))
		{
		cat(paste("###### ",mycomparisons[i]," ######",sep=""),sep="\n")
		#mylogp				<<- logp
		mymax				<- round(max(logp[is.finite(logp)],na.rm=TRUE))
		plot(logp[i,],col=neutralcol,ylim=c(0,mymax),pch=16,ylab="",xlab="",main="",xaxt='n',las=2)
		if(i==3){axis(1,at=seq(0,nloc,nloc/5),labels=seq(0,nloc,nloc/5))}
		mytitle				<- ifelse(i==1,"founder_1 vs source",(ifelse(i==2,"founder_2 vs source","both founders vs source")))
		mtext(mytitle,side=4,line=1,cex=1.25)
		mylogp				<- logp[i,]
		mylogpneutral		<- mylogp[c(1:nneutralloci)]
		myreflogp			<- mylogp
		mymean				<- mean(mylogpneutral[mylogpneutral<quantile(mylogpneutral,my_quantile)])	
		cat(paste("Mean ln(fisher exact test p-value):",round(mymean,2),sep=" "),sep="\n")
		myrate				<- 1/mymean
		gwds_pvalues		<- 1-pexp(mylogp,myrate)			# 03-08-2020: convert fisher exact test p-values to GWDS p-values: 
		mythres				<- 1-(my_alpha/nneutralloci)
		myvalue				<- qexp(mythres,myrate)
		gwdsout				<- which(mylogp>=myvalue)
		gwds_pvalues_uncorrected	<- gwds_pvalues
		if(mycorrection=="none")
			{
			cat(paste("Threshold Fisher exact test log p-value: ",round(myvalue,2),".",sep=""),sep="\n")
			#cat(paste("Threshold:",round(myvalue,2),sep=" "),sep="\n")
			ndetected_neutral		<- length(mylogpneutral[mylogpneutral>myvalue])
			}else{
			cat(paste("Correcting GWDS p-values using the ",mycorrection," method.",sep=""),sep="\n")
			gwds_pvalues			<- p.adjust(gwds_pvalues,method=mycorrection)
			gwdsout					<- which(gwds_pvalues<=my_alpha)
			gwds_pvalues_neutral	<- gwds_pvalues[1:nneutralloci]
			ndetected_neutral		<- length(mylogpneutral[gwds_pvalues_neutral<=my_alpha])
			}
		cat(paste("GWDS detected",length(gwdsout),"outlier loci.",sep=" "),sep="\n")
		my_fdr					<- ifelse(ndetected_neutral>0,1,0)						# we next correct this value if the simulation includes loci under selection
		if(nneutralloci<nloc)
			{
			if(parallelselection)
				{
				mylogpoutliers			<- mylogp[retained_both_snpid]		
				pvalues_retainedadaptive<- gwds_pvalues[retained_both_snpid]
				}else{
				mylogpoutliers			<- mylogp[retained_either_snpid]
				pvalues_retainedadaptive<- gwds_pvalues[retained_either_snpid]
				}
			# mylogpoutliers	<- mylogp[c(nneutralloci+1):nloc]
			ndetected_outliers	<- length(mylogpoutliers[mylogpoutliers>myvalue])
			if(mycorrection!="none")
				{
				ndetected_outliers	<- length(pvalues_retainedadaptive[pvalues_retainedadaptive<=my_alpha]) 
				}
			# 07-08-2020: note: false discovery rate ultimately depends on the proportion of adaptive loci in your dataset, and is hence not really informative.
			# for example: say power is 40% and specificity is 99.9%.
			# if you have 100.000 SNPs, of which 10.000 are adaptive, then false discovery rate is:
			# ((1-0.999)*90000)/(0.4*10000+((1-0.999)*90000)) = 0.022 = 2.2%
			# however, if you have 100K SNPs, of which only 10 are adaptive, then false discovery rate:
			# ((1-0.999)*90000)/(0.4*10+((1-0.999)*90000)) = 0.957 = 96%
			#
			my_fdr				<- ndetected_neutral/(ndetected_neutral+ndetected_outliers)
			nretained_select	<- ifelse(i==1,nretained_select_1,(ifelse(i==2,nretained_select_2,ifelse(parallelselection,nretained_select_both,nretained_select_either))))
			mytestscores[i,1]	<- round(nretained_select/nadaptiveloci_nonzero,my_round)						# proportion retained
			mytestscores[i,3]	<- round((nretained_select-ndetected_outliers)/(nretained_select),my_round)		# inverse of power
			mytestscores[i,11]	<- ndetected_neutral
			}else{
			ndetected_outliers	<- 0
			}
		testFDR[i,1]				<- my_fdr 
		nretained_neutral			<- ifelse(i==1,nretained_neutral_1,(ifelse(i==2,nretained_neutral_2,ifelse(parallelselection,nretained_neutral_both,nretained_neutral_either))))
		mytestscores[i,2]			<- round(nretained_neutral/nneutralloci_nonzero,my_round)
		#mytestscores[i,4]			<- round(ndetected_neutral/nneutralloci_nonzero,nchar(nneutralloci))
		mytestscores[i,4]			<- round(ndetected_neutral/nneutralloci_nonzero,my_round)
		mytestscores[i,12]			<- ndetected_outliers
		# add threshold to plot:
		abline(h=myvalue,lty=2) 
		mylogp[is.na(mylogp)]		<- 0	
		mysambarsim$gwdslogplist[[i]]			<<- mylogp
		mysambarsim$gwdslognewplist[[i]]		<<- -log10(gwds_pvalues_uncorrected)
		# threshold if including outliers:
		# mymean				<- mean(mylogp)	
		# myrate				<- 1/mymean
		# mybonf				<- 1-(0.05/(length(mylogp)))
		# myvalue				<- qexp(mybonf,myrate)
		# abline(h=myvalue,lty=2) 
		# Note: If selected loci are included in the simulation, this affects the overall distribution of the test parameter (such a -logp.)
		# Therefore, best to obtain neutral distribution from neutral loci only.
		# This is possible for gwds and for Outflank.
		# Not possible for PCadapt.
		# However, PCadapt seems to find it easier to recognize neutral loci as non-outlier if outliers are included. 
		# PCadapt and OutFLANK:
		if(i==3)
			{
			nsamples			<- c(2*samplesize,samplesize)
			nretained_select	<- ifelse(nneutralloci<nloc,ifelse(parallelselection,nretained_select_both,nretained_select_either),0)			# choose whether allele should have been retained in both pops during bottleneck event
			nretained_neutral	<- ifelse(parallelselection,nretained_neutral_both,nretained_neutral_either)
			}else{
			nsamples			<- c(samplesize,samplesize)
			if(i==1)
				{
				nretained_select	<- ifelse(nneutralloci<nloc,nretained_select_1,0)
				nretained_neutral	<- nretained_neutral_1
				}else{
				nretained_select	<- ifelse(nneutralloci<nloc,nretained_select_2,0)
				nretained_neutral	<- nretained_neutral_2
				}
			}
		n_inds_founder		<- samplesize*2		# 2 populations combined
		# 30-08-2020: previously it stated for all comparisons: mymaf_1 <- macmatrix[i*2,]/(n_inds_founder*2) 
		if(i==3)
			{
			mymaf_1				<- macmatrix[i*2,]/(n_inds_founder*2)	
			}else{
			mymaf_1				<- macmatrix[i*2,]/(samplesize*2)
			}
		mymaf_2				<- macmatrix[8,]/(samplesize*2)
		cat(paste("Number of individuals per founder population: ",samplesize,".",sep=""),sep="\n")
		cat(paste("Number of individuals in both founder populations combined: ",n_inds_founder,".",sep=""),sep="\n")
		cat(paste("Number of individuals in source population: ",samplesize,".",sep=""),sep="\n")
		if(do_selectionscan)
			{
			simscanout		<- simscan(my_correction=mycorrection,myalpha=my_alpha,sample_sizes=nsamples,mafvector1=mymaf_1,mafvector2=mymaf_2,n_selected=nselectedloci,store_adjusted=show_adjustedp)
			outflankout		<- simscanout[[1]]	
			outflanklogq	<- simscanout[[2]]	
			pcadaptout		<- simscanout[[3]]	
			pcadaptlogp		<- simscanout[[4]]
			outflanklogp	<- simscanout[[5]]
			testFDR[i,2]	<- mysambarsim$outflankfdr_value
			testFDR[i,3]	<- mysambarsim$pcadaptfdr_value
			# cat(max(pcadaptlogp,na.rm=TRUE),sep="\n")
			# what are the logp scores of the outliers detected by pcadapt and outflank? 
			gwdslogp_pcadaptout		<- logp[i,pcadaptout]
			points(pcadaptout,gwdslogp_pcadaptout,col="darkgreen",cex=1.5,pch=16)
			gwdslogp_outflankout	<- logp[i,outflankout]
			#if(any(outflankout)
			#	{
				points(outflankout,gwdslogp_outflankout,col="orange",cex=2.5)
			#	}
			# what is the sensitivity and specificity of PCadapt?
			if(parallelselection)
				{
				npcadaptout_select	<- length(pcadaptout[pcadaptout%in%retained_both_snpid])
				outflankout_select	<- length(outflankout[outflankout%in%retained_both_snpid])
				}else{
				npcadaptout_select	<- length(pcadaptout[pcadaptout%in%retained_either_snpid])
				outflankout_select	<- length(outflankout[outflankout%in%retained_either_snpid])
				}
			#npcadaptout_select		<- length(pcadaptout[pcadaptout>nneutralloci])
			#outflankout_select		<- length(outflankout[outflankout>nneutralloci])
			npcadaptout_neutral		<- length(pcadaptout[pcadaptout<=nneutralloci])
			outflankout_neutral		<- length(outflankout[outflankout<=nneutralloci])
			if(nneutralloci<nloc)
				{
				mytestscores[i,5]		<- round((nretained_select-npcadaptout_select)/(nretained_select),3)
				mytestscores[i,7]		<- round((nretained_select-outflankout_select)/(nretained_select),3)
				}
			mytestscores[i,6]		<- round(npcadaptout_neutral/nretained_neutral,nchar(nneutralloci))
			mytestscores[i,8]		<- round(outflankout_neutral/nretained_neutral,nchar(nneutralloci))
			mytestscores[i,13]		<- outflankout_neutral
			mytestscores[i,14]		<- outflankout_select
			mytestscores[i,15]		<- npcadaptout_neutral
			mytestscores[i,16]		<- npcadaptout_select
			# store outlier loci:
			pcadaptlogp[is.na(pcadaptlogp)]		<- 0
			outflanklogq[is.na(outflanklogq)]	<- 0
			outflanklogp[is.na(outflanklogp)]	<- 0
			mysambarsim$pcadaptlogplist[[i]]	<<- pcadaptlogp
			mysambarsim$outflanklogqlist[[i]]	<<- outflanklogq
			mysambarsim$outflanklogplist[[i]]	<<- outflanklogp
			mysambarsim$gwdsoutlierslist[[i]]	<<- gwdsout
			mysambarsim$pcadaptoutlierslist[[i]]<<- pcadaptout
			mysambarsim$outflankoutlierslist[[i]]<<- outflankout
			}
		}
	mtext("Fisher exact test score",side=2,line=0.5,cex=2.5,outer=TRUE)
	mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
	if(export){dev.off()}
	if(export)
		{
		fileConn	<- file("README.txt")
		writeLines(c("The Manhattan plot shows the Fisher exact test scores for both pairwise comparisons and for the pooled comparisons (both founders vs source).",
		"Selected SNPs are at the right hand side of the plot.",
		"Dots above the dashed line are marked by GWDS as outliers.",
		"Green dots are marked by PCadapt as outliers.",
		"Yellow encircled dots are marked by OutFLANK as outliers.",
		"The Venn diagram shows the overlap between true selected SNPs and SNPs marked by the selection scans.", 
		"The Fdist plots show the Cockerham & Weir 1987 He and Fst values of SNPs for both pairwise comparisons (.1 and .2) and the pooled comparison (.3).",
		"Red dots in the left tile are true SNPs under selection.",
		"Red dots in the other tiles are SNPs marked by selection scans.",
		""),fileConn)
		close(fileConn)
		}
	#
	# compare outliers detected in pairwise comparisons to outliers detected by pooled approach:
	overlapmatrix		<- matrix(NA,ncol=2,nrow=3)
	gwdsoutlierslist	<- mysambarsim$gwdsoutlierslist
	if(length(gwdsoutlierslist)==3)
		{
		gwds1neutral		<- gwdsoutlierslist[[1]][gwdsoutlierslist[[1]]<=nneutralloci]
		gwds1adaptive		<- gwdsoutlierslist[[1]][gwdsoutlierslist[[1]]>nneutralloci]
		gwds2neutral		<- gwdsoutlierslist[[2]][gwdsoutlierslist[[2]]<=nneutralloci]
		gwds2adaptive		<- gwdsoutlierslist[[2]][gwdsoutlierslist[[2]]>nneutralloci]
		gwds3neutral		<- gwdsoutlierslist[[3]][gwdsoutlierslist[[3]]<=nneutralloci]
		gwds3adaptive		<- gwdsoutlierslist[[3]][gwdsoutlierslist[[3]]>nneutralloci]
		overlapmatrix[1,1]	<- length(which(gwds3adaptive %in% gwds1adaptive))/length(gwds3adaptive)
		overlapmatrix[1,2]	<- length(which(gwds3adaptive %in% gwds2adaptive))/length(gwds3adaptive)
		}else{
		overlapmatrix[1,1]	<- 0
		overlapmatrix[1,2]	<- 0
		}
	pcadaptoutlierslist	<- mysambarsim$pcadaptoutlierslist
	if(length(pcadaptoutlierslist)==3)
		{
		pcadapt1neutral		<- pcadaptoutlierslist[[1]][pcadaptoutlierslist[[1]]<=nneutralloci]
		pcadapt1adaptive	<- pcadaptoutlierslist[[1]][pcadaptoutlierslist[[1]]>nneutralloci]
		pcadapt2neutral		<- pcadaptoutlierslist[[2]][pcadaptoutlierslist[[2]]<=nneutralloci]
		pcadapt2adaptive	<- pcadaptoutlierslist[[2]][pcadaptoutlierslist[[2]]>nneutralloci]
		pcadapt3neutral		<- pcadaptoutlierslist[[3]][pcadaptoutlierslist[[3]]<=nneutralloci]
		pcadapt3adaptive	<- pcadaptoutlierslist[[3]][pcadaptoutlierslist[[3]]>nneutralloci]
		overlapmatrix[2,1]	<- length(which(pcadapt3adaptive %in% pcadapt1adaptive))/length(pcadapt3adaptive)
		overlapmatrix[2,2]	<- length(which(pcadapt3adaptive %in% pcadapt2adaptive))/length(pcadapt3adaptive)
		}else{
		overlapmatrix[2,1]	<- 0
		overlapmatrix[2,2]	<- 0
		}
	outflankoutlierslist	<- mysambarsim$outflankoutlierslist
	if(length(mysambarsim$outflankoutlierslist)==3)
		{
		outflank1neutral	<- outflankoutlierslist[[1]][outflankoutlierslist[[1]]<=nneutralloci]
		outflank1adaptive	<- outflankoutlierslist[[1]][outflankoutlierslist[[1]]>nneutralloci]
		outflank2neutral	<- outflankoutlierslist[[2]][outflankoutlierslist[[2]]<=nneutralloci]
		outflank2adaptive	<- outflankoutlierslist[[2]][outflankoutlierslist[[2]]>nneutralloci]
		outflank3neutral	<- outflankoutlierslist[[3]][outflankoutlierslist[[3]]<=nneutralloci]
		outflank3adaptive	<- outflankoutlierslist[[3]][outflankoutlierslist[[3]]>nneutralloci]
		overlapmatrix[3,1]	<- length(which(outflank3adaptive %in% outflank1adaptive))/length(outflank3adaptive)
		overlapmatrix[3,2]	<- length(which(outflank3adaptive %in% outflank2adaptive))/length(outflank3adaptive)
		}else{
		overlapmatrix[3,1]	<- 0
		overlapmatrix[3,2]	<- 0
		}
	overlapdf				<- as.data.frame(overlapmatrix)
	colnames(overlapdf)		<- c("Pop1","Pop2")
	rownames(overlapdf)		<- c("gwds","pcadapt","outflank")
	mysambarsim$overlapdf	<<- overlapdf
	#
	# comparison between outliers scored by GWDS in both pairwise comparisons separately:
	if(do_selectionscan&nneutralloci<nloc)
		{
		nretained_select	<- ifelse(parallelselection,nretained_select_both,nretained_select_either)			# choose whether allele should have been retained in both pops during bottleneck event
		nretained_neutral	<- ifelse(parallelselection,nretained_neutral_both,nretained_neutral_either)
		myoverlap			<- intersect(gwdsoutlierslist[[1]],gwdsoutlierslist[[2]])							# same as: gwdsoutlierslist[[1]] %in% gwdsoutlierslist[[2]]
		ndetected_overlap	<- length(myoverlap[myoverlap])
		falseneg			<- round((nretained_select-ndetected_overlap)/(nretained_select),my_round)
		myoverlap_neutral	<- myoverlap[myoverlap>nneutralloci]
		ndetected_overlap_neutral<- length(myoverlap_neutral[myoverlap_neutral])
		mytestscores[4,1]	<- round(nretained_select/nselectedloci,my_round)
		mytestscores[4,2]	<- round(nretained_neutral/nneutralloci,my_round)
		mytestscores[4,3]	<- round((nretained_select-ndetected_overlap)/(nretained_select),my_round)
		mytestscores[4,4]	<- (ndetected_overlap_neutral)/nretained_neutral
		}
	#
	if(createplots)
		{
		cat("##### GENERATING OUTPUT PLOTS ######",sep="\n")
		cat("Plotting minor allele counts...",sep="\n")
		plotmac(export=TRUE,nloci=nloc,nselect=nselectedloci,sample_size=samplesize)
		if(do_selectionscan&do_logplot)
			{
			cat("Plotting teststatistics...",sep="\n")
			if(mycorrection=="none")
				{
				# 04-03-19: my simulations showed that OutFlank has lowest FDR when not using qvalues (default), but when using holm corrected p values
				# plotlogvalues(do_export=export,nr_loci=nloc,nr_selected=nselectedloci,plotqvalue=TRUE)
				plotlogvalues(do_export=export,nr_loci=nloc,nr_selected=nselectedloci,plotqvalue=FALSE)
				}else{
				plotlogvalues(do_export=export,nr_loci=nloc,nr_selected=nselectedloci,plotqvalue=FALSE)
				}
			}else{
			cat("Skipping teststatistic plots.",sep="\n")
			}
		if(do_selectionscan&do_Fdist)
			{
			cat("Creating Fdist plots...",sep="\n")
			simFdist(addbayescan=FALSE,do_export=export,nloci=nloc,nselloci=nselectedloci,n_samples=samplesize,retainedin1pop=TRUE)
			}
		# Generate 2D Manhattan plot with negative log of pvalues:
		if(do_selectionscan&do_logplot)
			{
			cat("Generating 2D test statistic plots...",sep="\n")
			multiplotp_sim(export="pdf",nr_loci=nloc,nr_selected=nselectedloci)
			}
		if(do_venn)
			{
			if(nneutralloci<nloc)
				{
				if(parallelselection)
					{
					my_realoutliers		<- retained_both_snpid
					}else{
					my_realoutliers		<- retained_either_snpid
					}
				}else{
				my_realoutliers		<- NULL
				}
			venn_plotname			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"Venn",sep=".")
			if(nselectedloci>0)
				{
				plotvennsim(export="pdf",plotname=venn_plotname,myrealoutliers=my_realoutliers)
				}
			}
		if(nselectedloci>0)
			{
			multioverlap_approach_sim(doexport="pdf",add_numbers=FALSE)
			}
		if(exists("snps"))
			{
			if("Barff"%in%mysambar$population2)
				{
				exp_nout(bayescanfile=NULL,export="pdf")
				}
			}
		}
	#
	# output test scores:
	cat("Generating testscore tables...",sep="\n")
	mytestscores						<- as.data.frame(mytestscores)
	mytestscores$fixed_adaptive2		<- round(mytestscores$fixed_adaptive/mytestscores$retained_adaptive,my_round)
	mytestscores$fixed_neutral2			<- round(mytestscores$fixed_neutral/mytestscores$retained_neutral,my_round)
	mytestscores2						<- 1-mytestscores
	colnames(mytestscores2)				<- c("loss_adaptive","loss_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","non_fixed_adaptive","non_fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","non_fixed_adaptive2","non_fixed_neutral2")
	mytestscores2$gwds_nout_neutral		<- mytestscores$gwds_nout_neutral
	mytestscores2$gwds_nout_adaptive	<- mytestscores$gwds_nout_adaptive
	mytestscores2$outflank_nout_neutral	<- mytestscores$outflank_nout_neutral
	mytestscores2$outflank_nout_adaptive<- mytestscores$outflank_nout_adaptive
	mytestscores2$pcadapt_nout_neutral	<- mytestscores$pcadapt_nout_neutral
	mytestscores2$pcadapt_nout_detected	<- mytestscores$pcadapt_nout_detected
	#
	mysambarsim$mytestscores			<<- mytestscores
	mysambarsim$mytestscores2			<<- mytestscores2
	#
	if(parallelselection)
		{
		tablename			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"bothpop",sep=".")
		}else{
		tablename			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"eitherpop",sep=".")
		}
	if(export)
		{
		write.table(mytestscores,file=paste(tablename,"testscores1.txt",sep="."),quote=FALSE)
		write.table(mytestscores2,file=paste(tablename,"testscores2.txt",sep="."),quote=FALSE)
		setwd(current_dir)
		}
	#nneutralloci		<<- c(nneutralloci_nonzero,nneutralloci,nneutralloci_nonzero/nneutralloci)	
	if(do_selectionscan)
		{
		cat("Generating False Discovery Rate table...",sep="\n")
		testFDR2					<- as.matrix(testFDR)
		testFDR2[is.nan(testFDR2)] 	<- NA
		testFDR2[is.na(testFDR2)] 	<- 0
		testFDR2					<- round(testFDR2,my_round)
		testFDR						<- testFDR2
		}
	mysambarsim$testFDR				<<- testFDR
	}	

plotmac<-function(export=FALSE,nloci=10000,nselect=1000,sample_size=100)
	{
	macmatrix	<- mysambarsim$macmatrix
	if(export){pdf("Minor_allele_counts.pdf",height=8,width=8)}
	par(mfrow=c(4,1))
	par(mfrow=c(4,1),mar=c(1,1,1,1),oma=c(3,4,1,2.5),cex.axis=1.5,cex.lab=2.5)
	#mymax	<- max(macmatrix[6,])
	mymax	<- sample_size*2	# diploid (2 alleles per individual) 
	mymax2	<- sample_size*2*2	# diploid (2 alleles per individual); 2 populations combined 
	plot(macmatrix[2,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"founder 1",line=1,cex=1.25)
	plot(macmatrix[4,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"founder 2",line=1,cex=1.25)
	plot(macmatrix[6,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"both founders",line=1,cex=1.25)
	plot(macmatrix[8,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"source",line=1,cex=1.25)
	mtext(side=1,"SNP index",outer=TRUE,line=2,cex=1.5)
	mtext(side=2,"Minor allele counts",outer=TRUE,line=2.5,cex=1.5)
	if(export){dev.off()}
	#
	# scatterplot:
	if(export){pdf("Minor_allele_counts_scatter.pdf",height=6,width=6)}
	plot(macmatrix[8,1:(nloci-nselect)],macmatrix[6,1:(nloci-nselect)],ylim=c(0,4*sample_size),xlim=c(0,2*sample_size),pch=16,cex=0.5,xlab="MAC source",ylab="MAC founders (combined)")
	if(nselect>0)
		{
		points(macmatrix[8,(nloci-nselect+1):nloci],macmatrix[6,(nloci-nselect+1):nloci],pch=16,cex=0.5,col="red")
		}
	if(export){dev.off()}
	}

plotvennsim<-function(export=NULL,plotname="Simulateddata.Venn",myrealoutliers=NULL,mycomp_nr=3,bayescanfile=NULL,bayescanFDR=0.01)
	{
	if(!is.null(bayescanfile)){getbayescansim(bayescanfile=bayescanfile,FDR=bayescanFDR)}
	gwdsoutlierslist	<- mysambarsim$gwdsoutlierslist
	outflankoutlierslist<- mysambarsim$outflankoutlierslist
	pcadaptoutlierslist	<- mysambarsim$pcadaptoutlierslist
	graphics.off()
	cat("Generating Venn diagram...",sep="\n")
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=6,width=8)}
		}
	#venn(list(GWDS=gwdsoutlierslist[[3]],OUTFLANK=outflankoutlierslist[[3]],adaptive=myrealoutliers,PCADAPT=pcadaptoutlierslist[[3]]))
	if(!is.null(myrealoutliers))
		{
		if(is.null(bayescanfile))
			{
			v1 <- venn.diagram(list(adaptive=myrealoutliers,GWDS=gwdsoutlierslist[[3]],PCadapt=pcadaptoutlierslist[[3]],OutFlank=outflankoutlierslist[[3]]),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("grey","blue","darkgreen","orange"),col=c("grey","blue","darkgreen","orange"),margin=0.12)
			}else{
			mybayescanout	<- which(simbayescan$bayescanout)
			v1 <- venn.diagram(list(adaptive=myrealoutliers,GWDS=gwdsoutlierslist[[3]],Bayescan=mybayescanout,PCadapt=pcadaptoutlierslist[[3]],OutFlank=outflankoutlierslist[[3]]),filename=NULL,alpha=0.6,cex=2.5,cat.cex=2.5,fill=c("grey","blue","darkred","darkgreen","orange"),col=c("grey","blue","darkred","darkgreen","orange"),margin=0.2)
			}
		grid.newpage()
		grid.draw(v1)
		if(!is.null(export)){dev.off()}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		}else{
		venn(list(GWDS=gwdsoutlierslist[[mycomp_nr]],OutFlank=outflankoutlierslist[[mycomp_nr]],PCadapt=pcadaptoutlierslist[[mycomp_nr]]))
		if(!is.null(export)){dev.off()}
		}
	}

plotvennsim_old<-function()
	{
	gwdsoutlierslist	<- mysambarsim$gwdsoutlierslist
	outflankoutlierslist<- mysambarsim$outflankoutlierslist
	pcadaptoutlierslist	<- mysambarsim$pcadaptoutlierslist
	pdf("venn.pdf",height=6,width=8)
	myrealoutliers		<- retained_either_snpid
	v1 <- venn.diagram(list(adaptive_loci=myrealoutliers,GWDS=gwdsoutlierslist[[2]],PCadapt=pcadaptoutlierslist[[2]],OutFLANK=outflankoutlierslist[[2]]),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("grey","blue","darkgreen","orange"),col=c("grey","blue","darkgreen","orange"),margin=0.13)
	grid.newpage()
	grid.draw(v1)
	dev.off()
	}
	
# requires locWeirFst()
simFdist<-function(addbayescan=FALSE,do_export=FALSE,nloci=10000,nselloci=1000,n_samples=30,retainedin1pop=FALSE)
	{
	macmatrix				<- mysambarsim$macmatrix
	mymafstartmatrix		<- mysambarsim$mymafstartmatrix
	graphics.off()
	# myfstvalues			<<- matrix(ncol=3,nrow=nloci)
	nneutralloci			<- nloci-nselloci
	retained_founder1		<- nneutralloci+which(mymafstartmatrix[1,c((nneutralloci+1):nloci)]>0)
	retained_founder2		<- nneutralloci+which(mymafstartmatrix[2,c((nneutralloci+1):nloci)]>0)
	retained_both_snpid		<- nneutralloci+(intersect(which(mymafstartmatrix[1,c((nneutralloci+1):nloci)]>0),which(mymafstartmatrix[2,c((nneutralloci+1):nloci)]>0)))
	retained_either_snpid	<- nneutralloci+(union(which(mymafstartmatrix[1,c((nneutralloci+1):nloci)]>0),which(mymafstartmatrix[2,c((nneutralloci+1):nloci)]>0)))
	for(i in c(1:3))
		{
		#plotname			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"Fdist",i,"pdf",sep=".")
		plotname			<- paste("Fdist",i,"pdf",sep=".")
		if(do_export){pdf(plotname,height=4,width=12)}
		par(mfrow=c(1,4),mar=c(0.5,0.5,0.5,0.5),oma=c(5,5,0.5,0.5),cex.axis=1.5,cex.lab=2.5)
		sample_sizes		<- c(2*n_samples,n_samples)									# 2 founder populations
		### First tile ###
		# plot all loci:
		if(i==3)
			{
			mafneutral1			<- macmatrix[i*2,]/(sample_sizes[1]*2)						# 2 alleles per individual
			}else{
			mafneutral1			<- macmatrix[i*2,]/(sample_sizes[2]*2)
			}
		mafneutral2			<- macmatrix[8,]/(sample_sizes[2]*2)						# 2 alleles per individual
		locWeirFst(mafvector1=mafneutral1,mafvector2=mafneutral2,plottitle="",xlabel="",ylabel="",dothin=TRUE)
		# add real outliers to plot:
		# myfstvalues[,i]		<<- WeirFst
		if(i==1)
			{
			myselection			<- retained_founder1
			mafselect_1			<- macmatrix[i*2,myselection]/(sample_sizes[2]*2)	
			}
		if(i==2)
			{
			myselection			<- retained_founder2
			mafselect_1			<- macmatrix[i*2,myselection]/(sample_sizes[2]*2)	
			}
		if(i==3)
			{
			myselection_either	<- retained_either_snpid
			myselection			<- retained_both_snpid
			mafselect_1			<- macmatrix[i*2,myselection]/(sample_sizes[1]*2)	
			if(retainedin1pop)
				{
				mafselect_1_either	<- macmatrix[i*2,myselection_either]/(sample_sizes[1]*2)
				mafselect_2_either	<- macmatrix[8,myselection_either]/(sample_sizes[2]*2)
				locWeirFst(mafvector1=mafselect_1_either,mafvector2=mafselect_2_either,addpoints=TRUE,outliercol="orange",dothin=TRUE)
				legend(x=0,y=0.95,legend=c("Both populations","One population"),fill=c("red","orange"),bty='n',cex=1.5)
				}
			}
		mafselect_2				<- macmatrix[8,myselection]/(sample_sizes[2]*2)
		locWeirFst(mafvector1=mafselect_1,mafvector2=mafselect_2,addpoints=TRUE,outliercol="red",dothin=TRUE)
		mtext("adaptive loci",side=3,line=-2.5,cex=1.75)
		### Other tiles ### 
		outlierlist				<- list()
		outlierlist[[1]]		<- mysambarsim$pcadaptoutlierslist[[i]]	
		if(addbayescan)
			{
			outlierlist[[2]]	<- bayescanoutlierslist[[i]]	
			}else{
			outlierlist[[2]]	<- mysambarsim$outflankoutlierslist[[i]]	
			}
		outlierlist[[3]]		<- mysambarsim$gwdsoutlierslist[[i]]
		if(addbayescan)
			{
			names(outlierlist)	<- c("PCadapt","Bayescan","GWDS")
			}else{
			names(outlierlist)	<- c("PCadapt","OutFLANK","GWDS")
			}
		# plot outliers detected by GWDS, OutFlank (or Bayescan), and PCadapt:
		# myoutlierlist			<<- outlierlist
		for(j in c(1:3))
			{
			myscan				<- names(outlierlist)[j]
			cat(myscan,sep="\n")
			myselection			<- outlierlist[[j]]
			if(i==3)
				{
				mafselect1			<- macmatrix[i*2,myselection]/(sample_sizes[1]*2)		# 2 alleles per individual
				}else{
				mafselect1			<- macmatrix[i*2,myselection]/(sample_sizes[2]*2)		# 2 alleles per individual
				}
			mafselect2			<- macmatrix[8,myselection]/(sample_sizes[2]*2)			# 2 alleles per individual
			# plot all loci:
			locWeirFst(mafvector1=mafneutral1,mafvector2=mafneutral2,plottitle="",xlabel="",ylabel="",myyaxis='n',dothin=TRUE)
			# add outliers to plot:
			locWeirFst(mafvector1=mafselect1,mafvector2=mafselect2,addpoints=TRUE,dothin=TRUE)
			mtext(myscan,side=3,line=-2.5,cex=1.75)
			}
		mtext("WC Fst",side=2,line=2,cex=2.5,outer=TRUE)
		mtext("WC He",side=1,line=3.5,cex=2.5,outer=TRUE)
		if(do_export){dev.off()}
		}
	}	
	
plotlogvalues<-function(do_export=FALSE,nr_loci=1000,nr_selected=100,plotqvalue=TRUE,addbayescan=FALSE)
	{
	#plotname	<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"testscores.pdf",sep=".")
	alloci		<- c(1:nr_loci)
	for(i in c(1:3))
		{
		graphics.off()
		plotname	<- paste("Simulated.testscores",i,"pdf",sep=".")
		if(addbayescan)
			{
			if(do_export){pdf(plotname,height=14,width=14)}
			par(mfrow=c(4,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
			}else{
			if(do_export){pdf(plotname,height=10,width=14)}
			par(mfrow=c(3,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
			}
		# bayescan:
		if(addbayescan)
			{
			if(is.na(bayescanlogqlist[[i]]))
				{
				mylogq		<- runif(nr_loci)
				plot(alloci,mylogq,xaxt='n',ylab="",pch=16,las=1)
				}else{
				mylogq		<- bayescanlogqlist[[i]]
				myout		<- bayescanoutlierslist[[i]]
				myoutq		<- mylogq[myout]
				plot(alloci,mylogq,xaxt='n',ylab="",pch=16,las=1)
				points(myout,myoutq,col="red",pch=16)
				}
			mtext("Bayescan",side=4,line=1.5,cex=2)
			mtext("-log(q)",side=2,line=3.75,cex=2)
			}
		# gwds:
		gwdslogp		<- mysambarsim$gwdslogplist[[i]]
		myout			<- mysambarsim$gwdsoutlierslist[[i]]
		myoutp			<- gwdslogp[myout]
		plot(alloci,gwdslogp,xaxt='n',ylab="",pch=16,las=1)
		points(myout,myoutp,col="red",pch=16)
		mtext("GWDS",side=4,line=1.5,cex=2)
		mtext("-log(p)",side=2,line=3.75,cex=2)
		# outflank:
		if(plotqvalue)
			{
			plot(alloci,mysambarsim$outflanklogqlist[[i]],xlab="",ylab="",xaxt='n',pch=16,las=1)		
			myout		<- mysambarsim$outflankoutlierslist[[i]]
			myoutq		<- mysambarsim$outflanklogqlist[[i]][myout]
			points(myout,myoutq,col="red",pch=16)
			mtext("-log(q)",side=2,line=3.75,cex=2)
			}else{
			plot(alloci,mysambarsim$outflanklogplist[[i]],xlab="",ylab="",xaxt='n',pch=16,las=1)
			myout		<- mysambarsim$outflankoutlierslist[[i]]
			myoutp		<- mysambarsim$outflanklogplist[[i]][myout]
			points(myout,myoutp,col="red",pch=16)
			mtext("-log(p)",side=2,line=3.75,cex=2)
			}
		mtext("OutFLANK",side=4,line=1.5,cex=2)
		# pcadapt:
		plot(alloci,mysambarsim$pcadaptlogplist[[i]],ylab="",pch=16,las=1)
		myout		<- mysambarsim$pcadaptoutlierslist[[i]]
		myoutp		<- mysambarsim$pcadaptlogplist[[i]][myout]
		points(myout,myoutp,col="red",pch=16)
		mtext("PCadapt",side=4,line=1.5,cex=2)
		mtext("-log(p)",side=2,line=3.75,cex=2)
		mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
		# mtext("-log(test statistic)",side=2,line=0.5,cex=2.5,outer=TRUE)
		if(do_export){dev.off()}
		}
	}

plotlogtest<-function(do_export=FALSE,nr_loci=80000,nr_selected=1000,mytest=1)
	{
	alloci		<- c(1:nr_loci)
	if(mytest==1)
		{
		myloglist		<- bayescanlogqlist
		myoutlierlist	<- bayescanoutlierslist
		testname		<- "Bayescan"
		}
	if(mytest==2)
		{
		myloglist		<- mysambarsim$gwdslogplist
		myoutlierlist	<- mysambarsim$gwdsoutlierslist
		testname		<- "GWDS"
		}
	if(mytest==3)
		{
		myloglist		<- mysambarsim$outflanklogqlist
		myoutlierlist	<- mysambarsim$outflankoutlierslist
		testname		<- "OutFlank"
		}
	if(mytest==4)
		{
		myloglist		<- mysambarsim$pcadaptlogplist
		myoutlierlist	<- mysambarsim$pcadaptoutlierslist
		testname		<- "PCadapt"
		}
	graphics.off()
	plotname	<-paste(testname,"logvalues.pdf",sep=".")
	if(do_export){pdf(plotname,height=7,width=14)}
	#par(mfrow=c(3,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	par(mfrow=c(2,1),mar=c(0.5,3,0.5,2.5),oma=c(4,3.5,2,2),cex.axis=1.5,cex.lab=2.5)
	#
	for(i in c(2:3))
		{
		plot(alloci,myloglist[[i]],xaxt='n',ylab="",pch=16,las=1)
		myout		<- myoutlierlist[[i]]
		myoutp		<- myloglist[[i]][myout]
		points(myout,myoutp,col="red",pch=16)
		if(i==2){mtext("Pairwise",side=4,line=0.5,cex=2)}
		if(i==3){mtext("Pooled",side=4,line=0.5,cex=2)}
		}
	axis(side=1)
	mtext(testname,side=3,line=0,cex=2,outer=TRUE)
	mtext("SNP index",side=1,line=2.5,cex=2.5,outer=TRUE)
	mtext("-log(test statistic)",side=2.5,line=0.5,cex=2.5,outer=TRUE)
	if(do_export){dev.off()}
	}

plotlogvalues_3d<-function(make_snapshot=FALSE)
	{
	# This function creates a 3D scatterplot:
	#library(rgl)
	mydf		<- data.frame(x=mysambarsim$outflanklogqlist[[3]],y=mysambarsim$pcadaptlogplist[[3]],z=mysambarsim$gwdslogplist[[3]])
	mydf$color	<- c(rep("black",900),rep("red",100))
	plot3d(mydf$x,mydf$y,mydf$z, col=mydf$color, size=2, type='s',xlab="OutFLANK",ylab="PCadapt",zlab="GWDS",box=FALSE)
	if(make_snapshot)
		{
		rgl.snapshot("selectionscan.logpvalues.png")
		}
	}	

plottestpower<-function()
	{
	# This function creates a 3D scatter plot.
	# library(rgl)
	x <- 1:5/10
	y <- 1:5
	z <- x %o% y
	persp3d(x, y, z, col="skyblue",box=FALSE)
	#rgl.snapshot("myplot.png")
	}

# Returns a list with output, so assign this function to an object when calling it. 	
simscan<-function(mafvector1=NULL,mafvector2=NULL,myalpha=0.05,sample_sizes=c(30,30),n_selected=0,my_correction="none",store_adjusted=FALSE,right_trim=0.95)
	{
	# my_correction can be: "none","holm","BH" (Benjamini-Hochberg), or "bonferroni"
	if(is.null(mafvector1)|is.null(mafvector2)){return(cat("Error: simscan function expects two input vectors.",sep="\n"))}
	mafmatrix		<- rbind(mafvector1,mafvector2)
	ntotalsnps		<- length(mafvector1)
	nneutralsnps	<- length(mafvector1)-n_selected	
	getpedfrommaf(n_ind=c(sample_sizes[1],sample_sizes[2]),nloc=ntotalsnps,mafinput=mafmatrix,exportname="simdata")
	cat(paste("Number of individuals in OutFLANK input dataset: ",nrow(mysambarsim$mygenlightmatrix),".",sep=""),sep="\n")
	# run OutFLANK:
	mypops			<- c(rep("founder",sample_sizes[1]),rep("source",sample_sizes[2]))	
	mylocs			<- c(1:ntotalsnps)
	outflankinput	<- MakeDiploidFSTMat(SNPmat=mysambarsim$mygenlightmatrix,locusNames=mylocs,popNames=mypops)
	# we define threshold using neutral loci only:
	myqthreshold	<- myalpha		 
	# It is important to only include the neutral loci for generating the null distribution, otherwise OutFLANK will not find outliers:
	cat("Trimming...",sep="\n")
	outflankerror	<- FALSE
	if(!is.null(right_trim))
		{
		# According to the OutFLANK manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
		# We assume that less than 5 percent are outliers (or other value specified by right_trim):
		cat(paste("Specified right_trim threshold: ",right_trim,". This means that whilst inferring the null Fst distribution, the SNPs with the top ",(1-right_trim)*100," percent Fst values will be ignored.",sep=""),sep="\n")
		mymean			<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
		myrate			<- 1/mymean
		myvalue			<- qexp(right_trim,myrate)
		prunevector		<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
		myfstmax		<- round(max(outflankinput$FSTNoCorr[prunevector],na.rm=TRUE),3)
		cat(paste("Highest Fst-value of pruned dataset: ", myfstmax,".",sep=""),sep="\n")
		if(!myfstmax<=0.99)
			{
			# This is to prevent the error:
			# ERROR: The largest FST in the trimmed set must be < 1. Please use a larger RightTrimFraction.
			cat("Fst of pruned dataset ranges until 1. SambaR will not run OutFLANK and assume there are no outliers.",sep="\n")
			outflankout			<- mylocs[rep(FALSE,ntotalsnps)]
			outflanklogq		<- rep(0,ntotalsnps)
			outflanklogp		<- rep(0,ntotalsnps)
			mysambarsim$outflankfdr_value		<<- 0
			outflankerror		<- TRUE
			}else{
			out_trim 		<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=2,qthreshold=myalpha,Hmin = 0.1)
			}
		}else{
		# alternatively do not trim and simply take the neutral snps as the null distribution
		cat("The flag right_trim is set to NULL. Inferring the null Fst distribution from all neutral SNPs.",sep="\n")
		out_trim 		<- OutFLANK(FstDataFrame=outflankinput[c(1:nneutralsnps),],NumberOfSamples=2,qthreshold=myqthreshold,Hmin = 0.1)
		}
	if(!outflankerror)
		{
		cat("Calculating p and q values...",sep="\n")
		P1 					<- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar=out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = myqthreshold, Hmin=0.1)
		cat("Ordering...",sep="\n")
		P2					<- P1[order(P1$LocusName),]
		cat("Selecting outliers...",sep="\n")
		P2$p_uncorrected	<- P2$pvalues 
		if(my_correction=="none")
			{
			# 04-03-19: my simulations showed that OutFlank has lowest FDR when not using qvalues (default), but when using holm corrected p values.
			# outflankout	<- P2$LocusName[P2$OutlierFlag=="TRUE"&!is.na(P2$OutlierFlag)]
			cat("No multiple test correction method specified. Defaulting to Holm method.",sep="\n")
			P2$pvalues		<- p.adjust(P2$pvalues,method="holm")
			P2$OutlierFlag	<- P2$pvalues<0.05
			outflankout		<- P2$LocusName[P2$OutlierFlag=="TRUE"&!is.na(P2$OutlierFlag)]
			}else{
			cat(paste("Specified multiple test correction method: ",my_correction,".",sep=""),sep="\n")
			P2$pvalues		<- p.adjust(P2$pvalues,method=my_correction)
			P2$OutlierFlag	<- P2$pvalues<0.05
			outflankout		<- P2$LocusName[P2$OutlierFlag=="TRUE"&!is.na(P2$OutlierFlag)]
			}
		outflanklogq		<- -(log10(P2$qvalues))
		if(store_adjusted)
			{
			outflanklogp	<- -(log10(P2$pvalues))
			}else{
			outflanklogp	<- -(log10(P2$p_uncorrected))
			}
		noutliers			<- length(outflankout)
		mysambarsim$outflankfdr_value		<<- ifelse(noutliers>0,(length(which(outflankout<=nneutralsnps)))/noutliers,0)
		cat(paste("OutFLANK detected",noutliers,"outlier loci.",sep=" "),sep="\n")
		}
	# run PCadapt:
	inputdir			<- getwd()
	cat(paste("Reading PED file from:",inputdir,sep=" "),sep="\n")
	x					<- read.pcadapt("simdata.ped",type="ped")
	y					<- pcadapt(x,K=10)
	z					<- pcadapt(x,K=2)
	z$p_uncorrected		<- z$pvalues
	if(my_correction!="none")
		{
		# 04-03-19: my simulations showed that PCadapt has lowest FDR when wen using bonferroni corrected p values
		cat(paste("Specified multiple test correction method: ",my_correction,".",sep=""),sep="\n")
		padj 			<- p.adjust(z$pvalues,method=my_correction)	
		}else{
		# 04-03-19: my simulations showed that PCadapt has lowest FDR when wen using bonferroni corrected p values
		# padj 			<- z$pvalues
		cat("No multiple test correction method specified. Defaulting to Bonferonni method.",sep="\n")
		padj 			<- p.adjust(z$pvalues,method="bonferroni")	
		}
	pcadaptout			<- which(padj<myalpha)
	if(store_adjusted)
		{
		pcadaptlogp		<- -log10(padj)  
		}else{
		pcadaptlogp		<- -log10(z$p_uncorrected)  
		}
	cat(max(pcadaptlogp,na.rm=TRUE),sep="\n")
	noutliers			<- length(pcadaptout)
	mysambarsim$pcadaptfdr_value	<<- ifelse(noutliers>0,(length(which(pcadaptout<=nneutralsnps)))/noutliers,0)
	cat(paste("PCadapt detected",noutliers,"outlier loci.",sep=" "),sep="\n")
	myoutputlist		<- list()
	myoutputlist[[1]]	<- outflankout
	myoutputlist[[2]]	<- outflanklogq
	myoutputlist[[3]]	<- pcadaptout
	myoutputlist[[4]]	<- pcadaptlogp
	myoutputlist[[5]]	<- outflanklogp
	return(myoutputlist)
	}

get_bayescan_multi<-function(myrates=c(0,0.01,seq(0.05,1,0.05)),retainedratio=1,nneutral=5000,nadaptive=500,export=FALSE,my_input="simdata.bayescanout.fst.txt")
	{
	nrates				<- length(myrates)
	mymatrix			<- matrix(NA,ncol=3,nrow=nrates)	
	for (j in c(1:nrates))
		{
		myrate			<- myrates[j]
		cat(myrate,sep="\n")
		get_bayescan(my_FDR=myrate,myinput=my_input,n_neutral=nneutral,n_adaptive=nadaptive)
		mymatrix[j,2]	<- nbaye_out_select
		mymatrix[j,3]	<- nbaye_out_neutral
		}	
	bayeout				<<- as.data.frame(mymatrix)
	colnames(bayeout)	<<- c("FDR","adaptive","neutral")
	bayeout$FDR			<<- myrates
	bayeout$power		<<- bayeout$adaptive/(retainedratio*nadaptive)
	bayeout$specificity	<<- (retainedratio*nneutral-bayeout$neutral)/(retainedratio*nneutral)
	bayeout$power[bayeout$power>1]	<<- 1
	bayeout$specificity[bayeout$specificity<0]	<<- 0
	bayeout$FDR_obs		<<- bayeout$neutral/(bayeout$adaptive+bayeout$neutral)
	bayeout$FDR[!is.finite(bayeout$FDR)]	<<- 0
	if(export){pdf("Bayescan.power.pdf",width=12,height=5)}
	par(mfrow=c(1,2),oma=c(0,0,1,0),mar=c(5,7,1,3),cex.lab=2,cex.main=2)
	plot(bayeout$FDR,bayeout$power,type='b',ylab="",xlab="Expected FDR",lwd=2,las=1)
	mtext("Power",side=2,line=3,cex=2)
	par(new = T)
	plot(bayeout$FDR,bayeout$specificity,col="grey50",yaxt='n',ylab="",xaxt='n',xlab="",type='b',lwd=2,ylim=c(0.9,1))
	axis(side=4,las=1)
	mtext("Specificity",side=4,line=3.5,cex=2,col="grey50")
	plot(bayeout$FDR,bayeout$FDR_obs,type='b',lwd=2,xlab="Expected FDR",ylab="",las=1,ylim=c(0,1),xlim=c(0,1))
	mtext("Observed FDR",side=2,line=3,cex=2)
	if(export){dev.off()}
	}
	
get_bayescan<-function(add_to_plot=FALSE,my_FDR=0.3,myinput="simdata.bayescanout.fst.txt",n_neutral=9000,n_adaptive=1000)
	{
	x					<- read.table(myinput)	
	bayescanlogq		<<- -log10(x$qval) 
	bayescanout			<<- which(x$qval<my_FDR)
	nbaye_out			<- length(bayescanout)
	nbaye_out_select	<<- length(bayescanout[bayescanout>n_neutral])
	nbaye_out_neutral	<<- length(bayescanout[bayescanout<=n_neutral])
	cat(paste("Bayescan detected",nbaye_out_select,"out of",n_adaptive,"outlier loci.",sep=" "),sep="\n")
	cat(paste("Bayescan wrongly marked",nbaye_out_neutral,"out of",n_neutral,"neutral loci as outliers.",sep=" "),sep="\n")
	# what are the logp scores of the outliers detected by pcadapt? 
	if(add_to_plot)
		{
		bayescanoutlogp		<- logp[3,bayescanout]
		points(bayescanout,bayescanoutlogp,col="darkred",pch=16)
		}
	}

run_sel<-function(export=FALSE,nloci=1000,nselected=100,sel_coef=0.1,sample_size=30,n_gen=20)
	{
	foundernevector	<- c(20,50,100,1000)
	popmaflist		<- list()
	samplemaclist	<- list()
	for(k in c(1:length(foundernevector)))
		{
		founderne			<- foundernevector[k]
		outliersim(export=FALSE,nloc=nloci,ngen=n_gen,nefounderpop1=founderne,nefounderpop2=founderne,nfounders=founderne,samplesize=sample_size,nselectedloci=nselected,selcoef=sel_coef,parallelselection=TRUE,do_haploid=TRUE,do_venn=FALSE,do_Fdist=TRUE,do_selectionscan=FALSE,do_logplot=FALSE)
		popmaflist[[k]]		<- mysambarsim$mymafendmatrix
		samplemaclist[[k]]	<- mysambarsim$macmatrix
		}
	# Plot:
	graphics.off()
	if(export){pdf("Fdist_selection.pdf",width=12,height=6)}
	par(mar=c(0.5,1,1,0.5),oma=c(5,5,1,1),cex.axis=1.5)
	layout(matrix(c(1:8),nrow=2,ncol=4,byrow=FALSE))
	for(k in c(1:length(foundernevector)))
		{
		founderne		<- foundernevector[k]
		mymafendmatrix	<- popmaflist[[k]]
		mymafendmatrix	<- round(mymafendmatrix,nchar(founderne))
		macmatrix		<- samplemaclist[[k]]
		my_yaxis		<- ifelse(k==1,'s','n')
		locWeirFst(mafvector1=mymafendmatrix[1,],mafvector2=mymafendmatrix[3,],myyaxis=my_yaxis,myxaxis='n',dothin=TRUE,plottitle=paste("Ne =",founderne,sep=" "))
		locWeirFst(mafvector1=mymafendmatrix[1,c((nloci-nselected):nloci)],mafvector2=mymafendmatrix[3,c((nloci-nselected):nloci)],addpoints=TRUE,cexout=1)
		samplemaf1		<- macmatrix[2,]/(sample_size*2)
		samplemaf2		<- macmatrix[8,]/(sample_size*2)
		locWeirFst(mafvector1=samplemaf1,mafvector2=samplemaf2,myyaxis=my_yaxis,dothin=TRUE,plottitle=paste("Ne =",founderne,sep=" "),plotsubtitle=paste("n =",sample_size,sep=" "))
		locWeirFst(mafvector1=samplemaf1[((nloci-nselected):nloci)],mafvector2=samplemaf2[c((nloci-nselected):nloci)],addpoints=TRUE,cexout=1)
		}
	mtext("Weir & Cockerham Fst",side=2,line=2.5,outer=TRUE,cex=2)
	mtext("Weir & Cockerham He",side=1,line=3,outer=TRUE,cex=2)
	if(export){dev.off()}
	}

	
locWeirFst<-function(mafvector1=NULL,mafvector2=NULL,addpoints=FALSE,cexout=1,myyaxis='s',myxaxis='s',plottitle="Fst/He",plotsubtitle="",xlabel="Weir & Cockerham He",ylabel="Weir & Cockerham Fst",neutralcol="black",outliercol="red",dothin=FALSE)
	{
	mafpop1		<- mafvector1
	mafpop2		<- mafvector2
	pop1f0		<- (mafpop1*mafpop1)+((1-mafpop1)*(1-mafpop1))
	pop2f0		<- (mafpop2*mafpop2)+((1-mafpop2)*(1-mafpop2))
	f1			<- (mafpop1*mafpop2)+((1-mafpop1)*(1-mafpop2))	
	WeirHe		<- 1-f1 
	WeirFst		<- (0.5*(pop1f0+pop2f0)-f1)/WeirHe
	# select unique WeirHe, WeirFst combinations, so the plot gets let's heavy:
	if(dothin)
		{
		mydf		<- as.data.frame(cbind(WeirHe,WeirFst))
		mydf		<- unique(mydf)
		WeirHe		<- mydf$WeirHe
		WeirFst		<- mydf$WeirFst
		}
	# now plot:
	if(addpoints)
		{
		points(WeirHe,WeirFst,xlim=c(0,1),ylim=c(0,1),pch=16,col=outliercol,cex=cexout,las=1)
		}else{
		plot(WeirHe,WeirFst,xlim=c(0,1),ylim=c(0,1),pch=16,xlab=xlabel,ylab=ylabel,col=neutralcol,yaxt=myyaxis,xaxt=myxaxis,cex=0.5,las=1)
		mtext(plottitle,side=3,line=-2,cex=1.25)
		mtext(plotsubtitle,side=3,line=-3.5,cex=1.25)
		}	
	}
	
# requires function 'mafsim'
getfounderpopmaf<-function(nsamplesfounder=30,nsamplessource=30,sourcemafvector=NULL,nrfounders=10,nesourcepop=1000,nefounderpop=20,nrloci=5000,ngensource=200,ngenfounder=20,plotmaf=FALSE,histointervals=0.02,meanmafsource=0.1,nselectloci=0,selc=0.1,dohap=TRUE,dodiscrete=TRUE)
	{
	if(!dohap)
		{
		return(cat("ERROR: currently allele frequencies can only reliably be simulated using the haploid approach. Please set the dohap flag to TRUE.",sep="\n")) 
		}
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	### This function returns founderendmaf
	### The user can either provide vector with the maf of the source. 
	### If the user does not provide such a vector, the function will create the vector itself, based on user-defined settings. 
	### The argument 'nefounderpop' can be either one value (static Ne) or a vector, of which the length should equal number of generations. 
	#
	cat("Settings whilst running getfounderpopmaf:",sep="\n")
	cat(paste("  Specified number of loci: ",nrloci,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",nselectloci,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficient: ",selc,".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",ngenfounder,".",sep=""),sep="\n")
	cat(paste("  Specified Ne source population: ",nesourcepop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 1: ",nefounderpop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 2: ",nefounderpop,".",sep=""),sep="\n")
	cat(paste("  Specified number of founders: ",nrfounders,".",sep=""),sep="\n")
	cat(paste("  Specified samplesize founder population(s): ",nsamplesfounder,".",sep=""),sep="\n")
	cat(paste("  Specified samplesize source population: ",nsamplessource,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",dohap,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",dodiscrete,".",sep=""),sep="\n")
	#
	if(!dohap&dodiscrete)
		{
		return(cat("Error: The flag dodiscrete is set to TRUE but the flag dohap is set to FALSE. The function mafsim() does not allow to simulate simulation discretely if not assuming haploidy.",'\n'))
		} 
	#
	# optionally simulate maf distribution of the source population:
	if(is.null(sourcemafvector))
		{
		sourcemafvec		<- mafsim(nloci=nrloci,popsize=nesourcepop,ngens=ngensource,meanmaf=meanmafsource,nselloci=0,haploid=dohap,do_discrete=dodiscrete)
		}else{
		sourcemafvec		<- sourcemafvector
		}	
	# effect of sampling (not used in downstream analyses, just to compare simulated distribution to observed distribution in Norway population):
	sourcesample			<- sapply(sourcemafvec,function(sourcemafvec){rbinom(1,(2*nsamplessource),sourcemafvec)})
	sourcesample			<- sourcesample/(2*nsamplessource)
	# get maf frequencies of the founders, by simulating bottleneck through sampling:
	if(length(nefounderpop)==1)
		{
		pop_ne				<- rep(nefounderpop,ngenfounder)
		}else{
		pop_ne				<- nefounderpop
		}
	founderstartmaf			<- sapply(sourcemafvec,function(sourcemafvec){rbinom(1,(2*nrfounders),sourcemafvec)})
	founderstartmaf			<- founderstartmaf/(2*nrfounders)
	# let the founder population drift for a number of generations:
	founderendmaf			<- mafsim(ngens=ngenfounder,nloc=nrloci,popsize=pop_ne,mafstartvector=founderstartmaf,nselloci=nselectloci,s=selc,haploid=dohap,do_discrete=dodiscrete)
	# effect of sampling:
	foundersample			<- sapply(founderendmaf,function(founderendmaf){rbinom(1,(2*nsamplesfounder),founderendmaf)})
	foundersample			<- foundersample/(2*nsamplesfounder)
	# plot:
	if(plotmaf)
		{
		breakpoints			<- seq(0,1,histointervals)
		par(mfrow=c(1,3))
		hist(sourcemafvec,breaks=breakpoints,xlim=c(0,1),ylim=c(0,nrloci/1.5),main="Source pop",xlab=NULL)
		hist(founderstartmaf,breaks=breakpoints,xlim=c(0,1),ylim=c(0,nrloci/1.5),main="Founder pop at founder event",xlab=NULL)
		hist(founderendmaf,breaks=breakpoints,xlim=c(0,1),ylim=c(0,nrloci/1.5),main="Founder pop at 20 gen",xlab=NULL)
		mtext("Simulated locus-specific minor allele frequencies", side = 1, outer = TRUE,line=-2)
		}
	mysambarsim$sourcemafvec	<<- sourcemafvec
	mysambarsim$founderstartmaf	<<- founderstartmaf
	mysambarsim$founderendmaf	<<- founderendmaf
	mysambarsim$foundersample	<<- foundersample
	mysambarsim$sourcesample	<<- sourcesample
	return(founderendmaf)
	}

mafsim<-function(nloci=1000,ngens=10,popsize=50,meanmaf=0.17,mafstartvector=NULL,nselloci=0,s=0.1,h=0.5,haploid=TRUE,r=1,do_discrete=TRUE)
	{
	if(!haploid)
		{
		return(cat("ERROR: currently allele frequencies can only reliably be simulated using the haploid approach. Please set the haploid flag to TRUE.",sep="\n")) 
		}
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	cat("Settings whilst running mafsim:",sep="\n")
	if(length(unique(popsize))==1)
		{
		cat(paste("  Popsize: ",unique(popsize),".",sep=""),sep="\n")
		}else{
		cat("  Non-uniform population size.",sep="\n")
		#cat(paste("Popsize: ",paste(popsize,collapse=","),".",sep=""),sep="\n")
		}
	cat(paste("  Number of generations: ",ngens,".",sep=""),sep="\n")
	cat(paste("  Number of loci: ",nloci,".",sep=""),sep="\n")
	if(nselloci>0)
		{
		cat(paste("  Number of loci under positive selection: ",nselloci,".",sep=""),sep="\n")
		cat(paste("  Selection coefficient: ",s,".",sep=""),sep="\n")
		cat(paste("  Simulate selection using discrete method: ",do_discrete,".",sep=""),sep="\n")
		}
	cat(paste("  Simulate allele frequencies assuming haploidy: ",haploid,".",sep=""),sep="\n")
	if(!haploid&do_discrete)
		{
		return(cat("Error: The flag do_discrete is set to TRUE but the flag haploid is set to FALSE. The function mafsim() does not allow to simulate simulation discretely if not assuming haploidy.",'\n'))
		} 
	# define population size over generations:
	if(length(popsize)==1)
		{
		popne	<- rep(popsize,ngens)
		}else{
		popne	<- popsize
		}
	# Create empty matrix for neutral loci:
	nneutral<-nloci-nselloci	
	z		<- matrix(NA,ncol=nneutral,nrow=ngens)
	# Create empty matrix for adaptive loci:
	zs		<- matrix(NA,ncol=nselloci,nrow=ngens)
	# Minor allele frequency in generation 1:
	if(is.null(mafstartvector))
		{
		z[1,]	<- (rpois(nneutral,lambda=(meanmaf*100)))/100
		zs[1,]	<- (rpois(nselloci,lambda=(meanmaf*100)))/100
		}else{
		z[1,]	<- mafstartvector[1:nneutral]
		zs[1,]	<- mafstartvector[(nneutral+1):nloci]
		}
	# Now do the actual simulation:
	# loss of alleles is permanent, as it should be: 0 stays 0.
	for (i in c(2:ngens))
		{ 
		# neutral loci:
		if(nselloci<nloci)
			{
			ztemp	<- z[i-1,]
			ztemp2	<- sapply(ztemp,function(ztemp){rbinom(1,(2*popne[i]),ztemp)})
			z[i,]	<- ztemp2/(2*popne[i])
			}
		# adaptive loci:
		if(nselloci>0)
			{
			if(haploid)
				{
				# No diploid genotypes, so simply drawing n alleles out of the population.
				# A haploid hermaphrodite system?		
				stemp						<- zs[i-1,]
				stemp2						<- sapply(stemp,function(stemp){rbinom(1,popne[i],stemp)})
				if(s<=0.05&do_discrete)
					{
					prtemp					<- runif(nselloci)<s
					stemp2[prtemp]			<- 2*stemp2[prtemp]					# this is a discrete way: s denotes probability of selective event per generation. If selective event, minor allele count is doubled.
					stemp2					<- stemp2/(popne[i])
					}else{
					stemp2					<- round((1+s)*stemp2)/(popne[i])	# due to rounding, this way of incorporating selection only works for a certain minimum number of alleles (i.e.: high popsize and/or high minor allele frequency) 
					}
				stemp2[stemp2>1]<- 1 
				zs[i,]			<- stemp2
				}else{
				# the next generation starts with random reproduction of offspring:
				# r is the mean number of offspring per individual
				stemp			<- zs[i-1,]
				stemp2			<- sapply(stemp,function(stemp){rbinom(1,(2*popne[i]),stemp)})
				q				<- stemp2/(2*popne[i])
				p				<- 1-q
				n_offspring		<- 2*popne[i]*r
				offspring_AA	<- (p^2)*n_offspring
				offspring_Aa	<- (2*p*q)*n_offspring
				offspring_aa	<- (q^2)*n_offspring
				# during the lifespan differential survival:
				# AA and Aa individuals have a mortality probability (s and h*s); aa individuals do not.
				# probability of survival is: 
				expAA			<- round((1-s)*offspring_AA)
				expAa			<- round((1-h*s)*offspring_Aa)
				expaa			<- round((1)*offspring_aa)
				expall			<- sum(expAA,expAa,expaa)
				stemp3			<- round((2*expaa+expAa)/(2*(expAA+expAa+expaa)),nchar(popne[i]))
				stemp3[stemp3>1]<- 1	# Frequency can not exceed 1
				zs[i,]			<- stemp3			
				}
			}
		}
	if(nselloci>0&nselloci<nloci)
		{
		z	<- cbind(z,zs)
		}
	if(nselloci>nloci&nselloci==nloci)
		{
		z	<- zs
		}
	return(z[ngens,])
	}	

multilin_old<-function(foundervec=c(5,10,20),nriter=100,export=FALSE,nsamples=NULL,nrgen=NULL)
	{
	mylist		<<- list()
	mymafs1		<- c(0.05,0.05,0.05,0.1,0.1)
	mymafs2		<- c(0.05,0.1,0.15,0.2,0.3)
	combitable	<- rbind(mymafs1,mymafs2)
	mylabels	<- paste(combitable[1,],combitable[2,],sep="_")
	mycolfunc 	<- colorRampPalette(c("grey20","darkorange"))
	myColours	<- c(mycolfunc(length(mymafs)))			
	#
	if(export){pdf("Deltamaf.simulations.pdf",height=5,width=15)}
	par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5))
	for (k in 1:length(foundervec))
		{
		nrfounders	<- foundervec[k]
		for(j in 1:ncol(combitable))
			{
			add_to_plot	<- ifelse(j==1,FALSE,TRUE)
			my_col		<- myColours[j]
			lin(pop_ne=200,nfounders=nrfounders,n=nriter,mymaf1=combitable[1,j],mymaf2=combitable[2,j],addtoplot=add_to_plot,mycol=my_col,samplesize=nsamples,ngen=nrgen)
			mylist[[j]]	<- mydf
			}
		if(k==length(foundervec))
			{
			legend("topright",mylabels,fill=myColours,bty='n',title="Smaf1_Smaf2",cex=2)
			}
		}
	if(export){dev.off()}
	mydf2		<<- do.call(rbind,mylist)
	#plot(mydf2$S_diff,mydf2$F_diff,ylim=c(0,1),xlim=c(0,1),pch=16)
	}

	
 
# Next tool is to simulate allele frequency differences between pairs of linked SNPs (i.e. no recombination). 
# We sampled 2 bp binary haplotypes (in which 0 coded for major allele and 1 for minor allele) using built in R functions. 
# Founder events and data sampling were simulated as sampling without replacement. 
# Genetic drift was simulated as sampling with replacement. SNP pairs under selection contained 1 SNP under selection and 1 neutral SNP. 
# Selective events were simulated by increasing the numbers of adaptive haplotypes prior to sampling. 
# Adaptive haplotypes were defined as all haplotypes containing the adaptive allele. 
# The single purpose of these simulations is to test the general relation between positively selected SNPs and linked neutral SNPs. 

multilin<-function(foundervec=c(10,50,200),nriter=10000,nriter_sel=500,export=FALSE,nsamples=NULL,nrgen=NULL,selc=NULL,plot_maf=FALSE)
	{
	mylist		<- list()
	if(export){pdf("Deltamaf.simulations.pdf",height=5,width=15)}
	par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5))
	for (k in 1:length(foundervec))
		{
		nrfounders	<- foundervec[k]
		ne_founders	<- foundervec[k]
		cat(nrfounders,sep="\n")
		add_legend	<- ifelse(k==length(foundervec),TRUE,FALSE)
		lin(pop_ne=200,nfounders=nrfounders,ne_f=ne_founders,plotmaf=plot_maf,n=nriter,samplesize=nsamples,ngen=nrgen,s=NULL)
		if(!is.null(selc)&!(is.null(nrgen)))
			{
			cat("Selected loci",sep="\n")
			lin(pop_ne=200,nfounders=nrfounders,ne_f=ne_founders,plotmaf=plot_maf,n=nriter_sel,samplesize=nsamples,ngen=nrgen,s=selc,addlegend=add_legend,addtoplot=TRUE)
			}
		mylist[[k]]	<- mydf
		}
	if(export){dev.off()}
	mydf2		<<- do.call(rbind,mylist)
	#plot(mydf2$S_diff,mydf2$F_diff,ylim=c(0,1),xlim=c(0,1),pch=16)
	}

# this function visualizes distortion of ld between 2 linkage snps due to sampling:
lin<-function(pop_ne=200,nfounders=10,n=100,mymaf=0.1,diploidy=2,mycol="black",plotmaf=FALSE,addtoplot=FALSE,samplesize=NULL,ngen=NULL,ne_f=50,s=NULL,addlegend=TRUE)
	{
	# table2matrix function is part of 'psych' package:
	# install.packages('psych',repos='http://cran.us.r-project.org')
	# library(psych)
	#
	mydf			<<- as.data.frame(matrix(NA,ncol=7,nrow=n))
	colnames(mydf)	<<- c("S1","S2","S_diff","F1","F2","F_diff","snp2_FminusS")
	# maf1 is maf of first allele, maf2 is maf of second allele:
	mymaf1			<- round(rlnorm(n,meanlog=log(mymaf),sdlog=0.5),3)
	mymaf2			<- round(rlnorm(n,meanlog=log(mymaf),sdlog=0.5),3)
	mymaf1[mymaf1>0.5]<- 0.5
	mymaf2[mymaf2>0.5]<- 0.5
	nsnps			<- 2
	nhaplo_s		<- diploidy*pop_ne
	nhaplo_f1		<- diploidy*nfounders
	nhaplo_f2		<- diploidy*ne_f
	nhaplo_sample	<- diploidy*samplesize
	for(i in c(1:n))
		{
		# snp1:
		mygenos	<- as.vector(rbinom(1,size=nhaplo_s,prob=mymaf1[i]))
		myvec1	<- c(rep(1,mygenos),rep(0,(nhaplo_s-mygenos)))
		myvec1	<- sample(myvec1)
		# snp2:
		mygenos	<- as.vector(rbinom(1,size=nhaplo_s,prob=mymaf2[i]))
		myvec2	<- c(rep(1,mygenos),rep(0,(nhaplo_s-mygenos)))
		myvec2	<- sample(myvec2)
		# combine:
		myvec	<- c(myvec1,myvec2)
		smatrix	<- matrix(myvec,ncol=2,nrow=nhaplo_s)			
		smaf	<- apply(smatrix,2,sum)/nhaplo_s	
		# get founder genos directly after founder event:
		select	<- sample(c(1:nrow(smatrix)),nhaplo_f1,replace=FALSE)		
		fmatrix	<- smatrix[select,]
		fmaf	<- apply(fmatrix,2,sum)/nhaplo_f1
		# get pop and founder genos after certain number of generations following the founder event:
		if(!is.null(ngen))
			{
			for(g in c(1:ngen))
				{
				#cat(g,sep="\n")
				# incorporate selective events:
				if(!is.null(s))
					{
					if(runif(1)<s)
						{
						fdf				<- as.data.frame(fmatrix)
						colnames(fdf)	<- c("snp1","snp2")
						fd1				<- fdf[fdf$snp2==1,]
						fd0				<- fdf[fdf$snp2==0,]
						# selection:
						nalleles		<- nrow(fd1)
						selected		<- sample(c(1:nalleles),ceiling(nalleles*s),replace=TRUE)
						fdf_selected	<- fd1[selected,]
						fmatrix			<- rbind(as.matrix(fdf),as.matrix(fdf_selected))
						row.names(fmatrix)<-NULL
						}
					}
				select	<- sample(c(1:nrow(fmatrix)),nhaplo_f2,replace=TRUE)
				fmatrix <- fmatrix[select,]
				select	<- sample(c(1:nrow(smatrix)),nhaplo_s,replace=TRUE)
				smatrix <- smatrix[select,]
				}
			fmaf		<- apply(fmatrix,2,sum)/nhaplo_f2
			smaf		<- apply(smatrix,2,sum)/nhaplo_s
			}
		fmatrix	<<- fmatrix
		# correct for sample size (because we normally don't sample the entire population, but only a certain number of individuals):
		if(!is.null(samplesize))
			{
			# source:
			if(nhaplo_sample<nrow(smatrix))
				{
				select	<- sample(c(1:nrow(smatrix)),nhaplo_sample,replace=FALSE)	
				smatrix <- smatrix[select,]
				smaf	<- apply(smatrix,2,sum)/nhaplo_sample
				}
			# founder:
			if(nhaplo_sample<nrow(fmatrix))
				{
				select	<- sample(c(1:nrow(fmatrix)),nhaplo_sample,replace=FALSE)	
				fmatrix <- fmatrix[select,]
				fmaf	<- apply(fmatrix,2,sum)/nhaplo_sample
				}
			}
		mydf[i,]<<- c(smaf,abs(smaf[1]-smaf[2]),fmaf,abs(fmaf[1]-fmaf[2]),fmaf[2]-smaf[2])
		}		
	# gradient colour based on delta maf between populations:
	br				<- seq(-0.4,1,0.2)
	mids			<- vector() 
	for(i in c(1:length(br)-1))
		{
		mids[i]		<- sum(br[i],br[i+1])/2
		}
	mycolfunc1 		<- colorRampPalette(c("grey85","red"))
	mycolours		<- mycolfunc1(length(br)-1)
	mydf$distclass	<- cut(mydf$snp2_FminusS,breaks=br,labels=mids) 
	mydf$distclass2	<- as.numeric(cut(mydf$snp2_FminusS,breaks=br,labels=FALSE))
	mydf$mycol		<- mycolours[mydf$distclass2]
	mydf2			<- mydf[,c("S_diff","F_diff","mycol")]
	mydf			<- mydf[row.names(unique(mydf2)),]
	if(!plotmaf)
		{
		if(addtoplot)
			{
			points(mydf$S_diff[mydf$F1==0],mydf$F_diff[mydf$F1==0],col=mydf2$mycol)		# adjacent allele got lost
			points(mydf$S_diff[mydf$F1>0],mydf$F_diff[mydf$F1>0],pch=16,col=mydf2$mycol)	# adjacent allele still segregating
			if(addlegend)
				{
				legend("topright",legend=mids,fill=mycolours,bty='n',cex=1.5)
				}
			}else{
			par(mar=c(5,6,2.5,2))
			plot(mydf$S_diff,mydf$F_diff,xlim=c(0,1),ylim=c(0,1),pch=16,col=mycol,xlab="",ylab="",cex.axis=1.5,las=1)
			mtext("Founder Delta_MAF",side=2,line=3.5,cex=2.5)
			mtext("Source Delta_MAF",side=1,line=3.5,cex=2.5)
			mtext(paste("Ne =",nfounders,sep=" "),cex=2,side=3)
			if(!is.null(samplesize))
				{
				mtext(paste("n =",samplesize,sep=" "),cex=1.5,line=-2,side=3)
				}
			if(!is.null(ngen))
				{
				mtext(paste("G =",ngen,sep=" "),cex=1.5,line=-1.5,side=4)
				}
			}
		}else{
		if(addtoplot)
			{
			points(mydf$S2,mydf$F2,pch=16,col="red")
			}else{
			plot(mydf$S2,mydf$F2,pch=16,col="black",xlab="Source maf",ylab="Founder maf",xlim=c(0,1),ylim=c(0,1))				
			}
		}
	}

mafsim_dynamic<-function(nloci=100,ngens=10,popsize=50,meanmaf=0.17,mafstartvector=NULL,nselloci=0,s=0.1,h=0.5,alpha=1,K=200,beta=0.5)
	{
	cat("popsize equals:",sep="\n")
	cat(popsize,sep="\n")
	cat("Number of generations equals:",sep="\n")
	cat(ngens,sep="\n")
	# define start population size:
	popne	<- vector()
	popne[1]<- popsize
	# Create empty matrix:
	z	<<- matrix(NA,ncol=nloci,nrow=ngens)
	# Minor allele frequency in generation 1:
	if(is.null(mafstartvector))
		{
		z[1,]	<<- (rpois(nloci,lambda=(meanmaf*100)))/100	# this doesn't lead to ordinary maf distribution
		}else{
		z[1,]	<<- mafstartvector
		}
	# Now do the actual simulation:
	# First we simulate the population demography:
	# loss of alleles is permanent, as it should be: 0 stays 0.
	mymatrix	<<- matrix(NA,ncol=6,nrow=ngen)  
	for (i in c(2:ngens))
		{  
		# population demography:	
		n_offspring	<- popne[i-1]*alpha					# alpha is the mean number of offspring per individual:
		Pr_mort		<- (beta*(10^(n_offspring/K)))/n_offspring
		#if((nselloci>0)&(nselloci<nloci))
		#	{
		#	my_meanmaf	<- mean(z[i-1,c((nloci-nselloci):nloci)])
		#	Pr_mort_sel	<- (((1-my_meanmaf)^2)*n_offspring*s+(2*(1-my_meanmaf)*my_meanmaf)*n_offspring*(h*s))/n_offspring
		#	}else{
		#	my_meanmaf	<- mean(z[i-1,])
		#	Pr_mort_sel	<- 0
		#	}
		# popne[i]	<<- round((alpha-Pr_mort-Pr_mort_sel)*popne[i-1])
		# population genetics:
		for (j in c(1:nloci))
			{
			# the next generation starts with random reproduction of offspring (so no sexual selection):
			q			<- (rbinom(1,2*popne[i-1],z[i-1,j]))/(2*popne[i-1])
			p			<- 1-q
			offspring_AA<- (p^2)*n_offspring
			offspring_Aa<- (2*p*q)*n_offspring
			offspring_aa<- (q^2)*n_offspring
			offspring_total<- sum(offspring_AA,offspring_Aa,offspring_aa)
			# during the lifespan differential survival:
			# Random mortality numbers we model as 0.5*(10^density), with density between the ratio between popsize and carrying capacity 		
			# AA and Aa individuals have a mortality probability (s and h*s) due to a selection pressure. 
			if(j>nselloci)
				{
				expAA		<- round((1-Pr_mort-s)*offspring_AA)
				expAa		<- round((1-Pr_mort-s*h)*offspring_Aa)
				expaa		<- round((1-Pr_mort)*offspring_aa)
				}else{
				expAA		<- round((1-Pr_mort)*offspring_AA)
				expAa		<- round((1-Pr_mort)*offspring_Aa)
				expaa		<- round((1-Pr_mort)*offspring_aa)
				}
			expAA		<- ifelse(expAA<0,0,expAA)
			expAa		<- ifelse(expAa<0,0,expAa)
			expaa		<- ifelse(expaa<0,0,expaa)
			z[i,j]		<<- round((2*expaa+expAa)/(2*(expAA+expAa+expaa)),nchar(popne[i]))
			z[i,j]		<<- ifelse(z[i,j]>1,1,z[i,j])	# Frequency can not exceed 1.
			if(j==nloci)
				{
				popne[i]	<- sum(expAA,exAa,expaa)
				}
			}
		}
	return(z[ngens,])
	}	

simdemography<-function(startpop=50,K=200,alpha=1,beta=0,my_base=10,s_coef=0,startmaf=0.2,ngens=100,my_h=0.5,do_plot=TRUE)
	{
	# K is value of population size at which number of random deaths equals 1 per generation if beta is 1. Comparable with carying capacity but technically different.
	# beta is amplifier of number of random deaths per generation
	pop_ne		<- vector()
	pop_ne[1] 	<- startpop 
	q			<- startmaf
	p			<- 1-startmaf
	my_genos	<- matrix(NA,ncol=3,nrow=ngens)
	my_genos[1,]<- c(round((p^2)*startpop),round((2*p*q)*startpop),round((q^2)*startpop))	
	my_probs	<- vector()
	my_probs[1]	<- NA
	for (i in c(2:ngens))
		{ 
		## number of newborns:
		n_offspring	<- pop_ne[i-1]*alpha										# alpha is the mean number of offspring per individual
		q			<- rbinom(1,2*pop_ne[i-1],q)/(2*pop_ne[i-1])
		p			<- 1-q
		offspring_AA<- round((p^2)*n_offspring)
		offspring_Aa<- round((2*p*q)*n_offspring)
		offspring_aa<- round((q^2)*n_offspring)
		## survival through generation:						
		Pr_mort		<- (beta*(my_base^(n_offspring/K)))/n_offspring				# random mortality due to carrying capacity limits
		my_probs[i]	<- Pr_mort
		q			<- rbinom(1,2*pop_ne[i-1],q)/(2*pop_ne[i-1])
		exp_AA		<- round((1-Pr_mort-s_coef)*offspring_AA)
		exp_Aa		<- round((1-Pr_mort-s_coef*my_h)*offspring_Aa)
		exp_aa		<- round((1-Pr_mort)*offspring_aa)
		pop_ne[i]	<- sum(exp_AA,exp_Aa,exp_aa)
		my_genos[i,]<- c(exp_AA,exp_Aa,exp_aa)
		}
	pop_ne			<- pop_ne
	my_probs		<<- my_probs
	if(do_plot)
		{
		plot(pop_ne,type='l',ylim=c(0,1.2*max(pop_ne)),ylab="Number of individuals",lwd=2,xlab="Number of generations",cex.lab=2,cex.axis=1.5)
		lines(my_genos[,1],col="red",lwd=2)
		lines(my_genos[,2],col="blue",lwd=2)
		lines(my_genos[,3],col="darkgreen",lwd=2)
		legend("topleft",fill=c("red","blue","darkgreen"),legend=c("AA","Aa","aa"),bty='n',cex=1.5)
		}
	}
		
expfix<-function(s=0.1,ne=50,q=0.17)
	{
	# Fixation probability according to Kimura's formula:
	if(s==0)
		{
		cat("s is reset to 0.00001",sep="\n")
		s	<- 0.00001
		}
	cat(paste("s =",s,sep=" "),sep="\n")
	cat(paste("ne =",ne,sep=" "),sep="\n")
	cat(paste("q =",q,sep=" "),sep="\n")
	cat("Fixation probability according to Kimura's formula:",sep="\n")
	pfix	<- round((1-exp(-2*ne*s*q))/(1-exp(-2*ne*s)),2)
	cat(pfix,sep="\n")
	}

getgenotypesfrommaf<-function(mafvector,nsamples)
	{
	### function to convert mafvector into expected genotype counts data
	### function returns a matrix with 3 columns (AA,Aa,aa) 
	# call objects:
	expAA		<-rep(NA,length(mafvector))
	expAa		<-rep(NA,length(mafvector))
	expaa		<-rep(NA,length(mafvector))
	# do the calculation:
	for (i in 1:(length(mafvector)))
		{
		expAA[i]<-round((1-mafvector[i])*(1-mafvector[i])*nsamples)
		expAa[i]<-round(2*(mafvector[i])*(1-mafvector[i])*nsamples)
		expaa[i]<-round(mafvector[i]*mafvector[i]*nsamples)
		}
	# store results:
 	z		<- cbind(expAA,expAa,expaa)
	colnames(z)	<- c("AA","Aa","aa")
	return(z)
	}
	
# create genlight object given two mafvectors (one mafvector for pop1, the other mafvector for pop2) stored in a matrix of 2 rows and nloc columns. 
getpedfrommaf<-function(n_ind=c(50,50),nloc=5000,mafinput=mafmatrix,exportname="simdata")
	{
	genocounts	<- list()
	for (k in c(1:2))
		{
		nind		<- n_ind[k]
		mafvector	<- mafinput[k,]
		### Convert mafvector into genotype counts data:
		expAA		<- rep(NA,length(mafvector))
		expAa		<- rep(NA,length(mafvector))
		expaa		<- rep(NA,length(mafvector))
		for (i in 1:(length(mafvector)))
			{
			expAA[i]<- round((1-mafvector[i])*(1-mafvector[i])*nind)
			expAa[i]<- round(2*(mafvector[i])*(1-mafvector[i])*nind)
			expaa[i]<- round(mafvector[i]*mafvector[i]*nind)
			}
 	temp1			<- cbind(expAA,expAa,expaa)	
	genocounts[[k]]	<- temp1 
	}
	#### Convert genotype count matrix into a cummulative genotype counts:
	genotypecum		<- genocounts
	for (k in c(1:2))
		{	
		for (j in c(1:nloc))
			{
			genotypecum[[k]][j,2]	<- genocounts[[k]][j,1]+genocounts[[k]][j,2]
			genotypecum[[k]][j,3]	<- genocounts[[k]][j,1]+genocounts[[k]][j,2]+genocounts[[k]][j,3]
			}
		}
	#### Now use info in genotypecum to create a genlight object:
	genlightobj	<- list()
	for (k in c(1:2))
		{
		nind<- n_ind[k]
		z	<- matrix(nrow=nind,ncol=nloc)
		for (j in 1:nloc)
			{
			for (i in 1:(nind))
				{
				if(i<=genotypecum[[k]][j,1])				{z[i,j]<-0}
				if(i>genotypecum[[k]][j,1]&i<=genotypecum[[k]][j,2])	{z[i,j]<-1}
				if(i>genotypecum[[k]][j,2])				{z[i,j]<-2}
				}
			}
		# Now shuffle, to get data into linkage equilibrium:
		z	<- as.data.frame(z)
		z[]	<- lapply(z,sample)	# lapply means: apply to each column
		genlightobj[[k]]	<- z
		}
	#### Create genlightobject with neutral loci (combining both pops):
	mygenlightmatrix	<- as.matrix(rbind(genlightobj[[1]],genlightobj[[2]]))
	simgenlight			<- as.genlight(mygenlightmatrix)
  	### Now create vectors of minor and major alleles (should match with the columns of the x-matrix):
  	# We assume alleles are either A (1) or C (2):
	minor				<- rep(2,nloc)
	major				<- rep(1,nloc)
	# Now we are ready to create our PED-file, starting with an empty matrix:
	genot<-matrix(NA,nrow=nrow(mygenlightmatrix),ncol=ncol(mygenlightmatrix))
  	rownames(genot)<-rownames(mygenlightmatrix)
  	colnames(genot)<-colnames(mygenlightmatrix)
  	for (j in c(1:ncol(mygenlightmatrix))) 
		{
    		g			<- mygenlightmatrix[,j]
    		maj			<- as.character(major[j])
    		min			<- as.character(minor[j])
    		g[is.na(g)]	<- paste(0,0,sep=" ")  				
    		g[g==0]		<- paste(maj,maj,sep=" ") 			 
    		g[g==1]		<- paste(min,maj,sep=" ") 		
    		g[g==2]		<- paste(min,min,sep=" ") 		
    		genot[,j]	<- g
  		}
  	pedfiledata	<- as.data.frame(genot)
	# Include additional information to pedfile:
	temp1		<- rep(1,n_ind[1])
	temp2		<- rep(2,n_ind[2])
	pedfile		<- cbind(FID=c(temp1,temp2),IID=seq(1:sum(n_ind)),PAT=0,MAT=0,SEX=0,PHENOTYPE=-9,pedfiledata)
	# Next create the MAP-file:
	mapfile		<- cbind(chr=rep("unknown",nloc),name=seq(1:nloc),gd=0,pos=rep(0,nloc))
	# Finally, export the files:
	write.table(pedfile,file=paste(exportname,"ped",sep = "."),sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	write.table(mapfile,file=paste(exportname,"map",sep = "."),sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	path1		<- paste(getwd(),exportname,sep="/")
	cat(paste("PED and MAP files have been written to", path1, sep =" "),sep="\n")
	mysambarsim$mygenlightmatrix	<<- mygenlightmatrix
	}	
	
	
randomDNA<-function(nseq=1,nbases=200)
	{
	bases 	<- c(rep('A',nbases/4), rep('C',nbases/4), rep('G',nbases/4), rep('T',nbases/4))
	seqs 	<<- rep(NA,nseq)
	for (i in 1:nseq)
		{
		seqs[i] <<- paste(sample(bases,nbases), collapse = '')
		}
	}

#randomreads(nref=200,mypositions=seq(20,80,20),ninds=5,cover=10,add_indels=TRUE,insertionsize=10,insertpos=50,deletpos=70)
randomreads<-function(nref=200,mypositions=seq(20,80,20),ninds=2,cover=5,add_indels=TRUE,insertionsize=3,insertpos=50,deletpos=70)
	{
	current_dir	<- getwd()
	out_dir		<- "Testsequences"
	my_dir		<- paste(current_dir,out_dir,sep="/")
	if(!file.exists(my_dir)){dir.create(file.path(my_dir))}
	setwd(my_dir)
	bases 		<- c(rep('A',nref/4), rep('C',nref/4), rep('G',nref/4), rep('T',nref/4))
	myref 		<- paste(sample(bases,nref),collapse='')
	for(j in c(1:ninds))
		{
		cat(j,sep="\n")
		read1		<- substring(myref,1,100)
		read2		<- substring(myref,101,200)
		for (mypos in mypositions)
			{
			if(j<=ninds/2)
				{
				substring(read1,mypos,mypos)<- "T"
				substring(read2,mypos,mypos)<- "A"
				}else{
				substring(read1,mypos,mypos) <- "C"
				substring(read2,mypos,mypos) <- "G"
				}
			}
		qualityscore_read1			<- paste(rep('Z',100),collapse='')
		qualityscore_read2			<- paste(rep('Z',100),collapse='')
		# insertions:
		if((j<=ninds/2)&(add_indels)&(j%%2==0))
				{
				# insertion:
				my_insertion		<- paste(rep("T",insertionsize),collapse="")
				temp1				<- substring(read1,1,insertpos)
				temp2				<- substring(read1,insertpos+1,100)
				read1				<- paste(temp1,my_insertion,temp2,sep='')
				qualityscore_read1	<- paste(rep('Z',100+insertionsize),collapse='')
				#deletion:
				temp1				<- substring(read2,1,deletpos)
				temp2				<- substring(read2,deletpos+1+insertionsize,100)
				read2				<- paste(temp1,temp2,sep='')
				qualityscore_read2	<- paste(rep('Z',100-insertionsize),collapse='')
				}
		cat(read1,sep="\n")
		cat(qualityscore_read1,sep="\n")
		newread1	<- paste(">read",read1,"+",qualityscore_read1,sep="\n")
		newreads1	<- rep(newread1,cover)
		cat(read2,sep="\n")
		cat(qualityscore_read2,sep="\n")
		newread2	<- paste(">read",read2,"+",qualityscore_read2,sep="\n")
		newreads2	<- rep(newread2,cover)
		my_filename_1	<- paste("ind",j,"1.fq",sep=".")
		my_filename_2	<- paste("ind",j,"2.fq",sep=".")
		write.table(newreads1,my_filename_1,quote=FALSE,col.names=FALSE,row.names=FALSE)
		write.table(newreads2,my_filename_2,quote=FALSE,col.names=FALSE,row.names=FALSE)
		}
	myref_fasta			<- paste(">myreference ",myref,sep="\n")	# without white space sed command doesn't work 
	write.table(myref_fasta,"testreference.fa",quote=FALSE,col.names=FALSE,row.names=FALSE)
	setwd(current_dir)
	cat(paste("Fasta files have been written to:",my_dir,sep="\n"),sep="\n")
	}
	
	
####################	

# old version:
outliersim_old<-function(nloc=1000,ngen=20,nesourcepop=1000,nefounderpop1=20,nefounderpop2=200,nfounders=10,samplesize=30,testgeno=FALSE,nselectedloci=0,selcoef=0.1)
	{
	founderpopsizes			<<- rbind(nefounderpop1,nefounderpop2)
	# To store results:
	genotypecounts			<- list()
	pvalue					<<- vector()
	pvaluepairwise			<<- matrix(nrow=3,ncol=nloc) 
	macmatrix				<- matrix(nrow=8,ncol=nloc)
	rownames(macmatrix)		<- c("founder1_A","founder1_a","founder2_A","founder2_a","founders_A","founders_a","source_A","source_a")
	# Simulate source mafs before founder event:
	sourcemaf				<<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=200,meanmaf=0.1)
	# Simulate source mac after founder event and after sampling:
	mafvec					<<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=ngen,mafstartvector=sourcemaf)
	for (j in c(1:nloc))
		{  
		macmatrix[8,j] 		<- rbinom(1,(2*samplesize),mafvec[j])
		}
	if(testgeno)
		{
		genotypecounts[[4]]	<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
		}
	# Simulate founder macs:
	for (k in c(1:2))
		{
		mafvec			<<- getfounderpopmaf(sourcemafvector=sourcemaf,nrfounders=nfounders,nefounderpop=founderpopsizes[k,],nrloci=nloc,ngenfounder=ngen,nselectloci=nselectedloci,selc=selcoef,dodiscrete=s_discrete)	
		for (j in c(1:nloc))
			{  
			macmatrix[k*2,j]<- rbinom(1,(2*samplesize),mafvec[j])
			}
		if(testgeno)
			{
			genotypecounts[[k]]<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
			}
		}
	###### Execute fisher's exact test on simulated data using built-in R-function:  
	if(testgeno)
		{
		# Combine both founder populations into one founder population:
		genotypecounts[[3]]	<- genotypecounts[[1]]+genotypecounts[[2]]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons, for source against source (pointless indeed), as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			for (i in c(1:nloc))
  				{
  				d	<- genotypecounts[[4]][i,1]
 				e	<- genotypecounts[[4]][i,2]
  				f	<- genotypecounts[[4]][i,3]
 				x	<- genotypecounts[[j]][i,1]
 				y	<- genotypecounts[[j]][i,2]
  				z	<- genotypecounts[[j]][i,3]
  				mytable	<- matrix(c(d,e,f,x,y,z),2,3,byrow=TRUE)
 				pvalue[i]<<-fisher.test(mytable)$p.value
  				}
			pvaluepairwise[j,]<<- pvalue
			}
		}else{
		# Combine both founder populations into one founder population:
		macmatrix[6,]		<- macmatrix[2,]+macmatrix[4,]
		# calculate number of major alleles:
		macmatrix[1,]		<- 2*samplesize-macmatrix[2,]
		macmatrix[3,]		<- 2*samplesize-macmatrix[4,]
		macmatrix[5,]		<- 4*samplesize-macmatrix[6,]
		macmatrix[7,]		<- 2*samplesize-macmatrix[8,]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons,as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(7,8,2*j-1,2*j),i],2,2,byrow=TRUE)})
			pvaluepairwise[j,]	<<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
			}
		}
	mysambarsim$macmatrix	<<- macmatrix
	# negative log of pvalues:
	logp					<- (-log(pvaluepairwise))
	rownames(logp)			<- c("F1vsS","F2vsS","FcombivsS")
	mysambarsim$logp		<<- logp
	# Plot:
	graphics.off()
	plot(logp[1,],col="blue",ylim=c(0,(max(logp))))
	points(logp[2,],col="red")
	points(logp[3,],col="green")
	legend(x=4/5*nloc,y=7/8*max(logp),legend=c("F1-S","F2-S","Fcomb-S"),fill=c("blue","red","green"))
	}

############################### END OF SIMULATION SECTION ###############################









############################### TREEMIX FUNCTIONS #############################

# functions for plotting Treemix output.
# Functions copy pasted from 'Treemix_plotting_funcs.R' on Treemix page (expect for plottreemix function).
# I added the option of specifying population colours.

plottreemix<-function(export=NULL,prefix=NULL,plotname="Treemixout",myxmin=0)
	{
	if(is.null(prefix))
		{
		return(cat("ERROR: provide base name of input files (i.e., without extension) to the prefix flag.",sep="\n")) 
		}
	myfile1		<- paste(prefix,"edges.gz",sep=".")
	myfile2		<- paste(prefix,"vertices.gz",sep=".")
	if(!file.exists(myfile1)|!file.exists(myfile2))
		{
		cat("ERROR: Could not find input files in the directory:",sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	if(!is.null(export))
		{
		mywidth		<- 8
		mywidth2	<- 720
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=8)}
		}
	plot_tree(stem=prefix,labelcolours=mypopcolours,cex=2,disp=0.001,plus=0.05,arrow=0.2,scale=T,ybar=0.1,mbar=T,plotmig=T,plotnames=T,xmin=myxmin,lwd=2,font=1)
	mtext(side=1,"Drift parameter",line=3,cex=2.25)
	if(!is.null(export))
		{
		dev.off()
		cat("Treemix plot exported to directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}


# library(RColorBrewer)
set_y_coords = function(d)
	{
	i = which(d[,3]=="ROOT")
	y = d[i,8]/ (d[i,8]+d[i,10])
	d[i,]$y = 1-y
	d[i,]$ymin = 0
	d[i,]$ymax = 1
	c1 = d[i,7]
	c2 = d[i,9]
	ni = which(d[,1]==c1)
	ny = d[ni,8]/ (d[ni,8]+d[ni,10])
	d[ni,]$ymin = 1-y
	d[ni,]$ymax = 1
	d[ni,]$y = 1- ny*(y)
	ni = which(d[,1]==c2)
    ny = d[ni,8]/ (d[ni,8]+d[ni,10])
    d[ni,]$ymin = 0
    d[ni,]$ymax = 1-y
    d[ni,]$y = (1-y)-ny*(1-y)
	for (j in 1:nrow(d))
		{
		d = set_y_coord(d, j)
		}	
	return(d)
	}

set_y_coord = function(d, i)
	{
	index = d[i,1]
	parent = d[i,6]
	if (!is.na(d[i,]$y))
		{
		return(d)
		}
	tmp = d[d[,1] == parent,]
	if ( is.na(tmp[1,]$y))
		{
		d = set_y_coord(d, which(d[,1]==parent))
		tmp = d[d[,1]== parent,]
		}
	py = tmp[1,]$y
	pymin = tmp[1,]$ymin
	pymax = tmp[1,]$ymax
	f = d[i,8]/( d[i,8]+d[i,10])
	#print (paste(i, index, py, pymin, pymax, f))
	if (tmp[1,7] == index)
		{
		d[i,]$ymin = py
		d[i,]$ymax = pymax
		d[i,]$y = pymax-f*(pymax-py)
		if (d[i,5]== "TIP")
			{
			d[i,]$y = (py+pymax)/2
			}
		}else{
		d[i,]$ymin = pymin
		d[i,]$ymax = py
		d[i,]$y = py-f*(py-pymin)
		if (d[i,5]== "TIP")
			{
            d[i,]$y = (pymin+py)/2
            }	
		}
	return(d)
	}


set_x_coords = function(d, e)
	{
	i = which(d[,3]=="ROOT")
	index = d[i,1]
        d[i,]$x = 0
        c1 = d[i,7]
        c2 = d[i,9]
        ni = which(d[,1]==c1)
	tmpx =  e[e[,1]==index & e[,2] == c1,3]
	if (length(tmpx) == 0){
		tmp = e[e[,1] == index,]
		tmpc1 = tmp[1,2]
		if ( d[d[,1]==tmpc1,4] != "MIG"){
			tmpc1 = tmp[2,2]
		}
		tmpx = get_dist_to_nmig(d, e, index, tmpc1)
	}
	if(tmpx < 0){
		tmpx = 0
	}
        d[ni,]$x = tmpx

        ni = which(d[,1]==c2)
        tmpx =  e[e[,1]==index & e[,2] == c2,3]
	if (length(tmpx) == 0){
    		tmp = e[e[,1] == index,]
                tmpc2 = tmp[2,2]
                if ( d[d[,1]==tmpc2,4] != "MIG"){
                        tmpc2 = tmp[1,2]
                }
                tmpx = get_dist_to_nmig(d, e, index, tmpc2)
	}
        if(tmpx < 0){
                tmpx = 0
        }
        d[ni,]$x = tmpx
        
        for (j in 1:nrow(d)){
                d = set_x_coord(d, e, j)
        }
	return(d)
	print(d)
	}

set_x_coord = function(d, e, i)
	{
	index = d[i,1]
        parent = d[i,6]
        if (!is.na(d[i,]$x)){
                return(d)
        }
        tmp = d[d[,1] == parent,]
        if ( is.na(tmp[1,]$x)){
                d = set_x_coord(d, e, which(d[,1]==parent))
                tmp = d[d[,1]== parent,]
        }
	#print (paste(parent, index))
	tmpx =  e[e[,1]==parent & e[,2] == index,3]
	if (length(tmpx) == 0){
                tmp2 = e[e[,1] == parent,]
                tmpc2 = tmp2[2,2]
		#print
                if ( d[d[,1]==tmpc2,4] != "MIG"){
                        tmpc2 = tmp2[1,2]
                }
		tmpx = get_dist_to_nmig(d, e, parent, tmpc2)
	}
        if(tmpx < 0){
                tmpx = 0
        }
	d[i,]$x = tmp[1,]$x+ tmpx
	return(d)
	}

plot_tree_internal = function(d, e, o = NA, cex = 1, disp = 0.001, plus = 0.003, arrow = 0.05, ybar = 0.01, scale = T, mbar = T, mse = 0.01, plotmig = T, plotnames = T, xmin = 0, lwd = 1, font = 1, my_colours = NULL){
	# 18-07-2021: change of cex.axis added for use in SambaR:
	par(cex.axis=1.5)
	#plot(d$x, d$y, axes = F, ylab = "", xlab = "Drift parameter", xlim = c(xmin, max(d$x)+plus), pch = "")
	plot(d$x, d$y, axes = F, ylab = "", xlab = "", xlim = c(xmin, max(d$x)+plus), pch = "")
	axis(1)
	mw = max(e[e[,5]=="MIG",4])
	mcols = rev(heat.colors(150))
	for(i in 1:nrow(e)){
		col = "black"
		if (e[i,5] == "MIG"){
			w = floor(e[i,4]*200)+50
			if (mw > 0.5){
				w = floor(e[i,4]*100)+50
			}
			col = mcols[w]
			if (is.na(col)){
				col = "blue"
			}
		}
		v1 = d[d[,1] == e[i,1],]
		v2 = d[d[,1] == e[i,2],]
		if (e[i,5] == "MIG"){
			if (plotmig){
			# 18-07-2021: addition of lwd=lwd for use in SambaR
			arrows( v1[1,]$x, v1[1,]$y, v2[1,]$x, v2[1,]$y, col = col, length = arrow,lwd = lwd)
			}
		}
		else{
			lines( c(v1[1,]$x, v2[1,]$x), c(v1[1,]$y, v2[1,]$y), col = col, lwd = lwd)
		}
	}
	tmp = d[d[,5] == "TIP",]
	print(tmp$x)
	print(disp)
	if ( !is.na(o)){
		for(i in 1:nrow(tmp)){
			tcol = o[o[,1] == tmp[i,2],2]
			if(plotnames){
				#print(tmp[i,2])
				text(tmp[i,]$x+disp, tmp[i,]$y, labels = tmp[i,2], adj = 0, cex = cex, col  = tcol, font = font)
			}
		}
	}
	else{
		if (plotnames)
			{
			# 18-07-2021: following lines added for use in SambaR:
			treemixlabels	<- tmp[,2]
			mypopcolours	<<- vector()
			if(length(mysambar$populations)!=length(treemixlabels))
				{
				cat("ERROR: number of populations in input Treemix files does not correspond to number of populations at mysambar$populations.",sep="\n")
				dev.off()
				return(cat("Aborting Treemix plot.",sep="\n"))
				}
			for(k in c(1:length(treemixlabels)))
				{
				mypopcolours[k]	<<- mysambar$mycolours[which(mysambar$populations==treemixlabels[k])]
				}
			# 18-07-2021: until here, as well as else statement in the the next conditional:
			if(is.null(my_colours))
				{
				text(tmp$x+disp, tmp$y, labels = tmp[,2], adj = 0, cex = cex, font = font)
				}else{
				text(tmp$x+disp, tmp$y, labels = tmp[,2], adj = 0, cex = cex, font = font, col = my_colours)
				}
			}
	}
	if (scale){
	print (paste("mse", mse))
        lines(c(0, mse*10), c(ybar, ybar))
	text( 0, ybar - 0.04, lab = "10 s.e.", adj = 0, cex  = 0.8)
	lines( c(0, 0), c( ybar - 0.01, ybar+0.01))
	lines( c(mse*10, mse*10), c(ybar- 0.01, ybar+ 0.01))
	}
    if(mbar)
		{
        mcols = rev( heat.colors(150) )
        mcols = mcols[50:length(mcols)]
        ymi = ybar+0.15
        yma = ybar+0.35
        l = 0.2
        w = l/100
        xma = max(d$x/20)
        mbarcex	= 1.0		# 18-07-2021: addition of mbarcex for use in SambaR. Default is 0.7.
		rect( rep(0, 100), ymi+(0:99)*w, rep(xma, 100), ymi+(1:100)*w, col = mcols, border = mcols)
        text(xma+disp, ymi, lab = "0", adj = 0, cex = mbarcex)
		if(mw>0.5)
			{ 
			text(xma+disp, yma, lab = "1", adj = 0, cex = mbarcex)
			}else{
			text(xma+disp, yma, lab = "0.5", adj = 0, cex = mbarcex)
			}
		text(0, yma+0.06, lab = "Migration", adj = 0 , cex = mbarcex)
		text(0, yma+0.03, lab = "weight", adj = 0 , cex = mbarcex)
		}		
	}

set_mig_coords = function(d, e){
	for (j in 1:nrow(d)){
		if (d[j,4] == "MIG"){
			p = d[d[,1] == d[j,6],]
			c = d[d[,1] == d[j,7],]
			tmpe = e[e[,1] == d[j,1],]
			y1 = p[1,]$y
			y2 = c[1,]$y
			x1 = p[1,]$x
			x2 = c[1,]$x

			mf = tmpe[1,6]	
			if (is.nan(mf)){
				mf = 0
			}
			#d[j,]$y = (y1+y2)* mf
                        #d[j,]$x = (x1+x2) *mf
                        d[j,]$y = y1+(y2-y1)* mf
			print(paste(mf, x1, x2))
                        d[j,]$x = x1+(x2-x1) *mf
		}	

	}
	return(d)

}

get_f = function(stem){
	d = paste(stem, ".cov.gz", sep = "")
	d2 = paste(stem, ".modelcov.gz", sep = "")
	d = read.table(gzfile(d), as.is = T, comment.char = "", quote = "")
	d2 = read.table(gzfile(d2), as.is = T, comment.char = "", quote = "")
	d = d[order(names(d)), order(names(d))]
	d2 = d2[order(names(d2)), order(names(d2))]
	tmpcf = vector()
        tmpmcf = vector()
        for (j in 1:nrow(d)){
                for (k in (j+1):nrow(d)){
                        tmpcf = append(tmpcf, d[j,k])
                        tmpmcf = append(tmpmcf, d[j,k] - d2[j,k])
                }
        }
        tmpv = var(tmpmcf)/var(tmpcf)
	return(1-tmpv)

}

plot_tree = function(stem, o = NA, cex = 1, disp = 0.004, plus = 0.02, flip = vector(), arrow = 0.05, scale = T, ybar = 0.1, mbar = T, plotmig = T, plotnames = T, xmin = 0, lwd = 1, font = 1, labelcolours = NULL)
	{
	d = paste(stem, ".vertices.gz", sep = "")
	e = paste(stem, ".edges.gz", sep = "")
	se = paste(stem, ".covse.gz", sep = "")
	d = read.table(gzfile(d), as.is = T, comment.char = "", quote = "")
	e = read.table(gzfile(e), as.is  = T, comment.char = "", quote = "")
	if (!is.na(o))
		{
		o = read.table(o, as.is = T, comment.char = "", quote = "")
		}
	e[,3] = e[,3]*e[,4]
	e[,3] = e[,3]*e[,4]
	se = read.table(gzfile(se), as.is = T, comment.char = "", quote = "")
	m1 = apply(se, 1, mean)
	m = mean(m1)
	#m = 0
	for(i in 1:length(flip))
		{
		d = flip_node(d, flip[i])
		}
	d$x = "NA"
	d$y = "NA"
	d$ymin = "NA"
	d$ymax = "NA"
	d$x = as.numeric(d$x)
	d$y = as.numeric(d$y)
	d$ymin = as.numeric(d$ymin)
	d$ymax = as.numeric(d$ymax)
	d = set_y_coords(d)
	d = set_x_coords(d, e)
	print(d)
	d = set_mig_coords(d, e)
	# 18-07-2021: my_colours argument added for use in SambaR:
	plot_tree_internal(d, e, o = o, cex = cex, xmin = xmin, disp = disp, plus = plus, arrow = arrow, ybar = ybar, mbar = mbar, mse = m, scale = scale, plotmig = plotmig, plotnames = plotnames, lwd = lwd, font = font, my_colours = labelcolours)
	return(list( d= d, e = e))
	}

get_dist_to_nmig = function(d, e, n1, n2)
	{
	toreturn = e[e[,1] == n1 & e[,2] == n2,3]
	#print(toreturn)
	while ( d[d[,1] ==n2,4] == "MIG")
		{
		tmp = e[e[,1] == n2 & e[,5] == "NOT_MIG",]
		toreturn = toreturn+tmp[1,3]
		n2 = tmp[1,2]
		}
	return(toreturn)
	}

flip_node = function(d, n)
	{
	i = which(d[,1] == n)
	t1 = d[i,7]
	t2 = d[i,8]
	d[i,7] = d[i,9]
	d[i,8] = d[i,10]
	d[i,9] = t1
	d[i,10] = t2
	return(d)
	}

plot_modelcov = function(stem, pop_order, min = -0.009, max = 0.009, cex = 1, usemax = T){
        c = read.table(gzfile(paste(stem, ".modelcov.gz", sep = "")), as.is = T, head = T)
        o = read.table(pop_order, as.is = T, comment.char = "", quote = "")


        toplot = data.frame(matrix(nrow = nrow(c), ncol = ncol(c)))
        for(i in 1:nrow(o)){
                for( j in 1:nrow(o)){

                        toplot[i, j] = c[which(names(c)==o[i,1]), which(names(c)==o[j,1])]
                }
        }
        if (usemax){
                m1 = max(abs(toplot))
                max = m1*1.1
                min = -(m1*1.1)
        }
        names(toplot) = o[,1]
        plot_resid_internal(toplot, max = max, min = min)
}



plot_cov = function(stem, pop_order, min = -0.009, max = 0.009, cex = 1, usemax = T, wcols = ""){
        c = read.table(gzfile(paste(stem, ".cov.gz", sep = "")), as.is = T, head = T)
        o = read.table(pop_order, as.is = T)


        toplot = data.frame(matrix(nrow = nrow(c), ncol = ncol(c)))
        for(i in 1:nrow(o)){
                for( j in 1:nrow(o)){

                        toplot[i, j] = c[which(names(c)==o[i,1]), which(names(c)==o[j,1])]
                }
        }
        if (usemax){
                m1 = max(abs(toplot))
                max = m1*1.1
                min = 0
        }
        names(toplot) = o[,1]
        plot_cov_internal(toplot, max = max, min = min, wcols = wcols, o = o, cex = cex)
}


plot_resid = function(stem, pop_order, min = -0.009, max = 0.009, cex = 1, usemax = T, wcols = "r"){
	c = read.table(gzfile(paste(stem, ".cov.gz", sep = "")), as.is = T, head = T, quote = "", comment.char = "")
	m = read.table(gzfile(paste(stem, ".modelcov.gz", sep = "")), as.is = T, head = T, quote = "", comment.char = "")
	names(c) = rownames(c)
	names(m) = rownames(m)
	o = read.table(pop_order, as.is = T, comment.char = "", quote = "")
	se = read.table(gzfile(paste(stem, ".covse.gz", sep = "")), as.is = T, head = T, quote = "", comment.char = "")
	mse = apply(se, 1, mean)
	mse = mean(mse)
	print(mse)	
	c = c[order(names(c)), order(names(c))]
	m = m[order(names(m)), order(names(m))]
	tmp = c -m 
	#tmp = m - c
	#tmp = (m-c)/m
	#print(tmp)
	toplot = data.frame(matrix(nrow = nrow(tmp), ncol = ncol(tmp)))
	for(i in 1:nrow(o)){
	        for( j in 1:nrow(o)){
			#print(paste(o[i,1], o[j,1]))
			if (o[i,1] %in% names(tmp) ==F){
				print(paste("not found", o[i,1]))
			}
			if (o[j,1] %in% names(tmp) ==F){
				print(paste("not found", o[j,1]))
			}
        	        toplot[i, j] = tmp[which(names(tmp)==o[i,1]), which(names(tmp)==o[j,1])]
        	}
	}
	#print(toplot)
	if (usemax){
		m1 = max(abs(toplot), na.rm = T)
		max = m1*1.02
		min = -(m1*1.02)	
	}
	print("here")
	names(toplot) = o[,1]
	toreturn = plot_resid_internal(toplot, max = max, min = min, wcols = wcols, mse = mse, o = o, cex = cex)
	return(toreturn)
}

plot_cov_internal = function(d, o = NA, max = 0.009, min = -0.009, cex =0.5, wcols = "", mse = 5){
        npop = nrow(d)
        width = 1/npop
        height = 1/npop
        colors = brewer.pal(9, "Spectral")
        colors = c("red", "orange","yellow", "white", "green", "blue", "black")
        pal = colorRampPalette(colors)
        ncol = 80
        cols = pal(ncol)
        plot("NA", xlim = c(0, 1), ylim = c(0, 1), axes = F, xlab = "", ylab = "")
        for (i in 1:npop){
                for( j in 1:i){
                        v = d[i,j]
                        col= "white"
                        if (v < 0){
                                if (wcols == "rb"){
                                col = rgb(0, 0, 1, v/min)
                                }
                                else{
                                #col = rgb(0, 0, 1, 0.1+0.9*(v/min))
                                col = cols[ncol/2-floor( (v/min)*(ncol/2))]
                                }
                        }
                        else{
                                if (wcols == "rb"){
                                col = rgb(1, 0, 0, v/max)
                                }
                                else{
                                #col = rgb(1, 0, 0, 0.1+0.9*(v/max))
                                col = cols[ceiling((v/max)*(ncol))]
                                }
                        }
                        xmin = j/npop - 1/npop
                        xmax = j/npop
                        ymin = 1-(i/npop)
                        ymax = 1-(i/npop)+1/npop
			if (v == 0){ col = "white"}
                        rect(xmin, ymin, xmax, ymax, col = col, border = col)
                }
                tcol = "black"
                tmp = o[o[,1] == names(d)[i],]
                if (length(tmp) != 1){
                        tcol = tmp[1,2]
                }
                mtext(names(d)[i], side = 2, at = 1-i/npop+0.5/npop, las = 1, cex = cex, col = tcol)
                mtext(names(d)[i], side = 1, at =  i/npop-0.5/npop, las = 3, cex = cex, col = tcol)
        }
        if ( !is.na(mse)){
                ymi = 0.5
                yma = 0.9
                w = (yma-ymi)/ncol
                xma = 0.80
                lmi = round(min, digits = 1)
                lma = round(max, digits = 1)
                print(cols)
                print(ymi+(0:ncol)*w)
                rect( rep(0.75, ncol), ymi+(0:(ncol-1))*w, rep(xma, ncol), ymi+(1:ncol)*w, col = cols, border = cols)
                text(xma+0.01, ymi, lab = paste(lmi),  adj = 0, cex = 0.8)
                text(xma+0.01, yma, lab = paste(lma, "(Variance)"), adj = 0, cex = 0.8)

        }
        return(d)
        #image(as.matrix(d), col = cols)
}

plot_resid_internal = function(d, o = NA, max = 0.009, min = -0.009, cex =0.5, wcols = "rb", mse = NA){
        npop = nrow(d)
        width = 1/npop
        height = 1/npop
	colors = brewer.pal(9, "Spectral")
	colors = c("red", "orange","yellow", "white", "green", "blue", "black")
	pal = colorRampPalette(colors)
	ncol = 80
	cols = pal(ncol)
        plot("NA", xlim = c(0, 1), ylim = c(0, 1), axes = F, xlab = "", ylab = "")
        for (i in 1:npop){
                for( j in 1:i){
                        v = d[i,j]
			print(paste(i, j, v))
                        col= "white"
                        if (v < 0){
				if (wcols == "rb"){
				col = rgb(0, 0, 1, v/min)
				}
				else{
                                #col = rgb(0, 0, 1, 0.1+0.9*(v/min))
				col = cols[ncol/2-floor( (v/min)*(ncol/2))]
				#col = "white"
				}
                        }
                        else{
				if (wcols == "rb"){
				col = rgb(1, 0, 0, v/max)
				}
				else{
                                #col = rgb(1, 0, 0, 0.1+0.9*(v/max))
				col = cols[ncol/2+ceiling((v/max)*(ncol/2))]
				}
                        }
                        xmin = j/npop - 1/npop
                        xmax = j/npop
                        ymin = 1-(i/npop)
                        ymax = 1-(i/npop)+1/npop
                        rect(xmin, ymin, xmax, ymax, col = col, border = col)
                }
		tcol = "black"
		tmp = o[o[,1] == names(d)[i],]
		if (length(tmp) != 1){
			tcol = tmp[1,2]
		}
                mtext(names(d)[i], side = 2, at = 1-i/npop+0.5/npop, las = 1, cex = cex, col = tcol)
                mtext(names(d)[i], side = 1, at =  i/npop-0.5/npop, las = 3, cex = cex, col = tcol)
        }
	if ( !is.na(mse)){
                ymi = 0.5
                yma = 0.9
                w = (yma-ymi)/ncol
                xma = 0.80
		lmi = round(min/mse, digits = 1)
		lma = round(max/mse, digits = 1)
		print(cols)
		print(ymi+(0:ncol)*w)
                rect( rep(0.75, ncol), ymi+(0:(ncol-1))*w, rep(xma, ncol), ymi+(1:ncol)*w, col = cols, border = cols)
                text(xma+0.01, ymi, lab = paste(lmi, "SE"),  adj = 0, cex = 0.8)
                text(xma+0.01, yma, lab = paste(lma, "SE"), adj = 0, cex = 0.8)

	}
	return(d)
	#image(as.matrix(d), col = cols)
	}

########## END OF TREEMIX FUNCTIONS ##########




































cat("SambaR loaded.",sep="\n")
cat("Now you can run the commands getpackages(), importdata(), filterdata(), and afterwards findstructure(), calcdistance(), calcdiversity() and selectionanalyses().",sep="\n")
cat("See the manual for more details and for solutions to potential errors you might encounter.",sep="\n")
cat("Make sure that none of the SambaR plots and other output files are opened in a file viewer when (re)running a function, otherwise you will encounter errors (e.g.: 'ERROR: cannot open file...: (Permission denied)').",sep="\n")
cat("Also, please prepare your commands in a plain text editor (e.g. Notepad) and not in Word, because Word might deform quotes, which will lead to the error: 'Error: unexpected input in...'.",sep="\n")    
cat(" ",sep="\n")
cat("IMPORTANT NOTE:",sep="\n")
cat("SambaR is meant to free its users from the disproportionate time investment which without SambaR is needed for trivial task associated with execution and presentation of population-genetic analyses.",sep="\n")
cat("SambaR is NOT meant for superficial data analyses without critical thinking and understanding of the theoretical underpinnings of these analyses.",sep="\n")
cat("SambaR users are expected to use the freed up time for critical evaluation of analyses outcomes as well as for the study of the algorithms behind population-genetic analyses.",sep="\n") 
cat("The file 'SambaR_methods2.txt' (included in download from Github) provides an overview of the SambaR commands which call functions of other R packages.",sep="\n")
cat("The section 10.3 in the SambaR manual contains detailed explanations of calculations performed by SambaR functions.",sep="\n") 

if(getRversion()<'4.0.0')
	{
	cat("",sep="\n")
	cat("WARNING: SambaR depends on certain packages which can only be installed on R versions 4.0.0 or higher.",sep="\n")
	cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
	cat("If you have succesfully run the getpackages() function on this R installation on your computer before, you are probably fine.",sep="\n")
	cat(paste("If not, the getpackages() function might throw errors like: 'ERROR: package 'packagename' is not available for R ",getRversion(),".",sep=""),sep="\n")
	cat("To avoid these errors, you are recommended to install the latest version of R and run SambaR there.",sep="\n")
	cat("",sep="\n")
	#cat("If you are working on a relatively recent version of R, you might be able to safe the effort of reinstalling R and all dependencies by omitting a package or trying to install an older version of the particular package which causes the error.",sep="\n")
	#cat("In that case, first run the getpackages() function to find out which package can not be installed.",sep="\n")
	#cat("Afterwards, look on the CRAN, Bioconductor or Github webpage of this particular R package to find an older version of this package.",sep="\n")
	#cat("Define this version in the 'required_version' column of the 'mypackageslist.txt' file.",sep="\n")
	#cat("Then try to install this older version of this package using the install_version() function of devtools (which normally should have been installed when running the getpackages() function).",sep="\n")
	#cat("For example, if you want to install version 0.9.1 of the ggplot2 package, you would run the command:",sep="\n")
	#cat("install_version('ggplot2',version='0.9.1',repos='http://cran.us.r-project.org')",sep="\n")
	#cat("Afterwards run the getpackages() function and repeat the same procedure for other packages until the getpackages() function completes without throwing errors.",sep="\n")
	#if("car" %in% rownames(installed.packages()))
	#	{
	#	cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
	#	cat("It is still worth considering installing a newer R version at some point.",sep="\n")
	#	}else{
	#	cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
	#	cat("Therefore, you need to install a newer version of R (3.5.0 or newer) and run SambaR on this newer version.",sep="\n")
	#	}
	}

#cat(" ",sep="\n")
cat("Update 25-04-2021 (SambaR version 1.04 and newer): inbreeding and relatedness calculations are no longer part of the filterdata function, but instead included in the new function 'calckinship'.",sep="\n")

#my_os<-as.vector(Sys.info()["sysname"])
#if(my_os=="Linux")
#	{
#	cat("",sep="\n")
#	cat("You are running R on a Linux computer. This might cause problems for SambaR when trying to install the package 'devtools'.",sep="\n")
#	cat("Unfortunately at this point I do not have a solution for this problem yet.",sep="\n")
#	}

#cat("",sep="\n")
#cat("SambaR update 1:",sep="\n")
#cat("As of May 2020, SambaR offers the option to define the order of your populations in the admixture plot. Use the 'pop_order' flag of the findstructure function.",sep="\n")    
#cat("For example: if your populations are named 'America', 'Asia', 'Europe', you can specify an order (from left to right) by typing (for example):",sep="\n")
#cat("findstructure(pop_order=c('Europe','Asia','America'))",sep="\n")
#cat("",sep="\n")
#cat("SambaR update 2:",sep="\n")
#cat("Also, as of May 2020, users can define subpopulation structure, by including in the sample file a column called 'pop2'.",sep="\n")
#cat("For example: if in the 'pop'-column samples are assigned to populations 'America', 'Asia', 'Europe', you can can use the 'pop2'-column to assign your samples to countries within these continents.",sep="\n")   
#cat("When running the findstructure() function, SambaR will use this information to run pcoa analyses per population individually.",sep="\n")


