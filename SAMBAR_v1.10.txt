# SAMBAR: Snp DatA Management and Basic Analyses in R 
# Author: Menno de Jong, 
# Affiliations: Durham University (Biosciences Department), Senckenberg Institute (BIK-f) 
# github page: https://github.com/mennodejong1986/SambaR
# R package for SNP data management and analyses


# To run most SambaR functions, you need to run 10 R commands, which roughly look like this:
example_run<-function()
	{
	source("https://github.com/mennodejong1986/SambaR/raw/master/SAMBAR_v1.10.txt")
	# or:
	# source("SAMBAR_v1.00.txt")
	setwd("C:/path/to/workingdir")
	getpackages(myrepos='http://cran.us.r-project.org')
	importdata(inputprefix="SNPdataprefix",sumstatsfile=FALSE,depthfile=FALSE)
	filterdata(indmiss=0.25,snpmiss=0.1)
	findstructure()
	createmaps()
	calckinship()
	calcdistance()
	calcdiversity()
	selectionanalyses()
	backupdata("mySNPdata")
	}
# For more instructions, see the manual






##### file and package management:

# to get a list of all packages with a certain function name: 
findpackages<-function(myfunction) 
	{
	h 	<- help.search(paste0("^",myfunction,"$"),agrep=FALSE)     
	h$matches[,"Package"] 
	#
	# To know which of the packages is being used when you define the function, simply type the function name
	#
	# To change the order of loaded packages, so that function is no longer masked: simply unload and load the desired packages .
	# For example:
	# unloadNamespace("zoo")
	# library("zoo")
	}  

# function to check if file is open:
# Careful: if not open, this function overrides the existing file with an empty file.
# Plus: opens the file in R, and as a result can only open as read-only and not delete.
# So not useful 
file_opened<-function(myfilename=NULL) 
	{
	if(is.null(myfilename))
		{
		return(cat("ERROR: Please provide the name of a file to flag 'myfilename'.",sep="\n"))
		}
	if(!file.exists(myfilename))
		{
		return(cat("ERROR: Specified file does not exist.",sep="\n"))
		}
	return(suppressWarnings("try-error" %in% class(try(file(myfilename,open="w"),silent=TRUE))))
	}

##### the 2 functions needed to create multi tile plots:

myplotfunctions<-function(function_nr=1)
	{
	# Note: upper margin of the plots should be 2 (i.e. par(mar(.,.,2,.)) in order to allow for tile labels.
	if(function_nr==1){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==2){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==3){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==4){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==5){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	if(function_nr==6){plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")}
	}

mymultiplot<-function(myplotfunctions=myplotfunctions,doexport=FALSE,plot_name="combinedplot",myscreens=NULL,doexample=FALSE,myheight=6,mywidth=8,tilelabelsize=4.5,tilelabels=NULL,show_screens=FALSE)
	{
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	# mytiles <- rbind(c(0,0.4,0.4,1.0),c(0.4,1.0,0.4,1.0),c(0.0,0.33,0.0,0.4),c(0.33,0.67,0.0,0.4),c(0.67,1.0,0.0,0.4))
	# each row represents a different tile: (xmin, xmax, ymin, ymax), from 0 to 1
	if(doexample)
		{
		myscreens <- rbind(c(0,0.45,0.45,1.0),c(0.45,1.0,0.45,1.0),c(0.0,0.33,0.0,0.45),c(0.33,0.67,0.0,0.45),c(0.67,1.0,0.0,0.45))
		}else{
		if(is.null(myscreens))
			{
			cat("ERROR: please provide input matrix in which you define how to divide the plot into separate screens.",sep="\n")
			cat("This matrix should contain 4 (unnamed) columns defining xmin, xmax, ymin, ymax. Values can range between 0 and 1. One row per screen.",sep="\n")
			cat("For example: to divide the plot into 3 tiles, you could type:",sep="\n")
			return(cat("myscreens=rbind(c(0,0.5,0.4,1.0),c(0.5,1.0,0.4,1.0),c(0.0,1.0,0.0,0.5))",sep="\n"))
			}
		}
	if(is.null(tilelabels))
		{
		tilelabels	<- letters
		}
	nscreens	<- nrow(myscreens)
	cat(paste("Plot will be divided into ",nscreens," tiles.",sep=""),sep="\n") 
	if(doexport)
		{
		combinedplotname	<- paste(plot_name,"pdf",sep=".")
		pdf(combinedplotname,height=myheight,width=mywidth)
		# just for reference: A4 size: 210 × 297 mm or 8.3 × 11.7 inch
		}
	split.screen(myscreens)
	for (myscreennr in c(1:nscreens))
		{
		cat(paste("Generating plot in screen ",myscreennr,".",sep=""),sep="\n")
		screen(myscreennr)
		if(doexample)
			{
			par(oma=c(0.5,0.5,0.5,0.5),mar=c(0.5,0.5,1,0.5))
			plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")
			}else{
			if(show_screens)
				{
				plot(c(1:5),xlab="",ylab="",xaxt='n',yaxt='n',col="white")
				}else{
				myplotfunctions(function_nr=myscreennr)
				}
			}
		title(tilelabels[myscreennr],adj=0,cex.main=tilelabelsize)
		}
	# close all tiles:
	close.screen(all.screens = TRUE)
	if(doexport)
		{
		dev.off()
		cat("Plot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

indscatter<-function(export=NULL,plotname="Lroh_vs_Nroh",xscore="nroh",yscore="lroh",xlabel="Number of ROHs",ylabel="Total ROH length (Mb)",legendpos="topleft",yline=5.5)
	{
	ind				<- dwd$ind
	popinfo			<- dwd$popinfo
	mypops			<- as.character(popinfo$pop)
	mycolours		<- as.character(popinfo$popcol)
	#
	inputdf			<- ind[,c(xscore,yscore)]
	colnames(inputdf)<- c("xscore","yscore")
	#
	xmax			<- max(inputdf$xscore)
	ymax			<- max(inputdf$yscore)
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,8.5,2.5,0.5),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(inputdf$xscore,inputdf$yscore,pch=16,col=as.character(ind$popcol),xlim=c(0,xmax),ylim=c(0,ymax),cex=3,xlab=xlabel,ylab="",las=1)
	mtext(side=2,line=yline,ylabel,cex=3)
	legend(legendpos,legend=mypops,bty='n',fill=mycolours,cex=2.5)
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

#################################################################################################






#################################################################################################
# CITATIONS, METHODS and COMMANDS:


getcitations<-function()
	{
	mysoftwares			<- c("ade4","adegenet","ape","bibtex","car","circlize","colorspace","curl","devtools","fsthet","factoextra","FactoMineR","gdsfmt","gplots","grid","gridExtra","gridGraphics","LEA","mapplots","MASS","migest","OutFLANK","pcadapt","pegas","plot3D","plyr","poppr","psych","raster","RcppEigen","RColorBrewer","Rcpp","rworldmap","qvalue","scales","scatterplot3d","SNPRelate","StAMPP","stats","tess3r","VennDiagram","vegan","vioplot","zoo") 
	setwd(mysambar$sambardir)
	mybool				<- mysoftwares%in%installed.packages()
	mysoftwares			<- mysoftwares[mybool]
	write.bib(mysoftwares, file = "SambaR_Rpackages.bib", append = FALSE, verbose = TRUE)
	cat("A file called 'SambaR_Rpackages.bib' has been exported to the SambaR directory.",sep="\n")
	cat("This file can be loaded into a referencing software, such as Zotero or Endnote, although it might need some manual editing.",sep="\n")
	}

getversions<-function(return_object=FALSE)
	{
	mysoftwares			<- c("ade4","adegenet","ape","bibtex","circlize","colorspace","curl","devtools","fsthet","gdsfmt","gplots","grid","gridExtra","gridGraphics","LEA","mapplots","MASS","migest","OutFLANK","pcadapt","pegas","phangorn","plot3D","plyr","poppr","qvalue","RcppEigen","RColorBrewer","rworldmap","scales","scatterplot3d","SNPRelate","StAMPP","stats","tess3r","vegan","vioplot","zoo") 
	mysoftwares			<- mysoftwares[order(mysoftwares)]
	mybool				<- mysoftwares%in%installed.packages()
	mysoftwares			<- mysoftwares[mybool]
	myversions			<- vector()
	for (j in c(1:length(mysoftwares)))
		{	
		mypackage		<- mysoftwares[j] 
		myversions[j]	<- packageDescription(mypackage)$Version
		}
	mysoftwares			<- c("R",mysoftwares)
	myversions			<- c(getRversion(),myversions)
	mydf				<- data.frame(package=mysoftwares,version=myversions)	
	mydf$combined		<- paste(mydf$package,mydf$version,sep="-")
	if(return_object)
		{
		return(mydf)
		}
	write.table(mydf,"Rpackage_versions.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
	cat("A list of installed R packages (versions) has been exported to a file named 'Rpackage_versions.txt' in the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}	

exportmethods<-function(ind_miss=0.25,snp_miss=0.1,minmac=2,hefilter=TRUE,minimumspacing=500)
	{
	#if(!exists("mypackageversions"))
	#	{
	#	cat("WARNING: Object 'mypackageversions' not found. This might mean that the importdata function did not finish completely.",sep="\n")
	#	return(cat("Due to the absence of the 'mypackageversions' object, SambaR will not generate the file 'SambaR_methods.txt'. The analyses are unaffected.",sep="\n"))
	#	}
	myversions		<- getversions(return_object=TRUE)
	myrversion		<- myversions$combined[myversions$package=="R"]
	myadegenet		<- myversions$combined[myversions$package=="adegenet"]
	myrworldmap		<- myversions$combined[myversions$package=="rworldmap"]
	mymapplots		<- myversions$combined[myversions$package=="mapplots"]
	myade4			<- myversions$combined[myversions$package=="ade4"]
	myape			<- myversions$combined[myversions$package=="ape"]
	mystampp		<- myversions$combined[myversions$package=="StAMPP"]
	myphangorn		<- myversions$combined[myversions$package=="phangorn"]
	mypoppr			<- myversions$combined[myversions$package=="poppr"]
	mysnprelate		<- myversions$combined[myversions$package=="SNPRelate"]
	mystats			<- myversions$combined[myversions$package=="stats"]
	mymass			<- myversions$combined[myversions$package=="MASS"]
	mylea			<- myversions$combined[myversions$package=="LEA"]
	mypegas			<- myversions$combined[myversions$package=="pegas"]
	mycirclize		<- myversions$combined[myversions$package=="circlize"]
	myfsthet		<- myversions$combined[myversions$package=="fsthet"]
	myoutflank		<- myversions$combined[myversions$package=="OutFLANK"]
	mypcadapt		<- myversions$combined[myversions$package=="pcadapt"]
	myzoo			<- myversions$combined[myversions$package=="zoo"]
	setwd(mysambar$sambardir)
	ntotalinds		<- nrow(inds)
	if(any(!inds$filter))
		{
		npopmin			<- min(as.vector(table(inds$filter,inds$pop)[2,]))
		npopmax			<- max(as.vector(table(inds$filter,inds$pop)[2,]))
		}else{
		npopmin			<- min(as.vector(table(inds$filter,inds$pop)[1,]))
		npopmax			<- max(as.vector(table(inds$filter,inds$pop)[1,]))
		}
	nretainedinds	<- nrow(inds[inds$filter,])
	ntotalsnps		<- nrow(snps)
	nretainedsnps	<- nrow(snps[snps$filter2,])
	nthinnedsnps	<- nrow(snps[snps$filter,])
	if("meandepth"%in%colnames(inds))
		{
		rdmean	<- round(mean(inds$meandepth,na.rm=TRUE),1)
		rdmin	<- round(min(inds$meandepth,na.rm=TRUE),1)
		rdmax	<- round(max(inds$meandepth,na.rm=TRUE),1)
		if(min(inds$miss,na.rm=TRUE)<0.1)
			{
			rd0.1	<- round(min(inds$meandepth[inds$miss<=0.1],na.rm=TRUE),1)
			}else{
			rd0.1	<- NA
			}
		if(min(inds$miss,na.rm=TRUE)<0.005)
			{
			rd0.01	<- round(min(inds$meandepth[inds$miss<=0.01],na.rm=TRUE),1)
			}else{
			rd0.01	<- NA
			}
		if(min(inds$miss,na.rm=TRUE)<0.005)
			{
			rd0.005	<- round(min(inds$meandepth[inds$miss<=0.005],na.rm=TRUE),1)
			}else{
			rd0.005	<- NA
			}
		if(min(inds$miss,na.rm=TRUE)<0.001)
			{
			rd0.001	<- round(min(inds$meandepth[inds$miss<=0.001],na.rm=TRUE),1)
			}else{
			rd0.001	<- NA
			}
		}else{
		rdmean	<- NA
		rdmin	<- NA
		rdmax	<- NA
		rd0.1	<- NA
		rd0.01	<- NA
		rd0.005	<- NA
		rd0.001	<- NA
		}
	if("meandepth"%in%colnames(snps))
		{
		snpmedian	<- round(median(snps$meandepth,na.rm=TRUE),1)
		snpmean		<- round(mean(snps$meandepth,na.rm=TRUE),1)
		snpmax		<- round(max(snps$meandepth,na.rm=TRUE),1)
		snpmin		<- round(min(snps$meandepth,na.rm=TRUE),1)
		}else{
		snpmedian	<- NA
		snpmean		<- NA
		snpmax		<- NA
		snpmin		<- NA
		}
	myGC		<- round(nrow(snps[snps$GC&snps$filter,])/nrow(snps[snps$filter,]),2)
	mytransit	<- round(nrow(snps[snps$transit&snps$filter,])/nrow(snps[snps$filter,]),2)
	fileConn	<- file("SambaR_methods.txt")
	writeLines(c("This file contains a template for your methods section. Remove the lines which are not applicable to your study.",
	"Full citations can be found in the 'SambaR_Rpackages.bib' file.",
	"",
	"DATA PREPARATION",
	"PGD-Spider (Lischer and Excoffier, 2012), plink  (Purcell et al., 2007) or vcftools (Danecek et al., 2011) was used to convert the SNP data into PED and MAP format.",
	"The vcftools (Danecek et al., 2011) flags --depth and --site-depth were used to calculate read depth per individual and per SNP.",
	paste("The mean sequence depth per individual ranged from ",rdmin," to ",rdmax," reads per SNP, with an average of ",rdmean," reads per SNP per individual.",sep=""),
	paste("Individuals with less than 10, 1, 0.5 and 0.25 percent missing data had a minimum cover of respectively ",rd0.1,", ",rd0.01,", ",rd0.005,", and ",rd0.001," reads (see figure 'missingdatapersample').",sep=""), 
	paste("The mean sequence depth per individual per SNP ranged from ",snpmin," to ",snpmax," reads per SNP, with a mean and median of respectively ",snpmean," and ",snpmedian," reads (see figure 'Locusdepth').",sep=""),
	"Binary files (BED, RAW and BIM) were generated from PED and MAP files using PLINK (Purcell et al., 2007, i.e. using the flags --make-bed, --recode A, --chr-set 95, and allow-extra-chr).",
	"DATA MANAGEMENT",
	paste("SNP data management and analyses were performed in ",myrversion," (R Core Team, 2019) using wrapper functions of the R package SambaR (github page: https://github.com/mennodejong1986/SambaR ).",sep=""),
	paste("The data was imported into R and stored in a genlight object using the function 'read.PLINK' of the R package ",myadegenet," (Jombart, 2008; Jombart and Ahmed, 2011).",sep=""), 
	paste("The data was filtered using the function 'filterdata' of the R package SambaR, with indmiss=",ind_miss,", snpmiss=",snp_miss,", min_mac=",minmac,", dohefilter=",hefilter," and min_spacing=",minimumspacing,".",sep=""),
	paste("After filtering ",nretainedinds," out of ",ntotalinds," individuals (",npopmin,"-",npopmax," per population) were retained (see figures 'Missingdata_perpop', 'Retainedinds_perpop' and 'Discardedinds_perpop').",sep=""),
	paste("After filtering ",nretainedsnps," out of ",ntotalsnps," SNPs were retained (see figure 'Filterclasses'). This filtered dataset was used for selection analyses.",sep=""),
	paste("Thinning reduced the dataset further to ",nthinnedsnps," SNPs (see figure 'Filterclasses'). This filtered and thinned dataset was used for structure analyses.",sep=""),
	"Note that SambaR's 'filterdata' function filters individuals based on their proportion of missing datapoints considering all SNPs.",
	"Subsequently, the function filters SNPs based on their proportion of missing datapoints considering retained individuals only.",
	"The opposite order - i.e. first filtering of SNPs, then filtering of individuals - could return different estimates of missing data and, as a result, different numbers of retained SNPs and individuals.",  
	paste("The GC-content of the retained dataset equalled ",myGC," (see figure 'Minoralleles') and the 'transversion vs transition'-ratio equalled ",mytransit," (see figure 'Transitions_vs_transversions.filtered').",sep=""),
	"Linkage disequilibrium (LD) estimates were calculated using PLINK (-genome --r2 --ld-window-kb 1000000 --ld-window -r2 0).", 
	"PLOTTING",
	paste("Geographical maps were generated with the function 'getMap' of the R package ",myrworldmap," (South, 2011). Piecharts were added using the function 'add.pie' of the R package ",mymapplots," (Gerritsen, 2018).",sep=""),
	"STRUCTURE ANALYSES",
	paste("Correspondence analyses (CA) were performed using the function 'dudi.coa' of the R package ",myade4," (Dray and Dufour, 2007; Bougeard and Dray, 2018). Data was imputed per SNP/individual by calculating genotype probabilities from population specific minor allele frequencies'.",sep=""),
	paste("Principal coordinate analyses (PCoA) were performed using the function 'pcoa' of the R package ",myape," (Paradis and Schliep, 2018) on distance matrices containing 3 different measures of genetic distance:",sep=""),
	paste("- Nei's genetic distance, calculated with the function 'stamppNeisD' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	paste("- Hamming's genetic distance, calculated with the function 'bitwise.dist' of the R package ",mypoppr," (Kamvar et al., 2014).",sep=""),
	"- pi (pairwise sequence dissimilarity), calculated with the function 'calcpi' of the R package SambaR.", 
	paste("Principal component analyses (PCA) were performed using the function 'snpgdsPCA' of the R package ",mysnprelate," (Zheng et al., 2012).",sep=""),
	paste("DAPC analyses were performed using the function 'dapc' of the R package ",myadegenet," (Jombart, 2008; Jombart and Ahmed, 2011), both with and without prior population assignment. The number of PCs was set to ... (based on the a-score), the number of clusters was set to ..., and the number of discriminant functions to 3.",sep=""), 
	paste("Multi dimensional scaling (MDS) was performed using the function 'cmdscale' (metric MDS) of the R package ",mystats," (R Core Team, 2019) and the function 'isoMDS' (non-metric MDS) of the R package ",mymass," (Venables and Ripley, 2002), on a Euclidean distance matrix generated with the function 'dist' of the R package ",mystats," (R Core Team, 2019).",sep=""),
	paste("Neighbourhood joining (NJ) clustering was performed using the function 'NJ' of the R package ",myphangorn," (Schliep, 2011), using as input a Hamming’s genetic distance matrix between individuals, calculated with the function 'bitwise.dist' of the R package ",mypoppr," (Kamvar et al. 2014).",sep=""), 
	"Bayesian population assignment (BPA) probabilities were calculated and plotted using the functions 'assign2pop' and 'plotassign2pop' of the R package SambaR.",
	"The optimal number of clusters (K) was determined using the elbow method on cross-entropy scores generated by the 'snmf' function, with the assumption that the startpoint of a plateau represents the optimal K.",
	#paste("Genotype networks were generated with function 'haploNet' of the R package ",mypegas," (Paradis, 2010).",sep=""),
	"GENETIC DISTANCE ANALYSES",
	paste("Nei's genetic distance was calculated with the function 'stamppNeisD' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	paste("Genome wide 'Weir & Cockerham 1984' Fst estimates (for all pairwise population comparisons) were calculated with the function 'stamppFst' of the R package ",mystampp," (Pembleton et al., 2013).",sep=""),
	"Locus specific Fst estimates (according to Wright (1943), Nei (1977), and Cockerham and Weir (1987) (for all pairwise population comparisons) were calculated with the functions 'runWrightFst', 'locusNeiFst', and 'locusWCFst' of the R package SambaR.",
	"KINSHIP ANALYSES",
	"Inbreeding was estimated using the inbreeding coefficient (F), which is the probability that the two alleles at any locus of a diploid individual are identical by descent (IBD)(Kardos et al., 2015).",
	"Relatedness between sample pairs was estimated with the kinship coefficient (Wapels et al. 2018) and the KING-robust score (Manichaikul et al. 2010). Sample pairs with scores close to 0.5 were considered related.", 
	"In addition, relatedness between sample pairs was calculated using the softwares PLINK and/or GCTA and plotted using SambaR functions.", 
	"GENETIC DIVERSITY ANALYSES",
	"HWE, (2D) folded site frequency spectra (SFS), Tajima's D and genome wide heterozygosity analyses were executed using the function 'calcdiversity' of the R package SambaR.",
	"More specifically, population specific SFS vectors were generated with the function 'getfoldedsfs' of the R package SambaR, which bins SNPs in classes based on their number of copies of the minor allele, and which subsequently calculated the size of each bin (i.e. number of SNPs within each bin).", 
	"Genome wide He (genomeHe) was calculated for each sample using the formula: genome He = (He_seg * N_seg)/N_total, in which:",
	"N_seg: 	the number of sites segregating within the population to which the investigated individual belonged.",
	"He_seg: 	the proportion of heterozygous sites within the investigated individual for those segregating sites.", 
	"N_total:	the combined length of all sequenced sites (polymorphic as well as monomorphic) which passed the filter settings.",  
	"DEMOGRAPHIC ANALYSES",
	paste("Admixture coefficients were calculated with the functions 'snmf' and 'Q' of the R package ",mylea," (Frichot and Francois, 2014). Alpha was set to 10, tolerance to 0.00001, and number of iterations to 200.",sep=""),
	"Ancestry coefficients were calculated with the software Admixture-1.3 (Alexander et al., 2009) and plotted using the 'plotstructure'-function of SambaR.",
	"SELECTION ANALYSES",
	paste("Selection analyses were performed using the R packages ",myfsthet," (Flanagan and Jones, 2018), ", myoutflank," (Whitlock and Lotterhos, 2015), ",mypcadapt," (Luu et al., 2016) and the 'gwdsfisher' function of SambaR.",sep=""), 
	paste("Association analyses (GWAS) were performed using the function 'gwdsfisher' of the R package SambaR.",sep=""),
	paste("Sliding window Fst analyses were performed using the function 'rollapply' of the R package ",myzoo,".",sep=""),
	"DEMOGRAPHY ANALYSES",
	"Historical Ne estimates were inferred from the folded SFS vectors with the software stairway_plot_v2 (Liu and Fu, 2015). The mutation rate was set to ... and, the generation time to ...",
	paste("Migration rates were estimated using BayesAss3-SNPs (Mussmann et al., 2019). The number of iterations was set to 1000000, burn-in to 100000 and delta values to 0.1. Output matrices were converted into gene flow plots with the function 'plotmigration' of the R package SambaR, with use of the R package ",mycirclize,".",sep=""), 
	""),fileConn)
	close(fileConn)
	}

sambarcommands<-function(filename="D:/PhD/General/SAMBAR/SAMBAR_v1.01.txt")
	{
	mysambarfile 	<- readLines(filename) 
	linenrs			<- grep("sambarfunction",mysambarfile,value=FALSE)
	mycommands		<- mysambarfile[linenrs+1]
	mycommands2		<- gsub("\"","'",gsub("\t","",mycommands))
	mycommands2		<- mycommands2[2:length(mycommands2)]
	fileConn		<- file("SambaR_methods2.txt")
	writeLines(mycommands2,fileConn)
	close(fileConn)
	# sambarfunction:
	# This file ('SambaR_methods2.txt') contains an overview of the commands executed by the SambaR pipeline which call functions of other packages.
	# sambarfunction:
	# Execution of the filterdata-function will export another file, called 'SambaR_methods.txt', to the SambaR directory. That file contains a description of the methods.
	# sambarfunction:
	}

sambaroptions<-function()
	{
	optionslist			<- list()
	fileConn			<- file("SambaR_options.txt")
	optionslist[[1]]	<- args(getpackages)
	writeLines(optionslist[[1]],fileConn)
	close(fileConn)
	optionslist[[2]]	<- args(importdata)
	optionslist[[3]]	<- args(filterdata)
	optionslist[[4]]	<- args(findstructure)
	optionslist[[5]]	<- args(calcdistance)
	optionslist[[6]]	<- args(calcdiversity)
	optionslist[[7]]	<- args(selectionanalyses)
	optionslist			<<- optionslist
	}

#######################################################################################################




############ INSTALLATION OF PACKAGES #############

remove_all_packages<-function(doremove=FALSE)
	{
	# This function removes all user installed packages.
	# create a list of all installed packages
	ip 				<- as.data.frame(installed.packages())
	# if you use MRO, make sure that no packages in this library will be removed
	ip 				<- subset(ip, !grepl("MRO", ip$LibPath))
	# we don't want to remove base or recommended packages either:
	ip 				<- ip[!(ip[,"Priority"] %in% c("base", "recommended")),]
	# determine the library where the packages are installed
	path.lib 		<- unique(ip$LibPath)
	# create a vector with all the names of the packages you want to remove
	pkgs.to.remove <- as.vector(ip[,1])
	mypackages		<<- pkgs.to.remove
	mylibs			<<- path.lib
	if(doremove)
		{
		# remove the packages
		cat("Removing all user installed packages...",sep="\n")
		sapply(pkgs.to.remove, remove.packages, lib = path.lib)
		cat("All user installed packages removed.",sep="\n")
		}else{
		cat("Type 'mypackages' to see the list of names of user-installed packages.",sep="\n")	
		cat("To remove all these packages, execute:",sep="\n")
		cat("'remove_all_packages(doremove=TRUE)'",sep="\n")
		}
	}

removeoldpackages<-function(doremove=FALSE,myrepos='http://cran.us.r-project.org',keepbasepackages=FALSE)
	{
	pgdf			<- as.data.frame(old.packages(repos=myrepos))
	myoldpackages	<- as.vector(pgdf$Package)
	#
	if(keepbasepackages)
		{
		# if you use MRO, make sure that no packages in this library will be removed
		allpgdf			<- as.data.frame(installed.packages())
		mydf2 			<- subset(allpgdf,grepl("MRO", pgdf$LibPath))
		mymro			<- as.vector(mydf2$Package)
		pgdf			<- pgdf[!(myoldpackages %in% mymro),]
		myoldpackages	<- myoldpackages[!(myoldpackages %in% mymro)]
		#
		# we don't want to remove base or recommended packages either:
		mydf2			<- allpgdf[!(allpgdf[,"Priority"] %in% c("base", "recommended")),]
		mybase			<- as.vector(mydf2$Package)
		pgdf			<- pgdf[!(myoldpackages %in% mybase),]
		myoldpackages	<- myoldpackages[!(myoldpackages %in% mybase)]
		}
	# determine the library where the packages are installed:
	if("pcadapt" %in% myoldpackages)
		{
		if(packageDescription("pcadapt")$Version!="4.1.0")
			{
			# 19-3-2020: this is necessary because later versions want you to use PLINK for conversion from ped to bed.
			cat("WARNING: The PCadapt version on your computer is not 4.1.0.",sep="\n")
			cat("SambaR needs PCadapt version 4.1.0. or lower.",sep="\n")
			}
		pgdf			<- pgdf[myoldpackages!="pcadapt",]
		myoldpackages	<- myoldpackages[myoldpackages!="pcadapt"]
		}
	oldpackagesdf	<<- pgdf[myoldpackages!="pcadapt",]
	myoldpackages	<<- myoldpackages
	# remove
	if(doremove)
		{
		# remove the packages
		cat("Removing outdated packages...",sep="\n")
		sapply(myoldpackages,remove.packages)
		cat("All outdated packages removed.",sep="\n")
		cat("Type 'oldpackagesdf' or 'myoldpackages' to see the list of names of these outdated packages.",sep="\n")
		cat("Now run the getpackages function to install the most recent version of the removed packages.",sep="\n")
		}else{
		cat("Type 'oldpackagesdf' or 'myoldpackages' to see the list of names of outdated packages.",sep="\n")	
		cat("These packages can lead to errors when running the getpackages() function.",sep="\n")
		cat("To remove these packages, execute:",sep="\n")
		cat("'removeoldpackages(doremove=TRUE)'",sep="\n")
		cat("Afterwards run the getpackages function to install the most recent version of the removed packages.",sep="\n")
		}
	}

sambar_getoldpackage<-function(my_package="pcadapt",my_repos='http://cran.us.r-project.org',my_lib=NULL,silent=FALSE)
	{	
	# 06-05-2020: works currently for pcadapt only
	mypackage_nr		<- which(myrpackages$package==my_package)
	if(my_package %in% rownames(installed.packages()))
		{
		if(packageDescription("pcadapt")$Version!="4.1.0")
			{
			# 19-3-2020: this is necessary because later versions want you to use PLINK for conversion from ped to bed.
			cat("The PCadapt version on your computer is not the required version 4.1.0.",sep="\n")
			cat("SambaR will remove this version and install PCadapt 4.1.0 instead.",sep="\n")
			if("pcadapt"%in%(.packages()) == TRUE){detach("package:pcadapt", unload=TRUE)}
			remove.packages("pcadapt")
			}else{
			if(!silent){cat(paste("Package ",my_package," already installed.",sep=""),sep="\n")}
			myrpackages$installed[mypackage_nr]		<<- TRUE
			if(my_package %in% (.packages()) == FALSE)
				{
				if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
				library(my_package,character.only=TRUE)
				myrpackages$loaded[mypackage_nr]		<<- TRUE
				}else{
				myrpackages$loaded[mypackage_nr]		<<- TRUE
				}
			}
		}
	if(my_package %in% rownames(installed.packages()) == FALSE)
		{
		if(is.null(my_lib))
			{
			if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=my_repos)}		
			library("devtools")
			cat("Installing the dependencies of package PCadapt 4.1.0 (which is the version required by SambaR). If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the dependencies of the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("plotly" %in% rownames(installed.packages()) == FALSE) {install.packages("plotly",repos=my_repos)}
			if("robust" %in% rownames(installed.packages()) == FALSE) {install.packages("robust",repos=my_repos)}
			#if("vcfR" %in% rownames(installed.packages()) == FALSE) {install.packages("vcfR",repos=my_repos)}
			if("vcfR" %in% rownames(installed.packages()) == FALSE)
				{
				cat("PCadapt depends on the package vcfR. Unfortunately this package is not available from CRAN anymore as of Spring 2020.",sep="\n")
				cat("Therefore, if you want to use PCadapt, you have to first download the vcfR tarball (on Unix computers) and then execute in R a function similar to:",sep="\n") 	
				cat('install.packages("path/to/vcfR_1.11.0.tar.gz",repos=NULL,type="source"',sep="\n")
				return(cat("Alternatively, edit the mypackageslist.txt file and set the value of PCadapt and vcfR to FALSE in the do_install column, and then run the getpackages() function again.",sep="\n"))
				}
			if("mmapcharr" %in% rownames(installed.packages()) == FALSE) {install.packages("mmapcharr",repos=my_repos)}
			if("RSpectra" %in% rownames(installed.packages()) == FALSE) {install.packages("RSpectra",repos=my_repos)}
			if("rmio" %in% rownames(installed.packages()) == FALSE) {install.packages("rmio",repos=my_repos)}
			cat("Installing the package PCadapt 4.1.0 (which is the version required by SambaR).. If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("pcadapt" %in% rownames(installed.packages()) == FALSE){install_version('pcadapt',version='4.1.0',repos=my_repos,dependencies=FALSE)}
			myrpackages$installed[mypackage_nr]	<<- TRUE
			if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
			library(my_package,character.only=TRUE)
			myrpackages$loaded[mypackage_nr]		<<- TRUE
			}else{
			if("devtools" %in% rownames(installed.packages()) == FALSE) {install.packages("devtools",repos=my_repos,lib=my_lib)}		
			library("devtools")
			cat("Installing the dependencies of package PCadapt 4.1.0 (which is the version required by SambaR). If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the dependencies of the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("plotly" %in% rownames(installed.packages()) == FALSE) {install.packages("plotly",repos=my_repos,lib=my_lib)}
			if("robust" %in% rownames(installed.packages()) == FALSE) {install.packages("robust",repos=my_repos,lib=my_lib)}
			#if("vcfR" %in% rownames(installed.packages()) == FALSE) {install.packages("vcfR",repos=my_repos,lib=my_lib)}
			if("vcfR" %in% rownames(installed.packages()) == FALSE)
				{
				cat("PCadapt depends on the package vcfR. Unfortunately this package is not available from CRAN anymore as of Spring 2020.",sep="\n")
				cat("Therefore, if you want to use PCadapt, you have to first download the vcfR tarball (on Unix computers) and then execute in R a function similar to:",sep="\n") 	
				cat('install.packages("path/to/vcfR_1.11.0.tar.gz",repos=NULL,type="source"',sep="\n")
				return(cat("Alternatively, edit the mypackageslist.txt file and set the value of PCadapt and vcfR to FALSE in the do_install column, and then run the getpackages() function again.",sep="\n"))
				}
			if("mmapcharr" %in% rownames(installed.packages()) == FALSE) {install.packages("mmapcharr",repos=my_repos)}
			if("RSpectra" %in% rownames(installed.packages()) == FALSE) {install.packages("RSpectra",repos=my_repos)}
			if("rmio" %in% rownames(installed.packages()) == FALSE) {install.packages("rmio",repos=my_repos)}
			cat("Installing the package PCadapt 4.1.0 (which is the version required by SambaR). If you receive an error after this line, edit the mypackageslist.txt file and set values in the do_install and do_load columns to FALSE in the row of the package 'pcadapt' (and its dependencies).",sep="\n")  
			#cat("Installing the package PCadapt 4.1.0. If you receive an error after this line, rerun the getpackages function with the do_pcadapt flag set to FALSE (i.e.: getpackages(do_pcadapt=FALSE)).",sep="\n")  
			if("pcadapt" %in% rownames(installed.packages()) == FALSE){install_version('pcadapt',version='4.1.0',repos=my_repos,lib=my_lib,dependencies=FALSE)}
			myrpackages$installed[mypackage_nr]	<<- TRUE
			if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
			library(my_package,character.only=TRUE)
			myrpackages$loaded[mypackage_nr]		<<- TRUE
			}
		}
	}

sambar_getpackage<-function(my_package="car",my_repos='http://cran.us.r-project.org',my_lib=NULL,github_dir=NULL,silent=FALSE,noupdates=TRUE,doload=TRUE)
	{
	# INSTALL:
	if(length(my_package)>1)
		{
		return(cat("ERROR: two packages specified to my_package flag.",sep="\n"))
		}
	mypackage_nr		<- which(myrpackages$package==my_package)
	if(length(mypackage_nr)==0)
		{
		return(cat("ERROR: specified package is not present in SambaR's list of packages.",sep="\n"))
		}
	if(length(mypackage_nr)>1)
		{
		mypackage_nr	<- mypackage_nr[1]
		cat("WARNING: two numbers found. Package might be present multiple times in input list. Selecting first option only.",sep="\n")
		}
	if(my_package %in% rownames(installed.packages()) == FALSE) 
		{
		# IF PACKAGE IS NOT YET INSTALLED
		# INSTALL:
		if(!silent){cat(paste("Installing package ",my_package,"...",sep=""),sep="\n")}
		package_source	<- as.vector(myrpackages$source[mypackage_nr])
		if(is.null(package_source))
			{
			return(cat("ERROR: package_source is NULL.",sep="\n")) 
			}
		
		if(length(package_source)!=1)
			{
			mypackagesource		<<- package_source
			return(cat("ERROR: The length of package_source (saved in global environment mypackagesource) does not equal 1.",sep="\n")) 
			}
		if(package_source!="CRAN"&package_source!="Bioconductor"&package_source!="github")
			{
			return(cat("ERROR: package source should be either 'CRAN', 'Bioconductor' or 'github'.",sep="\n")) 
			}
		if(package_source=="CRAN")
			{
			if(is.null(my_lib))
				{
				install_attempt		<- tryCatch(install.packages(my_package,repos=my_repos), error=function(e) e, warning=function(w) w)
				#install_attempt	<- install.packages(my_package,repos=my_repos)
				}else{
				install_attempt		<- tryCatch(install.packages(my_package,repos=my_repos,lib=my_lib), error=function(e) e, warning=function(w) w)
				#install_attempt	<- install.packages(my_package,repos=my_repos,lib=my_lib)
				}
			}
		if(package_source=="Bioconductor")
			{
			if(is.null(my_lib))
				{
				install_attempt		<- tryCatch(BiocManager::install(my_package,suppressUpdates=noupdates), error=function(e) e, warning=function(w) w)
				if(all(install_attempt%in%c("BiocVersion",my_package)))	# needed because BiocManager returns the package argument
					{
					install_attempt	<- NULL
					}
				#install_attempt	<- try(BiocManager::install(my_package,suppressUpdates=noupdates))
				}else{
				install_attempt 	<- tryCatch(BiocManager::install(my_package,suppressUpdates=noupdates,lib=my_lib), error=function(e) e, warning=function(w) w)
				if(all(install_attempt%in%c("BiocVersion",my_package)))	# needed because BiocManager returns the package argument
					{
					install_attempt	<- NULL
					}
				#install_attempt	<- try(BiocManager::install(my_package,suppressUpdates=noupdates,lib=my_lib))
				}
			}
		if(package_source=="github")
			{
			if(is.null(github_dir))
				{
				cat("ERROR: no github directory specified.",sep="\n")
				}
			install_attempt 	<- tryCatch(install_github(github_dir,upgrade=FALSE), error=function(e) e, warning=function(w) w)
			if(all(install_attempt%in%c(my_package)))	# needed because install_github returns the package argument
				{
				install_attempt	<- NULL
				}
			#install_attempt 	<- try(install_github(github_dir,upgrade=FALSE))
			}
		# LOAD:
		#if(class(install_attempt)=="try-error")
		if(!is.null(install_attempt))
			{
			install_problems							<<- install_attempt
			myrpackages$installed[mypackage_nr]			<<- FALSE
			myrpackages$loaded[mypackage_nr]			<<- FALSE
			cat(paste("SambaR did NOT manage to install the package ",my_package," and will therefore not attempt to load this package.",sep=""),sep="\n")
			cat("Type 'install_problems' to see which error or warning SambaR encountered.",sep="\n")
			cat("In case the warning reads that the package is not available, and if you are using an older R version, it could be that installing the latest R version will solve the problem.",sep="\n") 
			}else{
			cat("Package succesfully installed.",sep="\n")
			myrpackages$installed[mypackage_nr]			<<- TRUE
			if(doload)
				{
				if(my_package %in% (.packages()) == FALSE)
					{
					if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
					library(my_package,character.only=TRUE)					# character.only=FALSE gives: Error in library(my_package) : there is no package called 'my_package'
					myrpackages$loaded[mypackage_nr]		<<- TRUE	
					}else{
					cat("Package already loaded.",sep="\n")
					myrpackages$loaded[mypackage_nr]		<<- TRUE
					}
				}else{
				if(my_package %in% (.packages()) == FALSE)
					{
					cat("Not loading package because flag 'doload' is set to FALSE.",sep="\n")
					myrpackages$loaded[mypackage_nr]			<<- FALSE
					}else{
					cat("Flag doload is set to FALSE but package is already loaded anyway.",sep="\n")
					myrpackages$loaded[mypackage_nr]			<<- TRUE
					}
				}
			}
		}else{
		# IF PACKAGE IS ALREADY INSTALLED
		if(!silent){cat(paste("Package ",my_package," already installed.",sep=""),sep="\n")}
		myrpackages$installed[mypackage_nr]	<<- TRUE
		if(doload)
			{
			# LOAD:
			if(my_package %in% (.packages()) == FALSE)
				{
				if(!silent){cat(paste("Loading package ",my_package,"...",sep=""),sep="\n")}
				load_attempt		<- tryCatch(library(my_package,character.only=TRUE), error=function(e) e)								# character.only=FALSE gives: Error in library(my_package) : there is no package called 'my_package'
				if(is.character(load_attempt))
					{
					load_attempt	<- NULL
					}
				# character.only=FALSE gives: Error in library(my_package) : there is no package called 'my_package'
				if(!is.null(load_attempt))
					{
					install_problems							<<- load_attempt
					myrpackages$loaded[mypackage_nr]			<<- FALSE
					cat(paste("SambaR did NOT manage to load the package ",my_package,".",sep=""),sep="\n")
					cat("Type 'install_problems' to see which error or warning SambaR encountered.",sep="\n")
					}else{
					myrpackages$loaded[mypackage_nr]			<<- TRUE	
					}
				}else{
				cat("Package already loaded.",sep="\n")
				myrpackages$loaded[mypackage_nr]			<<- TRUE
				}
			}else{
			if(my_package %in% (.packages()) == FALSE)
				{
				cat("Not loading package because flag 'doload' is set to FALSE.",sep="\n")
				myrpackages$loaded[mypackage_nr]			<<- FALSE
				}else{
				cat("Flag doload is set to FALSE but package is already loaded anyway.",sep="\n")
				myrpackages$loaded[mypackage_nr]			<<- TRUE
				}
			}
		}
	}

# 23-06-2022: originally called getpg()
# additional packages needed to create range maps
getshapepg<-function(myrepos='http://cran.us.r-project.org')
	{
	# note sure if all packages are really needed.
	if("gpclib" %in% rownames(installed.packages()) == FALSE) {install.packages("gpclib",repos=myrepos)}
	if("rgdal" %in% rownames(installed.packages()) == FALSE) {install.packages("rgdal",repos=myrepos)}
	if("rgeos" %in% rownames(installed.packages()) == FALSE) {install.packages("rgeos",repos=myrepos)}
	if("rjson" %in% rownames(installed.packages()) == FALSE) {install.packages("rjson",repos=myrepos)}
	if("GISTools" %in% rownames(installed.packages()) == FALSE) {install.packages("GISTools",repos=myrepos)}
	if("ggplot2" %in% rownames(installed.packages()) == FALSE) {install.packages("ggplot2",repos=myrepos)}
	if("ggmap" %in% rownames(installed.packages()) == FALSE) {install.packages("ggmap",repos=myrepos)}
	if("dismo" %in% rownames(installed.packages()) == FALSE) {install.packages("dismo",repos=myrepos)}
	cat("All required packages installed.",sep="\n")
	if("sp"%in%(.packages()) == FALSE){library(sp)}
	if("rworldmap"%in%(.packages()) == FALSE){library(rworldmap)}
	if("maptools"%in%(.packages()) == FALSE){library(maptools)}
	if("rgdal"%in%(.packages()) == FALSE){library(rgdal)}
	if("RColorBrewer"%in%(.packages()) == FALSE){library(RColorBrewer)}
	if("rjson"%in%(.packages()) == FALSE){library(rjson)}
	if("GISTools"%in%(.packages()) == FALSE){library(GISTools)}
	if("ggplot2"%in%(.packages()) == FALSE){library(ggplot2)}
	if("ggmap"%in%(.packages()) == FALSE){library(ggmap)}
	if("dismo"%in%(.packages()) == FALSE){library(dismo)}
	if("rgdal"%in%(.packages()) == FALSE){library("rgdal")}
	cat("All required packages loaded.",sep="\n")
	}

# depends on: sambar_getpackage and sambar_getoldpackage and getversions
getpackages<-function(myrepos='http://cran.us.r-project.org',mylib=NULL,noupdates=TRUE,silent=TRUE,do_halt=TRUE,onlybioconductor=FALSE)
	{
	if(getRversion()<'3.6.0')
		{
		if("car" %in% rownames(installed.packages()))
			{
			cat("WARNING: SambaR depends on the package 'car', which as of February 2020 can only be installed on R versions 3.6.0 or higher (due to the dependency 'pbkrtest').",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
			cat("However, you might still encounter errors because of other packages not being available for your R version.",sep="\n")
			cat("If so, install a newer R version (3.6.0 or newer) and try again.",sep="\n")
			}else{
			cat("ERROR: SambaR depends on the package 'car', which can only be installed on R versions 3.5.0 or higher.",sep="\n")
			cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
			cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
			cat("Therefore, you need to install a newer version of R (3.6.0 or newer) and run SambaR on this newer version.",sep="\n")
			return(cat("Dependencies of SambaR have NOT been loaded.",sep="\n"))
			}
		}
	if(file.exists("mypackageslist.txt"))
		{
		cat("Importing file 'mypackageslist.txt' from the directory:",sep="\n")
		cat(getwd(),sep="\n")
		myrpackages	<<- read.table("mypackageslist.txt",header=TRUE)
		if(!"do_load"%in%colnames(myrpackages))
			{
			cat("ERROR: SambaR version 1.03 and higher require the 'mypackageslist.txt' to contain the column 'do_load'.",sep="\n") 
			cat("Either remove or manually edit the existing 'mypackageslist.txt' file.",sep="\n")
			return(cat("Instruction for manually editing: the do_load values for the essential packages 'cli','Rcpp','fs','rlang','usethis','vctrs','carl','curl','colorspace','vegan','sf' and 'spdep' can/should be set to FALSE.",sep="\n"))
			}
		# 28_10_2021:
		pcadaptversion	<- myrpackages$required_version[myrpackages$package=="pcadapt"]
		if(pcadaptversion!="latest")
			{
			cat("ERROR: from 28-10-2021 onwards, SambaR no longer requires (and therefore no longer accepts) PCadapt version 4.1.0.")
			return(cat("Please set in the column 'required_version' in the file 'mypackageslist.txt' the value for PCadapt to 'latest', or simply remove the entire file.",sep="\n"))  
			}
		}else{
		cat("File called 'mypackageslist.txt' not present in directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("SambaR will attempt to install and load all packages (but only if not installed/loaded yet).",sep="\n")
		# to recreate vectors, use: write.csv(matrix(as.character(myrpackages$package),nrow=1),row.names=FALSE)
		mypackagesvec	<- c("cli","Rcpp","fs","rlang","usethis","vctrs","car","curl","colorspace","ape","scales","vegan","sf","spdep","adegenet","StAMPP","scatterplot3d","plot3D","zoo","processx","devtools","vioplot","graphics","gplots","RColorBrewer","migest","plyr","circlize","grid","gridGraphics","gridExtra","MASS","poppr","FactoMineR","factoextra","rworldmap","mapplots","VennDiagram","fsthet","PopGenome","bibtex","mnormt","psych","sp","raster","phangorn","seqinr","RcppEigen","gtools","plotly","robust","vcfR","pcadapt","detectRUNS","BiocManager","SNPRelate","LEA","qvalue","gdsfmt","XML","karyoploteR","OutFLANK","tess3r","IRanges","Biostrings","HybridCheck","inbreedR","admixtools")
		# 28_10_2021:
		#versionvec		<- c("latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","4.1.0","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest")
		versionvec		<- c("latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest","latest")
		sourcevec		<- c("CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","CRAN","Bioconductor","Bioconductor","Bioconductor","Bioconductor","CRAN","Bioconductor","github","github","Bioconductor","Bioconductor","github","CRAN","github")
		githubdirvec	<- c(NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,"whitlock/OutFLANK","bcm-uga/TESS3_encho_sen",NA,NA,"BenJWard/HybridCheck",NA,"uqrmaie1/admixtools")
		requiredvec		<- c("essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","essential","to_be_removed","essential","essential","essential","optional","optional","optional","optional","optional","optional","optional","essential","recommended","recommended","optional","optional","optional","optional","optional","optional","optional","optional","optional","optional","recommended","TBC","optional","TBC","optional","optional","optional","optional","recommended","recommended","recommended","recommended","optional","TBC","recommended","recommended","optional","optional","optional","optional","optional","optional","optional")
		whichfuncvec	<- c("all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","all_functions","to_be_removed","all_functions","all_functions","all_functions","additional_analysis","additional_analysis","additional_analysis","findstructure()","findstructure()","findstructure()","findstructure()","findstructure()","findstructure()","findstructure()","additional_analysis","additional_analysis","selectionanalyses()","selectionanalyses()","selectionanalyses()","importdata()","additional_analysis","additional_analysis","additional_analysis","additional_analysis","findstructure()","TBC","additional_analysis","TBC","selectionanalyses()","selectionanalyses()","selectionanalyses()","selectionanalyses()","calcdiversity","importdata()","findstructure()","findstructure()","selectionanalyses()","TBC","calcdiversity();calcdistance()","calcdiversity();calcdistance()","selectionanalyses()","additional_analysis","calcdistance()","calcdistance()","calcdistance()","calcdistance()","calcdistance()")
		analysistypevec	<- c("data_management","data_management","data_management","data_management","data_management","data_management","data_management","data_management","data_management","plotting","data_management","data_management","data_management","data_management","data_management","data_management","data_management","plotting","plotting","sliding_window_analyses","install_packages","to_be_removed","plotting","plotting","plotting","circosplots_geneflow","circosplots_geneflow","circosplots_geneflow","DAPC_plots","DAPC_plots","DAPC_plots","MDS","pcoa_tree_fst","CA","CA","geographical_maps","geographical_maps","Venn_diagrams","Venn_diagrams","Venn_diagrams","referencing","RDA","RDA","geographical_maps_TESS","geographical_maps_TESS","NJtree_plot","TBC","geographical_maps_TESS","TBC","pcadapt","pcadapt","pcadapt","pcadapt","Runs_of_homozygosity","install_bioconductor_packages","PCA","admixture_analysis","qvalue_for_OutFLANK","TBC","karyoplots","karyoplots","OutFLANK","geographical_maps_TESS","HybridCheck","HybridCheck","HybridCheck","Heterozygosity_fitness_correlations","admixtools_statistics")
		#
		do_load			<- rep(TRUE,length(mypackagesvec))
		do_load[1:9]	<- FALSE
		do_load[12:14]	<- FALSE
		#
		#myrpackages		<- data.frame("package"=mypackagesvec,"required_version"=versionvec,"number"=c(1:length(mypackagesvec)),"do_install"=TRUE,"do_load"=do_load,"installed"=NA,"loaded"=NA,"source"=sourcevec,"githubdir"=githubdirvec,"required"=requiredvec,"SambaR_function"=whichfuncvec,"analysis_type"=analysistypevec)
		myrpackages		<<- data.frame("package"=mypackagesvec,"required_version"=versionvec,"number"=c(1:length(mypackagesvec)),"do_install"=TRUE,"do_load"=do_load,"installed"=NA,"loaded"=NA,"source"=sourcevec,"githubdir"=githubdirvec,"required"=requiredvec,"SambaR_function"=whichfuncvec,"analysis_type"=analysistypevec)
		write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
		cat("SambaR exported the newly created file 'mypackageslist.txt'. You can have a look at this file to see which packages SambaR will attempt to install. The file is exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(any(!(as.vector(unique(myrpackages$source))%in%c("CRAN","Bioconductor","github"))))
		{
		return(cat("ERROR: package source should be either 'CRAN', 'Bioconductor' or 'github'.",sep="\n")) 
		}
	if(!is.null(mylib))
		{
		if(!mylib %in% .libPaths())
			{
			cat("Adding specified library directory (mylib argument) to .libPaths.",sep="\n") 
			.libPaths( c( mylib , .libPaths() ) )
			# 18-06-2020: this doesn't solve the problem because if you don't have root access you can not connect with installed packages in the root, and that will cause problems in the end
			}else{
			cat("Specified library directory (mylib argument) already present in .libPaths. No need to add.",sep="\n")
			}
		}
	npackages			<- nrow(myrpackages)
	if(!silent){cat("Installing and loading packages (if needed)...",sep="\n")}
	if(onlybioconductor)
		{
		cat("Installing Bioconductor packages only...",sep="\n")
		}
	for (my_package_nr in c(1:npackages))
		{
		mypackage			<- as.vector(myrpackages$package[my_package_nr])
		if(!silent){cat(mypackage,sep="\n")}
		mysource			<- as.vector(myrpackages$source[my_package_nr])
		if(!silent){cat(mysource,sep="\n")}
		installbool			<- as.vector(myrpackages$do_install[my_package_nr])
		loadbool			<- as.vector(myrpackages$do_load[my_package_nr])
		mypackageversion	<- as.vector(myrpackages$required_version[my_package_nr])
		if(!onlybioconductor)
			{
			if(!installbool)
				{
				cat(paste("Skipping installation of ", mypackage," because it is set to FALSE in the column 'do_install' of the file 'mypackageslist.txt'.",sep=""),sep="\n")
				myrpackages$installed[my_package_nr]	<<- FALSE
				myrpackages$loaded[my_package_nr]		<<- FALSE
				myrpackages$loaded[my_package_nr]		<<- FALSE
				}else{
				if(mypackageversion=="latest")
					{
					if(mysource=="github")
						{
						mygithubdir	<- as.vector(myrpackages$githubdir[my_package_nr])
						sambar_getpackage(my_package=mypackage,github_dir=mygithubdir,my_lib=mylib,doload=loadbool) 
						}else{
						sambar_getpackage(my_package=mypackage,my_repos=myrepos,my_lib=mylib,doload=loadbool) 
						}
					}else{
					if(mypackage=="pcadapt")
						{
						# cat("Running sambar_getoldpackage.",sep="\n")
						# sambar_getoldpackage(my_package="pcadapt",my_repos='http://cran.us.r-project.org',my_lib=mylib)	
						return(cat("As of 28_10_2021, no longer needed to install old version of PCadapt (v4.1.0). In the column 'required_version' of mypackageslist.txt, set the value for PCadapt to 'latest'.",sep="\n"))  
						}else{
						cat("Unfortunately SambaR does not yet offer the option to install old versions of R package other than for pcadapt (4.1.0).",sep="\n")
						}
					}
				#if(do_halt&myrpackages$loaded[my_package_nr]==FALSE)
				if(do_halt&myrpackages$installed[my_package_nr]==FALSE)
					{
					cat("",sep="\n")
					write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
					cat(paste("ERROR: SambaR did NOT manage to install/load the package ",mypackage," and therefore also did not attempt to install/load remaining packages.",sep=""),sep="\n")
					cat("How to solve this problem?",sep="\n")
					if(mysource=="Bioconductor")
						{
						cat("The package which SambaR did not manage to install is a Bioconductor package.",sep="\n")
						cat("SambaR might interfere with the Bioconductor installation process. To solve this problem, follow the these instructions (also explained in the SambaR manual):",sep="\n")
						cat("Close your R session and start a new R session.",sep="\n")
						cat("Do not change the working directory, do not load SambaR, and do not attempt to run the getpackages function.",sep="\n")
						cat("Instead run the following two commands:",sep="\n")
						cat('if(!requireNamespace("BiocManager", quietly = TRUE)){install.packages("BiocManager")}',sep="\n")
						cat('BiocManager::install(c("gdsfmt","SNPRelate","LEA","qvalue","XML","karyoploteR", "IRanges","Biostrings"),update=FALSE)',sep="\n")
						cat("After succesfull completion, change the working directory, load SambaR, and rerun the getpackages function.",sep="\n")
						}else{
						cat(paste("SambaR exported a file called 'mypackageslist.txt' to the directory: ",getwd(),".",sep=""),sep="\n")
						cat("Observe this file in a plain text editor (e.g. in Notepad). The columns 'installed' and 'loaded' indicate which packages have not been installed and/or loaded yet.",sep="\n")
						cat("All packages which are marked as 'essential' in the column 'required' need to be installed (not necessarily loaded), otherwise SambaR will run into errors sooner or later.",sep="\n")
						cat("Other packages are not strictly needed. (If they are not installed (and loaded), SambaR will omit the analyses which depend on these packages.)",sep="\n")
						cat("To prevent SambaR from trying to install a certain package, change it's value in the 'do_install' column from TRUE to FALSE.",sep="\n") 
						cat("Save the editted file 'mypackageslist.txt' in the working directory and rerun the getpackages() function.",sep="\n")
						cat("Note that other packages might depend on this package, and in that case for those packages you will also have to set the 'do_install' value to FALSE.",sep="\n")  
						if(myrpackages$required[my_package_nr]=="essential")
							{
							cat(paste("However, the package ",mypackage," is essential and therefore this solution might lead to other errors sooner or later.",sep=""),sep="\n")
							}else{
							cat(paste("The package ",mypackage," is not essential and therefore this might indeed be a suitable workaround for now.",sep=""),sep="\n")
							}
						cat("",sep="\n")
						getversions()
						return(cat("",sep="\n"))
						}
					}
				}
			}else{
			# only install Bioconductor packages:
			if(mysource=="Bioconductor")
				{
				if(!installbool)
					{
					cat(paste("Skipping installation of ", mypackage," because it is set to FALSE in the column 'do_install' of the file 'mypackageslist.txt'.",sep=""),sep="\n")
					myrpackages$installed[my_package_nr]	<<- FALSE
					myrpackages$loaded[my_package_nr]		<<- FALSE
					myrpackages$loaded[my_package_nr]		<<- FALSE
					}else{
					sambar_getpackage(my_package=mypackage,my_repos=myrepos,my_lib=mylib,doload=loadbool) 
					}
				if(do_halt&myrpackages$installed[my_package_nr]==FALSE)
					{
					cat("",sep="\n")
					write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
					cat(paste("ERROR: SambaR did NOT manage to install/load the package ",mypackage," and therefore also did not attempt to install/load remaining packages.",sep=""),sep="\n")
					cat("How to solve this problem?",sep="\n")
					cat(paste("SambaR exported a file called 'mypackageslist.txt' to the directory: ",getwd(),".",sep=""),sep="\n")
					cat("Observe this file in a plain text editor (e.g. in Notepad). The columns 'installed' and 'loaded' indicate which packages have not been installed and/or loaded yet.",sep="\n")
					cat("All packages which are marked as 'essential' in the column 'required' need to be installed (not necessarily loaded), otherwise SambaR will run into errors sooner or later.",sep="\n")
					cat("Other packages are not strictly needed. (If they are not installed (and loaded), SambaR will omit the analyses which depend on these packages.)",sep="\n")
					cat("To prevent SambaR from trying to install a certain package, change it's value in the 'do_install' column from TRUE to FALSE.",sep="\n") 
					cat("Save the editted file 'mypackageslist.txt' in the working directory and rerun the getpackages() function.",sep="\n")
					cat("Note that other packages might depend on this package, and in that case for those packages you will also have to set the 'do_install' value to FALSE.",sep="\n")  
					if(myrpackages$required[my_package_nr]=="essential")
						{
						cat(paste("However, the package ",mypackage," is essential and therefore this solution might lead to other errors sooner or later.",sep=""),sep="\n")
						}else{
						cat(paste("The package ",mypackage," is not essential and therefore this might indeed be a suitable workaround for now.",sep=""),sep="\n")
						}
					cat("",sep="\n")
					getversions()
					return(cat("",sep="\n"))
					}
				}
			
			}
		}
	cat("DONE",sep="\n")
	cat("Reminder: if after this line you receive the error 'cannot open file 'mypackageslist.txt': Permission denied', the file 'mypackageslist.txt' is very likely open in a file viewer (like Excel).",sep="\n")  
	write.table(myrpackages,"mypackageslist.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
	#mybool					<- myrpackages$loaded
	mybool					<- myrpackages$installed
	mybool[is.na(mybool)]	<- FALSE
	mybool					<- mybool[myrpackages$do_install]
	# create table which lists R versions:
	pgversions				<- getversions(return_object=TRUE)
	pcadaptversion			<- pgversions$version[pgversions$package=="pcadapt"]
	if(any(!mybool))
		{
		cat("",sep="\n")
		cat("WARNING: SambaR did NOT manage to install and load all requested packages. Do NOT attempt yet to import your data.",sep="\n")
		cat("How to solve this problem?",sep="\n")
		cat(paste("SambaR exported a file called 'mypackageslist.txt' to the directory: ",getwd(),".",sep=""),sep="\n")
		cat("Observe this file in Excel or by typing on the R command line: myrpackages. The columns 'installed' and 'loaded' indicate which packages have not been installed and/or loaded yet.",sep="\n")
		cat("All packages which are marked as 'essential' in the column 'required' need to be installed and loaded, otherwise SambaR will run into errors sooner or later.",sep="\n")
		cat("Other packages are not strictly needed.  (If they are not installed and loaded, SambaR will omit the analyses which depend on these packages.)",sep="\n")
		cat("To prevent SambaR from trying to install a certain package, change it's value in the 'do_install' column from TRUE to FALSE.",sep="\n") 
		cat("Save the editted file 'mypackageslist.txt' in the working directory and rerun the getpackages() function.",sep="\n")
		cat("",sep="\n")
		}else{
		cat("All requested packages succesfully installed (and optionally loaded) :-)",sep="\n")
		# 28_10_2021:
		if(pcadaptversion=="4.1.0")
			{
			cat("However, currently an old version of PCadapt (4.1.0) is installed. SambaR no longer requires and therefore no longer accepts this version.")
			cat("Please remove the mypackageslist.txt file as well as the PCadapt installation - using the command: remove.packages('pcadapt') -, restart the R session, and afterwards rerun the getpackages function.",sep="\n")
			cat("This will install the latest version of PCadapt.",sep="\n") 
			return(cat("Depending on your current version of Rcpp, the selectionanalyses might run into an error related to Rcpp. If so, remove Rcpp as well (and then reinstall with the getpackages function.",sep="\n"))
			}
		if(onlybioconductor)
			{
			cat("Rerun the getpackages function with the flag 'onlybioconductor' set to FALSE.",sep="\n")
			}else{
			cat("You can proceed with importing your data using the importdata() or genlight2sambar() function.",sep="\n")
			}
		}
	}	

#################################################################










################## IMPORT DATA ###################


# import biallelic data from PLINK raw format:
importdata<-function(inputprefix=NULL,sumstatsfile=FALSE,snpinfofile=NULL,samplefile=NULL,vcfsamplefile=NULL,allow_edit=FALSE,geofile=NULL,depthfile=FALSE,poolsfile=NULL,nchroms=NULL,namechars=15,colourvector=NULL,popcol_by_alphabetical_order_popname=TRUE,popnchars=12,silent=TRUE,heplot=TRUE,domap=TRUE,qcplot=TRUE,do_citations=TRUE,dosoftwarecheck=FALSE,acceptalleles=FALSE,legend_cex=0.75,reorder_snps=TRUE,pop_order=NULL,geomap_thres=-15,geomap_cex=2)
	{
	# poolsfile: Name of optional input file (default is NULL) with the names of the sequencing library pool names of the samples. 
	# Input file should contain two tab-separated columns called ‘sample’ and ‘pool’. Sample names in the poolsfile should be identical to sample names in PED-file. 
	# The information in the poolsfile will in a subsequent step be used to create plots with show data quality per library pool. 
	#
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	options(scipen=999)		# 08-04-2020: to prevent that scaffold 900000 is renamed 9e+05
	cat("Importing data from the directory:",sep="\n")
	cat(getwd(),sep="\n")
	if(!"adegenet"%in%(.packages()))
		{
		cat("ERROR: 'adegenet' package (and likely other required packages) has not been installed and/or loaded yet. Did you run the getpackages() function?",sep="\n")
		return(cat("Note that the getpackages() function needs to complete without errors before you can proceed to importing the data, because sooner or later you will run into errors.",sep="\n"))
		}
	if(dosoftwarecheck)
		{
		# other software not present:
		mysoftwares			<- c("ade4","adegenet","ape","bibtex","circlize","colorspace","curl","devtools","fsthet","gdsfmt","gplots","grid","gridExtra","gridGraphics","LEA","mapplots","MASS","migest","OutFLANK","pcadapt","pegas","plot3D","plyr","poppr","qvalue","RcppEigen","RColorBrewer","rworldmap","scales","scatterplot3d","SNPRelate","StAMPP","stats","tess3r","vegan","vioplot","zoo") 
		if("bibtex" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="bibtex"]
			cat("WARNING: non-essential R package bibtex not installed.",sep="\n")
			}
		if("OutFLANK" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="OutFLANK"]
			cat("WARNING: non-essential R package OutFLANK not installed.",sep="\n")
			}else{
			if(!"OutFLANK" %in% (.packages()))
				{
				cat("WARNING: non-essential R package OutFLANK installed but not loaded.",sep="\n")
				mysoftwares		<- mysoftwares[mysoftwares!="OutFLANK"]
				}
			}
		if("vioplot" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="vioplot"]
			cat("WARNING: non-essential R package vioplot not installed.",sep="\n")
			}else{
			if(!"vioplot" %in% (.packages()))
				{
				cat("WARNING: non-essential R package vioplot installed but not loaded.",sep="\n")
				mysoftwares		<- mysoftwares[mysoftwares!="vioplot"]
				}
			}
		if("pcadapt" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="pcadapt"]
			cat("WARNING: non-essential R package pcadapt not installed.",sep="\n")
			}
		if("tess3r" %in% rownames(installed.packages()) == FALSE)
			{
			mysoftwares		<- mysoftwares[mysoftwares!="tess3r"]
			cat("WARNING: non-essential R package tess3r not installed.",sep="\n")
			}
		mybool	<- !(mysoftwares %in% (.packages()))
		mybool2	<- !(mysoftwares %in% rownames(installed.packages()))
		if(any(mybool))
			{
			if(any(mybool2))
				{
				cat("ERROR: some packages are not yet installed.",sep="\n")
				packages_notinstalled	<<- as.vector(mysoftwares[mybool2])
				packages_notloaded		<<- as.vector(mysoftwares[mybool]) 
				cat("To see the list of packages which still not to be installed, type: packages_notinstalled.",sep="\n")
				cat("To see the list of packages which still not to be loaded, type: packages_notloaded.",sep="\n")
				}else{
				cat("ERROR: all packages are installed, but one or more packages are not yet loaded.",sep="\n") 
				packages_notloaded		<<- as.vector(mysoftwares[mybool]) 
				cat("To see the list of packages which still not to be loaded, type: packages_notloaded.",sep="\n")
				}
			cat("First run or rerun the getpackages() function and make sure it finishes without errors (stating: 'ALL PACKAGES SUCCESSFULLY LOADED').",sep="\n")
			return(cat("Unfortunately the getpackages() function needs to complete without errors before you can proceed to importing the data, otherwise sooner or later you will run into errors.",sep="\n"))
			}
		}
	if(is.null(inputprefix))
		{
		return(cat("ERROR: provide the prefix of the input RAW file to the inputprefix flag.",sep="\n"))
		}
	if(!file.exists(paste(inputprefix,"raw",sep=".")))
		{
		cat(paste("ERROR: SambaR couldn't find a file called '",inputprefix,".raw' in the working directory.",sep=""),sep="\n")
		cat("Did you specify the correct prefix?",sep="\n")
		cat("Did you set the right working directory using the setwd() function?",sep="\n")
		cat("And did you run PLINK to convert PED/MAP to RAW/BIM files?",sep="\n") 
		return(cat("See manual for further details.",sep="\n"))
		}
	if(!file.exists(paste(inputprefix,"bim",sep=".")))
		{
		cat(paste("ERROR: SambaR couldn't find a file called '",inputprefix,".bim' in the working directory.",sep=""),sep="\n")
		cat("Did you set the right working directory using the setwd() function?",sep="\n")
		cat("And did you run PLINK to convert PED/MAP to RAW/BIM files?",sep="\n") 
		return(cat("See manual for further details.",sep="\n"))
		}
	if(sumstatsfile)
		{
		if(!file.exists("sumstats.tsv"))
			{
			cat("ERROR: SambaR couldn't find a file called 'sumstats.tsv' in the working directory.",sep="\n")
			return(cat("Either set the flag sumstatsfile to FALSE or make sure the file 'sumstats.tsv' is present (see manual for further details).",sep="\n"))
			}
		}
	if(!is.null(vcfsamplefile))
		{
		cat("ERROR: the 'vcfsamplefile' flag has been depreciated and replaced by the 'samplefile' flag.",sep="\n")
		return(cat(paste('So try again like this: importdata(samplefile="',vcfsamplefile,'")',sep=''),sep='\n'))
		}
	if(!is.null(samplefile))
		{
		if(!file.exists(samplefile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",samplefile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag samplefile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}else{
		cat("No samplefile provided. SambaR will infer population names from the PED-file.",sep="\n")
		}		
	if(!is.null(geofile))
		{
		if(!file.exists(geofile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",geofile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag geofile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(!is.null(poolsfile))
		{
		if(!file.exists(poolsfile))
			{
			cat(paste("ERROR: SambaR couldn't find a file called",poolsfile,"in the working directory.",sep=" "),sep="\n")
			return(cat("Either set the flag poolsfile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
			}
		}
	if(depthfile)
		{
		inddepthfile	<- paste(inputprefix,"idepth",sep=".") 
		if(!(file.exists("out.idepth")|file.exists(inddepthfile)))
			{
			cat(paste("ERROR: SambaR couldn't find a file called 'out.idepth' or '",inddepthfile,"' in the working directory.",sep=""),sep="\n")
			return(cat("Either set the flag depthfile to FALSE or make sure the file 'out.idepth' is present. See manual for more details.",sep="\n"))
			}
		snpdepthfile	<- paste(inputprefix,"ldepth.mean",sep=".") 
		if(!(file.exists("out.ldepth.mean")|file.exists(snpdepthfile)))
			{
			cat(paste("ERROR: SambaR couldn't find a file called 'out.ldepth.mean' or '",snpdepthfile,"' in the working directory.",sep=""),sep="\n")
			return(cat("Either set the flag depthfile to FALSE or make sure the file 'out.ldepth.mean' is present. See manual for more details.",sep="\n"))
			}
		}
	#
	# define colours:
	defaultcolours				<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","limegreen","gray80","steelblue3","gray40","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	# 30-08-2020: new default colours:
	# defaultcolours			<- c("mediumblue","darkred","steelblue3","grey50","deepskyblue1","grey20","darkorchid4","#654321","midnightblue","ivory2","#009595","darkgreen","greenyellow","indianred1","orange","lavenderblush3","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours	
		}
	mysambarcolours		<- colourvector
	#
	# create genlight:
	# sambarfunction_importdata:
	##### IMPORT DATA #####
	# sambarfunction_importdata:
	mygenlight 			<<- read.PLINK((paste(inputprefix,"raw",sep=".",collapse = NULL)),parallel=FALSE)
	if(is.null(samplefile))
		{
		if(any(grepl("_",pop(mygenlight))))
			{
			if(allow_edit)
				{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
				mypops			<- as.character(pop(mygenlight))
				pop(mygenlight)	<<- gsub("_","",mypops)
				}else{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("To solve this issue, you can choose any of the following three options:",sep="\n")
				cat("Option 1: Edit population names in the PED-file, convert PED/MAP to raw/bim using PLINK, and afterwards rerun the importdata() function.",sep="\n")
				cat("Option 2: Create a sample file as explained in the manual (e.g. called 'popfile.txt') and afterwards run: importdata(samplefile='popfile.txt').",sep="\n")
				return(cat("Option 3: Allow SambaR to remove underscores from population names by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		if(any(nchar(as.character(pop(mygenlight)))>popnchars))
			{
			if(allow_edit)
				{
				cat("WARNING: Because of plot margins, by default SambaR does by default not accept population names which contain more than 10 characters (or any other value defined to popnchars flag).",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will truncate population names (if longer than 10 characters) and continue.",sep="\n")
				mypops		<- as.character(pop(mygenlight))
				mypops		<- ifelse(nchar(mypops)>popnchars,substr(mypops,1,popnchars),mypops)
				pop(mygenlight)	<<- mypops
				}else{
				cat("ERROR: Because of plot margins, by default SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("To solve this issue, you can choose any of the following four options:",sep="\n")
				cat("Option 1: Rerun the importdata function with another value for popnchars (which by default is set to 10). Some output plots might, as a result, not fully display the population name.",sep="\n")
				cat("Option 2: Edit population names in the PED-file, convert PED/MAP to raw/bim using PLINK, and afterwards rerun the importdata() function.",sep="\n")
				cat("Option 3: Create a sample file as explained in the manual (e.g. called 'popfile.txt') and afterwards run: importdata(samplefile='popfile.txt').",sep="\n")
				return(cat("Option 4: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		mynind	<- as.vector(table(as.character(pop(mygenlight))))
		#if(min(mynind)<2)
		#	{
		#	if(allow_edit)
		#		{
		#		cat("WARNING: SambaR does not accept populations consisting of 1 sample only.",sep="\n")
		#		cat("Because you set the flag allow_edit to TRUE, SambaR will assign all individuals to the same population (pop1).",sep="\n")
		#		pop(mygenlight)	<<- as.factor(rep("pop1",length(pop(mygenlight))))
		#		}else{
		#		return(cat("ERROR: SambaR does not accept populations consisting of 1 sample only.\nPlease either set to flag allow_edit to TRUE or alternatively edit population names (in either PED file or samplefile) and then rerun the importdata function. \nIf you make changes in the PED-file, do not forget to convert PED/MAP to raw/bim.",sep="\n"))
		#		}
		#	}
		}
	#
	# create snps dataframe:
	cat("Creating snps dataframe...",sep="\n")
	snps 				<<- read.table((paste(inputprefix,"bim",sep=".",collapse = NULL)))
	if(ncol(snps)!=6)
		{
		cat("ERROR: number of columns in input BIM-file is not equal to 6.",sep="\n")
		cat("The BIM-file should contain six columns (without header): chrom, snpname, morgan, position, minor allele, and major allele.",sep="\n")  
		cat("If your BIM-file currently has 5 columns and the first column (chromosome/scaffold name) is missing, this might be because the MAP-file contains at the first column only zero's.",sep="\n")
		cat("If this is indeed the case, redo the conversion from MAP to BIM using as input a map with non-zero's value in the first column.",sep="\n")
		return(cat("Make sure that the BIM-file contains all required columns (not more, not less), and only then try importing the data again.",sep="\n")) 
		}
	if(nrow(snps)!=ncol(mygenlight))
		{
		return(cat("ERROR: number of rows in BIM-file does not correspond with number of SNPs in genlight object. Prior to converting to RAW/BIM, do the number of columns in the PED-file correspond to the number of rows in the MAP-file?",sep="\n")) 
		}
	colnames(snps) 		<<- c("chr","name","morgan","pos","minor","major")
	if(is.null(mygenlight@loc.names))
		{
		cat("WARNING: genlight object does not contain loc.names slot. Setting equal to data colnames.",sep="\n") 
		mygenlight@loc.names	<<- colnames(as.matrix(mygenlight))
		}
	snps$genlightname	<<- mygenlight@loc.names
	snps$nr				<<- c(1:nrow(snps))
	if(any(is.na(snps$chr)))
		{
		return(cat("ERROR: NA-value(s) present in snps$chr column. Please check the first column of the BIM-file and remove/replace NA-values. Afterwards rerun the importdata function.",sep="\n"))	
		}
	if(is.logical(snps$minor))
		{
		# addition 15-06-2021
		cat("WARNING: snps$minor (fifth column of input bim file) is imported as class 'logical' (TRUE or FALSE), likely because all values are set to 'T'. Resetting to 'T'.",sep="\n")
		snps$minor		<<- NULL
		snps$minor		<<- "T"
		}
	if(is.logical(snps$major))
		{
		# addition 15-06-2021
		cat("WARNING: snps$major (sixth column of input bim file) is imported as class 'logical' (TRUE or FALSE), likely because all values are set to 'T'. Resetting to 'T'.",sep="\n")
		snps$major		<<- NULL
		snps$major		<<- "T"
		}
	if(any(is.na(snps$genlightname)))
		{
		return(cat("ERROR: NA-values in second column of BIM-file.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(all(snps$name=="."))
		{
		cat("WARNING: all snp names (second column of MAP and BIM files are equal to '.'), which SambaR does not accept. Replacing with SNP1, SNP2, etc.",sep="\n")
		snps$name		<<- paste("SNP",c(1:nrow(snps)),sep="")
		}
	if(any(snps$name=="."))
		{
		return(cat("ERROR: one or more snp names (second column of MAP and BIM files are equal to '.'), which SambaR does not accept. Please edit and try again.",sep="\n"))
		}
	if(length(as.vector(unique(snps$chr)))==1)
		{
		cat("WARNING: Only 1 chromosome/contig specified.",sep="\n")
		}
	if(any(duplicated(snps$name)))
		{
		cat("WARNING: input bim/map file contains duplicated SNP names. Adding numbers to make them unique, in order to avoid errors downstream.",sep="\n")
		snps$name_old	<<- snps$name
		snps$name		<<- paste(snps$name,c(1:nrow(snps)),sep="_")
		}
	any(duplicated(mygenlight@loc.names))
		{
		cat("WARNING: input raw/ped file contains duplicated SNP names. Adding numbers to make them unique, in order to avoid errors downstream.",sep="\n")
		#
		snpnames			<- paste(mygenlight@loc.names,c(1:nrow(snps)),sep="_")
		indnames			<- mygenlight$ind.names
		popnames			<- pop(mygenlight)
		#
		mymatrix			<- as.matrix(mygenlight)
		colnames(mymatrix)	<- snpnames
		mygenlight			<<- as.genlight(mymatrix)
		#if(length(unique(as.vector(popnames)))!=nrow(mymatrix))
		#	{
			mygenlight@pop	<<- popnames
		#	}
		mygenlight@ind.names<<- indnames
		mygenlight@loc.names<<- snpnames
		snps$genlightname	<<- snpnames
		}
	if(!silent){cat("Assigning index based on length of chromosomes...",sep="\n")}
	mychrs				<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
	mychrs2				<- mychrs[order(-mychrs$x),]
	mychrs2$chr2		<- c(1:nrow(mychrs2))
	colnames(mychrs2)	<- c("chr","chrlength","chr2")
	mychrs2$chrcol		<- ifelse(mychrs2$chr2%%2==0,"black","grey40")
	snps				<<- merge(snps,mychrs2,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(colnames(as.matrix(mygenlight))!=snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Counting number of SNPs per scaffold...",sep="\n")}
	myn					<- table(snps$chr)
	myndf				<- data.frame("chr"=names(myn),"nsnps"=as.vector(myn))
	snps				<<- merge(snps,myndf,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#
	# 11-03-2020: newer versions of STACKs add ":+" and ":-" to SNP names (forward/reverse). For some applications we need to get rid of those:
	# To make matters worse, snps which occur on chromosome 7 position 122, are encoded as 7:123. So plus 1. (This problem occurs for both :+ and :- SNPs). 
	if(length(grep("\\+",snps$name))>0)
		{
		cat("Removing ':+' and ':-' from SNP names...",sep="\n")
		snps$strand		<<- NA
		myforward		<- grep("\\+",snps$name)
		myreverse		<- grep("\\-",snps$name)
		snps$strand[myforward]	<<- "forward"
		snps$strand[myreverse]	<<- "reverse"
		snps$name3		<<- NA
		# forward:
		tempname		<- gsub("\\:\\+","",snps$name[myforward])
		tempname2		<- gsub("\\:","_",tempname)
		# now we need to subtract 1 from position:
		for(j in c(1:length(tempname2)))
			{
			mylocus		<- as.numeric(strsplit(tempname2[j],"_")[[1]][1])
			mypos		<- as.numeric(strsplit(tempname2[j],"_")[[1]][2])
			mypos		<- mypos-1
			tempname2[j]<- paste(mylocus,mypos,sep="_")
			}
		snps$name3[myforward]	<<-  tempname2
		# same for reverse:
		tempname		<- gsub("\\:\\-","",snps$name[myreverse])
		tempname2		<- gsub("\\:","_",tempname)
		# now we need to subtract 1 from position:
		for(j in c(1:length(tempname2)))
			{
			mylocus		<- as.numeric(strsplit(tempname2[j],"_")[[1]][1])
			mypos		<- as.numeric(strsplit(tempname2[j],"_")[[1]][2])
			mypos		<- mypos-1
			tempname2[j]<- paste(mylocus,mypos,sep="_")
			}
		snps$name3[myreverse]	<<-  tempname2
		}else{
		snps$strand		<<- "unknown"
		snps$name3		<<- snps$name
		}
	if(any(snps$minor=="0"))
		{
		monofilter	<- snps$minor=="0"
		nmono		<- length(monofilter[monofilter])
		nloci		<- nrow(snps)
		cat(paste("WARNING: ",nmono," non-polymorphic sites (out of ",nloci," sites) present in inputfile. SambaR will ignore them.",sep=""),sep="\n")
		monolist	<- snps$name[monofilter]
		write.table(monolist,"monomorphicsites.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
		cat("A file called 'monomorphicsites.txt' has been written to the working directory.",sep="\n")
		}
	if(!sumstatsfile&!any(snps$chr!=0))	# if no info in first column
		{
		if(any(snps$pos!=0))			# if info in the fourth column	
			{
			cat("ERROR: The input bim file has zero's only in the first column (contig) but non-zero's in the fourth column (position).",sep="\n")	
			cat("Either both columns should contain zero's (i.e. denovo snpcalling) or both columns should contain non-zero's (i.e. refmap snpcalling).",sep="\n")
			cat("As mentioned in the SambaR manual, if you convert from vcf to PED/MAP format, the first column of your map file will likely contain zero's only.",sep="\n") 
			cat("To solve that problem, you can execute the following command on the Linux command line (and afterwards convert again to raw/bim):",sep="\n")
			cat("cut -f2 yourfile.map | cut -f1 -d ':' > mycontigs.txt && cut -f2,3,4 yourfile.map > mymap.txt && paste mycontigs.txt mymap.txt > yourfile.map && rm mycontigs.txt mymap.txt",sep="\n")   
			cat("Alternatively, if the map file does have non-zero's in the the first column, then something went wrong during the conversion from ped/map to raw/bim (see SambaR manual).",sep="\n")
			cat("If so, try redoing the conversion (using PLINK, see Sambar manual), or edit the first and fourth column in the input bim file yourself (e.g. in Excel).",sep="\n")
			}else{
			cat("WARNING: No positional information found in first and fourth column of bim file (i.e. zero's only).",sep="\n")
			cat("If you generated your SNP data with a denovo pipeline, this is correct.",sep="\n")
			cat("If you generated your SNP data with a refmap pipeline, then why is this information lacking?",sep="\n")
			}
		}
	myposmax	<- max(snps$pos)
	if(!sumstatsfile&any(snps$chr!=0)&myposmax<500)
		{
		cat(paste("WARNING: According to information in map-file, the snps are positioned at maximum",myposmax,"bp.",sep=" "),sep="\n")
		cat("Hence, SambaR will assume that the information in the second column of your mapfile refers to read positions rather than contig/chromosome positions.",sep="\n")	
		}
	#	
	# addition 29-04-2021, to prevent error: 'encountered unexpected allele' which happens when snps$minor is a factor with 1,2,3,4 values 
	if(is.factor(snps$minor))
		{
		minorvec		<- as.character(snps$minor)
		if(any(c("A","C","T","G")%in%minorvec))
			{
			cat("Converting snps$minor factor to character vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- minorvec
			}else{
			cat("Converting snps$minor factor to integer vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- as.integer(minorvec)
			}
		}else{
		cat("snps$minor not factor class.",sep="\n")
		}
	if(is.factor(snps$major))
		{
		majorvec		<- as.character(snps$major)
		if(any(c("A","C","T","G")%in%majorvec))
			{
			cat("Converting snps$major factor to character vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- majorvec
			}else{
			cat("Converting snps$major factor to integer vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- as.integer(majorvec)
			}
		}else{
		cat("snps$major not factor class.",sep="\n")
		}
	#
	snps$minor[snps$minor==0]	<<- NA	# In case data is non-polymorphic
	myalleles	<- as.vector(unique(snps$minor))
	if(any(is.na(myalleles)))
		{
		cat("WARNING: non-defined allele (NA or 0) present in bim-file.",sep="\n")
		myalleles	<- myalleles[!is.na(myalleles)]
		}
	#
	if(is.integer(snps$minor)|is.numeric(snps$minor))
		{
		if(any(myalleles!=1&myalleles!=2&myalleles!=3&myalleles!=4))
			{
			myalleles	<<- myalleles
			cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 (integer) or A,C,T,G. You can observe the alleles by typing 'myalleles'.",sep="\n")
			cat("Did you filter out indels? If not, you can use, for example, bcftools (outside of R environment) to do so, using the following command:",sep="\n")	
			return(cat("BCFTOOLS view --threads 2 --min-alleles 2 --max-alleles 2 --exclude-types indels -O z input.vcf.gz -o input.biallelicSNPs.vcf.gz.",sep="\n"))
			}
		snps$minor2										<<- NA
		snps$minor2[snps$minor==1&!is.na(snps$minor)]	<<- "A"
		snps$minor2[snps$minor==2&!is.na(snps$minor)]	<<- "C"
		snps$minor2[snps$minor==3&!is.na(snps$minor)]	<<- "G"
		snps$minor2[snps$minor==4&!is.na(snps$minor)]	<<- "T"
		}else{
		if(is.character(snps$minor))
			{
			if(any(myalleles!="A"&myalleles!="C"&myalleles!="G"&myalleles!="T"))
				{
				myalleles	<<- myalleles
				return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 or A,C,T,G (character). You can observe the alleles by typing 'myalleles'.",sep="\n")) 
				cat("Did you filter out indels? If not, you can use, for example, bcftools (outside of R environment) to do so, using the following command:",sep="\n")	
				return(cat("BCFTOOLS view --threads 2 --min-alleles 2 --max-alleles 2 --exclude-types indels -O z input.vcf.gz -o input.biallelicSNPs.vcf.gz.",sep="\n"))
				}
			snps$minor2										<<- snps$minor
			snps$minor										<<- NA
			snps$minor[snps$minor2=="A"&!is.na(snps$minor2)]<<- 1
			snps$minor[snps$minor2=="C"&!is.na(snps$minor2)]<<- 2
			snps$minor[snps$minor2=="G"&!is.na(snps$minor2)]<<- 3
			snps$minor[snps$minor2=="T"&!is.na(snps$minor2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	#
	if(is.integer(snps$major)|is.numeric(snps$major))
		{
		snps$major2										<<- NA
		snps$major2[snps$major==1&!is.na(snps$major)]	<<- "A"
		snps$major2[snps$major==2&!is.na(snps$major)]	<<- "C"
		snps$major2[snps$major==3&!is.na(snps$major)]	<<- "G"
		snps$major2[snps$major==4&!is.na(snps$major)]	<<- "T"
		}else{		# if in bim-file data is encoded as A,C,G,T rather than 1,2,3,4.
		if(is.character(snps$major))
			{
			snps$major2										<<- snps$major
			snps$major										<<- NA
			snps$major[snps$major2=="A"&!is.na(snps$major2)]<<- 1
			snps$major[snps$major2=="C"&!is.na(snps$major2)]<<- 2
			snps$major[snps$major2=="G"&!is.na(snps$major2)]<<- 3
			snps$major[snps$major2=="T"&!is.na(snps$major2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	snps$minor2[snps$minor2=="0"]	<<- NA
	#
	# check if expected alleles (A, C, T, G) only:
	myalleles1			<- names(table(snps$minor2))
	myalleles1			<- myalleles1[myalleles1!="A"&myalleles1!="C"&myalleles1!="G"&myalleles1!="T"&myalleles1!="0"]
	myalleles2			<- names(table(snps$major2))
	myalleles2			<- myalleles2[myalleles2!="A"&myalleles2!="C"&myalleles2!="G"&myalleles2!="T"&myalleles2!="0"]
	myalleles			<- c(myalleles1,myalleles2)
	if(length(myalleles)>0)
		{
		myalleles		<- myalleles[!is.na(myalleles)]
		if(length(myalleles)>0)
			{
			myotheralleles	<<- myalleles
			if(!acceptalleles)
				{
				cat("ERROR: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("If you want to continu trying to import the data anyway, set the 'acceptalleles' flag to TRUE (i.e. importdata(acceptalleles=TRUE)).",sep="\n")
				return(cat("Note however that downstream this could lead to errors.",sep="\n"))
				}else{
				cat("WARNING: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("Because the flag 'acceptalleles' is set to TRUE, SambaR will continu to import the data. However, you might encounter errors downstream.",sep="\n")
				}
			}
		}
	snps$polyfilter		<<- ifelse(is.na(snps$minor),FALSE,TRUE)
	#
	# reorder based on chromosome and position:
	if(any(mygenlight$loc.names!=snps$genlightname))
		{
		return(cat("ERROR: even before reordering, snps$genlightname does not correspond to mygenlight@loc.names. Please contact developer of SambaR.",sep="\n"))
		}
	if(reorder_snps)
		{
		cat("Reordering snps dataframe and genlight object based on chromosome name and chromosome position. If you receive an error after this line, set the flag 'reorder_snps' to FALSE.",sep="\n")
		mysnpsorder			<- order(snps$chr,snps$pos)
		snps				<<- snps[mysnpsorder,]
		mygenlight			<<- mygenlight[,mysnpsorder]
		if(any(mygenlight$loc.names!=snps$genlightname))
			{
			return(cat("ERROR: after reordering, snps$genlightname does not correspond to mygenlight@loc.names. Set the flag 'reorder_snps' to FALSE (or contact developer of SambaR).",sep="\n"))
			}
		snps$nr_neworder	<<- c(1:nrow(snps))
		}
	#
	# create inds dataframe:
	cat("Creating inds dataframe...",sep="\n")
	inds      			<<- as.data.frame(cbind(nr=1:nInd(mygenlight),name=indNames(mygenlight)))
	inds$pop			<<- pop(mygenlight)	# 06_02_2020: this line needs to be separate (i.e. do not include in the previous line), because pop(genlight) will otherwise be converted in 1,2,3
	inds$nr 			<<- 1:nrow(inds)
	inds$pop2			<<- inds$pop		# 24-04-2020: this column will remain the same as inds$pop, except when column pop2 (with subpopulations) are defined in samplefile (see below) 
	#	
	# in case there are duplicated sample names, we changes names to Ind1, Ind2, etc.
	if(length(unique(inds$name))<nrow(inds))
		{
		#cat("WARNING: duplicate sample names found. Sambar changes sample names to Ind1, Ind2, etc.",sep="\n")
		#inds$name				<<- paste("Ind",c(1:nrow(inds)),sep="")
		#indNames(mygenlight)	<<- inds$name
		cat("ERROR: duplicate sample names found in input data (PED file).",sep="\n")
		myduplicates			<<- as.vector(inds$name[duplicated(inds$name)])
		cat("A list of the duplicated sample name(s) is saved in the vector 'myduplicates'.",sep="\n")
		return(cat("Makes changes to filenames in the PED file (second column), convert to raw, and afterwards try running the importdata() function again.",sep="\n"))
		}
	# reorder inds dataframe:
	inds$sample_nr		<<- c(1:nrow(inds))				# this info is needed ro reorder data in mygenlight (in case not yet ordered by samplename)
	inds				<<- inds[order(inds$name),]
	# reorder mygenlight data (in case just not yet ordered by samplename):
	mymatrix			<- as.matrix(mygenlight)
	mymatrix			<- mymatrix[inds$sample_nr,]
	mygenlight			<<- as.genlight(mymatrix)
	pop(mygenlight)		<<- inds$pop
	inds$sample_nr		<<- NULL
	inds$nr				<<- NULL
	inds$nr				<<- c(1:nrow(inds))
	rownames(inds)		<<- inds$nr
	#
	# if sample file is provided population assignment is extracted from additional input file (samplefile):
	# This is necessary when the ped file is generated from vcf file (because vcf file does not contain pop info), but is also useful in general to quickly change population names and to insert hierarchial structure (inds$pop2) 
	if(!is.null(samplefile))
		{
		cat("Extracting information from sample file...",sep="\n")
		cat("If you receive an error stating 'Error in scan : line ... did not have ... elements', please double check if your samplefile does not contain white spaces (for example in the population names).",sep="\n")
		# 21-2-20: I originally called this vcfinput file and I decided not to change it.
		vcfinput		<- read.table(samplefile,header=TRUE)
		if(ncol(vcfinput)<2)
			{
			return(cat("ERROR: Sample file should contain at least two columns ('name' and 'pop').",sep="\n"))
			}
		if(!"name"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop'). Please edit the sample file and try again.",sep="\n"))
			}
		if(!"pop"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop'). Please edit the sample file and try again.",sep="\n"))
			}
		if(!"pop2"%in%colnames(vcfinput))
			{
			vcfinput$pop2	<- vcfinput$pop
			}
		# reorder vcf-file:
		vcfinput$name	<- as.character(vcfinput$name) 
		vcfinput		<- vcfinput[order(vcfinput$name),]
		# now extract information:
		if(nrow(vcfinput)<nrow(inds))
			{
			indvec		<<- inds$name[!as.character(inds$name)%in%as.character(vcfinput$name)]
			indvec2		<<- vcfinput$name[!as.character(vcfinput$name)%in%as.character(inds$name)]
			return(cat(paste("ERROR: less samples in sample file (",nrow(vcfinput),") than in PED/RAW file (",nrow(inds),"). Type indvec to find out which samples are missing. Please add these samples to the sample file.",sep=""),sep="\n")) 
			}
		if(nrow(vcfinput)>nrow(inds))
			{
			cat("WARNING: more samples in sample file than in PED/RAW file. SambaR will select try to select samples occuring in PED/RAW file.",sep="\n")
			boolvec		<- as.character(vcfinput$name)%in%as.character(inds$name)
			if(!any(boolvec))
				{
				cat("ERROR: not a single sample name in sample file corresponds with sample name in PED/RAW file. Please edit the sample file.",sep="\n") 
				samplefilenames	<<- as.vector(vcfinput$name) 
				indsdatanames	<<- as.vector(inds$name)
				booldatanames	<<- as.vector(as.character(vcfinput$name))==as.vector(as.character(inds$name))
				cat("Sample names in sample file can be observed by typing: samplefilenames.",sep="\n")
				cat("Sample names in inds dataset can be observed by typing: indsdatanames.",sep="\n")
				return(cat("The similarity between both vectors can be observed by typing: booldatanames.",sep="\n"))
				}
			vcfinput	<- droplevels(vcfinput[boolvec,])
			}
		if(any(as.vector(as.character(vcfinput$name))!=as.vector(as.character(inds$name))))
			{
			cat("ERROR: Sample names in sample file do not correspond with names in inds dataset.",sep="\n")
			samplefilenames	<<- as.vector(vcfinput$name) 
			indsdatanames	<<- as.vector(inds$name)
			booldatanames	<<- as.vector(as.character(vcfinput$name))==as.vector(as.character(inds$name))
			cat("Sample names in sample file can be observed by typing: samplefilenames.",sep="\n")
			cat("Sample names in inds dataset can be observed by typing: indsdatanames.",sep="\n")
			return(cat("The similarity between both vectors can be observed by typing: booldatanames.",sep="\n"))
			}
		if(any(grepl("_",vcfinput$pop))|any(grepl("_",vcfinput$pop2)))
			{
			if(allow_edit)
				{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
				mypops			<- as.character(vcfinput$pop)
				vcfinput$pop	<- gsub("_","",mypops)
				mypops2			<- as.character(vcfinput$pop2)
				vcfinput$pop2	<- gsub("_","",mypops2)
				}else{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("To solve this issue, you can choose any of the following two options:",sep="\n")
				cat("Option 1: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 2: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		if(any(nchar(as.character(vcfinput$pop))>popnchars))
			{
			if(allow_edit)
				{
				cat("WARNING: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will truncate population names (if longer than 10 characters) and continue.",sep="\n")
				mypops		<- as.character(vcfinput$pop)
				vcfinput$pop<- ifelse(nchar(mypops)>popnchars,substr(mypops,1,popnchars),mypops)
				mypops2		<- as.character(vcfinput$pop2)
				vcfinput$pop2<- ifelse(nchar(mypops2)>popnchars,substr(mypops2,1,popnchars),mypops2)
				}else{
				cat("ERROR: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("To solve this issue, you can choose any of the following three options:",sep="\n")
				cat("Option 1: Rerun the importdata function with another value for popnchars (which by default is set to 10). Some output plots might, as a result, not fully display the population name.",sep="\n")
				cat("Option 2: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 3: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		mynind	<- as.vector(table(vcfinput$pop))
		#if(min(mynind)<2)
		#	{
		#	vcfinput2	<<- vcfinput 
		#	return(cat("ERROR: SambaR does not accept populations consisting of 1 sample only.\nPlease edit population names and try again. \nThis means: make changes in the samplefile, and afterwards rerun the importdata() function.",sep="\n"))
		#	}
		inds$pop		<<- vcfinput$pop
		inds$pop2		<<- vcfinput$pop2
		if("sex"%in%colnames(vcfinput))
			{
			inds$sex	<<- vcfinput$sex
			}	
		if("type"%in%colnames(vcfinput))
			{
			inds$type2	<<- vcfinput$type
			if(is.logical(inds$type2))
				{
				inds$type	<<- inds$type2
				}else{
				inds$type	<<- ifelse(inds$type2==as.vector(unique(inds$type2))[1],TRUE,FALSE)
				}
			if(length(as.vector(unique(inds$type2)))!=2)
				{
				cat("WARNING: number of classes defined in inds$type column does not equal 2.",sep="\n")
				}
			}
		if("longitude"%in%colnames(vcfinput))
			{
			#if(any(is.na(vcfinput$longitude)))
			#	{
			#	return(cat("ERROR: SambaR does not accept NA-values in longitude column of input samplefile.",sep="\n"))
			#	}
			inds$longitude	<<- as.numeric(gsub(",",".",as.character(vcfinput$longitude)))
			}
		if("latitude"%in%colnames(vcfinput))
			{
			#if(any(is.na(vcfinput$latitude)))
			#	{
			#	return(cat("ERROR: SambaR does not accept NA-values in latitude column of input samplefile.",sep="\n"))
			#	}
			inds$latitude	<<- as.numeric(gsub(",",".",as.character(vcfinput$latitude)))
			}
		if("plotname"%in%colnames(vcfinput))
			{
			inds$plotname	<<- vcfinput$plotname
			}
		if("mtDNA"%in%colnames(vcfinput))
			{
			inds$mtDNA	<<- vcfinput$mtDNA
			}
		if("mtsymbol"%in%colnames(vcfinput))
			{
			inds$mtsymbol	<<- vcfinput$mtsymbol
			}
		# assign population labels to genlight object:
		mygenlight@pop	<<- as.factor(inds$pop)
		}
	# in case number of populations equals number of samples, we set number of populations to 1:
	nuniqpop		<- length(unique(inds$pop))
	if(nuniqpop==nrow(inds))
		{
		cat("Warning: number of populations equals number of samples.",sep="\n") 
		cat(paste("Number of populations:",nuniqpop,sep=" "),sep="\n")
		cat(paste("Number of individuals:",nrow(inds),sep=" "),sep="\n")
		cat("Did you maybe switch the first two columns of the PED-file?",sep="\n")
		cat("Or did you generate the PED/MAP file from a vcf file and forget to provide the name of the sample file to the samplefile flag?",sep="\n")
		cat("Because Sambar does not accept that all samples belong to different populations, Sambar will assign all samples to 1 population.",sep="\n")
		inds$pop  		<<- "Pop1"
		pop(mygenlight)	<<- inds$pop
		inds$pop2		<<- inds$pop
		}
	# assign population colours:
	if(!silent){cat("Assigning population colours...",sep="\n")}
	populations			<- as.vector(unique(pop(mygenlight)))
	ncolours			<- length(mysambarcolours)
	npops				<- length(populations)
	if(ncolours<npops)
		{
		cat(paste("ERROR: Currently more populations (",npops,") defined than popcolours (",ncolours,").",sep=""),sep="\n")
		cat("Please provide a (longer) vector with colours to the colourvector argument (i.e.: 'importdata(colourvector=c('col1','col2','col3'))'",sep="\n")
		cat("The default colours of SambaR (if you don't specify anything) are:",sep="\n")
		cat(defaultcolours,sep=", ")
		sambarpopulations	<<- populations
		sambarpopcolours	<<- mysambarcolours
		cat(" ",sep="\n")
		cat(" ",sep="\n")
		cat("Currently defined population names are stored in the vector: 'sambarpopulations'.",sep="\n")
		cat("Currently defined colour names are stored in the vector 'sambarpopcolours'.",sep="\n")
		return(cat(" ",sep="\n"))
		}
	mydatapopcolours		<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		# assign colours in alphabetical order of population names (e.g.: Apop gets colour1, Bpop gets colour2, etc)
		cat("Assigning populations colours based on alphabetical order of population names.",sep="\n")
		populations			<- popNames(mygenlight)	 	# this is needed downstream to correctly assign colours at mysambar$mycolours
		inds$popcol			<<- mydatapopcolours[as.factor(inds$pop)]	
		}else{
		# assign colours in order of occurence of populations in datasets. (e.g. Apop, Apop, Cpop, Bpop, Bpop, Cpop would result in Cpop being assigned colour2)
		cat("Assigning populations colours based on order of occurrence of populations in ped-file.",sep="\n")
		populations			<- as.vector(unique(pop(mygenlight)))	
		inds$popcol			<<- NA
		for (i in (1:(length(populations))))
			{
			for (j in (1:nrow(inds)))
				{
				if (inds$pop[j]==populations[i])
					{
					inds$popcol[j] <<- mydatapopcolours[i]
					}
				}
			}
		}
	# assign plotting symbols:
	symbolvector		<- c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype		<<- symbolvector[as.factor(inds$pop)]
	inds$symboltype2	<<- symbolvector[as.factor(inds$pop)]
	if(any(as.vector(inds$pop)!=as.vector(inds$pop2)))
		{
		populations		<- as.vector(unique(inds$pop))
		populations		<- populations[order(populations)] 
		npops			<- length(populations)
		for(j in c(1:npops))
			{
			mypop		<- populations[j]
			subpops		<- as.vector(inds$pop2[inds$pop==mypop])
			inds$symboltype2[inds$pop==mypop]	<<- symbolvector[as.factor(subpops)]
			}
		}
	#
	# optionally add additional information to snps dataframe:
	if(sumstatsfile)
		{
		# positional information can be derived either from map file or from sumstats file.
		cat("Extracting information from STACKS sumstats file...",sep="\n")
		cat("If you receive an error after this line, you could opt to omit this step (i.e. importdata(sumstatsfile=FALSE)).",sep="\n")
		cat("Note that the population names defined in the sumstats file should not contain spaces, otherwise you might encounter the error stating: line ... did not have ... elements.",sep="\n")
		#chrom			<- read.table("sumstats.tsv",skip=(length(populations)+1),header=FALSE)
		chrom			<- read.table("sumstats.tsv",comment.char="#",header=FALSE)		# this way users can import sumstats file even if using a different number of populations then when running STACKS
		if(length(unique(chrom[,1]))==1)		# if old sumstats version which lists batch number in first column
			{
			chrom			<- chrom[,c(2:5)]
			}else{
			chrom			<- chrom[,c(1:4)]
			}
		colnames(chrom)	<- c("Stack_ID","Chromosome","ChromBasepair","StackBasepair")
		chrom$name3		<- paste(chrom$Stack_ID,chrom$StackBasepair,sep="_")
		chrom			<- unique(chrom)			# filter out redundant information (multiple lines per site, one for each population)
		chrom			<<- chrom
		if(nrow(chrom)!=nrow(snps))
			{
			cat("WARNING: Number of loci in sumstatsfile does not agree with number of loci in PED/MAP file.",sep="\n")
			cat(paste("Number of snps in PED/MAP file: ",nrow(snps),".",sep=""),sep="\n")
			cat(paste("Number of loci in sumstats file: ",nrow(chrom),".",sep=""),sep="\n")
			ignoredloci	<- chrom$name3[which(!chrom$name3%in%snps$name3)]
			chrom		<- chrom[which(chrom$name3%in%snps$name3),]
			cat("SambaR will ignore loci in the sumstatsfile which are not present in the PED/MAP file.",sep="\n")
			write.table(ignoredloci,"sumstatsfile.ignoredloci.txt",row.names=FALSE,col.names=FALSE,quote=FALSE)
			cat("The names of these loci are exported to a file called 'sumstatsfile.ignoredloci.txt'.",sep="\n")
			}
		snpstemp		<- snps[order(as.character(snps$name3)),]
		chrom			<- chrom[order(as.character(chrom$name3)),]
		chrom_ordered	<<- chrom
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snps$name3)])
		mygenlight		<<- as.genlight(mymatrix)	
		mygenlight@pop	<<- as.factor(inds$pop)
		snps			<<- snpstemp
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		if(any(chrom$name3!=snps$name3))
			{
			cat("ERROR: SNP names in snps dataframe do not correspond with SNP names in sumstats file.",sep="\n")
			return(cat("You can compare the columns snps$name3 and chrom_ordered$name3 to observe the differences.",sep="\n")) 
			}else{
			snps_test		<<- snps
			chrom_test		<<- chrom
			snps$chr		<<- chrom$Chromosome
			snps$pos		<<- chrom$ChromBasepair
			snps$stackID	<<- chrom$Stack_ID
			snps$stackbp	<<- chrom$StackBasepair
			snps_test2		<<- snps
			}
		snps$readpos	<<- as.numeric(sub(".*_","",snps$name3))			# Note: this function assumes that name of snp indicates position of SNP on stacks data. This is not always true.
		if(!silent){cat("End of sumstatsfile section.",sep="\n")}
		}else{
		snps$readpos	<<- NA
		}
	if(any(snps$pos!=0)&any(snps$pos>=500)&any(snps$chr!=0))	# 27-09-2020
	#if(any(snps$pos!=0)&any(snps$pos>=500))
		{
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		cat("Reordering data based on locations within the reference genome.",sep="\n")
		if(length(unique(snps$chr))==nrow(snps))
			{
			cat("WARNING: Number of chromosomes/contigs specified in map and bim file equals number of SNPs.",sep="\n")
			cat("Are these really contigs or in fact sequencing reads?",sep="\n")
			}
		if(length(unique(snps$chr))>0.4*nrow(snps))	# 0.4 is randomly chosen
			{
			cat("WARNING: High number of chromosomes/contigs specified in map and bim file.",sep="\n")
			cat("Are these really contigs or in fact sequencing reads?",sep="\n")
			}
		## REFMAP:
		snps$name2		<<- paste(snps$chr,snps$pos,sep="_")
		# Are snps located on chromosomes or on unplaced contigs?
		chr(mygenlight) <<- snps$chr
		if(!is.null(nchroms))
			{
			cat("Defining first n (as defined by nchroms) scaffolds as chromosomes, which will be used for plotting.",sep="\n")
			snps$placed		<<- snps$chr2<=nchroms
			snps$autosomal	<<- snps$chr2<=nchroms 
			snps$placedcol	<<- ifelse(snps$placed,"black","red")
			}else{
			snps$placed		<<- FALSE
			snps$autosomal	<<- FALSE 
			snps$placedcol	<<- "black"
			}
		#snps$placed	<<- !(grepl("\\.",snps$chr))	# This is assuming that the names of unplaced contigs contain a dot, wheras chromosomes do not
		#snps$autosomal	<<- (!(grepl("\\.",snps$chr)))&snps$chr!="X"
		### Reorder the snps to the order they occur in the genome:
		# First reorder the snps dataframe:
		snpstemp		<- snps
		snps			<<- snpstemp[order(snpstemp$chr,snpstemp$pos),]
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snpstemp$chr,snpstemp$pos)])
		mygenlight		<<- as.genlight(mymatrix)
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		### Spacing between snps:
		cat("Calculating distance between SNPs...",sep="\n")
		new_chr			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
		new_chr			<- c(TRUE,new_chr[1:(length(new_chr)-1)])
		snps$new_chr	<<- TRUE
		mydist			<- c(as.vector(snps$pos[2:length(snps$pos)]),NA)-snps$pos
		mydist			<- c(NA,mydist[1:(length(mydist)-1)])
		mydist[new_chr]	<- NA
		snps$dist		<<- as.numeric(mydist)
		snps$dist2		<<- !(is.na(snps$dist))
		# Are snps on same position? (STACKS sometimes outputs two snps which are in fact on same position within genome)
		snps$samepos	<<- (duplicated(snps$name2,fromLast=FALSE))|(duplicated(snps$name2,fromLast=TRUE))
		snps$uniqpos	<<- !(snps$samepos)
		}else{
		# output from DENOVO pipeline, or from PyRAD pipeline (which returns read pos rather than chromosome/contig pos):
		snps$placed		<<- FALSE
		snps$autosomal	<<- FALSE
		snps$placedcol	<<- "black"
		snps$new_chr	<<- NA
		snps$uniqpos	<<- TRUE
		snps$samepos	<<- FALSE
		snps$name2		<<- snps$name
		# reorder the snps dataframe:
		snpstemp		<- snps
		snps			<<- snpstemp[order(snpstemp$name),]		# if denovo, we order on name, rather than on position.
		# Second reorder the data in the genlight object:
		mymatrix		<- as.matrix(mygenlight[,order(snpstemp$name)])
		mygenlight		<<- as.genlight(mymatrix)
		}
	
	# optionally add additional information to snps and inds dataframe about read depth:
	if(depthfile)
		{
		cat("Extracting read depth information...",sep="\n")
		snps$chr		<<- tolower(as.character(snps$chr))
		#
		if(file.exists(inddepthfile))
			{
			depth1			<- read.table(inddepthfile,header=TRUE)
			}else{
		 	depth1			<- read.table("out.idepth",header=TRUE)
			}
		if("MEAN.DEPTH"%in%colnames(depth1))
			{
			if(!silent){cat("Changing period to underscore in out.idepth file.",sep="\n")} 
			depth1$MEAN_DEPTH	<- depth1$MEAN.DEPTH 
			depth1$MEAN.DEPTH	<- NULL
			depth1$N_SITES		<- depth1$N.SITES 
			depth1$N.SITES		<- NULL
			depth1				<<- depth1
			}
		if(any(!(c("INDV","N_SITES","MEAN_DEPTH")%in%colnames(depth1))))
			{
			return(cat("ERROR: One more expected column names ('INDV','N_SITES','MEAN_DEPTH') missing in out.idepth file. Edit the out.idepth file or set depthfile flag to FALSE.",sep="\n"))
			}
		#
		if(file.exists(snpdepthfile))
			{
			depth2		<- read.table(snpdepthfile,header=TRUE)
			}else{
			depth2		<- read.table("out.ldepth.mean",header=TRUE)
			}
		if("MEAN.DEPTH"%in%colnames(depth2))
			{
			if(!silent){cat("Changing period to underscore in out.ldepth.mean file.",sep="\n")} 
			depth2$MEAN_DEPTH	<- depth2$MEAN.DEPTH 
			depth2$MEAN.DEPTH	<- NULL
			depth2$VAR_DEPTH	<- depth2$VAR.DEPTH 
			depth2$VAR.DEPTH	<- NULL
			depth2				<<- depth2
			}
		if(any(!(c("CHROM","POS","MEAN_DEPTH","VAR_DEPTH")%in%colnames(depth2))))
			{
			return(cat("ERROR: One or more expected column names ('CHROM','POS','MEAN_DEPTH' and 'VAR_DEPTH') missing in out.ldepth.mean file. Edit the out.ldepth.mean file or set depthfile flag to FALSE.",sep="\n"))
			}
		depth1$INDV		<- as.character(depth1$INDV)
		depth1			<- depth1[order(depth1$INDV),]
		depth2			<- depth2[order(as.factor(depth2$CHROM),as.numeric(depth2$POS)),]
		if((nrow(inds)!=nrow(depth1))|(any(as.character(inds$name)!=as.character(depth1$INDV))))
			{
			cat("ERROR: Some individuals listed in PED file are not listed in out.idepth file.",sep="\n")
			cat("Sample names need to be identical (including upper/lower case).",sep="\n")
			depthsamplenames	<<- as.character(depth1$INDV)
			indsamplenames		<<- as.character(inds$name)
			cat("You can observe sample names by typing 'depthsamplenames' and 'indsamplenames'.",sep="\n")
			return(cat("Make sure that sample names correspond or set depthfile to FALSE.",sep="\n"))
			}
		if(any(!is.finite(depth1$MEAN_DEPTH)))
			{
			return(cat("ERROR: Infinite values in out.idepth file. Edit the out.idepth file or set depthfile flag to FALSE.",sep="\n"))
			}
		if(any(!is.finite(depth2$MEAN_DEPTH)))
			{
			return(cat("ERROR: Infinite values in out.ldepth.mean file. Edit the out.ldepth.mean file or set depthfile flag to FALSE.",sep="\n"))
			}
		inds$meandepth	<<- depth1$MEAN_DEPTH
		if(nrow(snps)==nrow(depth2))
			{
			if(!silent){cat("nsnps == nrow(depth2)",sep="\n")}
			snps$meandepth	<<- depth2$MEAN_DEPTH
			if(!silent){cat("Added depth info.",sep="\n")}
			}else{
			cat(paste("WARNING: The number of snps in out.ldepth.mean file (",nrow(depth2),") is not the same as number of snps in ped file (",nrow(snps),").",sep=""),"\n")
			cat("This can arise from glitches in the SNP calling pipeline or file conversion.",sep="\n")
			cat("SambaR will ignore sites in out.ldepth.mean file which are not present in ped file.",sep="\n")
			snps$chr_pos	<<- paste(snps$chr,snps$pos,sep="_")
			snpstemp		<- snps[snps$uniqpos,]
			snpsdup			<- snps[snps$samepos,]
			nsnpsdup		<- length(unique(snpsdup$chr_pos))
			if(nsnpsdup>0)
				{
				snpsdup$MEAN_DEPTH 	<- NA
				snpsdup$VAR_DEPTH 	<- NA	
				snpsdup$dup			<- TRUE
				cat(paste("Found",nsnpsdup,"duplicated snp(s) in snps dataset. Marked as TRUE in snps$samepos column.",sep=" "),sep="\n")
				}
			depth2$CHROM	<- tolower(as.character(depth2$CHROM))
			depth2$POS		<- as.character(depth2$POS)
			depth2$chr_pos	<- paste(depth2$CHROM,depth2$POS,sep="_")
			temp			<- depth2[order(depth2$chr_pos),]
			temp$dup		<- (duplicated(temp$chr_pos,fromLast=FALSE))|(duplicated(temp$chr_pos,fromLast=TRUE))
			ndup			<- length(unique(temp$chr_pos[temp$dup]))
			if(ndup>0)
				{
				cat(paste("Found",ndup,"duplicated snp(s) in out.ldepth.mean file. SambaR will ignore this/these site(s).",sep=" "),sep="\n")
				}
			depth2			<- temp[order(as.factor(temp$CHROM),as.numeric(temp$POS)),]
			depth2temp		<- depth2[!depth2$dup,]
			combitemp		<- merge(x=snpstemp, y=depth2temp, by="chr_pos", all=TRUE)
			combitemp2		<- combitemp[!is.na(combitemp$chr),]
			combitemp2$CHROM<- NULL
			combitemp2$POS	<- NULL
			if(nsnpsdup>0)
				{
				combitemp3		<- rbind(combitemp2,snpsdup)
				}else{
				combitemp3		<- combitemp2
				}
			snps			<<- combitemp3[order(combitemp3$chr,combitemp3$pos),]
			colnames(snps)[which(colnames(snps)=="MEAN_DEPTH")]	<<- "meandepth" 
			}
		if(!silent){cat("Adding depth info.",sep="\n")}
		temp			<- snps$meandepth[snps$meandepth<quantile(snps$meandepth,0.995,na.rm=TRUE)]
		mythreshold		<- qnorm((1-0.05/length(snps$meandepth)), mean = mean(temp,na.rm=TRUE), sd = sd(temp,na.rm=TRUE), lower.tail = TRUE, log.p = FALSE)
		snps$depthfilter<<- snps$meandepth<mythreshold
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		if(!silent){cat("Added depth filter.",sep="\n")}
		}else{
		snps$depthfilter<<- TRUE
		}
	if(!is.null(snpinfofile))
		{
		addsnpinfo()
		}
	# optionally add longitude and latitude information to inds dataframe:
	if(!is.null(geofile))
		{
		if(!file.exists(geofile))
			{
			cat(paste("ERROR: could not find file:",geofile,sep=" ",sep="\n"))
			return(cat("Check the name of the file and whether you stored it in the right directory.",sep="\n"))
			}
		cat("Adding geographical coordinates to inds dataframe...",sep="\n")
		mygeo			<- read.table(geofile,header=TRUE)
		if(any(!(c("sample","longitude","latitude")%in%colnames(mygeo))))
			{
			return(cat("ERROR: geofile should contain columns named 'sample', 'longitude' and 'latitude'.",sep="\n"))
			}
		mygeo			<- mygeo[order(as.character(mygeo$sample)),]
		if(any(!as.vector(as.character(mygeo$sample))==as.vector(as.character(inds$name))))
			{
			cat("WARNING: Sample names in geofile do not correspond with names in inds dataset. SambaR will not add geographical coordinates.",sep="\n")
			mygeo			<<- mygeo
			cat("To view the sample names in geofile, type: 'mygeo$sample'.",sep="\n")
			cat("To view the sample names in inds dataset, type: 'inds$name'.",sep="\n")
			}else{
			inds$longitude	<<- mygeo$longitude
			inds$latitude	<<- mygeo$latitude
			if(class(inds$longitude)=="factor")
				{
				cat("WARNING: Longitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
				inds$longitude	<<- as.numeric(sub(",",".",as.character(inds$longitude)))
				
				}
			if(class(inds$latitude)=="factor")
				{	
				cat("WARNING: Latitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
				inds$latitude	<<- as.numeric(sub(",",".",as.character(inds$latitude)))
				}
			}
		}
	if("longitude"%in%colnames(inds))
		{
		# pacific or atlantic centred map?
		inds$longitude2	<<- ifelse(inds$longitude>=0,inds$longitude,abs(inds$longitude)+180)
		inds$longitude3	<<- ifelse(inds$longitude>=geomap_thres,inds$longitude,180+(180-abs(inds$longitude)))
		}
	if(length(unique(inds$pop))>length(unique(inds$pop2)))
		{
		cat("WARNING: inds$pop contains more unique population names than inds$pop2 column. SambaR expects it to be the other way around.",sep="\n") 
		}
	# optionally add pool information to inds dataframe:
	if(!is.null(poolsfile))
		{
		if(!silent){cat("Adding pool information.",sep="\n")}
		mypools	<- read.table(poolsfile,header=TRUE)
		mypools	<- mypools[order(mypools$sample),]
		if(any(!mypools$sample==inds$name))
			{
			cat("WARNING: Sample names in poolsinfo file do not correspond with names in inds dataset. SambaR will not add pool info.",sep="\n")
			}else{
			inds$pool	<<- mypools$pool
			}
		}
	# short names for individuals:
	inds$name2			<<- NA
	if(grepl(".",as.vector(inds$name[1])))
		{
		for (i in c(1:nrow(inds)))
			{
			inds$name2[i]	<<- strsplit(as.vector(inds$name[i]), "[.]")[[1]][1]
			}
		}else{
		inds$name2			<<- substr(inds$name,start=1,stop=namechars)
		}
	#
	# short names for populations:
	mypops				<- as.vector(inds$pop)
	myshort1			<- ifelse(nchar(mypops)>2,substr(mypops,1,2),mypops)
	myshort2			<- ifelse(nchar(mypops)>3,substr(mypops,1,3),mypops)
	if(length(unique(myshort1))<length(unique(myshort2)))
		{
		inds$shortpop	<<- myshort2
		}else{
		inds$shortpop	<<- myshort1
		}
	# short names for subpopulations:
	mypops				<- as.vector(inds$pop2)
	myshort1			<- ifelse(nchar(mypops)>2,substr(mypops,1,2),mypops)
	myshort2			<- ifelse(nchar(mypops)>3,substr(mypops,1,3),mypops)
	if(length(unique(myshort1))<length(unique(myshort2)))
		{
		inds$shortpop2	<<- myshort2
		}else{
		inds$shortpop2	<<- myshort1
		}
	#
	if(sumstatsfile)
		{
		if(!silent){cat("Marking SNPs which are derived from same sequencing read...",sep="\n")}
		# 18042019: For some reason the output is incorrect if I include this line in sumstatsfile section.
		# Is snps on same stack (sequencing read) as previous snp?
		snps$sameread	<<- (duplicated(snps$stackID,fromLast=FALSE))
		}
	#
	### create inds2 (sample pairs) and pops2 (pop pairs) dataframes:
	getinds2()
	if(any(is.na(inds2$indpair))){return(cat("ERROR: NA-values in inds2$indpair column.",sep="\n"))} 
	getpops2()
	#
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	kinshipdir			<- paste(sambardir,"Kinship",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(sambardir,"Maps",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(kinshipdir)){dir.create(file.path(kinshipdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- populations
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	if(popcol_by_alphabetical_order_popname)
		{
		mysambar[[17]]	<<- mydatapopcolours[order(populations)]
		}else{
		mysambar[[17]]	<<- mydatapopcolours
		}
	mysambar[[18]]			<<- geomapsdir
	names(mysambar)			<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$inds2			<<- inds2
	mysambar$pops2			<<- pops2
	mysambar$populations2	<<- mysambar$populations	# needed for excludepop()
	mysambar$mycolours2		<<- mysambar$mycolours		# needed for excludepop()
	mysambar$defaultcolours	<<- defaultcolours
	mysambar$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambar$datasource		<<- "imported_from_ped"
	mysambar$kinshipdir		<<- kinshipdir
	#
	# check:
	checkpopcolours()
	if(mysambar$colourerror){return(cat(" ",sep="\n"))}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: row names of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#
	if(!is.null(pop_order))
		{
		if(any(!as.character(inds$pop)%in%as.character(pop_order)))
			{
			return(cat("ERROR: not all populations specified at inds$pop present in pop_order vector.",sep="\n"))
			}
		if(any(!as.character(pop_order)%in%as.character(inds$pop)))
			{
			return(cat("ERROR: not all populations specified in pop_order vector present in inds$pop column.",sep="\n"))
			}
		}
	reorderpop(poporder=pop_order)
	if(mysambar$reordererror)
		{
		return(cat("ERROR: problem with reordering of populations (see previous lines).",sep="\n"))
		}
	# cat("Removing snps which are on the same position...")
	posfilter		<- snps$samepos
	if(any(posfilter))
		{
		removedloci		<- snps[posfilter,c("name","chr","pos","readpos")]		# this loci will give problems down the line when merging datasets.
		write.table(removedloci,"removedloci.txt",row.names=FALSE,col.names=TRUE,quote=FALSE)	
		snps			<<- snps[!posfilter,]
		mymatrix		<- as.matrix(mygenlight)
		mymatrix		<- mymatrix[,!posfilter]
		mygenlight		<<- as.genlight(mymatrix)
		cat(paste("Removed",nrow(removedloci),"snps which share the same position in the genome. The names of these loci are listed in a file called removedloci.txt.",sep=" "),sep="\n")
		}
	#
	# assignment of neworder number has to be after removal of SNPs, otherwise it will lead to errors downstream
	snps$nr_neworder 			<<- 1:nrow(snps)
	# export information for individuals:
	setwd(mysambar$sambardir)
	cat("Exporting sample information...",sep="\n")
	indstable	<- inds[,c("name","nr","pop","pop2","popcol")]
	write.table(indstable,"SambaR_samples.txt",row.names=FALSE,sep="\t",quote=FALSE)
	#
	if(do_citations)
		{
		cat("Exporting citations of the R packages...",sep="\n")
		cat("If you receive an error after this line, rerun the importdata function with the do_citations flag set to FALSE (i.e.: importdata(do_citations=FALSE)).",sep="\n")  
		getcitations()
		}else{
		cat("Omitting BibTex library because do_citations FLAG is set to FALSE.",sep="\n")
		}
	#
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	if("longitude"%in%colnames(inds)&"latitude"%in%colnames(inds)&domap)
		{
		cat("Creating geographical map with sample locations. If you receive an error after this line, so the flag domap to FALSE.",sep="\n")
		plotlocations2(export="pdf",indsfilter=rep(TRUE,nrow(inds)),addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=geomap_cex,dolabels=FALSE,showborders=TRUE)
		plotlocations2(export="pdf",indsfilter=rep(TRUE,nrow(inds)),addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1,dolabels=TRUE,showborders=TRUE)
		}
	if(qcplot)
		{	
		cat("Creating data_quality plot...",sep="\n")
		cat("If you receive an error after this line, rerun the importdata()-function with the flag 'qcplot' set to FALSE. I.e.: importdata(qcplot=FALSE).",sep="\n")
		calcretainedsnps(export="pdf",logy=TRUE)
		calcretainedsnps(export="pdf",logy=FALSE)
		}
	if(heplot)
		{
		cat("Creating He_vs_miss plot...",sep="\n")
		cat("If you receive an error after this line, type 'dev.off()' and rerun the importdata()-function with the flag 'heplot' set to FALSE. I.e.: importdata(heplot=FALSE).",sep="\n")
		indhetero_allsnps()
		#myminsites	<- ifelse(0.01*nrow(snps)<200,200,0.01*nrow(snps))
		He_vs_miss(export="pdf",allsites=TRUE,minsites=200,legendcex=legend_cex)
		#cat("Not included in the plot are samples with less than 250 non-missing data points.",sep="\n")
		}
	cat("DATA SUCCESSFULLY IMPORTED.",sep="\n")
	cat("The data is stored in 'mygenlight'. For an overview, type on the command line: 'mygenlight'.",sep="\n") 
	cat("You can observe a subset of the data by typing: as.matrix(mygenlight[1:10,1:10]).",sep="\n")
	cat("SNP information is and will be stored in an object called 'snps'. You can observe the first ten lines by typing: head(snps,10). Or, if working on a Windows computer, type: fix(snps).",sep="\n")
	cat("Sample information is and will be stored in an object called 'inds'. You can observe the first ten lines by typing: head(inds,10). Or, if working on a Windows computer, type: fix(inds).",sep="\n")
	cat("Sample information (including population colours and sample numbers) is also exported to a file called 'SambaR_samples.txt', which you can find in your SambaR directory.",sep="\n")
	cat("Information on sample pairs is and will be stored in an object called 'inds2'.",sep="\n")
	cat("Information on populations pairs is and will be stored in an object called 'pops2'.",sep="\n")
	cat("Reruns of the importdata() function will be much quicker than the first run, and the same is true for the filterdata() function.",sep="\n")
	cat("Therefore there is no need to save the workspace image when exiting R.",sep="\n")
	cat("ROUGH GUIDELINES BEFORE RUNNING THE FILTERDATA() FUNCTION:",sep="\n")
	cat("Before running the filterdata() function, observe the figures 'Data_quality' and/or 'He_vs_miss_ind.allsites.pop' to determine an appropriate value for the indmiss and snpmiss arguments.",sep="\n")
	cat("If you are mainly interested in structure analyses, set snpmiss to 0 (or if needed a bit higher, but preferably not higher than 0.05) and indmiss to the highest value which returns at least a few thousands SNPs scattered across the entire genome (see black line in 'Data_quality.log_yaxis').",sep="\n")
	cat("The reason is that variation in missingness among samples will affect the outcome of structure analyses. A few thousand SNPs from across the entire genome are generally sufficient to detect population structure (although this obviously depends on your study system).",sep="\n")
	cat("For other purposes (e.g. genetic diversity and selection analyses (especially the latter), you are probably better off by setting a more strict threshold for indmiss (default is 0.25) and more relaxed threshold for snpmiss (default is 0.1).",sep="\n")
	cat("If you are mainly interested in comparing genetic diversity among your study populations, observe the 'He_vs_miss_ind.allsites.pop'.",sep="\n")
	cat("Set indmiss to the highest value (which might be as low as 0.05) such that for retained individuals there is no relation between heterozygosity and their proportions of missing data.",sep="\n")
	options(scipen=0)	# 08-04-2020: reset scientific notation (because disabled at start of function)
	}

getpopninds<-function(popnames=mysambar$populations)
	{
	popninds	<- vector()
	npops		<- length(popnames)
	for(j in c(1:npops))
		{
		mypop		<- popnames[j]
		cat(mypop,sep="\n")
		indfilter	<- (inds$pop==mypop)&inds$filter
		ninds		<- length(indfilter[indfilter])
		popninds[j]	<- ninds 
		}
	names(popninds)	<- popnames
	mysambar$popninds	<<- popninds
	}

checkpopcolours<-function(popnames=mysambar$populations2,silent=TRUE)
	{
	if(is.null(mysambar$colourerror))
		{
		mysambar$colourerror	<<- FALSE
		}
	if(any(is.na(inds$popcol)))
		{
		mysambar$colourerror	<<- TRUE
		return(cat("ERROR: NA-values present in inds$popcol column.",sep="\n")) 
		}
	for(k in c(1:length(popnames)))
		{
		mypop			<- popnames[k]
		if(!silent){cat(mypop,sep="\n")}
		indsdfpopcols	<- inds$popcol[inds$pop==mypop]
		indsdfpopcol	<- as.vector(unique(indsdfpopcols))
		if(!silent){cat(paste("Colour defined in inds dataframe: ",indsdfpopcol,".",sep=""),sep="\n")}
		if(!silent){cat(paste("Object type: ",class(indsdfpopcol),".",sep=""),sep="\n")}
		if(length(indsdfpopcol)!=1)
			{
			mysambar$colourerror	<<- TRUE
			return(cat(paste("ERROR: in inds dataframe more than 1 colour defined for population ",mypop,". Contact the developer of SambaR.",sep=""),sep="\n")) 
			}
		sambarpopcol	<- mysambar$mycolours2[k]
		if(!silent){cat(paste("Colour defined in mysambar$mycolours2: ",sambarpopcol,".",sep=""),sep="\n")}
		if(!silent){cat(paste("Object type: ",class(sambarpopcol),".",sep=""),sep="\n")}
		if(indsdfpopcol!=sambarpopcol)
			{
			mysambar$colourerror	<<- TRUE
			return(cat(paste("ERROR: colours defined in inds dataframe for population ",mypop," do not correspond with colours defined in mysambar list. Contact the developer of SambaR.",sep=""),sep="\n")) 
			}
		}
	cat("All colours defined in mysambar$mycolours2 correspond with colours defined in inds$popcol column.",sep="\n") 
	}

reorderpop<-function(poporder=NULL)
	{
	mysambar$reordererror	<<- TRUE
	cat("Assigning population order to be used in output plots.",sep="\n")
	if(is.null(poporder))
		{
		cat("No population order defined. Populations will be sorted alphabetically.",sep="\n") 
		poporder			<- mysambar$populations2
		}else{
		cat("Ordering populations based on user defined input (poporder or pop_order flag).",sep="\n")
		}
	if(length(mysambar$populations)<length(mysambar$populations2))
		{
		cat("WARNING: resetting population filter using excludepop() command.",sep="\n")
		excludepop()
		}
	if(length(poporder)!=length(mysambar$populations2))
		{
		return(cat(paste("ERROR: length of input vector to poporder (or pop_order) flag, does not correspond with the number of populations in data. Type 'mysambar$populations2' to see which populations are expected.",sep=""),sep="\n")) 
		}
	if(any(!mysambar$populations2%in%poporder))
		{
		missingpop			<<- mysambar$populations2[!mysambar$populations2%in%poporder]
		return(cat(paste("ERROR: one or more populations present in data are not listed in the input vector to the poporder (or pop_order) flag. Type 'missingpop' to see which populations are missing.",sep=""),sep="\n")) 
		}
	if(any(!poporder%in%mysambar$populations2))
		{
		missingpop			<<- poporder[!poporder%in%mysambar$populations2]
		return(cat(paste("ERROR: one or more populations listed in the input vector to the poporder (or pop_order) flag are not present in the data. Type 'missingpop' to see which populations are missing.",sep=""),sep="\n")) 
		}
	inds$poporder			<<- factor(inds$pop,levels=poporder)
	mysambar$poporder		<<- poporder
	mysambar$poporder2		<<- poporder
	mycolorder				<- vector()
	myordernr				<- vector()
	for(i in c(1:length(poporder)))
		{
		mypop				<- as.character(poporder[i])
		mypopnr				<- which(as.character(mysambar$populations2)==mypop)
		if(length(mypopnr)==0)
			{
			return(cat(paste("ERROR: Population name ",mypop," not present in actual data.",sep=""),sep="\n"))
			}
		mycolorder[i]		<- mysambar$mycolours2[mypopnr]
		myordernr[i]		<- mypopnr
		}
	mysambar$colorder		<<- mycolorder
	mysambar$colorder2		<<- mycolorder
	#
	# population order in numbers (relative to alphabetical order):
	mysambar$popordernr		<<- myordernr
	mysambar$popordernr2	<<- myordernr
	#
	inds2$poporder1			<<- factor(inds2$pop1,levels=mysambar$poporder)
	inds2$poporder2			<<- factor(inds2$pop2,levels=mysambar$poporder)
	mysambar$reordererror	<<- FALSE
	cat("Finished reordering. Type mysambar$poporder2 to observe the new population order.",sep="\n")
	}

editchr2<-function(silent=FALSE,countsnps=FALSE,nchroms=NULL)
	{
	snps$chrlength		<<- NULL 
	snps$chr2			<<- NULL 
	snps$chrcol			<<- NULL
	snps$nsnps			<<- NULL
	#	
	if(!silent){cat("Assigning index based on length of chromosomes...",sep="\n")}
	mychrs				<- aggregate(snps$pos,by=list(as.character(snps$chr)),FUN=max)
	mychrs2				<- mychrs[order(-mychrs$x),]
	mychrs2$chr2		<- c(1:nrow(mychrs2))
	colnames(mychrs2)	<- c("chr","chrlength","chr2")
	mychrs2$chrcol		<- ifelse(mychrs2$chr2%%2==0,"black","grey40")
	snps				<<- merge(snps,mychrs2,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(any(as.character(colnames(as.matrix(mygenlight)))!=as.character(snps$genlightname)))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	#	
	if(!is.null(nchroms))
		{
		cat("Defining first n (as defined by nchroms) scaffolds as chromosomes, which will be used for plotting.",sep="\n")
		snps$placed		<<- snps$chr2<=nchroms
		snps$autosomal	<<- snps$chr2<=nchroms 
		snps$placedcol	<<- ifelse(snps$placed,"black","red")
		}else{
		snps$placed		<<- FALSE
		snps$autosomal	<<- FALSE 
		snps$placedcol	<<- "black"
		}
	#	
	if(countsnps)
		{
		if(!silent){cat("Counting number of SNPs per scaffold...",sep="\n")}
		myn					<- table(as.character(snps$chr))
		myndf				<- data.frame("chr"=names(myn),"nsnps"=as.vector(myn))
		snps				<<- merge(snps,myndf,by="chr",all=TRUE)
		snps				<<- snps[order(snps$nr),]
		if(any(!colnames(as.character(as.matrix(mygenlight)))==as.character(snps$genlightname)))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		}
	snps$placed		<<- TRUE
	snps$autosomal	<<- ifelse(snps$chr=="X",FALSE,TRUE)
	}

indsscatter<-function(export=NULL,addlegend=TRUE,legendcex=2.5,plottitle=NULL,plotname="Indscatter",xscore="snp_he",yscore="hetero_all",labelscore=NULL,xlabel="Genome-wide He (%)",ylabel="TE He",legendpos="topleft",yline=5.5,symbolsize=3.5,logx=FALSE,logy=FALSE,labelcex=1,corrpos=NULL,corrcex=1.75)
	{
	mypops			<- as.character(mysambar$populations)
	mycolours		<- as.character(mysambar$mycolours)
	#
	if(!xscore%in%colnames(inds))
		{
		return(cat("ERROR: xscore not present in inds dataframe.",sep="\n"))
		}
	if(!yscore%in%colnames(inds))
		{
		return(cat("ERROR: yscore not present in inds dataframe.",sep="\n"))
		}
	if(!is.null(labelscore))
		{
		if(!labelscore%in%colnames(inds))
			{
			return(cat("ERROR: labelscore not present in inds dataframe.",sep="\n"))
			}
		inputdf				<- inds[inds$filter,c("pop","popcol",xscore,yscore,labelscore)]
		colnames(inputdf)	<- c("pop","popcol","xscore","yscore","labelscore")
		}else{
		inputdf				<- inds[inds$filter,c("pop","popcol",xscore,yscore)]
		colnames(inputdf)	<- c("pop","popcol","xscore","yscore")
		}
	xmax			<- max(inputdf$xscore)
	xmin			<- min(inputdf$xscore)
	ymax			<- max(inputdf$yscore)
	ymin			<- min(inputdf$yscore)
	if(!is.null(export))
		{
		plotname	<- ifelse(!is.null(labelscore),paste(plotname,"indnames",sep="_"),plotname)
		plotname	<- ifelse(logx,paste(plotname,"logx",sep="."),plotname)
		plotname	<- ifelse(logy,paste(plotname,"logy",sep="."),plotname)
		legendlabel	<- ifelse(addlegend,"withlegend","NOlegend")
		if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8.5,height=8)}
		if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8.5,height=8)}
		if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8.5,height=8)} 
		}
	par(mar=c(5.25,9,2.5,1.25),cex.axis=2.5,cex.lab=3,cex.main=3)
	mylog	<- ifelse(logx,ifelse(logy,"xy","x"),ifelse(logy,"y",""))
	if(is.null(labelscore))
		{
		plot(inputdf$xscore,inputdf$yscore,pch=16,log=mylog,col=as.character(inputdf$popcol),xlim=c(xmin,xmax),ylim=c(ymin,ymax),cex=symbolsize,xlab=xlabel,ylab="",las=1)
		}else{
		plot(inputdf$xscore,inputdf$yscore,pch=16,log=mylog,col="white",xlim=c(xmin,xmax),ylim=c(ymin,ymax),cex=3,xlab=xlabel,ylab="",las=1)
		text(inputdf$xscore,inputdf$yscore,inputdf$labelscore,col=as.character(inputdf$popcol),cex=labelcex)
		}
	mtext(side=2,line=yline,ylabel,cex=3)
	if(!is.null(corrpos))
		{
		mycorr1		<- round(cor(inputdf$xscore,inputdf$yscore,method="pearson"),2)
		mycorr2		<- round(cor(inputdf$xscore,inputdf$yscore,method="spearman"),2)
		legend(corrpos,legend=c(paste("Pearson r: ",mycorr1,sep=""),paste("Spearman r: ",mycorr2,sep="")),bty='n',fill=NA,border=NA,cex=corrcex)
		}
	if(addlegend)
		{
		legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,cex=2.5,line=0.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

poppairscatter<-function(export=NULL,addlegend=TRUE,legendcex=2.5,plottitle=NULL,plotname="Poppair_scatter",xscore=mysambar$popneivector,yscore=mysambar$WC1983fstvector,xlabel="Nei's genetic distance (D)",ylabel="Weir & Cockerham 1983 Fst",legendpos="bottomright",yline=5.5,symbolsize=3.5,logx=FALSE,logy=FALSE,labelcex=1,corrpos=NULL,corrcex=1.75,alignaxes=FALSE)
	{
	pop1		<- mysambar$poppair1
	pop2		<- mysambar$poppair2
	if(is.null(mysambar$pairpopcol1))
		{
		cat("Generating mysambar$pairpop1 and mysambar$pairpop2.",sep="\n")
		popnames				<- mysambar$populations
		popcols					<- mysambar$mycolours
		npops					<- length(popnames)
		nsnps					<- nrow(snps)
		combitable				<- combn(popnames,m=2)
		mysambar$pairpop1		<<- combitable[1,]
		mysambar$pairpop2		<<- combitable[2,]
		mysambar$pairpopcol1	<<- vector()
		mysambar$pairpopcol2	<<- vector()
		for(k in c(1:ncol(combitable)))
			{
			mysambar$pairpopcol1[k]	<<- popcols[which(popnames==mysambar$pairpop1[k])]
			mysambar$pairpopcol2[k]	<<- popcols[which(popnames==mysambar$pairpop2[k])]
			}
		}
	popcol1		<- mysambar$pairpopcol1
	popcol2		<- mysambar$pairpopcol2
	if(is.null(xscore))
		{
		return(cat("ERROR: xscore not present.",sep="\n"))
		}
	if(is.null(yscore))
		{
		return(cat("ERROR: yscore not present.",sep="\n"))
		}
	inputdf			<- data.frame("xscore"=xscore,"yscore"=yscore)
	colnames(inputdf)<- c("xscore","yscore")
	#
	xmax			<- max(inputdf$xscore)
	xmin			<- min(inputdf$xscore)
	ymax			<- max(inputdf$yscore)
	ymin			<- min(inputdf$yscore)
	if(!is.null(export))
		{
		legendlabel	<- ifelse(addlegend,"withlegend","NOlegend")
		alignlabel	<- ifelse(alignaxes,"aligned","NOTaligned")
		if(export=="eps"){postscript(paste(plotname,alignlabel,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,alignlabel,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,alignlabel,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,alignlabel,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,8.5,2.5,0.5),cex.axis=2.5,cex.lab=3,cex.main=3)
	mylog	<- ifelse(logx,ifelse(logy,"xy","x"),ifelse(logy,"y",""))
	if(alignaxes)
		{
		axismin	<- min(c(inputdf$xscore,inputdf$yscore))
		axismax	<- max(c(inputdf$xscore,inputdf$yscore))
		plot(inputdf$xscore,inputdf$yscore,pch=21,lwd=5,log=mylog,col=as.character(popcol1),bg=as.character(popcol2),xlim=c(axismin,axismax),ylim=c(axismin,axismax),cex=symbolsize,xlab=xlabel,ylab="",las=1)
		lines(c(0,1),c(0,1),lty=2)
		}else{
		plot(inputdf$xscore,inputdf$yscore,pch=21,lwd=5,log=mylog,col=as.character(popcol1),bg=as.character(popcol2),xlim=c(xmin,xmax),ylim=c(ymin,ymax),cex=symbolsize,xlab=xlabel,ylab="",las=1)
		}
	mtext(side=2,line=yline,ylabel,cex=3)
	if(addlegend)
		{
		legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)
		}
	if(!is.null(corrpos))
		{
		mycorr1		<- round(cor(inputdf$xscore,inputdf$yscore,method="pearson"),2)
		mycorr2		<- round(cor(inputdf$xscore,inputdf$yscore,method="spearman"),2)
		legend(corrpos,legend=c(paste("Pearson r: ",mycorr1,sep=""),paste("Spearman r: ",mycorr2,sep="")),bty='n',fill=NA,border=NA,cex=corrcex)
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,cex=2.5,line=0.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 01-07-2022: function to generate dummy SambaR objects
# Can be useful for plotting output generated with software outside of R (for example for plotting iqtree and raxml phylogenies)
sambarsim<-function(nind=100,nsnps=1000,sampleinfo=NULL,do_confirm=FALSE,popordervec=NULL,colourvec=NULL)
	{
	if(!is.null(sampleinfo))
		{
		if(!is.data.frame(sampleinfo))
			{
			return(cat("ERROR: sampleinfo should be a dataframe.",sep="\n"))
			}
		if(any(!c("name","pop")%in%colnames(sampleinfo)))
			{
			return(cat("ERROR: sampleinfo should contain the columns 'name' and 'pop'.",sep="\n"))
			}
		if(nrow(sampleinfo)!=nind)
			{
			return(cat(paste("ERROR: number of rows of sampleinfo (",nrow(sampleinfo),") does not correspond with number specified to nind flag (",nind,").",sep=""),sep="\n"))
			}
		cat("Extracting sample names and population assignment from dataframe specified to sampleinfo flag...",sep="\n")
		indnames	<- sampleinfo$name
		popnames	<- sampleinfo$pop
		}else{
		cat("WARNING: no sample information provided. Generating genlight object with random sample names and population assignment.",sep="\n") 
		cat("To adjust sample names and population assignment, specify to the sampleinfo flag an input dataframe with columns 'name' and 'pop'.",sep="\n") 
		cat('An example dataframe can be created with the command: mydf<-data.frame("name"=paste("ind",c(1:100),sep=""),"pop"=c(rep("popA",50),rep("popB",50))).',sep='\n')
		indnames	<- paste("ind",c(1:nind),sep="")
		popnames	<- sample(c("popA","popB"),nind,replace=TRUE)
		}
	mygl			<<- glSim(n.ind=nind,n.snp.nonstruc=nsnps,n.snp.struc=0,ploidy=2)				
	mygl@ind.names	<<- indnames											
	pop(mygl)		<<- popnames															
	mygl@loc.names	<<- paste("snp",c(1:nsnps))											
	cat(" ",sep="\n")
	if(!do_confirm)
		{
		cat("WARNING: this function will create (and if necessary overwrite) SambaR output directories in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("If you agree, set the flag 'do_confirm' (i.e. sambarsim(do_confirm=TRUE)) to TRUE.",sep="\n")
		return(cat("If not, first navigate to another directory using setwd().",sep="\n"))
		}
	genlight2sambar(genlight_object="mygl",do_confirm=TRUE,pop_order=popordervec,colourvector=colourvec)						
	filterdata(dohefilter=FALSE,min_mac=1)														
	}

# if not importing data, but instead converting from a genlight object:
genlight2sambar<-function(genlight_object=NULL,do_confirm=FALSE,colourvector=NULL,popvector=NULL,major=1,minor=4,qcplot=TRUE,heplot=TRUE,silent=TRUE,allow_edit=FALSE,pop_order=NULL,reorder_snps=TRUE)
	{
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	options(scipen=999)		# 08-04-2020: to prevent that scaffold 900000 is renamed 9e+05
	#
	if(is.null(genlight_object))
		{
		return(cat("ERROR: provide name of the genlight object to the flag genlight_object.",sep="\n"))
		}
	if(!do_confirm)
		{
		cat("WARNING: this function will create (and if necessary overwrite) SambaR output directories in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("If you agree, set the flag 'do_confirm' (i.e. genlight2sambar(do_confirm=TRUE)) to TRUE.",sep="\n")
		return(cat("If not, first navigate to another directory using setwd().",sep="\n"))
		}
	cat("REMINDER: use quotes when specifying the input genlight_object, otherwise you will run into the error: 'Error in get(genlight_object, envir = myglobal) : invalid first argument'.",sep="\n")
	myglobal	<- globalenv()
	mygenlight	<<- get(genlight_object,envir=myglobal)
	mymat		<- as.matrix(mygenlight)
	mymat2		<- mymat!=0&mymat!=1&mymat!=2&!is.na(mymat)
	#any(mymat2)
	#	{
	#	mymat	<<- mymat
	#	mymat2	<<- mymat2	
	#	cat("ERROR: unexpected genotypes detected in input genlight object. Only values allowed are 0, 1, 2 and NA.",sep="\n")
	#	cat("The numbers 0, 1 and 2 represent the number of minor (or alternative) alleles.",sep="\n")
	#	cat("In other words, if a SNP contains the alleles A (major) and T (minor), the diploid genotypes AA, AT and TT should be encoded as 0, 1 and 2 respectively.",sep="\n")
	#	cat("In principle, you can convert the data by using some simple R commands, such as x[x=='NN']<-NA; x[x=='AA']<-0; x[x=='AT']<-1; x[x=='TT']<-2.",sep="\n")
	#	return(cat("Try rerunning the genlight2sambar() function once all genotypes have been converted to 0, 1 and 2.",sep="\n"))
	#	}
	if(is.null(mygenlight@ind.names))
		{
		cat("WARNING: slot ind.names not present in genlight object. Adding uninformative names instead.",sep="\n")
		nrinds					<- nrow(as.matrix(mygenlight))
		mygenlight@ind.names	<<- paste("Ind",c(1:nrinds),sep="")
		}
	if(is.null(mygenlight@loc.names))
		{
		if(!is.null(colnames(as.matrix(mygenlight))))
			{
			cat("WARNING: genlight object does not contain loc.names slot. Setting equal to data colnames.",sep="\n") 
			mygenlight@loc.names	<<- colnames(as.matrix(mygenlight))
			}else{
			cat("WARNING: slot loc.names not present in genlight object. Adding uninformative names instead.",sep="\n")
			nrsnps					<- ncol(as.matrix(mygenlight))
			mygenlight@loc.names	<<- paste("SNP",c(1:nrsnps),sep="")
			}
		}else{
		if(any(mygenlight@loc.names!=colnames(as.matrix(mygenlight))))
			{
			return(cat("ERROR: loc.names specified in input genlight object do not correspond with actual names in dataset (i.e.: colnames(as.matrix(mygl))).",sep="\n"))
			}
		}
	if(any(is.na(mygenlight@ind.names)))
		{
		return(cat("ERROR: NA-value in ind.names slot of input genlight object.",sep="\n"))
		}
	indvec	<- mygenlight@ind.names
	if(any(duplicated(indvec)))
		{
		dupvec	<<- indvec[duplicated(indvec)]
		cat("ERROR: duplicated sample names in ind.names slot of input genlight object.",sep="\n")
		cat("Type 'dupvec' to find out which names are duplicated.",sep="\n")
		return(cat("Please edit these names in the input genlight object (see: @ind.names) and afterwards try rerunning the 'genlight2sambar' function.",sep="\n"))
		}
	cat("Creating inds object...",sep="\n")
	nrinds		<- length(mygenlight@ind.names)
	if(is.null(mygenlight@pop))
		{
		mypops	<- rep("pop1",nrinds)		
		}else{
		mypops	<- as.vector(as.character(mygenlight@pop))
		if(length(mypops)!=nrinds)
			{
			return(cat("ERROR: length of pop slot in input genlight object does not correspond with number of individuals.",sep="\n"))
			}
		}
	inds		<<- data.frame("name"=as.vector(mygenlight@ind.names),"nr"=c(1:nrinds),"pop"=mypops,"pop2"=mypops)
	if(!is.null(popvector))
		{
		cat("WARNING: basing population assignment on information provided to the popvector flag. Assuming that the order of the samples in the genlight object corresponds to the order of the popvector.",sep="\n") 
		inds$pop		<<- as.character(popvector)
		inds$pop2		<<- as.character(popvector)
		mygenlight@pop	<<- as.factor(popvector)
		mypops			<-  as.character(popvector)
		}
	if(any(grepl("_",mypops)))
		{
		if(allow_edit)
			{
			cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
			cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
			mypops			<- as.character(inds$pop2)
			popvector		<- gsub("_","",mypops)
			inds$pop		<<- as.character(popvector)
			inds$pop2		<<- as.character(popvector)
			mygenlight@pop	<<- as.factor(popvector)
			mypops			<-  as.character(popvector)
			}else{
			cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
			cat("To solve this issue, edit population names and try again.",sep="\n")
			return(cat("Alternatively, allow SambaR to remove underscores from population names by setting the flag allow_edit to TRUE.",sep="\n"))
			}
		}
	popnames	<- as.vector(unique(as.character(mypops)))
	popnames	<- popnames[order(popnames)] 	
	npops		<- length(popnames)
	if(!silent){cat(paste("Number of populations: ",npops,sep=""),sep="\n")}
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","forestgreen","gray80","midnightblue","lavenderblush3","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	#defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours
		}
	ncolours			<- length(colourvector)
	if(npops>ncolours)
		{
		popnames		<<- popnames
		return(cat(paste("ERROR: more populations in (",npops,") (see popnames vector) than population colours (",ncolours,"). Please provide a longer vector of colour names to the colourvector flag.",sep=""),sep="\n"))
		}
	colvector			<-  colourvector[1:npops]
	# Note: this does not work correctly if inds$pop is originally a factor in which one or more levels are not present in the actual data. 
	# (Sounds strange, but this can happen. You would not notice when running the command 'unique(inputfactorvector)', only when running the command 'table(inputfactorvector)'. 
	inds$popcol			<<- colvector[as.factor(inds$pop)]
	if(any(is.na(inds$popcol)))
		{
		colvector		<<- colvector
		return(cat("ERROR: NA-values in inds$popcol column. Contact the developer of SambaR.",sep="\n"))
		}
	symbolvector		<-  c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype		<<- symbolvector[as.factor(inds$pop)]
	inds$symboltype2	<<- symbolvector[as.factor(inds$pop)]
	#
	mypopcolours		<-vector()
	for(k in c(1:npops))
		{
		mypop			<- popnames[k]
		mypopcolours[k]	<- inds$popcol[inds$pop==mypop][1]	
		}
	cat("Creating snps object...",sep="\n")
	nrsnps				<- length(mygenlight@loc.names)	
	if(is.null(mygenlight$chromosome)&!is.null(mygenlight$position))
		{
		cat("ERROR: input genlight object has a slot specifying chromosome names (mygl$chromosome) but not a slot specifying positions (mygl$position).",sep="\n")
		return(cat("SambaR only accepts as input genlight objects in which these slots are either both present or absent.",sep="\n"))
		}
	if(!is.null(mygenlight$chromosome)&is.null(mygenlight$position))
		{
		cat("ERROR: input genlight object has a slot specifying positions (mygl$positions) but not a slot specifying chromosome names (mygl$chromosome).",sep="\n")
		return(cat("SambaR only accepts as input genlight objects in which these slots are either both present or absent.",sep="\n"))
		}
	if(is.null(mygenlight@chromosome))
		{
		cat("WARNING: slot 'chromosome' not found in genlight object. Setting chromosome names to 'un' for unknown.",sep="\n")
		mychrnames		<- rep("un",nrsnps)
		}else{
		cat("Using chromosome names defined in slot 'chromosome' of input genlight object.",sep="\n")
		mychrnames		<- as.character(mygenlight@chromosome)
		}
	if(is.null(mygenlight@position))
		{
		cat("WARNING: slot 'position' not found in genlight object. Setting positions to arbitrary sequence of adjacent numbers.",sep="\n")
		mypos			<- seq(1:nrsnps)
		}else{
		cat("Using position values defined in slot 'position' of input genlight object.",sep="\n")
		mypos			<- mygenlight@position
		}
	snps				<<- data.frame("name"=as.vector(mygenlight@loc.names),"nr"=c(1:nrsnps),"chr"=mychrnames,pos=mypos)
	snps$morgan			<<- 0
	snps$uniqpos		<<- TRUE
	snps$genlightname	<<- mygenlight@loc.names
	snps$nr_neworder	<<- snps$nr
	if(length(unique(paste(snps$chr,snps$pos,sep="_")))==1)
		{
		return(cat("ERROR: why are all snps on same chromosome/position?",sep="\n"))
		}
	#
	# edit minor/major alleles columns:
	if(length(minor)==1|length(major)==1)
		{
		cat(" ",sep="\n")
		#cat("WARNING: genlight object does not contain info about type of allele (A,C,G,T). Assuming either A or T, or any other combination specified by minor and major flags.",sep="\n")
		cat("WARNING: only 1 allele type specified to the minor and/or major flag.",sep="\n")
		cat("SambaR will assume that all SNPs have the same type of minor or major allele (by default A for major and T for minor).",sep="\n")
		cat("This does not affect subsequent analyses, except for calculation of transition-transversion ratios and GC-content.",sep="\n")
		cat("Still, if you have the information on allele types (e.g. 1,2,3,4, or alternatively A,C,G,T, why not provide these vectors to the minor and major flags?",sep="\n") 
		cat(" ",sep="\n")
		}else{
		if(length(minor)!=nrow(snps)|length(major)!=nrow(snps))
			{
			return(cat("ERROR: length of vector(s) provided to minor/major flag not equal to number of SNPs in dataset, nor to 1.",sep="\n"))
			}else{
			minor		<- as.factor(minor)
			major		<- as.factor(major)
			}
		}
	snps$minor			<<- minor
	snps$major			<<- major
	#
	# addition 29-04-2020:
	if(is.factor(snps$minor))
		{
		minorvec		<- as.character(snps$minor)
		if(any(c("A","C","T","G")%in%minorvec))
			{
			cat("Converting snps$minor factor to character vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- minorvec
			}else{
			cat("Converting snps$minor factor to integer vector...",sep="\n")
			snps$minor	<<- NULL
			snps$minor	<<- as.integer(minorvec)
			}
		}else{
		cat("snps$minor not factor class.",sep="\n")
		}
	if(is.factor(snps$major))
		{
		majorvec		<- as.character(snps$major)
		if(any(c("A","C","T","G")%in%majorvec))
			{
			cat("Converting snps$major factor to character vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- majorvec
			}else{
			cat("Converting snps$major factor to integer vector...",sep="\n")
			snps$major	<<- NULL
			snps$major	<<- as.integer(majorvec)
			}
		}else{
		cat("snps$major not factor class.",sep="\n")
		}
	#
	snps$minor[snps$minor==0]	<<- NA	# In case data is non-polymorphic
	#
	myalleles		<- as.vector(unique(snps$minor))
	if(any(is.na(myalleles)))
		{
		cat("WARNING: non-defined allele (NA or 0) present in vectors given as input to minor flag.",sep="\n")
		myalleles	<- myalleles[!is.na(myalleles)]
		}
	if(is.integer(snps$minor)|is.numeric(snps$minor))
		{
		if(any(myalleles!=1&myalleles!=2&myalleles!=3&myalleles!=4))
			{
			myalleles	<<- myalleles
			return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 (integer) or A,C,T,G. You can observe the alleles by typing 'myalleles'.",sep="\n")) 
			}
		snps$minor2										<<- NA
		snps$minor2[snps$minor==1&!is.na(snps$minor)]	<<- "A"
		snps$minor2[snps$minor==2&!is.na(snps$minor)]	<<- "C"
		snps$minor2[snps$minor==3&!is.na(snps$minor)]	<<- "G"
		snps$minor2[snps$minor==4&!is.na(snps$minor)]	<<- "T"
		}else{
		if(is.character(snps$minor))
			{
			if(any(myalleles!="A"&myalleles!="C"&myalleles!="G"&myalleles!="T"))
				{
				myalleles	<<- myalleles
				return(cat("ERROR: encountered unexpected allele in bim file. Alleles should be either 1,2,3,4 or A,C,T,G (character). You can observe the alleles by typing 'myalleles'.",sep="\n")) 
				}
			snps$minor2										<<- snps$minor
			snps$minor										<<- NA
			snps$minor[snps$minor2=="A"&!is.na(snps$minor2)]<<- 1
			snps$minor[snps$minor2=="C"&!is.na(snps$minor2)]<<- 2
			snps$minor[snps$minor2=="G"&!is.na(snps$minor2)]<<- 3
			snps$minor[snps$minor2=="T"&!is.na(snps$minor2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	#
	if(is.integer(snps$major)|is.numeric(snps$major))
		{
		snps$major2										<<- NA
		snps$major2[snps$major==1&!is.na(snps$major)]	<<- "A"
		snps$major2[snps$major==2&!is.na(snps$major)]	<<- "C"
		snps$major2[snps$major==3&!is.na(snps$major)]	<<- "G"
		snps$major2[snps$major==4&!is.na(snps$major)]	<<- "T"
		}else{		# if in bim-file data is encoded as A,C,G,T rather than 1,2,3,4.
		if(is.character(snps$major))
			{
			snps$major2										<<- snps$major
			snps$major										<<- NA
			snps$major[snps$major2=="A"&!is.na(snps$major2)]<<- 1
			snps$major[snps$major2=="C"&!is.na(snps$major2)]<<- 2
			snps$major[snps$major2=="G"&!is.na(snps$major2)]<<- 3
			snps$major[snps$major2=="T"&!is.na(snps$major2)]<<- 4
			}else{
			return(cat("ERROR: class of snps$minor not numeric, integer or character. Please contact the developer of SambaR.",sep="\n")) 
			}
		}
	snps$minor2[snps$minor2=="0"]	<<- NA
	#
	# check if expected alleles (A, C, T, G) only:
	myalleles1			<- names(table(snps$minor2))
	myalleles1			<- myalleles1[myalleles1!="A"&myalleles1!="C"&myalleles1!="G"&myalleles1!="T"&myalleles1!="0"]
	myalleles2			<- names(table(snps$major2))
	myalleles2			<- myalleles2[myalleles2!="A"&myalleles2!="C"&myalleles2!="G"&myalleles2!="T"&myalleles2!="0"]
	myalleles			<- c(myalleles1,myalleles2)
	if(length(myalleles)>0)
		{
		myalleles		<- myalleles[!is.na(myalleles)]
		if(length(myalleles)>0)
			{
			myotheralleles	<<- myalleles
			if(!acceptalleles)
				{
				cat("ERROR: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("If you want to continu trying to import the data anyway, set the 'acceptalleles' flag to TRUE (i.e. importdata(acceptalleles=TRUE)).",sep="\n")
				return(cat("Note however that downstream this could lead to errors.",sep="\n"))
				}else{
				cat("WARNING: unexpected alleles (other than NA,A,C,T,G or 0,1,2,3,4) present in data.",sep="\n")
				cat("Note that missing data should be encoded by o rather than by N.",sep="\n")
				cat("You can observe these alleles by typing 'myotheralleles'.",sep="\n")
				cat("Because the flag 'acceptalleles' is set to TRUE, SambaR will continu to import the data. However, you might encounter errors downstream.",sep="\n")
				}
			}
		}
	if(!silent){cat("Assigning index based on length of chromosomes...",sep="\n")}
	mychrs				<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
	mychrs2				<- mychrs[order(-mychrs$x),]
	mychrs2$chr2		<- c(1:nrow(mychrs2))
	colnames(mychrs2)	<- c("chr","chrlength","chr2")
	mychrs2$chrcol		<- ifelse(mychrs2$chr2%%2==0,"black","grey40")
	snps				<<- merge(snps,mychrs2,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	if(!silent){cat("Counting number of SNPs per scaffold...",sep="\n")}
	myn					<- table(snps$chr)
	myndf				<- data.frame("chr"=names(myn),"nsnps"=as.vector(myn))
	snps				<<- merge(snps,myndf,by="chr",all=TRUE)
	snps				<<- snps[order(snps$nr),]
	cat("Creating mygenlight object...",sep="\n")
	mymatrix			<- as.matrix(mygenlight)
	colnames(mymatrix)	<- snps$genlightname
	rownames(mymatrix)	<- inds$name
	mygenlight			<<- as.genlight(mymatrix)
	mygenlight@pop		<<- as.factor(inds$pop)
	mygenlight@ind.names<<- as.character(rownames(mymatrix))
	mygenlight@loc.names<<- as.character(colnames(mymatrix))
	if(any(colnames(as.matrix(mygenlight))!=snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(reorder_snps)
		{
		cat("Reordering snps dataframe and genlight object based on chromosome name and chromosome position. If you receive an error after this line, set the flag 'reorder_snps' to FALSE.",sep="\n")
		mysnpsorder			<- order(snps$chr,snps$pos)
		snps				<<- snps[mysnpsorder,]
		mygenlight			<<- mygenlight[,mysnpsorder]
		if(any(mygenlight$loc.names!=snps$genlightname))
			{
			return(cat("ERROR: after reordering, snps$genlightname does not correspond to mygenlight@loc.names. Set the flag 'reorder_snps' to FALSE (or contact developer of SambaR).",sep="\n"))
			}
		snps$nr_neworder	<<- c(1:nrow(snps))
		}
	cat("Calculating distances between SNPs...",sep="\n")
	new_chr				<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	new_chr				<- c(TRUE,new_chr[1:(length(new_chr)-1)])
	snps$new_chr		<<- TRUE
	mydist				<- c(as.vector(snps$pos[2:length(snps$pos)]),NA)-snps$pos
	mydist				<- c(NA,mydist[1:(length(mydist)-1)])
	mydist[new_chr]		<- NA
	snps$dist			<<- as.numeric(mydist)
	snps$dist2			<<- !(is.na(snps$dist))
	# Are snps on same position? (STACKS sometimes outputs two snps which are in fact on same position within genome)
	snps$name2			<<- paste(snps$chr,snps$pos,sep="_")
	snps$samepos		<<- (duplicated(snps$name2,fromLast=FALSE))|(duplicated(snps$name2,fromLast=TRUE))
	snps$uniqpos		<<- !(snps$samepos)
	snps$polyfilter		<<- ifelse(is.na(snps$minor),FALSE,TRUE)
	snps$placed			<<- FALSE
	snps$autosomal		<<- FALSE
	snps$placedcol		<<- "black"
	snps$depthfilter	<<- TRUE
	if(length(unique(paste(snps$chr,snps$pos,sep="_")))==1)
		{
		return(cat("ERROR: why are all snps on same chromosome/position?",sep="\n"))
		}
	if(nrow(snps[!snps$samepos,])==0)
		{
		return(cat("ERROR: why are so many SNPs found on the same position? (see column snps$pos).",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!as.character(row.names(as.matrix(mygenlight)))==as.character(as.vector(inds$name))))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column (prior to reordering). Contact developer of SambaR.",sep="\n"))
		}
	cat("Reordering rows of inds and genlight object on alphabetical order of sample names.",sep="\n")  
	ordervec			<-  order(inds$name)
	inds				<<- inds[ordervec,]
	mygenlight			<<- mygenlight[ordervec,]
	if(any(!as.character(row.names(as.matrix(mygenlight)))==as.character(as.vector(inds$name))))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column (after reordering). Contact developer of SambaR.",sep="\n"))
		}
	#	
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	kinshipdir			<- paste(sambardir,"Kinship",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(sambardir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(QCdir)){dir.create(file.path(kinshipdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	cat("SambaR output directory created in the directory:",sep="\n")
	cat(getwd(),sep="\n")
	cat(" ",sep="\n")
	#
	# create inds2 (sample pairs) and pops2 (pop pairs) dataframes:
	getinds2()
	if(any(is.na(inds2$indpair))){return(cat("ERROR: NA-values in inds2$indpair column.",sep="\n"))} 
	getpops2()
	#
	cat("Creating mysambar list object...",sep="\n")
	mysambar				<<- list()
	mysambar[[1]]			<<- popnames
	mysambar[[5]]			<<- inputdatadir
	mysambar[[6]]			<<- sambardir
	mysambar[[7]]			<<- QCdir
	mysambar[[8]]			<<- structuredir
	mysambar[[9]]			<<- divergencedir
	mysambar[[10]]			<<- diversitydir
	mysambar[[11]]			<<- demographydir
	mysambar[[12]]			<<- selectiondir
	mysambar[[13]]			<<- inputfilesdir
	mysambar[[14]]			<<- "sans"
	mysambar[[17]]			<<- mypopcolours
	mysambar[[18]]			<<- geomapsdir
	names(mysambar)			<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$inds2			<<- inds2
	mysambar$pops2			<<- pops2
	mysambar$os				<<- as.vector(Sys.info()["sysname"])
	mysambar$populations2	<<- mysambar$populations
	mysambar$mycolours2		<<- mysambar$mycolours
	mysambar$defaultcolours	<<- defaultcolours	
	mysambar$datasource		<<- "converted_from_genlight"
	mysambar$kinshipdir		<<- kinshipdir
	#
	# check:
	if(!silent){cat("Checking pop colours...",sep="\n")}
	checkpopcolours()
	if(mysambar$colourerror){return(cat(" ",sep="\n"))}
	#
	reorderpop(poporder=pop_order)
	if(mysambar$reordererror)
		{
		return(cat("ERROR: problem with reordering of populations (see previous lines).",sep="\n"))
		}
	#
	cat("DATA SUCCESFULLY CONVERTED TO SAMBAR OBJECTS.",sep="\n")
	cat("ANY ERRORS OCCURRING AFTER THIS LINE ARE RELATED TO CREATING QUALITY CONTROL TABLES AND PLOTS AND WILL NOT DENY YOU FROM RUNNING SUBSEQUENT FUNCTIONS.",sep="\n")
	cat(" ",sep="\n")
	#
	cat("Creating list of installed R package versions...",sep="\n")
	getversions()
	#
	cat(" ",sep="\n")
	cat("Creating quality control plots which can be used for choosing the right settings when running the filterdata function...",sep="\n")
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	if(qcplot)
		{	
		cat("Creating data_quality plot...",sep="\n")
		cat("If you receive an error after this line, rerun the genlight2sambar()-function with the flag 'qcplot' set to FALSE. I.e.: genlight2sambar(qcplot=FALSE).",sep="\n")
		calcretainedsnps(export="pdf",logy=TRUE)
		calcretainedsnps(export="pdf",logy=FALSE)
		}
	if(heplot)
		{
		cat("Creating He_vs_miss plot...",sep="\n")
		cat("If you receive an error after this line, type 'dev.off()' and rerun the genlight2sambar()-function with the flag 'heplot' set to FALSE. I.e.: genlight2sambar(heplot=FALSE).",sep="\n")
		indhetero_allsnps()
		#myminsites	<- ifelse(0.01*nrow(snps)<200,200,0.01*nrow(snps))
		He_vs_miss(export="pdf",allsites=TRUE,minsites=200)
		#cat("Not included in the plot are samples with less than 250 non-missing data points.",sep="\n")
		}
	#
	cat(" ",sep="\n")
	cat("Conversion finished :-)",sep="\n")
	cat("New inds, snps and mygenlight objects, as well as data quality plots have been succesfully created.",sep="\n")
	cat("ROUGH GUIDELINES BEFORE RUNNING THE FILTERDATA() FUNCTION:",sep="\n")
	cat("Before running the filterdata() function, observe the figures 'Data_quality' and/or 'He_vs_miss_ind.allsites.pop' to determine an appropriate value for the indmiss and snpmiss arguments.",sep="\n")
	cat("If you are mainly interested in structure analyses, set snpmiss to 0 (or if needed a bit higher, but preferably not higher than 0.05) and indmiss to the highest value which returns at least a few thousands SNPs scattered across the entire genome (see black line in 'Data_quality.log_yaxis').",sep="\n")
	cat("The reason is that variation in missingness among samples will affect the outcome of structure analyses. A few thousand SNPs from across the entire genome are generally sufficient to detect population structure (although this obviously depends on your study system).",sep="\n")
	cat("For other purposes (e.g. genetic diversity and selection analyses (especially the latter), you are probably better off by setting a more strict threshold for indmiss (default is 0.25) and more relaxed threshold for snpmiss (default is 0.1).",sep="\n")
	cat("If you are mainly interested in comparing genetic diversity among your study populations, observe the 'He_vs_miss_ind.allsites.pop'.",sep="\n")
	cat("Set indmiss to the highest value (which might be as low as 0.05) such that for retained individuals there is no relation between heterozygosity and their proportions of missing data.",sep="\n")
	options(scipen=0)	# 08-04-2020: reset scientific notation (because disabled at start of function)
	}	

getsymbol2<-function(mysambarcolours=mysambar$mycolours)
	{
	symbolvector		<- c(15,16,17,18,0,1,2,6,3,4,5,8)
	inds$symboltype2	<<- symbolvector[as.factor(inds$pop)]
	if(any(as.vector(inds$pop)!=as.vector(inds$pop2)))
		{
		populations		<- as.vector(unique(inds$pop))
		populations		<- populations[order(populations)] 
		npops			<- length(populations)
		for(j in c(1:npops))
			{
			mypop		<- populations[j]
			subpops		<- as.vector(inds$pop2[inds$pop==mypop])
			inds$symboltype2[inds$pop==mypop]	<<- symbolvector[as.factor(subpops)]
			}
		}
	}

# define popcol2 (for subpopulations, if applicable). Doesn't give nice results, so not used.
getcol2<-function(mysambarcolours=mysambar$mycolours)
	{
	inds$popcol2		<<- inds$popcol
	if(any(as.vector(inds$pop)!=as.vector(inds$pop2)))
		{
		populations		<- as.vector(unique(inds$pop))
		populations		<- populations[order(populations)] 
		npops			<- length(populations)
		for(j in c(1:npops))
			{
			mypop		<- populations[j]
			mypopcol	<- mysambarcolours[j]
			cat(mypop,sep="\n")
			#
			popinds		<- as.vector(inds$name[inds$pop==mypop])
			subpops		<- as.vector(inds$pop2[inds$pop==mypop])
			npopinds	<- length(popinds) 
			#
			subpopnames	<- unique(subpops)
			subpopnames	<- subpopnames[order(subpopnames)]
			nsubpop		<- length(subpops)
			#
			if(length(grep("grey",mypopcol))==0)
				{
				cat("grey is NOT main colour",sep="\n")
				mycolfunc 	<- colorRampPalette(c("grey",mypopcol))
				mycolours	<- mycolfunc(nsubpop+1)
				mycolours	<- mycolours[2:(nsubpop+1)]
				}else{
				cat("grey is main colour",sep="\n")
				mycolfunc 	<- colorRampPalette(c("grey90",mypopcol))
				mycolours	<- mycolfunc(nsubpop+1)
				mycolours	<- mycolours[2:(nsubpop+1)]
				}
			for (k in c(1:npopinds))
				{
				myind	<- popinds[k]
				mysubpop<- subpops[k]
				mypopnr	<- which(subpopnames==mysubpop)
				mycol	<- as.vector(mycolours[mypopnr])
				inds$popcol2[inds$name==myind]	<<- mycol
				}
			}
		}
	}

addgeofile<-function(geofile=NULL)
	{
	if(is.null(geofile))
		{
		return(cat("Error: provide input to geofile flag.",sep="\n"))
		}else{
		cat("Looking for input file in the following directory:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		setwd(mysambar$inputdatadir)
		cat("Adding geographical coordinates to inds dataframe...",sep="\n")
		mygeo			<- read.table(geofile,header=TRUE)
		if(any(!(c("sample","longitude","latitude")%in%colnames(mygeo))))
			{
			return(cat("ERROR: geofile should contain columns named 'sample', 'longitude' and 'latitude'.",sep="\n"))
			}
		mygeo			<- mygeo[order(mygeo$sample),]
		inds$longitude	<<- mygeo$longitude
		inds$latitude	<<- mygeo$latitude
		if(class(inds$longitude)=="factor")
			{
			cat("WARNING: Longitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
			inds$longitude	<<- as.numeric(as.character(inds$longitude))
			}
		if(class(inds$latitude)=="factor")
			{	
			cat("WARNING: Latitude values in geofile are stored as factor. Converting to numeric, but this might affect the values.",sep="\n")
			inds$latitude	<<- as.numeric(as.character(inds$latitude))
			}
		# pacific or atlantic centred map?
		inds$longitude2	<<- ifelse(inds$longitude>=0,inds$longitude,abs(inds$longitude)+180)
		inds$longitude3	<<- ifelse(inds$longitude>=-15,inds$longitude,180+(180-abs(inds$longitude)))
		}
	}

addsnpinfo<-function(snpinfofile=NULL)
	{
	if(is.null(snpinfofile))
		{
		return(cat("Error: provide input to snpinfofile flag.",sep="\n"))
		}
	cat("Looking for input file in the following directory:",sep="\n")
	cat(getwd(),sep="\n")
	myinfo			<<- read.table(snpinfofile,header=TRUE)	
	if(!"name"%in%colnames(myinfo))
		{
		return(cat("ERROR: sample info file should contain a column named 'name'.",sep="\n"))
		}
	myinfo			<<- myinfo[order(myinfo$name),]
	mycolnames		<- colnames(myinfo)
	mycolnames		<- mycolnames[!mycolnames=="name"]		
	present_in_snps	<- mycolnames%in%colnames(snps)
	if(any(present_in_snps))
		{
		cat("WARNING: removing from inds dataframe columns with columnnames with match with column names in info file.",sep="\n")	
		for(j in c(1:length(mycolnames)))
			{
			mycolname	<- as.character(mycolnames[j])
			colfilter	<- colnames(snps)!=mycolname
			snps		<- snps[,colfilter] 
			}
		}
	myinfotemp			<- myinfo
	snpstemp			<- merge(snps,myinfotemp,all=TRUE,by="name")
	snpstemp			<- indstemp[order(indstemp$name),]
	if(any(!as.character(col.names(as.matrix(mygenlight)))==as.character(as.vector(snpstemp$name))))
		{
		return(cat("ERROR: colnames of genlight object do not correspond with snps$name column. Contact developer of SambaR.",sep="\n"))
		}
	snps		<<- snpsstemp
	cat("Information added to the snps dataframe.",sep="\n")
	}	

# depreciated at 04-05-2021:
addsnpinfo_old<-function()
	{
	mynamevec	<- c("class","impact","gene","exon","nucl_mut","aa_mut","codon_nr","aa_nr")
	if(any(mynamevec%in%colnames(snps)))
		{
		cat("Removing existing columns in snps dataframe...",sep="\n")
		mynrs	<- which(mynamevec %in% colnames(snps))
		for(i in mynrs)
			{
			mycolname	<- mynamevec[i]
			snps[,colnames(snps)==mycolname]	<<- NULL
			}
		}
	cat("Adding columns with snps information to snps dataframe...",sep="\n")
	setwd(mysambar$inputdatadir)
	myann		<<- read.table("snp_ann.txt",header=TRUE)
	myann$name3	<<- as.factor(paste(myann$chrom,myann$pos,sep=":"))
	myann$chrom	<<- NULL
	myann$pos	<<- NULL
	myann		<<- myann[myann$name3%in%snps$name3,]
	snpstemp	<<- merge(snps,myann,by="name3",all=TRUE)
	snps		<<- snpstemp[order(snpstemp$chr,snpstemp$pos),]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	snps$impact		<<- as.character(snps$impact)
	snps$gene		<<- as.character(snps$gene)
	snps$exon		<<- as.character(snps$exon)
	snps$nucl_mut	<<- as.character(snps$nucl_mut)
	snps$aa_mut		<<- as.character(snps$aa_mut)
	snps$codon_nr	<<- as.character(snps$codon_nr)
	snps$aa_nr		<<- as.character(snps$aa_nr)
	snps$class		<<- as.character(snps$class)
	#
	snps$impact[is.na(snps$class)]	<<- "intergenic"
	snps$gene[is.na(snps$class)]	<<- "intergenic"
	snps$exon[is.na(snps$class)]	<<- "intergenic"
	snps$nucl_mut[is.na(snps$class)]<<- "intergenic"
	snps$aa_mut[is.na(snps$class)]	<<- "intergenic"
	snps$codon_nr[is.na(snps$class)]<<- "intergenic"
	snps$aa_nr[is.na(snps$class)]	<<- "intergenic"
	snps$class[is.na(snps$class)]	<<- "intergenic"
	}

addsampleinfo<-function(samplefile="sample_info.txt",filteronly=TRUE,geomap_thres=-15)
	{
	return(cat("ERROR: the function 'addsampleinfo()' has been renamed to 'add2inds()'.",sep="\n"))
	}

# 22-06-2022: renamed from 'addsampleinfo' to 'add2inds'
add2inds<-function(samplefile=NULL,filteronly=FALSE,geomap_thres=-15)
	{
	cat("Adding information to inds (NOT inds2!) dataframe.",sep="\n")
	if(is.null(samplefile))
		{
		return(cat("Error: provide input to samplefile flag.",sep="\n"))
		}
	cat("Looking for input file in the following directory:",sep="\n")
	cat(mysambar$inputdatadir,sep="\n")
	setwd(mysambar$inputdatadir)
	myinfo			<<- read.table(samplefile,header=TRUE)
	if(!"name"%in%colnames(myinfo))
		{
		return(cat("ERROR: sample info file should contain a column named 'name'.",sep="\n"))
		}
	myinfo			<<- myinfo[order(myinfo$name),]
	if(filteronly)
		{
		indsretained<- inds[inds$filter,]
		}else{
		indsretained<- inds
		}
	indsretained	<- indsretained[order(indsretained$name),]
	if(nrow(myinfo)!=nrow(indsretained))
		{
		if(filteronly)
			{
			return(cat("ERROR: number of samples in sample info (see 'myinfo') does not correspond with number of retained individuals in inds dataframe.",sep="\n"))	
			}else{
			if(nrow(myinfo)>nrow(indsretained))
				{
				cat("Selecting within input dataframe sample names which occur in inds dataframe.",sep="\n")
				myinfo	<- myinfo[myinfo$name%in%indsretained$name,]
				if(nrow(myinfo)!=nrow(indsretained))
					{
					return(cat("ERROR: after subselecting, number of samples in sample info (see 'myinfo') does not correspond with number of individuals in inds dataframe.",sep="\n"))
					}
				}else{
				return(cat("ERROR: number of samples in sample info (see 'myinfo') does not correspond with number of individuals in inds dataframe.",sep="\n"))
				}
			}
		}
	if(any(!as.character(myinfo$name)==as.character(indsretained$name)))
		{
		return(cat("ERROR: sample names in sample info file (see 'myinfo') do not correspond with inds$name column.",sep="\n"))	
		}
	mycolnames		<- colnames(myinfo)
	mycolnames		<- mycolnames[!mycolnames=="name"]
	present_in_inds	<- mycolnames%in%colnames(inds)
	if(any(present_in_inds))
		{
		cat("WARNING: removing from inds dataframe columns with columnnames with match with column names in info file.",sep="\n")	
		for(j in c(1:length(mycolnames)))
			{
			mycolname	<- as.character(mycolnames[j])
			#mynewname	<- paste(mycolname,"old",sep="_")
			#cat(mynewname,sep="\n")
			colfilter	<- colnames(inds)!=mycolname
			inds		<- inds[,colfilter] 
			}
		#return(cat("ERROR: one or more column names within sample info file (apart from 'name') already present in inds data frame. Not adding information.",sep="\n"))	
		}
	#myinfotemp			<- myinfo[,!present_in_inds]
	#myinfotemp$name	<- myinfo$name
	myinfotemp			<- myinfo
	indstemp			<- merge(inds,myinfotemp,all=TRUE,by="name")
	indstemp			<- indstemp[order(indstemp$name),]
	if(any(!as.character(row.names(as.matrix(mygenlight)))==as.character(as.vector(indstemp$name))))
		{
		indstemp		<<- indstemp
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	geobool				<- "longitude"%in%colnames(indstemp)&"latitude"%in%colnames(indstemp)
	if(geobool)
		{
		# pacific or atlantic centred map?
		cat("Adding longitude2 and longitude3 column, using geomap_thres (default= -15)...",sep="\n")
		mylong	<- as.numeric(sub(",",".",as.character(indstemp$longitude)))
		mylat	<- as.numeric(sub(",",".",as.character(indstemp$latitude)))
		indstemp$longitude	<- NULL
		indstemp$latitude	<- NULL
		indstemp$longitude	<- mylong
		indstemp$latitude	<- mylat
		#
		indstemp$longitude2	<- ifelse(indstemp$longitude>=0,indstemp$longitude,abs(indstemp$longitude)+180)
		indstemp$longitude3	<- ifelse(indstemp$longitude>=geomap_thres,indstemp$longitude,180+(180-abs(indstemp$longitude)))
		}
	inds		<<- indstemp
	if(geobool)
		{
		cat("Adding geographical distances to inds2 dataframe...",sep="\n")
		inds2$long1			<- NA
		inds2$long2			<- NA
		inds2$lat1			<- NA
		inds2$lat2			<- NA
		for(i in c(1:nrow(inds2)))
			{
			ind1			<- as.character(inds2$name1[i])
			ind2			<- as.character(inds2$name2[i])
			if(!ind1%in%inds$name|!ind2%in%inds$name)
				{
				return(cat("ERROR: individual listed in inds2 dataframe not present in inds dataframe.",sep="\n"))
				}
			inds2$long1[i]	<- indstemp$longitude3[as.character(indstemp$name)==ind1]
			inds2$long2[i]	<- indstemp$longitude3[as.character(indstemp$name)==ind2]
			inds2$lat1[i]	<- indstemp$latitude[as.character(inds$name)==ind1]
			inds2$lat2[i]	<- indstemp$latitude[as.character(inds$name)==ind2]
			}
		cat("Calculating choord distance...",sep="\n")
		inds2temp		<<- inds2
		# chord distance (in degrees):
		long			<- abs(inds2$long2-inds2$long1)
		lat				<- abs(inds2$lat2-inds2$lat1)
		inds2$chorddist	<- sqrt(long^2+lat^2)
		#
		# great circle distance (in km):
		cat("Calculating great circle distance...",sep="\n")
		lat1			<- inds2$lat1*pi/180
		lat2			<- inds2$lat2*pi/180
		long1			<- inds2$long1*pi/180
		long2			<- inds2$long2*pi/180
		inds2$geodist 	<- acos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2) * cos(long2-long1)) * 6371	# 6371 is estimate of earth mean radius in km
		inds2$geodist[!is.finite(inds2$geodist)]	<- NA
		inds2$geodist	<- inds2$geodist/100		# unit: 100 km
		#
		cat("Adding geographical distances to pops2 dataframe...",sep="\n")
		for(i in c(1:nrow(pops2)))
			{
			pop1			<- pops2$pop1[i]
			pop2			<- pops2$pop2[i]
			pops2$long1[i]	<- mean(indstemp$longitude3[as.character(indstemp$pop)==pop1&indstemp$filter],na.rm=TRUE)
			pops2$long2[i]	<- mean(indstemp$longitude3[as.character(indstemp$pop)==pop2&indstemp$filter],na.rm=TRUE)
			pops2$lat1[i]	<- mean(indstemp$latitude[as.character(indstemp$pop)==pop1&indstemp$filter],na.rm=TRUE)
			pops2$lat2[i]	<- mean(indstemp$latitude[as.character(indstemp$pop)==pop2&indstemp$filter],na.rm=TRUE)
			}
		# chord distance (in degrees):
		long			<- abs(pops2$long2-pops2$long1)
		lat				<- abs(pops2$lat2-pops2$lat1)
		pops2$chorddist	<- sqrt(long^2+lat^2)
		# great circle distance (in km):
		lat1			<- pops2$lat1*pi/180
		lat2			<- pops2$lat2*pi/180
		long1			<- pops2$long1*pi/180
		long2			<- pops2$long2*pi/180
		pops2$geodist 	<- acos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2) * cos(long2-long1)) * 6371	# 6371 is estimate of earth mean radius in km
		pops2$geodist[!is.finite(pops2$geodist)]	<- NA
		pops2$geodist	<- pops2$geodist/100		# unit: 100 km
		inds2			<<- inds2
		pops2			<<- pops2
		}
	cat("Information added to the inds, inds2 and pops2 dataframes.",sep="\n")
	}	

# function to add single vectors to inds dataframe:
addinfo2inds<-function(namevec=sampleinfo$name,infovec=sampleinfo$regionhe,infovec2=sampleinfo$regionhe2)
	{
	inds$regionhe	<<- NA
	inds$regionhe2	<<- NA
	namevec			<- as.character(namevec)
	for(j in c(1:nrow(inds)))
		{
		cat(j,sep="\n")
		myname				<- as.character(inds$name[j])
		mynr				<- which(namevec==myname)
		cat(mynr,sep="\n")
		if(length(mynr)==0)
			{
			inds$regionhe[j]	<<- NA 
			inds$regionhe2[j]	<<- NA 
			}else{
			inds$regionhe[j]	<<- infovec[mynr] 
			inds$regionhe2[j]	<<- infovec2[mynr] 
			}
		}
	}

# function to add a second population structure (columns 'inds$subpop' and 'inds$subpopcol'):
# 24-04-2020: depreciated since inds$pop2 is now used to defined subpopulations	
addpop<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(is.null(samplefile))
		{
		return(cat("ERROR: Provide an input file to samplefile flag."),sep="\n")
		}
	# cat("Extracting information from sample file...",sep="\n")
	popinput			<- read.table(samplefile,header=FALSE)
	colnames(popinput)	<- c("name","pop")
	# reorder vcf-file:
	popinput			<- popinput[order(popinput$name),]
	# now extract information:
	inds$subpop			<<- popinput$pop
	#
	# add colours:
	mypops				<- as.vector(unique(inds$subpop))
	colvector			<- mycolours[1:length(mypops)] 
	inds$subpopcol		<<- colvector[as.factor(inds$subpop)]
	# add to mysambar list:
	mysambar$subpop		<<- mypops[order(mypops)]
	mysambar$subpopcol	<<- mycolours
	cat("Columns 'subpop' and 'subpopcol' added to inds dataframe.",sep="\n")
	cat("Vectors 'subpop' and 'subpopcol' added to mysambar list.",sep="\n")
	}

# 27-07-2021: function to change population assignment of a single sample.
addpop<-function(myind="TorontoZoo",mypop="zoohybrid",mycol="red")
	{
	# edit mysambar list:
	mysambar$populations2						<<- c(mysambar$populations2,mypop)
	mysambar$mycolours2							<<- c(mysambar$mycolours2,mycol)
	myorder										<- order(mysambar$populations2)
	mysambar$populations2						<<- mysambar$populations2[myorder]
	mysambar$mycolours2							<<- mysambar$populations2[myorder]
	#
	# edit inds dataframe:
	inds$pop3									<<- as.character(inds$pop)
	inds$pop3[as.character(inds$name)==myind]	<<- "zoohybrid"
	inds$pop									<<- as.factor(inds$pop3)
	#
	excludepop()
	snpsmissingness()
	snp_maf()
	}

# function to redefine population assignment:	
replacepop<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(!is.null(samplefile))
		{
		cat("Extracting information from sample file...",sep="\n")
		# 21-2-20: I originally called this vcfinput file and I decided not to change it.
		vcfinput		<- read.table(samplefile,header=TRUE)
		if(ncol(vcfinput)<2)
			{
			return(cat("ERROR: Sample file should contain at least two columns ('name' and 'pop').",sep="\n"))
			}
		if("name"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop').",sep="\n"))
			}
		if("pop"%in%colnames(vcfinput))
			{
			return(cat("ERROR: As of 24-04-2020, the sample file should contain column names (at minimum 'name' and 'pop').",sep="\n"))
			}
		if("pop2"%in%colnames(vcfinput))
			{
			vcfinput$pop2	<- vcfinput$pop
			}
		# reorder vcf-file:
		vcfinput$name	<- as.character(vcfinput$name) 
		vcfinput		<- vcfinput[order(vcfinput$name),]
		# now extract information:
		if(any(as.vector(as.character(vcfinput$name))!=as.vector(as.character(inds$name))))
			{
			cat("ERROR: Sample names in sample file do not correspond with names in inds dataset.",sep="\n")
			samplefilenames	<<- as.vector(vcfinput$name) 
			indsdatanames	<<- as.vector(inds$name)
			booldatanames	<<- as.vector(as.character(vcfinput$name))==as.vector(as.character(inds$name))
			cat("Sample names in sample file can be observed by typing: samplefilenames.",sep="\n")
			cat("Sample names in inds dataset can be observed by typing: indsdatanames.",sep="\n")
			return(cat("The similarity between both vectors can be observed by typing: booldatanames.",sep="\n"))
			}
		if(any(grepl("_",vcfinput$pop))|any(grepl("_",vcfinput$pop2)))
			{
			if(allow_edit)
				{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will remove underscores from population names and continue.",sep="\n")
				mypops			<- as.character(vcfinput$pop)
				vcfinput$pop	<- gsub("_","",mypops)
				mypops2			<- as.character(vcfinput$pop2)
				vcfinput$pop2	<- gsub("_","",mypops2)
				}else{
				cat("WARNING: SambaR does not accept population names which contain an underscore.",sep="\n")
				cat("To solve this issue, you can choose any of the following two options:",sep="\n")
				cat("Option 1: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 2: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		if(any(nchar(as.character(vcfinput$pop))>10))
			{
			if(allow_edit)
				{
				cat("WARNING: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("Because you set the flag allow_edit to TRUE, SambaR will truncate population names (if longer than 10 characters) and continue.",sep="\n")
				mypops		<- as.character(vcfinput$pop)
				vcfinput$pop<- ifelse(nchar(mypops)>10,substr(mypops,1,10),mypops)
				mypops2		<- as.character(vcfinput$pop2)
				vcfinput$pop2<- ifelse(nchar(mypops2)>10,substr(mypops2,1,10),mypops2)
				}else{
				cat("ERROR: Because of plot margins, SambaR does not accept population names which contain more than 10 characters.",sep="\n")
				cat("To solve this issue, you can choose any of the following two options:",sep="\n")
				cat("Option 1: Edit population names in the sample file and rerun the importdata function.",sep="\n")
				return(cat("Option 2: Allow SambaR to truncate population names (if needed) by setting the flag allow_edit to TRUE (i.e. importdata(allow_edit=TRUE)).",sep="\n"))
				}
			}
		mynind	<- as.vector(table(vcfinput$pop))
		#if(min(mynind)<2)
		#	{
		#	return(cat("ERROR: SambaR does not accept populations consisting of 1 sample only.\nPlease edit population names and try again. \nThis means: make changes in the samplefile, and afterwards rerun the importdata() function.",sep="\n"))
		#	}
		inds$pop		<<- vcfinput$pop
		inds$pop2		<<- vcfinput$pop2		
		# assign population labels to genlight object:
		mygenlight@pop	<<- as.factor(inds$pop)
		cat("Population assignment has been succesfully updated.",sep="\n")
		}
	}

# depreciated 24-04-2020:
replacepop_old<-function(samplefile=NULL,mycolours=c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1"))
	{
	if(is.null(samplefile))
		{
		return(cat("ERROR: Provide an input file to samplefile flag."),sep="\n")
		}
	setwd(mysambar$inputdatadir)
	if(!file.exists(samplefile))
		{
		cat(paste("ERROR: SambaR couldn't find a file called",samplefile,"in the directory:",sep=" "),sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Either set the flag samplefile to NULL or make sure the file is present. See manual for more details.",sep="\n"))
		}
	# cat("Extracting information from sample file...",sep="\n")
	popinput			<- read.table(samplefile,header=FALSE)
	colnames(popinput)	<- c("name","pop")
	# reorder vcf-file:
	popinput			<- popinput[order(popinput$name),]
	if(any(!as.vector(popinput$name)==as.vector(inds$name)))
		{
		return(cat("ERROR: Sample names in vcfinput file do not correspond with names in inds dataset.",sep="\n"))
		}
	mypops			<- as.vector(unique(popinput$pop))
	mypops			<- mypops[order(mypops)]
	if(length(mypops)>length(mycolours))
		{
		return(cat("ERROR: Number of populations exceeds number of colours. Provide a vector with colour names to the 'mycolours' argument.",sep="\n"))
		}
	# now extract information:
	inds$pop		<<- popinput$pop
	inds$pop2		<<- inds$pop
	#
	# add colours:
	inds$popcol		<- mycolours[1:length(mypops)] 
	inds$popcol		<<- colvector[as.factor(inds$pop)]	
	# add to mysambar list:
	mysambar$populations<<- mypops[order(mypops)]
	mysambar$mycolours	<<- mycolours
	# add to genlight:
	mygenlight@pop		<<- as.factor(inds$pop)
	cat("Population assignment has been succesfully updated.",sep="\n")
	}






################ MULTI-ALLELIC DATA #################	
	
# import multiallelic data from structure format (using adegenet):
importmultidata<-function(structurefile="allsamples.stru",colourvector=NULL,onerow=TRUE,popfile=NULL,nloc=NULL,locusinfo=NULL,silent=TRUE,popcol_by_alphabetical_order_popname=TRUE,pop_order=NULL,qcplot=TRUE)
	{
	# define colours:
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","forestgreen","gray80","midnightblue","lavenderblush3","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	#defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours	
		}
	mysambarcolours		<- colourvector
	#
	# create genlight object:
	if(onerow)
		{
		mydata				<- read.table(structurefile)
		colnames(mydata)	<- c("name","pop")
		if(any(grepl("_",mydata$pop)))
			{
			return(cat("SambaR does not accept population names which contain an underscore.\nPlease edit population names and try again.",sep="\n"))	
			}
		nloc				<- (ncol(mydata)-2)/2
		nind				<- nrow(mydata)
		mygenind			<- read.structure(structurefile,n.ind=nind,n.loc=nloc,onerowperind=TRUE,col.lab=1,col.pop=2,col.others=0,row.marknames=0)
		}else{
		sampleinfo			<- read.table(popfile,header=TRUE)
		#sampleinfo2		<- sampleinfo[,c("name","pop","popcol")]
		sampleinfo2			<- sampleinfo
		nind				<- nrow(sampleinfo)
		if(is.null(nloc))
			{
			return(cat("ERROR: specify number of loci to the nloc flag.",sep="\n"))
			}
		mygenind			<- read.structure(structurefile,n.ind=nind,n.loc=nloc,onerowperind=FALSE,col.lab=1,col.pop=1,col.others=0,row.marknames=0)
		# does not accept argument row.marknames=1 (even if loc.names are on first column)
		# mygenind			<- read.structure(structurefile,n.ind=nind,n.loc=nloc,onerowperind=FALSE,col.lab=1,col.pop=1,col.others=0,row.marknames=1)
		# receive the error: Error in dimnames(x) <- dn :  length of 'dimnames' [2] not equal to array extent
		#
		# Note: the function read.structure is meant for DIPLOID DATA ONLY. Haploid data with the STRUCTURE format can easily be read into R using read.table or read.csv and then converted using df2genind.
		# for example:
		# x <- read.table("dm0row.tsv",header=TRUE)
		# transpose data:
		# y <- t(x)
		# convert to genind:
		# mygenind <- df2genind(X=y,ncode=1,ploidy=1,ind.names=rownames(y))
		#
		mydata				<- data.frame("name"=sub("_1","",mygenind@pop),"nr"=c(1:nrow(as.matrix(mygenind))))
		mydata				<- merge(mydata,sampleinfo2,by="name")	
		mydata				<- mydata[order(mydata$nr),]
		popNames(mygenind)	<- mydata$pop
		indNames(mygenind)	<- mydata$name
		mygenind			<- mygenind[order(mydata$name),]
		}
	cat("Data imported to genind. Next converting into genlight...",sep="\n")
	mygenind			<<- mygenind
	mymatrix			<- as.matrix(mygenind@tab)
	mygenlight			<<- as.genlight(mymatrix)
	mygenlight@pop		<<- as.factor(mydata$pop)
	#
	cat("Creating inds dataframe...",sep="\n")
	# create populations vector:
	populations			<<- as.vector(unique(mydata$pop))
	# create inds dataframe:
	inds 				<<- mydata[,c("name","pop")]
	inds				<<- inds[order(mydata$name),]
	inds$pop2			<<- inds$pop
	temp				<- as.factor(inds$pop)
	inds$popcol			<<- colourvector[temp]
	inds$nr				<<- c(1:nrow(inds))
	inds$allgeno		<<- TRUE
	inds$allgeno2		<<- TRUE
	#
	cat("Creating inds dataframe...",sep="\n")
	# create snps dataframe:
	snps				<<- as.data.frame(cbind(mygenlight@loc.names,mygenind@loc.fac,as.vector(unlist(mygenind@all.names))))
	colnames(snps)		<<- c("name","locus","allele")
	snps$allele2		<<- as.numeric(as.character(snps$allele))
	snps$nalleles		<<- as.vector(rep(mygenind@loc.n.all,mygenind@loc.n.all))
	nmissing			<- apply(mymatrix,2,function(x) length(x[is.na(x)])) # number of NA per allele
	snps$allelecount	<<- round(colSums(mymatrix,na.rm=TRUE))
	snps$nonmiss		<<- 2*nind-2*nmissing
	snps$allelefreq		<<- round(colSums(mymatrix,na.rm=TRUE)/(2*nind-2*nmissing),4)
	snps$genlightname	<<- mygenlight@loc.names
	snps$nr				<<- c(1:nrow(snps))
	snps$nr_neworder	<<- snps$nr
	#
	if(length(mysambarcolours)<length(populations))
		{
		return(cat("ERROR: less colours than populations. Provide a longer vector to the colourvector flag.",sep="\n"))
		}
	mydatapopcolours		<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		# assign colours in alphabetical order of population names (e.g.: Apop gets colour1, Bpop gets colour2, etc)
		cat("Assigning populations colours based on alphabetical order of population names.",sep="\n")
		populations			<- popNames(mygenlight)	 	# this is needed downstream to correctly assign colours at mysambar$mycolours
		inds$popcol			<<- mydatapopcolours[as.factor(inds$pop)]	
		}else{
		# assign colours in order of occurence of populations in datasets. (e.g. Apop, Apop, Cpop, Bpop, Bpop, Cpop would result in Cpop being assigned colour2)
		cat("Assigning populations colours based on order of occurrence of populations in ped-file.",sep="\n")
		populations			<- as.vector(unique(pop(mygenlight)))	
		inds$popcol			<<- NA
		for (i in (1:(length(populations))))
			{
			for (j in (1:nrow(inds)))
				{
				if (inds$pop[j]==populations[i])
					{
					inds$popcol[j] <<- mydatapopcolours[i]
					}
				}
			}
		}
	#
	if(!is.null(locusinfo))
		{
		addsnpinfo(addsnpinfofile=locusinfo)
		}
	# calculate allelefreq per population:
	cat("Calculating population specific allele frequencies...",sep="\n")
	for (i in c(1:length(populations)))
		{
		mypop			<- populations[i]
		if(!silent){cat(mypop,sep="\n")}
		mypopmatrix		<- mymatrix[as.character(inds$pop)==as.character(mypop),,drop=FALSE]
		npopind			<- nrow(mypopmatrix)
		if(length(npopind>0))
			{
			nmissing		<- apply(mypopmatrix,2,function(x) length(x[is.na(x)])) # number of NA per allele 
			snps$freqtemp	<<- round(colSums(mypopmatrix,na.rm=TRUE)/(2*npopind-2*nmissing),4)
			names(snps)[names(snps) == "freqtemp"] <<- paste("allelefreq",mypop,sep = "_")
			}else{
			cat("WARNING: population not found.",sep="\n")
			}
		}
	#
	### create inds2 (sample pairs) and pops2 (pop pairs) dataframes:
	getinds2()
	if(any(is.na(inds2$indpair))){return(cat("ERROR: NA-values in inds2$indpair column.",sep="\n"))} 
	getpops2()
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	inputdatadir		<- getwd()
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(sambardir,"Maps",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambar		<<- list()
	mysambar[[1]]	<<- populations
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	mydatapopcolours		<- mysambarcolours[1:length(populations)] 
	if(popcol_by_alphabetical_order_popname)
		{
		mysambar[[17]]	<<- mydatapopcolours[order(populations)]
		}else{
		mysambar[[17]]	<<- mydatapopcolours
		}
	mysambar[[18]]			<<- geomapsdir
	names(mysambar)			<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$populations2	<<- mysambar$populations	# needed for excludepop()
	mysambar$mycolours2		<<- mysambar$mycolours		# needed for excludepop()
	mysambar$defaultcolours	<<- defaultcolours
	mysambar$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambar$datasource		<<- "imported_from_ped"
	mysambar$genind			<<- mygenind
	#
	reorderpop(poporder=pop_order)
	if(mysambar$reordererror)
		{
		return(cat("ERROR: problem with reordering of populations (see previous lines).",sep="\n"))
		}
	# check:
	checkpopcolours()
	if(mysambar$colourerror){return(cat(" ",sep="\n"))}
	#
	if(qcplot)
		{	
		cat("Creating data_quality plot...",sep="\n")
		cat("If you receive an error after this line, rerun the importdata()-function with the flag 'qcplot' set to FALSE. I.e.: importdata(qcplot=FALSE).",sep="\n")
		calcretainedsnps(export="pdf",logy=TRUE)
		calcretainedsnps(export="pdf",logy=FALSE)
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: row names of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	# Print info on screen:
	cat("Created two dataframes called 'snps' and 'inds', as well as a genlight object called 'mygenlight'.",sep="\n")
	}

genindlea<-function(mindemes=2,maxdemes=6,order_on_longitude=FALSE,exportdata=FALSE,poporder=NULL,popnames=mysambar$populations,myfile="LEAinput.stru")
	{
	if(exportdata)
		{
		## EXPORT STRUCTURE FILE:
		mygenind		<- mysambar$genind[inds$filter,snps$filter]
		genind2structure(obj=mygenind,file=myfile,pops=FALSE)
		# genind2structure(obj=mygenind,file="LEAinput.stru",pops=FALSE)
		# Note: if your data contains allele 9, then afterwards in plain text editor:
		# - replace -9 with NAN (assuming no sample or locus name contains string 'NAN')
		# - replace 9 with 13 (because 9 is going to be used by the software as code for missing data)
		# - replace NA back to 9
		}
	#
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		indstemp		<- inds[inds$filter,]
		}
	## LOAD DATA:
	struct2geno(myfile,ploidy=2,FORMAT=2,extra.row=1,extra.column=1)
	# Check (and replace with -9) in Notepad++ for NA-values, otherwise you might run into the error:
	# Error in struct2geno("mymicrosats.stru", ploidy = 2, FORMAT = 2, extra.row = 0,  :  Multiple values for missing data.
	# Also replace alleles encoded as 9 to another value, because the struct2geno function will replace -9 with 9, assuming it is not used as code for alleles.
	# The outcome would be another error ('out of bound')
	myfile			<- paste(myfile,"geno",sep=".")
	obj.snmf		<- LEA::snmf(myfile,K=mindemes:maxdemes,ploidy=2,entropy=T,alpha = 100,project="new")
	#
	# RUN ANALYSES:
	# Creating LEA matrices:
	mydemes			<- c(mindemes:maxdemes)
	totalnr			<- length(mydemes)
	leaqmatrixlist	<- vector(mode="list",length=length(totalnr))
	for(mynr in c(1:totalnr))
		{
		ndemes		<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		# sambarfunction_findstructure:
		obj.snmf	<- LEA::snmf(myfile,K=ndemes,alpha=100,project="new")
		# sambarfunction_findstructure:
		qmatrix 	<- LEA::Q(obj.snmf, K = ndemes)
		#
		if(!is.null(poporder))
			{
			qmatrix				<- qmatrix[order(indstemp$poporder),]
			}
		leaqmatrixlist[[mynr]]	<- qmatrix
		}
	names(leaqmatrixlist)		<- paste("K",mydemes,sep="_")
	if(order_on_longitude)
		{
		mysambar$genindlealist_longitude	<<- leaqmatrixlist
		}else{
		mysambar$genindlea					<<- leaqmatrixlist
		}
	# sambarfunction_findstructure:
	# remove.snmfProject("mymicrosats.filtered2.stru.snmfProject")
	myfile2	<- gsub("geno","snmfProject",myfile)
	remove.snmfProject(myfile2)
	# if function above doesn't work, delete directory and files like this:
	# sambarfunction_findstructure:
	#unlink("mymicrosats.filtered2.stru.snmf", recursive=TRUE)
	unlink(paste(myfile,"snmf",sep="."),recursive=TRUE)
	#  LEAstructureplot(mymatrixlist=mysambar$genindlea,mindemes=2,maxdemes=6,export=NULL,exportname=NULL,popnames=mysambar$populations,poporder=NULL,addindnr=TRUE)
	}

genindnalleles<-function(popnames=mysambar$poporder2,popcols=mysambar$colorder2)
	{
	npops		<- length(popnames)
	mydf		<<- data.frame("pop"=popnames,"ninds"=NA,"nalleles"=NA,"nmax"=NA) 
	for(j in c(1:npops))
		{
		mypop			<- popnames[j]
		cat(mypop,sep="\n")
		popgenind		<- popsub(mysambar$genind,mypop)
		mydf$ninds[j]	<<- nrow(inds[as.character(inds$pop)==as.character(mypop)&inds$filter,])
		mydf$nalleles[j]<<- mean(popgenind@loc.n.all) 
		mydf$nmax[j]	<<- max(popgenind@loc.n.all) 
		}
	plot(mydf$ninds,mydf$nalleles,col=popcols,pch=16,cex=2.5)
	legend("bottomright",legend=popnames,fill=popcols,border=popcols,cex=0.75,bty='n')
	}

genindbarcode<-function(popnames=mysambar$populations,mygenind=mysambar$genind)
	{
	popgenindlist	<- seppop(mygenind)
	npops			<- length(popnames)
	#
	genindmat		<- as.matrix(mygenind[,snps$filter])
	maxalleles		<- max(snps$allele2,na.rm=TRUE)
	snpstemp		<- snps[snps$filter,]
	myloci			<- unique(snpstemp$locus)
	nloci			<- length(myloci)
	nmarkers		<- maxalleles*nloci
	#
	alleledf		<<- as.data.frame(matrix(NA,nrow=nmarkers,ncol=npops))
	colnames(alleledf)<<- popnames
	alleledf$locus	<<- rep(myloci,each=maxalleles)
	alleledf$allele	<<- rep(c(1:maxalleles),times=nloci)
	#
	popninds		<- vector()
	for(j in c(1:npops))
		{
		mypop		<- popnames[j]
		cat(mypop,sep="\n")
		indfilter	<- (inds$pop==mypop)&inds$filter
		ninds		<- length(indfilter[indfilter])
		popninds[j]	<- ninds 
		if(length(ninds)==0)
			{
			cat("WARNING: zero retained individuals.",sep="\n")
			}
		for (k in c(1:nloci))
			{
			mylocus		<- myloci[k]
			locusfilter	<- snpstemp$locus==mylocus
			snpstemp2	<- snpstemp[locusfilter,]
			snpmat		<- genindmat[,locusfilter]
			myalleles	<- snpstemp2$allele2
			for(i in c(1:maxalleles))
				{
				if(!i%in%myalleles)
					{
					alleledf[(k-1)*maxalleles+i,j]	<<- 0
					}else{
					mymarker	<- as.character(snpstemp2$name[snpstemp2$allele2==i])
					markermat	<- genindmat[indfilter,as.character(snpstemp$name)==mymarker]
					alleledf[(k-1)*maxalleles+i,j]	<<- sum(markermat,na.rm=TRUE)
					}
				}
			}
		}
	#
	tempdf	<- alleledf[,1:npops]
	run_ca(mydf=tempdf)
	plot_ca()
	#
	mysambar$popninds	<<- popninds
	allelefreqdf		<<- tempdf/(rep(2*mysambar$popninds,each=nrow(tempdf)))
	}


plotgenind<-function(myBreaks=NULL,my_col="orange",nbins=4,nmarkers=500,popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	#tempdf		<- alleledf[1:nmarkers,1:npops]
	tempdf		<- allelefreqdf[1:nmarkers,1:npops]
	tempdf2		<- tempdf[rowSums(tempdf)!=0,]
	tempdf3		<- tempdf2[,mysambar$popordernr]
	mymatrix	<- as.matrix(tempdf3)
	if(is.null(myBreaks))
		{
		floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
		ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
		mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
		if(max(mymatrix,na.rm=TRUE)==1)
			{
			mymax	<- 1
			}else{
			mymax	<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
			}
		binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
		myBreaks	<- seq(mymin,mymax,binsize)
		}
	mycolfunc 	<- colorRampPalette(c("white",my_col))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	#
	heatpos		<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
	}

findhybrid<-function(pop1="Ural",pop2="Jakutia",admixpop="CentreRus")
	{
	# detect admixed population:
	myloci		<- unique(alleledf$locus)
	nloci		<- length(myloci)
	maxalleles	<- max(alleledf$allele)
	#
	pop1vec		<- alleledf[,colnames(alleledf)==pop1]
	pop2vec		<- alleledf[,colnames(alleledf)==pop2]
	admixpopvec	<- alleledf[,colnames(alleledf)==admixpop]
	triodf		<- data.frame("pop1"=pop1vec,"pop2"=pop2vec,"admixpop"=admixpopvec)
	#
	alleledf$bool1	<<- triodf$pop1>0&triodf$admixpop>0&triodf$pop2==0
	alleledf$bool2	<<- triodf$pop1==0&triodf$admixpop>0&triodf$pop2>0
	alleledf$bool3	<<- triodf$pop1>0&triodf$admixpop==0&triodf$pop2>0
	alleledf$bool4	<<- triodf$pop1==0&triodf$admixpop>0&triodf$pop2==0
	#
	alleledf$admix	<<- NA
	alleledf$private<<- NA
	for(j in c(1:nloci))
		{
		mylocus									<- myloci[j]
		locusdf									<- alleledf[alleledf$locus==mylocus,]
		alleledf$admix[alleledf$locus==mylocus]<<- any(locusdf$bool1)&any(locusdf$bool2)&(!any(locusdf$bool3))
		#alleledf$admix[alleledf$locus==mylocus]<<- any(locusdf$bool1)&any(locusdf$bool2)
		#alleledf$admix[alleledf$locus==mylocus] <<- any(locusdf$bool1)
		alleledf$private[alleledf$locus==mylocus]<<- any(locusdf$bool4)
		}
	nadmix		<- nrow(alleledf[alleledf$admix==TRUE,])/maxalleles
	cat("Number of loci indicative of admixture:",sep="\n")
	nprivate	<- nrow(alleledf[alleledf$private==TRUE,])/maxalleles
	cat(nadmix,sep="\n")
	cat("Number of private alleles:",sep="\n")
	cat(nprivate,sep="\n")
	admixdf		<<- alleledf[alleledf$admix==TRUE,c("locus","allele",pop1,admixpop,pop2,"bool1","bool2","admix")]
	}

# calculate he per individual:
indhe<-function(silent=TRUE,do_analysis,do_compare=FALSE)
	{
	if(do_analysis)
		{
		x				<- read.table("mymicrosats.stru",header=TRUE)
		ninds			<- nrow(inds)
		inds$nmicro		<<- NA
		inds$nmicrohe	<<- NA
		inds$microhe	<<- NA
		for (j in c(1:ninds))
			{
			if(!silent){cat(j,sep="\n")}
			allele1			<- x[j*2-1,]
			allele2			<- x[j*2,]
			mybool			<- allele1!=(-9)&allele2!=(-9)
			allele1			<- allele1[mybool]
			allele2			<- allele2[mybool]
			ngeno			<- length(allele1)
			inds$nmicro[j]	<<- ngeno
			nhe				<- length(which(allele1!=allele2)) 
			inds$nmicrohe[j]<<- nhe
			inds$microhe[j]	<<- round(nhe/ngeno,5)
			}
		}
	if(do_compare)
		{
		hedf	<- brownauto_data$inds[,c("name","pop","popcol","F2")]
		tempdf	<- brownmicrosat_data$inds[,c("name","microhe")]
		hedf	<- merge(hedf,tempdf,by="name")
		plot(hedf$microhe,hedf$F,cex=3,pch=16,col=as.character(pophe$popcol),ylim=c(-1.25,1.25))
		}
	}

# calculates he per pop:
genindhe<-function(export=NULL,popnames=mysambar$populations,legendcex=2,do_analysis=TRUE,mygenind=mysambar$genind[,snps$filter])
	{
	popgenindlist	<- seppop(mysambar$genind)
	if(do_analysis)
		{
		mystats 				<- summary(mygenind)
		popgenindlist			<- seppop(mygenind) 
		Hobs	 				<- t(sapply(popgenindlist,function(ls) summary(ls)$Hobs))
		Hexp 					<- t(sapply(popgenindlist,function(ls) summary(ls)$Hexp))
		Hobs[!is.finite(Hobs)]	<- NA
		Hexp[!is.finite(Hexp)]	<- NA
		Hobs.pop 				<- apply(Hobs,1,mean,na.rm=TRUE)
		Hexp.pop 				<- apply(Hexp,1,mean,na.rm=TRUE) 
		#par(mfrow=c(2,1))
		#barplot(Hexp.pop,ylim=c(0,1),las=3,ylab="Expected heterozygosity")
		#barplot(Hobs.pop,ylim=c(0,1),las=3,ylab="Observed heterozygosity")
		names(Hobs.pop)			<- names(popgenindlist)
		names(Hexp.pop)			<- names(popgenindlist)
		mysambar$Hobs.pop		<<- Hobs.pop
		mysambar$Hexp.pop		<<- Hexp.pop
		}
	if(is.null(mysambar$Hobs.pop))
		{
		return(cat("ERROR: mysambar$Hobs.pop is missing.",sep="\n"))
		}
	if(is.null(mysambar$Hexp.pop))
		{
		return(cat("ERROR: mysambar$Hexp.pop is missing.",sep="\n"))
		}
	Hobs.pop	<- mysambar$Hobs.pop
	Hexp.pop	<- mysambar$Hexp.pop
	#
	if(!is.null(export))
		{
		plotname		<- "Microsat_Hobs"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(Hexp.pop[order(names(Hexp.pop))],Hobs.pop[order(names(Hobs.pop))],col=mysambar$mycolours,pch=16,cex=4,xlim=c(0,0.5),ylim=c(0,0.5),xlab="",ylab="")
	mtext(side=1,"Expected He",cex=2.75,line=3.5)
	mtext(side=2,"Observed He",cex=2.75,line=3.5)
	abline(c(0,0),c(1,1))
	legend("topleft",legend=popnames,fill=mysambar$mycolours,border=mysambar$mycolours,cex=1.75,bty='n')
	if(!is.null(export)){dev.off()}
	#
	#excludepop(c("polar","Black"))
	#hedf			<- dwd$ind[,c("name","pop","popcol","regionhe")]
	#pophe			<- aggregate(hedf$regionhe,list(hedf$pop),mean)
	#colnames(pophe)<- c("pop","regionhe")
	#pophe$microsat	<- mysambar$Hobs.pop
	#tempdf			<- aggregate(hedf$popcol,list(hedf$pop),unique)
	#pophe$popcol	<- as.character(tempdf$x)
	#plot(pophe$regionhe,pophe$microsat,cex=3,pch=16,col=as.character(pophe$popcol))
	}

genindfst<-function(mygenind=mysambar$genind[,snps$filter],nmarkers=2000)
	{
	matFst 		<- pairwise.fst(mygenind[,c(1:nmarkers)],res.type="matrix")
	matFst 		<- pairwise.fst(mysambar$genind,res.type="matrix")
	mytree 		<- nj(matFst)
	plot(mytree,type="unrooted",tip.col=funky(17)[-17],font=2)
	annot 		<- round(mytree$edge.length,2)
	edgelabels(annot[annot>0],which(annot>0),frame="n")
	add.scale.bar()
	}

genindhwe<-function()
	{
	# hwe test:
	popgenindlist	<- seppop(mysambar$genind)
	HWE.test 		<- data.frame(sapply(popgenindlist,function(ls) pegas::hw.test(ls,B=0)[,3]))
	HWE.test.chisq 	<- t(data.matrix(HWE.test))
	# with 1000 Monte Carlo permutations (takes ages):
	# HWE.test <- data.frame(sapply(seppop(mysambar$genind),function(ls) pegas::hw.test(ls,B=1000)[,4]))
	# HWE.test.MC <- t(data.matrix(HWE.test))
	# value per population:
	alpha					<- 0.05
	Prop.pops.out.of.HWE 	<- vector()
	for (k in c(1:ncol(HWE.test)))
		{
		mycolumn	<- HWE.test[,k]
		mycolumn	<- mycolumn[!is.na(mycolumn)]
		Prop.pops.out.of.HWE[k] <- length(mycolumn[mycolumn<alpha])/length(mycolumn)
		}
	names(Prop.pops.out.of.HWE)<- names(popgenindlist)
	}

genindpca<-function(mygenind=NULL,naxes=3,return_object=FALSE,NA_method="mean")
	{
	if(is.null(mygenind))
		{
		return(cat("ERROR: define the name of the genind object to the mygenind flag.",sep="\n"))
		}
	# dudi.pca does not accept missing data points.
	# How to deal with this?
	# NA.method can be either 'asis' (leave as is), 'zero' (replace with 0, or 'mean' (replace with mean allele frequencies)
	# The latter may result in unrealistic situation of more than 2 allele per individual.
	mymat 		<- tab(mygenind,freq=TRUE,NA.method=NA_method)
	if(any(is.na(mymat)))
		{
		cat("WARNING: na-values present.",sep="\n")
		mymat[is.na(mymat)]	<- 0
		}
	mypca 					<- dudi.pca(mymat,center=TRUE,scale=FALSE,nf=naxes,scannf=FALSE)
	mypops					<- unique(pop(mygenind))
	# histogram explained variance:
	fviz_eig(mypca)
	# pca plot:
	fviz_pca_ind(mypca,col.ind="cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),repel=TRUE)
	# pca plot with labels:
	s.class(mypca$li,fac=pop(mygenind),col=funky(length(mypops)))
	#
	# get explained variance:
	myeigen					<- get_eig(mypca)
	#mypca					<<- mypca
	#points(mypca$li[,1],mypca$li[,2])
	mysambar$pcascores$vectors	<<- mypca$li
	if(return_object)
		{
		mypcalist <- list("eig"=mypca$eig,"vectors"=mypca$li)
		mypcalist$values$Relative_eig	<- myeigen$variance.percent/100
		return(mypcalist)
		}
	}

genindassign<-function(mygenind=NULL,mindemes=2,maxdemes=6,mycolours=mysambar$mycolours,poporder=NULL,popnames=mysambar$populations)
	{
	if(is.null(mygenind))
		{
		return(cat("ERROR: define the name of the genind object to the mygenind flag.",sep="\n"))
		}
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		}
	inds	<<- inds
	#
	mydemes		<- c(mindemes:maxdemes)
	totalnr		<- length(mydemes)
	qmatrixlist	<- vector(mode="list",length=length(totalnr))
	for(mynr in c(1:totalnr))
		{
		ndemes				<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		mygrp 				<- find.clusters(mygenind,max.n.clust=20,n.pca=75,n.clust=ndemes)
		mydapc 				<- dapc(mysambar$genind[inds$filter,snps$filter],n.pca=75,n.da=14,pop=mygrp$grp)
		mypred				<- predict(mydapc)
		qmatrix				<- round(mypred$posterior,3)
		#
		if(!is.null(poporder))
			{
			indstemp		<- inds[inds$filter,]
			qmatrix			<- qmatrix[order(indstemp$poporder),]
			}
		qmatrixlist[[mynr]]	<- qmatrix
		#barplot(t(100*round(mypred$posterior,2)),col=mycolours,ylab="% assignment",las=3)
		}
	names(qmatrixlist)		<- paste("K",mydemes,sep="_")
	mysambar$genindqlist	<<- qmatrixlist
	}

# export genind to structure file
# function from github page of Lindsay Clark:
genind2structure<-function(obj=mysambar$genind,file="LEAinput.stru",pops=FALSE)
	{
	if(is.null(file))
		{
		return(cat("Specify the name of output structure file to the 'file' flag.",sep="\n"))
		}
	if(is.null(obj))
		{
		return(cat("Specify an (existing) genind object to the 'obj' flag.",sep="\n"))
		}
	if(!"genind" %in% class(obj))
		{
		warning("Function was designed for genind objects.")
		}
	# get the max ploidy of the dataset
	pl <- max(obj@ploidy)
	# get the number of individuals
	S <- adegenet::nInd(obj)
	# column of individual names to write; set up data.frame
	tab <- data.frame(ind=rep(indNames(obj), each=pl))
	# column of pop ids to write
	if(pops)
		{
		popnums <- 1:adegenet::nPop(obj)
		names(popnums) <- as.character(unique(adegenet::pop(obj)))
		popcol <- rep(popnums[as.character(adegenet::pop(obj))], each=pl)
		tab <- cbind(tab, data.frame(pop=popcol))
		}
	loci <- adegenet::locNames(obj) 
	# add columns for genotypes
	tab <- cbind(tab, matrix(-9, nrow=dim(tab)[1], ncol=adegenet::nLoc(obj),dimnames=list(NULL,loci)))
	# begin going through loci
	for(L in loci)
		{
		thesegen <- obj@tab[,grep(paste("^", L, "\\.",sep=""),dimnames(obj@tab)[[2]]),drop = FALSE] # genotypes by locus
		al <- 1:dim(thesegen)[2] # numbered alleles
		for(s in 1:S)
			{
			if(all(!is.na(thesegen[s,])))
				{
				tabrows <- (1:dim(tab)[1])[tab[[1]] == indNames(obj)[s]] # index of rows in output to write to
				tabrows <- tabrows[1:sum(thesegen[s,])] # subset if this is lower ploidy than max ploidy
				tab[tabrows,L] <- rep(al, times = thesegen[s,])
				}
			}
		}
	# export table
	write.table(tab,file=file,sep="\t",quote=FALSE,row.names=FALSE)
	}

# correlation between multi allelic allele frequencies:
corrfrequencies<-function()
	{
	combitable	<- combn(populations,m=2)
	mycorr1		<- rep(NA,ncol(combitable))	# pearson
	mycorr2		<- rep(NA,ncol(combitable))	# spearman
	for (i in c(1:ncol(combitable)))
		{
		pop1	<- combitable[1,i]	
		freq1	<- snps[,names(snps)==paste("allelefreq",pop1,sep="_")]
		pop2	<- combitable[2,i]	
		freq2	<- snps[,names(snps)==paste("allelefreq",pop2,sep="_")]
		mycorr1[i]	<- cor(freq1,freq2,method="pearson")
		mycorr2[i]	<- cor(freq1,freq2,method="spearman")
		}
	mycorr						<<- rbind(combitable,mycorr1,mycorr2)
	b							<<- matrix(1,nrow=length(populations),ncol=length(populations))
	b[lower.tri(b, diag=FALSE)] <<- mycorr1
	b							<<- t(b)
	b[lower.tri(b, diag=FALSE)] <<- mycorr2
	colnames(b)				<<- populations
	rownames(b)				<<- populations
	}

# histogram of allele frequencies for multiallelic data:
allelefreqhisto<-function(export=FALSE)
	{
	# reorder:
	snpstemp	<- snps[order(as.integer((levels(snps$allele))),as.integer((levels(snps$allele)))),]
	if(export){pdf("Allelefrequencies.pdf",width=12,height=20)}
	par(mfrow=c(16,4),mar=c(3,0.5,0.5,0.5),oma=c(1,5,3,1),cex.axis=1.25,cex.lab=1,cex.main=1.5)
	for (j in (c(1:16)))
		{
		npop		<- length(populations)
		temp		<- snpstemp[snpstemp$locus==j,c(8:(8+npop-1))]
		myymax		<- max(temp)
		for (i in c(1:length(populations)))
			{
			mypop	<- populations[i]
			myfreq	<- snpstemp[,names(snpstemp)==paste("allelefreq",mypop,sep="_")]
			myyaxt	<- ifelse(i == 1,"s","n")
			barplot(myfreq[snpstemp$locus==j],las=2,names.arg=snpstemp$allele[snpstemp$locus==j],col=mypop,ylim=c(0,myymax),ylab="",yaxt=myyaxt)
			if(i == 1){mtext(paste("locus",j,sep=""),side=2,line=3.5,cex=1.5)}
			if(j == 1){mtext(mypop,side=3,line=0.25,cex=1.5)}
			}
		}
	if(export){dev.off()}
	}

# These plots are useless: there is no reason to expect correlation between Fst and Fis, other than when populations are wrongly defined. 
# maples plot for each population:
# locusspecific Fst (pairwise comparison) vs locusspecific Fis
# y-axis: Fis	(Hexp_pop-Hobs_pop)/Hexp_pop		# if true population (no substructure), Fis hovers around 0.   
# x-axis: Fst 	(Hexp_meta-Hobs_meta)Hexp_meta		# high if many homozygotes due to popstructure (e.g AA in pop1 and aa in pop2)	
# So flat plot if population has no substructure.
# If more than 2 populations, we have to select a pairwise population comparison for running the fst analysis.  

# for snps (binned):
waples_snps<-function(mysteps=0.05,mypop=snps$F_Busen,myfst=snps$WeirFst_Busen_Norway)
	{
	mybreaks	<- seq(0,1,mysteps)
	myhalf		<- mysteps/2
	mylabels	<- seq(myhalf,1-myhalf,mysteps)
	fstbins		<- cut(windowfstdf$WeirFst_Eurasia_polar,mybreaks)
	fisperbin		<- aggregate(mypop[myselection], by=list(fstbins),FUN=mean) 
	nperbin			<- aggregate(mypop[myselection], by=list(fstbins),FUN=length)
	nbins			<- nrow(fisperbin)
	ndata			<- nperbin$x
	mylabels2		<- mylabels[1:nbins]
	myfis			<- cbind(mylabels2,fisperbin$x) 
	plot(myfis[ndata>10,],xlab="Fst",ylab="Fis",xlim=c(0,1),ylim=c(-1,1))
	}

# for microsatellites:
waples<-function(export=FALSE,histo=FALSE,multi=FALSE,compare_to_fst=FALSE)
	{
	myseploc 		<- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	library(hierfstat)
	# warning: hierfstat masks pcoa function of ape
	# fst:
	myseplocfst 	<<- lapply(myseploc,pairwise.fst)	# pairwise fst values for each locus (multiple values per locus)
	# locfst		<- sapply(myseplocfst, mean)		# mean of pairwise fst values for each locus (one value per locus)
	# fst between two main clusters(ocean and sea of japan)
	locfst			<- as.vector(unlist(myseplocfst))	#
	locfst			<- locfst[seq(5,95,6)]				# this depends on position of the pairwise comparison we are interested in.
	locfst			<<- locfst
	# fis of all populations combined:
	metasummary		<- summary(mygenind)
	metafis 		<- (metasummary$Hexp-metasummary$Hobs)/metasummary$Hexp
	# fis_all or fst as comparison?
	if(compare_to_fst)
		{
		mycontrast		<- locfst 
		}else{
		mycontrast		<- metafis
		}
	# fis per population:
	mypops			<- popNames(mygenind)
	npops			<- length(mypops)
	popfislist		<<- list()
	for (i in c(1:4))
 		{
		mypop		<- mypops[i]
		# mymatrix	<- as.matrix(mygenind[inds$pop==mypop,])
		mymatrix	<- as.matrix(mygenind[mygenind$pop==mypop,])
		popgenind	<- as.genind(mymatrix)
		popsummary	<- summary(popgenind)
		popfislist[[i]]	<- (popsummary$Hexp-popsummary$Hobs)/popsummary$Hexp
		}
	# plot:
	myxlim			<- c(min(mycontrast),max(mycontrast))
	myylim			<- c(min(unlist(popfislist)),max(unlist(popfislist)))
	mylim			<- c(min(c(myxlim,myylim)),max(c(myxlim,myylim)))
	if(histo)
		{
		if(multi)
			{
			graphics.off()
			if(export){pdf("mapleshisto.multi.pdf",height=13.5,width=13.5)}
			par(mfrow=c(2,2),mar=c(2.5,3,3,3),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
			for (i in c(1:4))
				{
				mypop		<- mypops[i]
				popfis		<- popfislist[[i]]
				hist(mycontrast,col="grey",br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005),main=mypop,ylab="",xlab="",ylim=c(0,4))
				hist(popfis,col=mypop,add=TRUE,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005))
				}
			if(compare_to_fst)
				{
				mtext(side=1,"Fst (grey) and Fis (colour)",outer=TRUE,line=2,cex=3)
				}else{
				mtext(side=1,"Fis",outer=TRUE,line=2,cex=3)
				}
			mtext(side=2,"Frequency",outer=TRUE,line=1,cex=3)
			}else{
			graphics.off()
			if(export){pdf("mapleshisto.single.pdf",height=9,width=9)}
			par(cex.axis=1.5,cex.lab=2,cex.main=2)
			for (i in c(1:4))
				{
				mypop		<- mypops[i]
				popfis		<- popfislist[[i]]
				if(i==1)
					{
					hist(popfis,col=mypop,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005),main="",ylab="",xlab="",ylim=c(0,4))
					mtext(side=1,"Fis",line=3,cex=3)
					#mtext(side=2,"Frequency",line=1,cex=3)	
					}else{
					hist(popfis,col=mypop,add=TRUE,br=seq(mylim[1]-0.01,mylim[2]+0.01,0.005))
					}
				}
			}
		if(export){dev.off()}
		}else{
		if(export){pdf("maplesscatter.pdf",height=13.5,width=13.5)}
		par(mfrow=c(2,2),mar=c(1,1,1.5,0.5),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
		for (i in c(1:4))
			{
			mypop		<- mypops[i]
			nind		<- nrow(inds[inds$pop==mypop,])
			popfis		<- popfislist[[i]]
			# plot:
			myyaxt		<- ifelse(i==1|i==3,"s","n")
			myxaxt		<- ifelse(i>2,"s","n")
			plot(locfst,popfis,xlim=mylim,ylim=mylim,ylab="",xlab="",pch=16,xaxt=myxaxt,yaxt=myyaxt,col=mypop,cex=1.5)
			fit 		<- lm(popfis ~ locfst)
			fit2		<- summary(fit)
			mypos		<- c(mylim[1],mylim[1])
			mtext(bquote("n" == .(nind)),at = mylim[1],adj=0,line=-1.5,cex=1.5)
			mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=-3.5,cex=1.5)
			mtext(mypop,cex=2)
			# regression:
			mydata		<-	as.data.frame(cbind(popfis,locfst)) 
			abline(lm(popfis ~ locfst,data=mydata),lty=2)
			}
		mtext(side=1,"Fst",outer=TRUE,line=3,cex=2.5)
		mtext(side=2,"Fis",outer=TRUE,line=2,cex=2.5)
		if(export){dev.off()}
		}
	}
	
# Fis within populations vs Fst between population for multiallelic data:
waples_random<-function(export=FALSE,mysizes=c(100,250,500,1000,2000,4000),mycolours=c("blue","darkgreen","darkred","orange","purple","grey50"))
	{
	myseploc 		<- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	library(hierfstat)
	myseplocfst 	<- lapply(myseploc,pairwise.fst)	# pairwise fst values for each locus (multiple values per locus)
	locfst			<- sapply(myseplocfst, mean)		# mean of pairwise fst values for each locus (one value per locus)
	# fst between two main clusters(ocean and sea of japan):
	locfst			<- as.vector(unlist(myseplocfst))	#
	locfst			<- locfst[seq(5,95,6)]				# this depends on position of the pairwise comparison we are interested in.
	popfislist		<- list()
	for (i in c(1:6))
 		{
		mysize			<- mysizes[i]
		mymatrix		<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
		randomgenind	<- as.genind(mymatrix)
		randomsum		<- summary(randomgenind)
		popfislist[[i]]	<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
		}
	# plot:
	myxlim			<- c(min(locfst),max(locfst))
	myylim			<- c(min(unlist(popfislist)),max(unlist(popfislist)))
	#mylim			<- c(min(c(myxlim,myylim)),max(c(myxlim,myylim)))
	mylim			<- myxlim
	if(export){pdf("maplesplot.randomsubsets.pdf",height=10,width=13.5)}
	par(mfrow=c(2,3),mar=c(1,1,1.5,0.5),oma=c(5,5,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)	
	for (i in c(1:6))
 		{
		mysize		<- mysizes[i]
		randomfis	<- popfislist[[i]]
		myyaxt		<- ifelse(i==1|i==4,"s","n")
		myxaxt		<- ifelse(i>3,"s","n")
		plot(locfst,randomfis,xlim=mylim,ylim=mylim,ylab="",xlab="",pch=16,xaxt=myxaxt,yaxt=myyaxt)
		fit 		<- lm(randomfis ~ locfst)
		fit2		<- summary(fit)
		mtext(bquote("n" == .(mysize)),cex=1.5)
		mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=-1.5)
		mydata		<-	as.data.frame(cbind(randomfis,locfst)) 
		abline(lm(randomfis ~ locfst,data=mydata),lty=2)
		for(j in c(1:length(mycolours)))
			{
			mycol		<- mycolours[j]
			mymatrix	<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
			randomgenind<- as.genind(mymatrix)
			randomsum	<- summary(randomgenind)
			randomfis	<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
			points(locfst,randomfis,pch=16,col=mycol)
			fit 		<- lm(randomfis ~ locfst)
			fit2		<- summary(fit)
			mtext(bquote(paste("r"^"2") == .(round(fit2$r.squared,3))),at = mylim[1],adj=0,line=((j+1)*-1.5),col=mycol)
			mydata		<-	as.data.frame(cbind(randomfis,locfst)) 
			abline(lm(randomfis ~ locfst,data=mydata),lty=2,col=mycol)
			}
 		}
	mtext(side=1,"Fst",outer=TRUE,line=3,cex=2.5)
	mtext(side=2,"Fis",outer=TRUE,line=2,cex=2.5)
	if(export){dev.off()}
	}

# expected correlation between fst and fis for this dataset if neutral subset:
meanr2<-function(mysize=500,ntimes=100)
	{
	myoutput<<- rep(NA,ntimes)
	# fst per locus:
	myseploc <- seploc(mygenind, truenames=TRUE, res.type=c('genind','matrix'))
	myseplocfst <- lapply(myseploc,pairwise.fst)
	locfst<- as.vector(unlist(myseplocfst))
	locfst<- locfst[seq(4,94,6)]
	# fis per locus, and regression with fst:
	for (i in c(1:ntimes))
		{
		cat(i,sep="\n")
		mymatrix<- as.matrix(mygenind[sample(c(1:4656),mysize,replace=FALSE),])
		randomgenind<- as.genind(mymatrix)
		randomsum<- summary(randomgenind)
		randomfis<- (randomsum$Hexp-randomsum$Hobs)/randomsum$Hexp
		fit <- lm(randomfis ~ locfst)
		fit2<- summary(fit)
		myoutput[i]<- round(fit2$r.squared,3)
		}
	}






#################### DATA PREPARATION ################### 

filtermultidata<-function(indmiss=0.65,snpmiss=0.4,silent=TRUE)
	{
	setwd(mysambar$QCdir)
	indsmissingness(indthreshold=indmiss)
	snpsmissingness(indthreshold=indmiss,snpthreshold=snpmiss)
	inds$filter	<<- ifelse(inds$miss>indmiss,FALSE,TRUE)
	inds$filter2<<- inds$filter
	snps$filter	<<- ifelse(snps$miss>snpmiss,FALSE,TRUE)
	snps$filter2<<- snps$filter
	#
	nretainedinds	<- nrow(inds[inds$filter,])
	ntotalinds		<- nrow(inds)
	nretainedsnps	<- nrow(snps[snps$filter2,])
	nthinnedsnps	<- nrow(snps[snps$filter,])
	ntotalsnps		<- nrow(snps)	
	cat(paste("After filtering retained",nretainedinds,"out of",ntotalinds,"individuals.",sep=" "),sep="\n")
	cat(paste("After filtering retained",nretainedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
	cat(paste("After filtering and thinning retained",nthinnedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
	#
	plot_indsmissingdata(indthreshold=indmiss,export="pdf")
	if(!silent){cat("plot_snpsmissingdata",sep="\n")}
	plot_snpsmissingdata(snpthreshold=snpmiss,export="eps")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="pdf")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="png")
	if(mysambar$os=="Windows"){plot_snpsmissingdata(snpthreshold=snpmiss,export="wmf")}
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("missingness_perpop",sep="\n")}
		missingness_perpop(export="eps")
		missingness_perpop(export="pdf")
		missingness_perpop(export="png")
		if(mysambar$os=="Windows"){missingness_perpop(export="wmf")}
		if(min(inds$miss,na.rm=TRUE)>0)
			{
			missingness_perpop(export="eps",logy=TRUE)
			missingness_perpop(export="pdf",logy=TRUE)
			missingness_perpop(export="png",logy=TRUE)
			if(mysambar$os=="Windows"){missingness_perpop(export="wmf",logy=TRUE)}
			}
		}
	snp_maf(indthreshold=indmiss)
	setwd(mysambar$inputdatadir)
	}

# This function executes all steps of the data preparation at once: 
filterdata<-function(indmiss=0.25,snpmiss=0.1,min_mac=2,dohefilter=TRUE,maxprop_hefilter=0.05,snpdepthfilter=TRUE,min_spacing=500,kinship_thres=NULL,silent=TRUE,nchroms=NULL,do_calckin=FALSE,TsTvfilter=NULL,ychrom=NULL,do_distplot=TRUE,do_highestsd=TRUE,do_mafdiff=FALSE,F_correct_maf=TRUE,plot_inbreeding=TRUE,paralog_threshold1=0.5,paralog_threshold2=0.05,stop_correctmaf=FALSE,legend_cex=3,old_distfilter=FALSE,do_genoheatmap=FALSE,redo_kinship=FALSE,plot_transits=TRUE)
	{
	if(!exists("inds"))
		{
		return(cat("ERROR: Object 'inds' is missing. First (re)run the importdata() or genlight2sambar() function.",sep="\n"))
		}
	if(!exists("snps"))
		{
		return(cat("ERROR: Object 'snps' is missing. First (re)run the importdata() or genlight2sambar() function.",sep="\n"))
		}
	if(!exists("mygenlight"))
		{
		return(cat("ERROR: Object 'mygenlight' is missing. First (re)run the importdata() or genlight2sambar() function.",sep="\n"))
		}
	if(!exists("mysambar"))
		{
		return(cat("ERROR: Object 'mysambar' is missing. First (re)run the importdata() or genlight2sambar() function and make sure it finishes without errors.",sep="\n"))
		}	
	#if(indmiss>=1|indmiss<=0)
	if(indmiss>1|indmiss<0)
		{
		return(cat("ERROR: Value of indmiss argument should be between 0 and 1.",sep="\n"))
		}
	#if(snpmiss>=1|snpmiss<=0)
	if(snpmiss>1|snpmiss<0)
		{
		return(cat("ERROR: Value of snpmiss argument should be between 0 and 1.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(is.na(snps$genlightname)))
		{
		cat("WARNING: NA-values in snps$genlightname column.",sep="\n")
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(min_spacing<0)
		{
		return(cat("ERROR: value to min_spacing flag should be positive.",sep="\n"))
		}
	if(is.null(inds$poporder))
		{
		return(cat("ERROR: inds$poporder is NULL. Was the data succesfully imported?",sep="\n"))
		}
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	setwd(mysambar$QCdir)
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	cat("Step 1 out of 6: Checking data quality...",sep="\n")
	# Reorder the snps to the order they occur in the genome:
	# Not necessary when data is created with importdata function, but possibly necessary if created with findoverlap() or dummydata() or subsetdata() functions:
	snpstemp		<- snps
	if(!"nr_neworder"%in%colnames(snps))
		{
		return(cat("ERROR: column snps$nr_neworder is missing.",sep="\n"))
		}
	snps			<<- snps[snps$nr_neworder,]			# 10-11-2020
	mymatrix		<- as.matrix(mygenlight[,snpstemp$nr_neworder])	# 10-11-2020
	mygenlight		<<- as.genlight(mymatrix)
	pop(mygenlight)	<<- inds$pop
	if(any(is.na(snps$genlightname)))
		{
		cat("WARNING: after reordering, NA-values in snps$genlightname column.",sep="\n")
		}
	if(any(colnames(as.matrix(mygenlight))!=snps$genlightname))
		{	
		return(cat("ERROR: after reordering, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(mygenlight@loc.names!=snps$genlightname))
		{	
		return(cat("ERROR: after reordering, values in mygenlight@loc.names do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}		
	# general statistics and missing data:
	# if(mysambar$datasource=="converted_from_genlight")
	#	{
	#	cat("Skipping GC-content table and transition-vs-transition plot because data has been converted from a genlight object, and this information got lost.",sep="\n")
	#	}else{
		if(!silent){cat("calcGC",sep="\n")}
		calcGC()
		if(!silent){cat("calctransit",sep="\n")}
		calctransit()
	#}
	if("dist" %in% colnames(snps))
		{
		if(any(snps$dist2))
			{
			mymaxdist	<- max(snps$dist,na.rm=TRUE)
			if(mymaxdist<=1000)
				{
				cat("WARNING: No pair of adjacent snps is separated by more than 1 kb.",sep="\n")
				cat("Are you sure the information in the first column of your MAP file refers to chromosomes/contigs and not to reads?",sep="\n")
				}
			if(do_distplot)
				{
				cat("Creating plots showing distances between adjacent SNPs.",sep="\n")
				cat("If you receive an error after this line, set the flag do_distplot to FALSE.",sep="\n")
				if(!silent){cat("readpos",sep="\n")}
				readpos(export="eps")
				readpos(export="pdf")
				readpos(export="png")
				if(mysambar$os=="Windows"){readpos(export="wmf")}
				if(!silent){cat("plotspacing",sep="\n")}
				plotspacing(export="eps")
				plotspacing(export="pdf")
				plotspacing(export="png")
				if(mysambar$os=="Windows"){plotspacing(export="wmf")}
				}
			}else{
			cat("Skipping distance plots because no contig/chromosome with more than 1 SNP, which means it is impossible to calculate and plot distance between SNPs.",sep="\n")  
			}
		}
	# 13-08-2020: depreciated
	#if(chromosomes)
	#	{
	#	if(!silent){cat("distperchrom",sep="\n")}
	#	distperchrom()
	#	#plotspacingperchrom(export="pdf") # replaced by distperchrom
	#	}
	if(!silent){cat("indsmissingness",sep="\n")}
	indsmissingness(indthreshold=indmiss)	
	if(!any(inds$miss<=indmiss))
		{
		cat("ERROR: no individuals retained after filtering on missingness.",sep="\n")
		if(!silent){cat("barplot missing data",sep="\n")}
		barplot(inds$miss,ylab="Proportion missing data per sample",xlab="Sample number",ylim=c(0,1),names=inds$nr,las=2,cex.names=0.5)
		abline(h=0.1,lty=2)
		return(cat("Change filter settings (i.e. choose a higher value for indmiss) and rerun the filterdata() function.",sep="\n"))
		}
	if(!silent){cat("plot_indsmissingdata",sep="\n")}
	plot_indsmissingdata(indthreshold=indmiss,export="eps")
	plot_indsmissingdata(indthreshold=indmiss,export="pdf")
	plot_indsmissingdata(indthreshold=indmiss,export="png")
	if(mysambar$os=="Windows"){plot_indsmissingdata(indthreshold=indmiss,export="wmf")}
	if(!silent){cat("snpsmissingness",sep="\n")}
	snpsmissingness(indthreshold=indmiss,snpthreshold=snpmiss)
	if(!any(snps$miss<=snpmiss))
		{
		cat("ERROR: no snps retained after filtering on missingness.",sep="\n")
		cat("Change filter settings (i.e. choose a higher value for snpmiss) and rerun the filterdata() function.",sep="\n")
		return(cat("For an overview of missing data per snp, have a look at the 'missingdataperlocus' plot in the QC subdirectory.",sep="\n"))
		}
	if(!silent){cat("plot_snpsmissingdata",sep="\n")}
	plot_snpsmissingdata(snpthreshold=snpmiss,export="eps")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="pdf")
	plot_snpsmissingdata(snpthreshold=snpmiss,export="png")
	if(mysambar$os=="Windows"){plot_snpsmissingdata(snpthreshold=snpmiss,export="wmf")}
	if(length(mysambar$populations)>1)
		{
		if(!silent){cat("missingness_perpop",sep="\n")}
		missingness_perpop(export="eps")
		missingness_perpop(export="pdf")
		missingness_perpop(export="png")
		if(mysambar$os=="Windows"){missingness_perpop(export="wmf")}
		if(min(inds$miss,na.rm=TRUE)>0)
			{
			missingness_perpop(export="eps",logy=TRUE)
			missingness_perpop(export="pdf",logy=TRUE)
			missingness_perpop(export="png",logy=TRUE)
			if(mysambar$os=="Windows"){missingness_perpop(export="wmf",logy=TRUE)}
			}
		}
	#if(any(inds$miss==1))
	#	{
	#	cat("ERROR: The following sample(s) has/have zero data:",sep="\n")
	#	cat(as.vector(inds$name[inds$miss==1]),sep="\n")
	#	cat("For an overview of missing data per sample, have a look at the 'missingdatapersample' plot in the QC subdirectory.",sep="\n")
	#	cat("SambaR does not accept samples with zero data.", sep="\n")
	#	return(cat("Remove this/these sample(s) from input file (i.e ped file) and run the plink --make-bed and Sambar importdata() function again to import reduced dataset.",sep="\n"))
	#	}
	cat("Step 2 out of 6: Calculating locus specific minor allele frequencies and heterozygosities...",sep="\n")
	if(!silent){cat("snp_maf",sep="\n")}
	snp_maf(indthreshold=indmiss)
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(length(mysambar$popnoind)>0)
		{
		cat("ERROR: SambaR does not accept populations with zero retained individuals.",sep="\n")
		cat("You have three options:",sep="\n")
		cat("Option 1: Change filter settings (i.e. choose a higher value for indmiss) and run the filterdata() again.",sep="\n")
		cat("Option 2: Use SambaR's mergepop(sourcepop='...',targetpop='...') function to merge a population (the 'sourcepop') into another population (the 'targetpop') and afterwards rerun the filterdata() function.",sep="\n")
		cat("Option 3: Alternatively, remove samples/populations from input file (i.e. ped file) and rerun the plink --make-bed --recode A and Sambar importdata() function to import reduced dataset.",sep="\n")
		return(cat("For an overview of missing data per population, have a look at the 'Missingdata.perpop' plot in the QC subdirectory.",sep="\n"))
		}
	if(!stop_correctmaf)
		{
		if(!silent){cat("correctmaf",sep="\n")}
		correctmaf(silent=TRUE)
		if(!silent){cat("corrected maf",sep="\n")}
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}
		if(!silent){cat("getpopmaf",sep="\n")}
		getpopmaf(snpthreshold=snpmiss)
		if(!silent){cat("mafsd",sep="\n")}
		mafsd()
		if(!silent){cat("snp_hetero",sep="\n")}
		snp_hetero(indthreshold=indmiss,snpthreshold=snpmiss)
		#if(chromosomes)
		#	{
		#	if(!silent){cat("chrom_He_maf",sep="\n")}
		#	chrom_He_maf(export="eps")	
		#	chrom_He_maf(export="pdf")
		#	chrom_He_maf(export="png")
		#	if(mysambar$os=="Windows"){chrom_He_maf(export="wmf")}
		#	}
		# filter:
		cat("Step 3 out of 6: Setting filters...",sep="\n")
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		filters(indthreshold=indmiss,snpthreshold=snpmiss,mac=min_mac,mindistance=min_spacing,kin_thres=kinship_thres,hefilter=dohefilter,paralogthreshold1=paralog_threshold1,paralogthreshold2=paralog_threshold2,snpdepth_filter=snpdepthfilter,TsTv_filter=TsTvfilter,olddistfilter=old_distfilter,redo_kin=redo_kinship)
		if(!"filter"%in%colnames(inds2))
			{
			return(cat("ERROR: filter column absent from inds2 dataframe.",sep="\n"))
			}
		#
		mysambar$indmissfilter	<<- indmiss
		mysambar$snpmissfilter	<<- snpmiss
		mysambar$min_mac		<<- min_mac
		mysambar$hefilter		<<- dohefilter
		mysambar$snpdepthfilter	<<- snpdepthfilter&("meandepth"%in%colnames(snps))
		#	
		plotfilters(export="eps",plotdiscarded=TRUE)
		plotfilters(export="pdf",plotdiscarded=TRUE)
		plotfilters(export="png",plotdiscarded=TRUE)
		if(mysambar$os=="Windows"){plotfilters(export="wmf",plotdiscarded=TRUE)}
		plotfilters(export="eps",plotdiscarded=FALSE)
		plotfilters(export="pdf",plotdiscarded=FALSE)
		plotfilters(export="png",plotdiscarded=FALSE)
		if(mysambar$os=="Windows"){plotfilters(export="wmf",plotdiscarded=FALSE)}
		if(!any(snps$filter))
			{
			cat("ERROR: No snps retained after overall filtering.",sep="\n")
			cat("Change filter settings (i.e. choose a higher value for snpmiss) and run the filterdata() again.",sep="\n")
			return(cat("For an overview of missing data per snp, have a look at the 'missingdataperlocus' plot in the QC subdirectory.",sep="\n"))
			}
		mynind	<- as.vector(table(inds$pop))
		#if(min(mynind)<2)
		#	{
		#	cat("ERROR: SambaR does not accept populations which contain only 1 retained individual only.",sep="\n")
		#	cat("Change filter settings (i.e. choose a higher value for indmiss) and run the filterdata() again.",sep="\n")
		#	cat("Alternatively, remove samples/populations from input file (i.e. ped file) and run the plink --make-bed and Sambar importdata() function again to import reduced dataset.",sep="\n")
		#	return(cat("For an overview of missing data per population, have a look at the 'Missingdata.perpop' plot in the QC subdirectory.",sep="\n"))
		#	}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values. Contact the developer of SambaR.",sep="\n"))
			}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values. Contact developer of SambaR.",sep="\n"))
			}
		if(dohefilter)
			{
			prop_hefiltered	<- nrow(snps[!snps$hefilter,])/nrow(snps)
			cat(paste("Proportion SNPs which did not pass the heterozygosity excess filter: ",round(prop_hefiltered,3),".",sep=""),sep="\n")
			#if(prop_hefiltered>0.05&paralog_threshold1==0.5)
			if(prop_hefiltered>maxprop_hefilter)
				{
				plotparalogs(export="pdf")
				cat(" ",sep="\n")
				cat("ERROR: proportion of SNPs that do not pass the heterozygosity excess filter is higher than the limit set by the flag 'maxprop_hefilter' (default is 0.05).",sep="\n")
				cat("Observe the 'He_vs_maf' plot to evaluate whether the discarded SNPs do indeed exhibit excessive levels of heterozygosity, indicative of paralogous loci.",sep="\n")
				cat("If so, rerun the filterdata function with a higher threshold 'maxprop_hefilter' value.",sep="\n")
				cat("If not, set the flag dohefilter to FALSE, or rerun the filterdata function with different heterozygosity filter settings, as defined by the 'paralog_threshold1' (default=0.5) and 'paralog_threshold2' flags (default=0.05).",sep="\n")
				return(cat("SambaR's heterozygosity excess filter defines he-excess as: He>(2pq+zq) for q>w, with p and q representing major and minor allele frequency, and z and w representing threshold1 and threshold2.",sep="\n"))  
				}
			}
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		#
		indsmissingness(prior2snpfilter=FALSE)		# calculate missingness per individual for retained snp dataset
		nretainedinds	<- nrow(inds[inds$filter,])
		ntotalinds		<- nrow(inds)
		nretainedsnps	<- nrow(snps[snps$filter2,])
		nthinnedsnps	<- nrow(snps[snps$filter,])
		ntotalsnps		<- nrow(snps)	
		cat(paste("After filtering retained",nretainedinds,"out of",ntotalinds,"individuals.",sep=" "),sep="\n")
		cat(paste("After filtering retained",nretainedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
		cat(paste("After filtering and thinning retained",nthinnedsnps,"out of",ntotalsnps,"snps.",sep=" "),sep="\n")
		#
		# 25-04-2021: moved to function: calckinship()
		if(do_calckin)
			{
			cat("As of 25-04-2021, relatedness calculations are no longer part of the filterdata function.",sep="\n")
			cat("Instead, run the calckinship() function.",sep="\n")
			}
		# inds maf/he:
		cat ("Step 4 out of 6: Calculating sample specific minor allele frequencies and heterozygosities...",sep="\n")
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		if(!silent){cat("ind_maf",sep="\n")}
		ind_maf(allsites=FALSE)
		ind_maf(allsites=TRUE)
		if(!silent){cat("ind_hetero",sep="\n")}
		ind_hetero(allsites=FALSE)
		ind_hetero(allsites=TRUE)
		if(!silent){cat("hwe",sep="\n")}
		if(length(mysambar$populations)<9){hwe(export="eps")}
		hwe(export="pdf")			
		hwe(export="png")
		if(mysambar$os=="Windows"){hwe(export="wmf")}
		cat("FILTERS HAVE BEEN SUCCESFULLY SET. ANY ERRORS OCCURRING AFTER THIS LINE ARE (MOSTLY) RELATED TO CREATING QUALITY CONTROL TABLES AND PLOTS AND WILL NOT DENY YOU FROM RUNNING SUBSEQUENT FUNCTIONS.",sep="\n")
		#
		cat("Step 5 out of 6: Generating summary table...",sep="\n")
		mysummarytable()
		cat("Step 6 out of 6: Generating summary plots...",sep="\n")
		if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
			{	
			return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
			}	
		if(!any(snps$pos!=0))
			{
			cat("No information on genomic positions of SNP. Not creating 'Chrom_length' plots.",sep="\n")
			}else{
			if(length(unique(snps$chr))>1)
				{
				if(!silent){cat("plotscaffoldsize",sep="\n")}
				plotscaffoldsize(export="eps",n_chroms=nchroms)
				plotscaffoldsize(export="pdf",n_chroms=nchroms)
				plotscaffoldsize(export="png",n_chroms=nchroms)
				if(mysambar$os=="Windows"){plotscaffoldsize(export="wmf",n_chroms=nchroms)}
				if(any(snps$chrlength!=0))
					{
					if(!silent){cat("chrlength_vs_nsnps",sep="\n")}
					chrlength_vs_nsnps(export="eps")
					chrlength_vs_nsnps(export="pdf")
					chrlength_vs_nsnps(export="png")
					if(mysambar$os=="Windows"){chrlength_vs_nsnps(export="wmf")}
					}
				if(!is.null(nchroms))
					{
					if(!silent){cat("barplotnsnps",sep="\n")}
					barplotnsnps(n_chroms=nchroms,export="eps")
					barplotnsnps(n_chroms=nchroms,export="pdf")
					barplotnsnps(n_chroms=nchroms,export="png")
					if(mysambar$os=="Windows"){barplotnsnps(n_chroms=nchroms,export="wmf")}
					if(!silent){cat("chromhetero",sep="\n")}
					chromhetero(nchroms=nchroms,export="pdf")	# determine male and females based on X-chromosome
					}
				}else{
				cat("Not plotting nsnps per scaffold, because only 1 scaffold detected.",sep="\n")
				}
			}
		if(!is.null(ychrom))
			{
			plot_Ychrom(export="pdf",y_chrom=ychrom)	# determine male and females based on Y-chromosome
			}
		if(is.null(inds2$pairmiss_obs))
			{
			nind		<- nrow(inds)
			npairwise	<- (nind*(nind-1))/2
			nsnp		<- nrow(snps[snps$filter,])
			ntotal		<- nsnp*npairwise
			if(ntotal>250000000)
				{
				cat("The dataset is quite big. Omitting pairwise sample missingness plots for sake of calculation time.",sep="\n")
				cat("If you want to create these plots, run the functions:",sep="\n")
				cat("calcpairmiss(exporttype='pdf',definebreaks=TRUE,snpsfilter=TRUE,silent=FALSE)",sep="\n")
				cat("showmiss(export='pdf')",sep="\n")
				}else{
				if(min(inds$miss,na.rm=TRUE)>0)
					{
					if(!silent){cat("calcpairmiss",sep="\n")}
					calcpairmiss(exporttype="pdf",definebreaks=TRUE,use_currentdir=TRUE,silent=TRUE,snpsfilter=TRUE,legendcex=1.4,nrbins=20,addmiss=TRUE)
					}
				if(!silent){cat("showmiss",sep="\n")}
				if(min(inds$miss,na.rm=TRUE)>0)
					{
					showmiss(export="pdf")
					}
				}
			}else{
			if(min(inds$miss,na.rm=TRUE)>0)
				{
				if(!silent){cat("calcpairmiss",sep="\n")}
				calcpairmiss(exporttype="pdf",definebreaks=TRUE,use_currentdir=TRUE,silent=TRUE,snpsfilter=TRUE,legendcex=1.4,nrbins=20,addmiss=TRUE)	# only plotting (in built conditional to omit calculations if mysambar$kindf is already present.
				#calcpairmiss(exporttype="pdf",definebreaks=TRUE,use_currentdir=TRUE,silent=TRUE,snpsfilter=FALSE,legendcex=1.4,nrbins=20,addmiss=TRUE)
				}
			}
		# to prevent error relating to plot margins
		if(nrow(inds)>10)
			{
			if(!silent){cat("plotHe_perind",sep="\n")}
			plotHe_perind(export="eps")
			plotHe_perind(export="pdf")
			plotHe_perind(export="png")
			if(mysambar$os=="Windows"){plotHe_perind(export="wmf")}
			}
		if(!silent){cat("plotgenocounts_ind",sep="\n")}
		plotgenocounts_inds(export=TRUE,addlabels=TRUE,metapop=TRUE)
		plotgenocounts_inds(export=TRUE,addlabels=FALSE,metapop=TRUE)
		plotgenocounts_inds(export=TRUE,addlabels=TRUE,metapop=FALSE)
		plotgenocounts_inds(export=TRUE,addlabels=FALSE,metapop=FALSE)
		#if(!silent){cat("plotn2",sep="\n")}
		#plotn2(export="pdf")
		if(!silent){cat("plotgenotri",sep="\n")}
		plotgenotri(export="eps",allsites=FALSE)
		plotgenotri(export="pdf",allsites=FALSE)
		plotgenotri(export="png",allsites=FALSE)
		if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
		plotgenotri(export="eps",allsites=TRUE)
		plotgenotri(export="pdf",allsites=TRUE)
		plotgenotri(export="png",allsites=TRUE)
		if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
		heall_vs_he(export="eps")
		heall_vs_he(export="pdf")
		heall_vs_he(export="png")
		if(mysambar$os=="Windows"){heall_vs_he(export="wmf")}
		if(!silent){cat("glPlot",sep="\n")}
		if(do_genoheatmap)
			{
			genoheatmap(export=TRUE,dofilter=FALSE)
			}
		if(length(mysambar$populations)>1)
			{
			if(!silent){cat("retainedinds_perpop",sep="\n")}
			retainedinds_perpop(export="eps")
			retainedinds_perpop(export="pdf")
			retainedinds_perpop(export="png")
			if(mysambar$os=="Windows"){retainedinds_perpop(export="wmf")}
			if(!silent){cat("discardedinds_perpop",sep="\n")}
			if(any(!inds$filter))
				{
				discardedinds_perpop(export="eps")
				discardedinds_perpop(export="pdf")
				discardedinds_perpop(export="png")
				if(mysambar$os=="Windows"){discardedinds_perpop(export="wmf")}
				}else{
				cat("All individuals retained. Omitting 'Discardedinds.perpop' plots.",sep="\n")
				}
			# showing retained and discarded combined in one plot:
			if(!silent){cat("indsfilter_perpop",sep="\n")}
			indsfilter_perpop(export="eps")
			indsfilter_perpop(export="pdf")
			indsfilter_perpop(export="png")
			if(mysambar$os=="Windows"){indsfilter_perpop(export="wmf")}
			if(!silent){cat("retainedsites_perpop",sep="\n")}
			retainedsites_perpop(export="eps")
			retainedsites_perpop(export="pdf")
			retainedsites_perpop(export="png")
			if(mysambar$os=="Windows"){retainedsites_perpop(export="wmf")}
			}
		if("meandepth"%in%colnames(snps))
			{
			if(!silent){cat("plotlocusdepth",sep="\n")}
			plotlocusdepth(export=TRUE)			# This is in fact mean individual depth, different from plot created in snpsmissingness function.
			}
		if(!silent){cat("plot_number_segregating_sites",sep="\n")}
		plot_number_segregating_sites(export="eps",dofilter=TRUE)
		plot_number_segregating_sites(export="pdf",dofilter=TRUE)
		plot_number_segregating_sites(export="png",dofilter=TRUE)
		if(mysambar$os=="Windows"){plot_number_segregating_sites(export="wmf",dofilter=TRUE)}
		plot_number_segregating_sites(export="eps",dofilter=FALSE)
		plot_number_segregating_sites(export="pdf",dofilter=FALSE)
		plot_number_segregating_sites(export="png",dofilter=FALSE)
		if(mysambar$os=="Windows"){plot_number_segregating_sites(export="wmf",dofilter=FALSE)}
		#if(mysambar$datasource=="converted_from_genlight")
		#	{
		#	cat("Skipping GC-content table and transition-vs-transition plot because data has been converted from a genlight object, and this information got lost.",sep="\n")
		#	}else{
			if(plot_transits)
				{
				cat("If you receive an error soon after this line, set the flag plot_transits to FALSE.",sep="\n")
				if(!silent){cat("plotminor",sep="\n")}
				plotminor(export="eps")
				plotminor(export="pdf")
				plotminor(export="png")
				if(mysambar$os=="Windows"){plotminor(export="wmf")}
				if(!silent){cat("plottransits",sep="\n")}
				plottransits(filter=FALSE,export="eps")
				plottransits(filter=FALSE,export="pdf")
				plottransits(filter=FALSE,export="png")
				if(mysambar$os=="Windows"){plottransits(filter=FALSE,export="wmf")}
				plottransits(filter=TRUE,export="eps")
				plottransits(filter=TRUE,export="pdf")
				plottransits(filter=TRUE,export="png")
				if(mysambar$os=="Windows"){plottransits(filter=TRUE,export="wmf")}
				}
		#	}
		if(!silent){cat("plotfiltermaf",sep="\n")}
		if(length(mysambar$populations)<9){plotfiltermaf(export="eps")}	# figure margins too large if 10 pops
		plotfiltermaf(export="pdf")
		plotfiltermaf(export="png")
		if(mysambar$os=="Windows"){plotfiltermaf(export="wmf")}
		if("dist" %in% colnames(snps)&do_mafdiff)
			{
			if(!silent){cat("multimafdiff",sep="\n")}
			multimafdiff()
			}
		if(length(mysambar$populations)>1)
			{
			if(!silent){cat("histo_locusHe",sep="\n")}
			if(length(mysambar$populations)<9){histo_locusHe(export="eps")}
			histo_locusHe(export="pdf")
			histo_locusHe(export="png")
			if(mysambar$os=="Windows"){histo_locusHe(export="wmf")}
			if(!silent){cat("boxplot_locusHe",sep="\n")}
			boxplot_locusHe(export="eps")
			boxplot_locusHe(export="pdf")
			boxplot_locusHe(export="png")
			if(mysambar$os=="Windows"){boxplot_locusHe(export="wmf")}
			}
		if(!silent){cat("plotparalogs",sep="\n")}
		plotparalogs(export="eps")
		plotparalogs(export="pdf")
		plotparalogs(export="png")
		if(mysambar$os=="Windows"){plotparalogs(export="wmf")}
		plotparalogs(export="eps",dothin=TRUE)
		plotparalogs(export="pdf",dothin=TRUE)
		plotparalogs(export="png",dothin=TRUE)
		if(mysambar$os=="Windows"){plotparalogs(export="wmf",dothin=TRUE)}
		if("meandepth"%in%colnames(inds))
			{
			if(!silent){cat("He_vs_readdepth",sep="\n")}
			He_vs_readdepth(export="eps",allsites=TRUE,legendcex=legend_cex)
			He_vs_readdepth(export="pdf",allsites=TRUE,legendcex=legend_cex)
			He_vs_readdepth(export="png",allsites=TRUE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_readdepth(export="wmf",allsites=TRUE,legendcex=legend_cex)}
			He_vs_readdepth(export="eps",allsites=FALSE,legendcex=legend_cex)
			He_vs_readdepth(export="pdf",allsites=FALSE,legendcex=legend_cex)
			He_vs_readdepth(export="png",allsites=FALSE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_readdepth(export="wmf",allsites=FALSE,legendcex=legend_cex)}
			}
		if(!silent){cat("He_vs_miss",sep="\n")}
		if(max(inds$miss,na.rm=TRUE)>0)
			{
			He_vs_miss(export="eps",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="pdf",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="png",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_miss(export="wmf",allsites=TRUE,maxmiss=indmiss,legendcex=legend_cex)}
			He_vs_miss(export="eps",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="pdf",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)
			He_vs_miss(export="png",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)
			if(mysambar$os=="Windows"){He_vs_miss(export="wmf",allsites=FALSE,maxmiss=indmiss,legendcex=legend_cex)}
			}else{
			cat("No missing data. Skipping He_vs_miss plot.",sep="\n")
			}
		#
		# optionally plot statistics per sequencing pool:
		if(!silent){cat("plotperpool",sep="\n")}
		plotperpool()
		# stacks_demultiplex()
		#
		# create a report of filter settings:
		mysettings			<- data.frame("settings"=c("date/time","indmiss","snpmiss","minimum_minor_allele_count","dohefilter","min_spacing"),"value"=rep(NA,6))
		mysettings$value[1]	<- as.character(Sys.time())
		mysettings$value[2]	<- as.character(indmiss)
		mysettings$value[3]	<- as.character(snpmiss)
		mysettings$value[4]	<- ifelse(is.null(min_mac),"0",as.character(min_mac))
		mysettings$value[5]	<- as.character(dohefilter)
		mysettings$value[6]	<- as.character(ifelse("dist"%in%colnames(snps),min_spacing,0))
		write.table(mysettings,"SambaR_filtersettings.txt",row.names=FALSE,col.names=FALSE,quote=FALSE,sep="\t")
		# create a file with information about filter settings per individual:
		if(!silent){cat("SambaR_samples.filterinfo.txt",sep="\n")}
		indstable	<- inds[,c("name","nr","pop","pop2","popcol","filter","miss","nsites2","hetero_all","hetero")]
		colnames(indstable)<- c("name","nr","pop","pop2","popcol","filter","prop_miss","n_retained_sites","hetero_retained_sites","hetero_segregating_sites")
		write.table(indstable,"SambaR_samples.filterinfo.txt",row.names=FALSE,sep="\t",quote=FALSE)
		#
		cat("Writing out file listing number of retained individuals per population...",sep="\n") 
		mydf			<- aggregate(inds$name[inds$filter],list(inds$pop[inds$filter]),length)
		colnames(mydf)	<- c("pop","n_retained")
		write.table(mydf,"Retainedinds.perpop.txt",sep="\t",quote=FALSE,col.names=TRUE,row.names=FALSE)
		#
		if(do_highestsd)
			{
			cat("WARNING: this option has been moved to the exportsambarfiles() function. Not exporting files.",sep="\n")
			}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values. Contact the developer of SambaR.",sep="\n"))
			}
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values. Contact developer of SambaR.",sep="\n"))
			}
		cat("Finished filtering dataset. Summary plots and tables have been written to:",sep="\n")
		#
		setwd(mysambar$sambardir)
		exportmethods(ind_miss=indmiss,snp_miss=snpmiss,minmac=min_mac,hefilter=dohefilter,minimumspacing=min_spacing)
		cat("A description of the methods has been written to a txt.file called 'SambaR_methods.txt' within the directory:",sep="\n")
		cat(mysambar$sambardir,sep="\n")
		setwd(mysambar$inputdatadir)
		cat("To export the retained dataset in immanc format (i.e. Bayesass input) as well as PED/MAP format (for relatedness and LD calculations in plink), type on the command line:",sep="\n")
		cat("exportsambarfiles()",sep="\n")
		cat("Note: as of 25-04-2021 (Sambar version 1.04), inbreeding and kinship calculations/plots are executed/generated with the calckinship function and outputted to the 'Kinship' subdirectory.",sep="\n")  
		}
	}

runthinfilter<-function(overwrite_bin=TRUE,binsize=500,silent=TRUE)
	{
	if(binsize<0)
		{
		return(cat("ERROR: binsize should be positive.",sep="\n"))
		}
	if(binsize==0)
		{
		snps$distfilter							<<- TRUE
		return(cat("WARNING: binsize set to 0. As a consequence, no thinning will be applied. All values in distfilter column will be set to TRUE.",sep="\n"))
		}
	if(!"pos"%in%colnames(snps))
		{
		return(cat("ERROR: column snps$pos is missing.",sep="\n"))
		}
	if(any(is.na(snps$pos)))
		{
		cat("WARNING: NA-values present in snps$pos column.",sep="\n")
		}
	if("dist" %in% colnames(snps))
		{
		if("distclass"%in%colnames(snps)&!overwrite_bin)
			{
			cat("WARNING: Using existing position bins defined in column snps$distclass.",sep="\n")
			cat("If you want to create new position bins, set the flag overwrite_bin to TRUE or alternatively delete existing column.",sep="\n")
			}else{
			cat("Dividing snps into bins based on position in genome...",sep="\n")
			cat(paste("Using bins of ",binsize," bp width.",sep=""),sep="\n")  
			snps$distclass	<<- NA
			mychroms		<- as.vector(unique(snps$chr))
			for(mychrom in mychroms)
				{
				if(!silent){cat(mychrom,sep="\n")}
				mysnpspos							<- snps$pos[snps$chr==mychrom]
				if(length(mysnpspos)>1)
					{
					mybreaks						<- seq(0,max(mysnpspos,na.rm=TRUE)+binsize,binsize)
					if(length(mybreaks)==1)
						{
						if(mybreaks==0)
							{
							snps$distclass[snps$chr==mychrom]<<- paste(as.character(mychrom),as.character(binsize/2),sep="_")
							}else{
							mylabelstemp	<- mybreaks-binsize/2
							mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
							snps$distclass[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
							}
						}else{
						mylabelstemp		<- mybreaks[2:length(mybreaks)]-binsize/2
						mylabels			<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
						snps$distclass[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
						}
					}else{
					snps$distclass[snps$chr==mychrom]	<<- paste(as.character(mychrom),as.character(mysnpspos),sep="_")
					}
				}
			if(any(is.na(snps$distclass)))
				{
				nna	<- length(which(is.na(snps$distclass)))
				cat(paste("WARNING: ",nna," NA-values in distclass column.",sep=""),sep="\n")
				}
			#
			cat("Selecting one snp per position bin.",sep="\n")
			snps$distfilter						<<- NA
			snps$distfilter						<<- !duplicated(snps$distclass)
			#
			# adjusting NA's:
			myclass1					<- snps$distclass[1:(nrow(snps)-1)]
			myclass2					<- snps$distclass[2:nrow(snps)]
			mybool						<- c(TRUE,myclass1!=myclass2)
			snps$distfilter				<<- ifelse(is.na(snps$distfilter),mybool,snps$distfilter)	
			#
			if(any(is.na(snps$distfilter)))
				{
				nna	<- length(which(is.na(snps$distfilter)))
				cat(paste("WARNING: ",nna," NA-values in distfilter column. Replacing with FALSE.",sep=""),sep="\n")
				}
			snps$distfilter[is.na(snps$distfilter)]	<<- FALSE
			nretained								<- nrow(snps[snps$distfilter,])
			cat(paste("Number of SNPs retained after thinning: ",nretained,".",sep=""),sep="\n")  
			}
		}else{
		cat("WARNING: No positional information. All values in distfilter column will be set to TRUE.",sep="\n")
		snps$distfilter							<<- TRUE
		}
	}

mergepop<-function(sourcepop=NULL,targetpop=NULL)
	{
	if(is.null(sourcepop))
		{
		return(cat("ERROR: provide to the 'sourcepop'-flag the name(s) of population(s) to be merged into another population.",sep="\n"))
		}
	if(is.null(targetpop))
		{
		return(cat("ERROR: provide to the 'targetpop'-flag the name(s) of population(s) in which other populations should be merged into.",sep="\n"))
		}
	if(length(sourcepop)!=length(targetpop))
		{
		return(cat("ERROR: input vectors provided to sourcepop and targetpop should be of the same length.",sep="\n"))
		}
	popvector		<- as.character(inds$pop)
	mypops			<- mysambar$populations
	mypops2			<- mysambar$populations2
	mycolours		<- mysambar$mycolours
	mycolours2		<- mysambar$mycolours2
	mypoporder		<- mysambar$poporder
	mypoporder2		<- mysambar$poporder2
	mycolorder		<- mysambar$colorder
	mycolorder2		<- mysambar$colorder2
	npopsbefore		<- length(mysambar$populations2)
	#
	for(j in c(1:length(sourcepop)))
		{
		mysource	<- as.character(sourcepop[j])
		mytarget	<- as.character(targetpop[j])
		cat(paste("Merging population ",mysource," into population ",mytarget,".",sep=""),sep="\n")
		if(mysource==mytarget)
			{
			return(cat("ERROR: sourcepop and targetpop can not be the same.",sep="\n"))
			}
		if(!mysource%in%popvector)
			{
			return(cat("ERROR: sourcepop does not occur inds$pop column.",sep="\n"))
			}
		if(!mytarget%in%popvector)
			{
			return(cat("ERROR: sourcepop does not occur inds$pop column.",sep="\n"))
			}
		popvector[popvector==mysource]	<- mytarget
		mycolours	<- mycolours[!mypops%in%sourcepop]
		mypops		<- mypops[!mypops%in%sourcepop]
		mycolours2	<- mycolours2[!mypops2%in%sourcepop]
		mypops2		<- mypops2[!mypops2%in%sourcepop]
		mycolorder	<- mycolorder[!mypoporder%in%sourcepop]
		mypoporder	<- mypoporder[!mypoporder%in%sourcepop]
		mycolorder2	<- mycolorder2[!mypoporder2%in%sourcepop]
		mypoporder2	<- mypoporder2[!mypoporder2%in%sourcepop]
		}
	#
	inds$pop				<<- as.factor(popvector)
	mysambar$populations	<<- mypops
	mysambar$populations2	<<- mypops
	mysambar$mycolours		<<- mycolours
	mysambar$mycolours2		<<- mycolours2
	mysambar$poporder		<<- mypoporder
	mysambar$poporder2		<<- mypoporder2
	mysambar$colorder		<<- mycolorder
	mysambar$colorder2		<<- mycolorder2
	#
	# updating mysambar$popordernr and mysambar$popordernr2:
	myordernr				<- vector()
	for(i in c(1:length(mypoporder)))
		{
		mypop				<- as.character(mypoporder[i])
		mypopnr				<- which(as.character(mysambar$populations)==mypop)
		if(length(mypopnr)==0)
			{
			return(cat(paste("ERROR: Population name ",mypop," not present in actual data.",sep=""),sep="\n"))
			}
		myordernr[i]		<- mypopnr
		}
	myordernr2				<- vector()
	for(i in c(1:length(mypoporder2)))
		{
		mypop				<- as.character(mypoporder2[i])
		mypopnr				<- which(as.character(mysambar$populations2)==mypop)
		if(length(mypopnr)==0)
			{
			return(cat(paste("ERROR: Population name ",mypop," not present in actual data.",sep=""),sep="\n"))
			}
		myordernr2[i]		<- mypopnr
		}
	# population order in numbers (relative to alphabetical order):
	mysambar$popordernr		<<- myordernr
	mysambar$popordernr2	<<- myordernr2
	cat("Specified populations have been merged.",sep="\n")
	npopsafter	<- length(mysambar$populations2)
	cat(paste("Number of populations before merging: ",npopsbefore,".",sep=""),sep="\n")
	cat(paste("Number of populations after merging: ",npopsafter,".",sep=""),sep="\n")
	}

excludepop<-function(popvector=NULL,do_exclude=NULL,retain=FALSE)
	{
	if((!exists("inds"))|(!exists("mysambar")))
		{
		return(cat("ERROR: objects inds and/or mysambar not found.",sep="\n"))
		}
	if(!is.null(do_exclude))
		{
		cat("WARNING: as of 28-10-2021, the flag do_exclude has been replaced by the flag 'popvector'.",sep="\n")
		cat("The input vector to the popvector flag defines the names of populations to be either excluded or retained, depending on the flag 'retain' (default is FALSE, meaning: exclude).",sep="\n")
		cat("Renaming do_exclude to popvector and continuing...",sep="\n")
		popvector	<- do_exclude 	
		}
	# exclude population:
	if(any(!(inds2$name1%in%inds$name|inds2$name2%in%inds$name)))
		{
		return(cat("ERROR: Unexpected sample names in inds2 dataframe.",sep="\n"))
		}
	if(any(!(inds$name%in%inds2$name1|inds$name%in%inds$name2)))
		{
		return(cat("ERROR: sample names missing in inds2 dataframe.",sep="\n"))
		}
	if(!"filter2"%in%colnames(inds))
		{
		return(cat("ERROR: Column filter2 not present in inds dataframe. Did you run the filterdata() function?",sep="\n"))
		}
	if(is.null(mysambar$poporder))
		{
		return(cat("ERROR: mysambar$poporder missing.",sep="\n"))
		}
	if(any(!popvector%in%mysambar$populations2))
		{
		cat("ERROR: the following specified populations are not present in the data:",sep="\n")
		missingpop	<- popvector[!popvector%in%mysambar$populations2]
		return(cat(missingpop,sep="\n"))
		}
	cat("Resetting filters...",sep="\n")
	mysambar$mycolours	<<- mysambar$mycolours2
	mysambar$populations<<- mysambar$populations2
	mysambar$poporder	<<- mysambar$poporder2
	mysambar$colorder	<<- mysambar$colorder2
	mysambar$popordernr	<<- mysambar$popordernr2
	inds$filter			<<- inds$filter2
	if(is.null(popvector))
		{
		excludepopvector		<- c()
		cat("WARNING: no population name provided to the popvector flag. Not excluding any population.",sep="\n")
		}else{
		if(retain)
			{
			cat("The flag 'retain' is set to TRUE, meaning that the specified populations will be retained.",sep="\n")
			mybool				<- mysambar$populations2%in%popvector
			mybool2				<- mysambar$poporder2%in%popvector
			excludepopvector	<- mysambar$populations2[!mysambar$populations2%in%popvector]
			}else{
			cat("The flag 'retain' is set to FALSE, meaning that the specified populations will be excluded.",sep="\n")
			mybool				<- !mysambar$populations2%in%popvector
			mybool2				<- !mysambar$poporder2%in%popvector
			excludepopvector	<- popvector
			}
		mysambar$populations	<<- mysambar$populations2[mybool]
		mysambar$mycolours		<<- mysambar$mycolours2[mybool]
		mysambar$poporder		<<- mysambar$poporder2[mybool2]
		mysambar$colorder		<<- mysambar$colorder2[mybool2]
		#
		for (k in c(1:length(excludepopvector)))
			{
			my_pop				<- excludepopvector[k]
			cat(paste("Excluding population: ",my_pop,".",sep=""),sep="\n")
			inds$filter			<<- inds$filter&inds$pop!=my_pop
			}
		#
		popordernr				<- vector()
		for(i in c(1:length(mysambar$poporder)))
			{
			mypop				<- as.character(mysambar$poporder[i])
			mypopnr				<- which(as.character(mysambar$populations)==mypop)
			if(length(mypopnr)==0)
				{
				return(cat(paste("ERROR: Population name ",mypop," not present in actual data.",sep=""),sep="\n"))
				}
			popordernr[i]		<- mypopnr
			}
		mysambar$popordernr		<<- popordernr
		}
	#cat("Updating inds2 dataframe...",sep="\n")
	#indstemp1			<- inds[,c("name","filter")]	
	#colnames(indstemp1)<- c("name1","filter1")
	#indstemp2			<- inds[,c("name","filter")]	
	#colnames(indstemp2)<- c("name2","filter2")
	#inds2merged		<- merge(inds2,indstemp1,by="name1")	
	#if(nrow(inds2merged)!=nrow(inds2))
	#	{
	#	return(cat("ERROR: unexpected number of rows of inds2 dataframe after adding filter1 column. Contact developer of SambaR.",sep="\n"))
	#	}
	#inds2merged2		<- merge(inds2merged,indstemp2,by="name2")	
	#if(nrow(inds2merged2)!=nrow(inds2))
	#	{
	#	return(cat("ERROR: unexpected number of rows of inds2 dataframe after adding filter2 column. Contact developer of SambaR.",sep="\n"))
	#	}
	#inds2				<<- inds2 
	#inds2$filter		<<- inds2$filter1&inds2$filter2
	# 12-01-2023: replaced above lines with the following lines:
	cat("Updating inds2 dataframe ...",sep="\n")
	retainedvec			<- inds$name[inds$filter] 
	inds2$filter1[inds2$name1%in%retainedvec]	<<- TRUE
	inds2$filter1[!inds2$name1%in%retainedvec]	<<- FALSE
	inds2$filter2[inds2$name2%in%retainedvec]	<<- TRUE
	inds2$filter2[!inds2$name2%in%retainedvec]	<<- FALSE
	inds2$filter		<<- inds2$filter1&inds2$filter2
	# checkpoint:
	boolvec				<- c(inds2$name1%in%retainedvec,inds2$name2%in%retainedvec)
	if(all(boolvec))
		{
		if(any(!inds$filter))
			{
			return(cat("ERROR: unexpected number of retained individuals (namely all) in inds2 dataframe after updating ind2 dataframe. Contact developer of SambaR.",sep="\n"))
			}
		}else{
		#nretained2		<- length(boolvec[boolvec])
		#ndiscarded2		<- length(boolvec[!boolvec])
		#nretained		<- length(inds$filter[inds$filter])
		#ndiscarded		<- length(inds$filter[!inds$filter])
		#if(nretained2!=(ndiscarded2/ndiscarded*nretained))
		#	{
	 	#	return(cat("ERROR: unexpected number of retained individuals in inds2 dataframe after updating ind2 dataframe. Contact developer of SambaR.",sep="\n"))
		#	}
		retainedvec		<- inds$name[inds$filter]
		discardedvec	<- inds$name[!inds$filter]
		check1			<- any(inds2$filter[inds2$name2%in%discardedvec|inds2$name2%in%discardedvec])
		check2			<- any(!inds2$filter[inds2$name1%in%retainedvec&inds2$name2%in%retainedvec])
		if(check1|check2)
			{
			return(cat(paste("ERROR: unexpected number of retained individuals in inds2 dataframe (",nretained2," instead of ",nexpected2,") after updating ind2 dataframe. Contact developer of SambaR.",sep=""),sep="\n"))
			}
		}
	cat("Updating pops2 dataframe ...",sep="\n")
	for(i in c(1:nrow(pops2)))
		{
		pop1				<- as.character(pops2$pop1[i])
		pop2				<- as.character(pops2$pop2[i])
		pops2$filter1[i]	<<- !pop1%in%excludepopvector
		pops2$filter2[i]	<<- !pop2%in%excludepopvector
		}
	pops2$filter			<<- pops2$filter1&pops2$filter2
	}

# 17-01-2023: function to randomly select at maximum n individuals per population 
popthin<-function(n=NULL,popnames=mysambar$populations,popvec=inds$pop)
	{
	filtervec		<- inds$filter
	inds$filter		<<- inds$filter2
	if(is.null(popvec))
		{
		return(cat("ERROR: specified popvec does not exist.",sep="\n"))
		}
	if(any(!popnames%in%popvec))
		{
		return(cat("ERROR: one or more specified populations not found in population list.",sep="\n"))
		}
	npops			<- length(popnames)
	inds$popthin	<<- TRUE
	if(is.null(n))
		{
		cat("No number specified to n flag. Not downsampling. Instead resetting filters.",sep="\n") 
		inds$popthin<<- TRUE
		nretained	<- nrow(inds[inds$filter,])
		}else{
		for(k in c(1:npops))
			{
			mypop	<- popnames[k]
			cat(mypop,sep="\n")
			#myinds	<- inds$name[inds$pop==mypop&inds$filter2]
			myinds	<- inds$name[popvec==mypop&inds$filter2]
			ninds	<- length(myinds)
			if(ninds<=n)
				{
				cat(paste("Number of retained samples is ",ninds,". Not downsampling.",sep=""),sep="\n")
				}else{
				cat(paste("Number of retained samples is ",ninds,". Randomly selecting ",n," individuals.",sep=""),sep="\n")
				selectvec		<- sample(myinds,n,replace=FALSE)
				discardvec		<- myinds[!myinds%in%selectvec]
				inds$popthin[inds$name%in%discardvec]	<<- FALSE
				}
			}
		inds$filter	<<- filtervec&inds$popthin
		nretained	<- nrow(inds[inds$filter,])
		}
	cat("Updating inds2 dataframe ...",sep="\n")
	retainedvec			<- inds$name[inds$filter] 
	inds2$filter1[inds2$name1%in%retainedvec]	<<- TRUE
	inds2$filter1[!inds2$name1%in%retainedvec]	<<- FALSE
	inds2$filter2[inds2$name2%in%retainedvec]	<<- TRUE
	inds2$filter2[!inds2$name2%in%retainedvec]	<<- FALSE
	inds2$filter		<<- inds2$filter1&inds2$filter2
	# checkpoint:
	boolvec				<- c(inds2$name1%in%retainedvec,inds2$name2%in%retainedvec)
	if(all(boolvec))
		{
		if(any(!inds$filter))
			{
			return(cat("ERROR: unexpected number of retained individuals (namely all) in inds2 dataframe after updating ind2 dataframe. Contact developer of SambaR.",sep="\n"))
			}
		}else{
		#nretained2		<- length(boolvec[boolvec])
		#ndiscarded2		<- length(boolvec[!boolvec])
		#nretained		<- length(inds$filter[inds$filter])
		#ndiscarded		<- length(inds$filter[!inds$filter])
		#if(nretained2!=(ndiscarded2/ndiscarded*nretained))
		#	{
	 	#	return(cat("ERROR: unexpected number of retained individuals in inds2 dataframe after updating ind2 dataframe. Contact developer of SambaR.",sep="\n"))
		#	}
		retainedvec		<- inds$name[inds$filter]
		discardedvec	<- inds$name[!inds$filter]
		check1			<- any(inds2$filter[inds2$name2%in%discardedvec|inds2$name2%in%discardedvec])
		check2			<- any(!inds2$filter[inds2$name1%in%retainedvec&inds2$name2%in%retainedvec])
		if(check1|check2)
			{
			return(cat(paste("ERROR: unexpected number of retained individuals in inds2 dataframe (",nretained2," instead of ",nexpected2,") after updating ind2 dataframe. Contact developer of SambaR.",sep=""),sep="\n"))
			}
		}
	cat(paste("Done. Number of randomly selected individuals: ",nretained,".",sep=""),sep="\n")
	}

exporthighestsd<-function(nsnps=c(10,20,50,100,150,250),silent=TRUE,do_export=TRUE)
	{
	if(!"sd_popmaf"%in%colnames(snps))
		{
		return(cat("ERROR: Column 'sd_popmaf' not present in snps dataframe. First run the filterdata() function.",sep="\n")) 
		}
	mywd	<- getwd()
	setwd(mysambar$inputfilesdir)
	# 18-3-2020: this myfilter and sd filter still needs to be included in pcoa function:
	# first get filter settings:
	popmafs 				<- snps[,grep("maf_",colnames(snps))]
	mafmin					<- apply(popmafs,1,min)
	nodatavec				<- !is.na(rowSums(popmafs))
	mysd					<- snps$sd_popmaf
	myfilter				<- (snps$filter)&(mafmin>0)&(nodatavec)&is.finite(mysd)&!is.na(mysd)
	snps$sdfilter			<<- myfilter
	n_snps					<- nrow(snps[myfilter,])
	if(n_snps<250)
		{
		return(cat("Less than 250 retained SNPs of which the minor allele is present in all populations. Aborting exporthighestsd() function.",sep="\n")) 
		}
	# now select:
	mysd					<- mysd[myfilter] 
	snpsfiltered			<- snps[myfilter,]
	snpstemp				<- snpsfiltered[order(-mysd),]
	for (nsubset in nsnps)
		{
		if(!silent){cat(paste(nsubset,"SNPs",sep=" "),sep="\n")}
		snpsubset		<- head(snpstemp,nsubset)
		thres			<- min(snpsubset$sd_popmaf,na.rm=TRUE)
		myselection		<- snps$sd_popmaf>=thres&myfilter
		snps$sdfilter	<<- myselection
		if(do_export)
			{
			genlight2ped(snpsfilter=myselection,indsfilter=inds$filter,exportname=paste("metapop",nsubset,"SNPs.highest_popmaf_sd.number",sep="."),quiet=TRUE) 
			}
		}
	cat("Datasets with small subsets of most informative SNPs (highest standard deviation of population minor allele frequencies) exported to:",sep="\n")
	cat(getwd(),sep="\n")
	setwd(mywd)
	}

exportsambarfiles<-function(do_immanc=TRUE,do_pednumber=TRUE,do_pedletter=TRUE,do_treemix=TRUE,do_popcluster=FALSE,do_silent=TRUE,per_pop=FALSE,do_tab=TRUE,imputeddata=FALSE,do_highestsd=FALSE)
	{
	if(imputeddata)
		{
		if(is.null(mysambar$imputedmatrix))
			{
			return(cat("ERROR: The flag 'imputeddata' is set to TRUE but mysambar$imputedmatrix does not exist. Did you run the sambarimpute(per_snp=FALSE) function?",sep="\n")) 
			}
		cat("Using imputed data (because flag 'imputeddata' is set to TRUE).",sep="\n")
		inputgenlight	<- as.genlight(mysambar$imputedmatrix)
		}else{
		inputgenlight	<- mygenlight
		}
	setwd(mysambar$inputfilesdir)
	if(do_immanc)
		{
		if(length(mysambar$populations)>1)
			{
			cat("Exporting input for Bayesass ('Bayesassinput.immanc.txt')...",sep="\n")
			genlight2immanc(quiet=TRUE)
			}else{
			cat("Currently only 1 population defined. Not exporting Bayesass input ('Bayesassinput.immanc.txt').",sep="\n")
			}
		}
	if(do_treemix)
		{
		cat("Exporting input for Treemix software. If you receiving an error after this line, set the flag 'do_treemix' to FALSE.",sep="\n")
		exporttreemix(silent=do_silent)
		}
	if(do_pednumber)
		{
		cat("Exporting input for plink relatedness (pi_hat) calculations ('metapop.allinds.filter.number.ped' and 'metapop.allinds.filter.number.map)...",sep="\n")
		myexportname		<- ifelse(imputeddata,"metapop.allinds.filter.number.imputed","metapop.allinds.filter.number")
		genlight2ped(input=inputgenlight,snpsfilter=snps$filter,indsfilter=rep(TRUE,nrow(inds)),exportname=myexportname,quiet=TRUE,use_tab=do_tab) 		
		cat("Exporting input for Admixture software and plink relatedness (pi_hat) calculations ('metapop.filter.number.ped' and 'metapop.filter.number.map')...",sep="\n")
		myexportname		<- ifelse(imputeddata,"metapop.retainedinds.filter.number.imputed","metapop.retainedinds.filter.number")
		genlight2ped(input=inputgenlight,snpsfilter=snps$filter,indsfilter=inds$filter,exportname=myexportname,quiet=TRUE,use_tab=do_tab)
		# 17-06-2019: This was originally called 'Relatednessinput'
		# 16-03-2019: I made changes to include all samples in the output file.
		cat("Exporting input for plink LD calculations (files ending on 'filter2.number.ped' and 'filter2.number.map'). This make take a while...",sep="\n")
		myexportname		<- ifelse(imputeddata,"filter2.number.imputed","filter2.number")
		exportdata(input_genlight=inputgenlight,snpsfilter=snps$filter2,indsfilter=inds$filter,export_name="filter2.number",quiet2=TRUE,do_all=per_pop,dotab=do_tab)
		}
	if(do_pedletter)
		{
		cat("Exporting input for 'plink --recode vcf' command (files ending on 'filter.number.ped' and 'filter.number.map'), in case you would like to convert filtered datasets (back) to vcf format.",sep="\n")
		myexportname		<- ifelse(imputeddata,"filter.letter.imputed","filter.letter")
		exportdata(input_genlight=inputgenlight,snpsfilter=snps$filter,indsfilter=inds$filter,export_name=myexportname,geno_nr=FALSE,quiet2=TRUE,do_all=per_pop,dotab=do_tab)
		}
	if(do_popcluster)
		{
		cat("Exporting input for PopCluster software. If you receiving an error after this line, set the flag 'do_popcluster' to FALSE.",sep="\n")
		cat("This conversion may take a while. Note that PopCluster also accepts ordinary PED and MAP format, so you might consider skipping this conversion if it takes too long.",sep="\n")
		genlight2ped(exportname="PopCluster_input",genonumber=TRUE,miss_char="0",use_tab=FALSE,popcluster=TRUE)
		}
	if(do_highestsd)
		{
		cat("Exporting ped and map files with SNP subsets with highest sd of population allele frequencies...",sep="\n")
		cat("To skip, set the flag 'do_highestsd' to FALSE.",sep="\n")
		if(length(mysambar$populations)>1)
			{
			cat("Exporting data subsets with highly informative SNPs.",sep="\n") 
			cat("By default, subsets are exported with the most informative 10, 20, 50, 100, 150, and 250 SNPs.",sep="\n")
			cat("To export a subset with a different number of most informative SNPs (for example: 500), type on the command line: exporthighestsd(nsnps=500).",sep="\n")  
			cat("If you receive an error after this line, rerun the filterdata function with the flag 'do_highestsd' set to FALSE.",sep="\n") 
			exporthighestsd(nsnps=c(10,20,50,100,150,250),silent=TRUE)
			}else{
			cat("Only 1 population defined. Skipping selection of most informative SNPs.",sep="\n")
			}
		}else{
		cat("The flag 'do_highestsd' is set to FALSE. Skipping exporting files with most informative SNPs.",sep="\n")
		}
	setwd(mysambar$inputdatadir)
	cat("Filtered datasets have been written to:",sep="\n")
	cat(mysambar$inputfilesdir,sep="\n")
	}

calcretainedsnps<-function(export=NULL,logy=FALSE,silent=FALSE,wide_plot=FALSE,linewidth=3)
	{
	my_wd			<- getwd()
	indmissvector	<- c(0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.075,0.1,0.15,0.2,0.25,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)
	snpmissvector	<- c(0.2,0.1,0.05,0.02,0.01,0)
	if(!"miss"%in%colnames(inds))
		{
		mat 		<- as.matrix(mygenlight)
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		}
	if(!is.null(export))
		{
		if(wide_plot)
			{
			mywidth=16
			myheight=8
			mywidth2=1200
			myheight2=600
			}else{
			mywidth=10.5
			myheight=10.5
			mywidth2=720
			myheight2=720
			}
		mylabel	<- ifelse(logy,"log_yaxis","linear_yaxis")
		if(export=="eps"){postscript(paste("Data_quality",mylabel,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste("Data_quality",mylabel,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste("Data_quality",mylabel,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste("Data_quality",mylabel,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	par(mar=c(5,7,8.5,1.5),cex.axis=2.5,cex.lab=3)
	if(logy)
		{
		x			<- c(1,nrow(mygenlight))
		y			<- c(1,ncol(mygenlight))
		plot(x,y,col="white",log="y",xlab="",ylab="",las=1,yaxt='n')
		myaxis		<- c(100,500,1000,5000,10000,50000,100000)
		axis(2,at=myaxis,labels=myaxis/1000,las=1)
		abline(h=myaxis,col="grey95")
		}else{
		x			<- c(0,nrow(mygenlight))
		y			<- c(0,ncol(mygenlight))
		plot(x,y,col="white",yaxt='n',xlab="",ylab="")
		if(ncol(mygenlight)>20000)
			{
			myaxis		<- seq(0,ncol(mygenlight),10000)
			}else{
			myaxis		<- seq(0,ncol(mygenlight),1000)
			}
		axis(2,at=myaxis,labels=myaxis/1000,las=1)
		abline(h=myaxis,col="grey95")
		}
	if(is.null(mysambar$snpmissmat))
		{
		setwd(mysambar$sambardir)
		if(file.exists("Data_quality.txt"))
			{
			cat("Using existing table 'Data_quality.txt' in the directory:",sep="\n")
			cat(getwd(),sep="\n")
			snpmissmat			<- read.table("Data_quality.txt",header=FALSE)
			do_analysis			<- FALSE
			mysambar$snpmissmat	<<- snpmissmat
			nretainedinds		<- snpmissmat[nrow(snpmissmat),]
			}else{
			do_analysis			<- TRUE
			snpmissmat			<- matrix(NA,nrow=length(snpmissvector)+1,ncol=length(indmissvector))
			cat("Data_quality.txt file is not present. Creating datafile now.",sep="\n")
			cat("This will take some time, but the next time you run the importdata() function this step will be automatically omitted and then it will be much faster.",sep="\n") 
			nretainedinds		<- snpmissmat[nrow(snpmissmat),] 
			}
		}else{
		cat("Using existing table saved at mysambar$snpmissmat.",sep="\n")
		do_analysis				<- FALSE
		snpmissmat				<- mysambar$snpmissmat
		nretainedinds			<- snpmissmat[nrow(snpmissmat),]
		}
	if(length(nretainedinds)!=length(indmissvector))
		{
		cat("WARNING: number of columns of data quality matrix does not equal expected length (length 'indmissvector').",sep="\n")
		cat("Redoing analyses...")
		cat("This will take some time, but the next time you run the importdata() function this step will be automatically omitted and then it will be much faster.",sep="\n") 
		do_analysis			<- TRUE
		snpmissmat			<- matrix(NA,nrow=length(snpmissvector)+1,ncol=length(indmissvector))
		nretainedinds		<- snpmissmat[nrow(snpmissmat),] 
		}
	mycolfunc 					<- colorRampPalette(c("orange","grey80"))
	mycolours					<- mycolfunc(length(snpmissvector)-1)
	mycolours					<- c(mycolours,"black")
	for (k in c(1:length(snpmissvector)))
		{
		max_miss				<- snpmissvector[k]
		if(!do_analysis)
			{
			nretainedinds		<- snpmissmat[nrow(snpmissmat),]
			nretainedsnps		<- snpmissmat[k,]
			}else{
			nretainedinds		<- vector()
			nretainedsnps		<- vector()
			for (j in c(1:length(indmissvector)))
				{
				mymiss			<- indmissvector[j]
				myselection		<- inds$miss<=mymiss
				ninds			<- length(myselection[myselection])
				indmiss			<- inds$miss[myselection]
				nretainedinds[j]<- ninds 
				if(ninds==0)
					{
					nretainedsnps[j]	<- 0
					}else{
					tempgenlight		<- mygenlight[myselection,]
					missingpersnp		<- glNA(tempgenlight,alleleAsUnit=FALSE)/nInd(tempgenlight)
					nretainedsnps[j]	<- length(which(missingpersnp<=max_miss))
					}
				}
			if(k==1)
				{
				snpmissmat[nrow(snpmissmat),]<- nretainedinds
				}
			snpmissmat[k,]					<- nretainedsnps	
			}
		if(k==1)
			{
			abline(v=nretainedinds,col="grey95")
			}
		points(x=nretainedinds[nretainedinds>0],y=nretainedsnps[nretainedinds>0],col=mycolours[k],lwd=linewidth,type='b')
		setwd(my_wd)
		}
	legend("bottomleft",legend=snpmissvector,fill=mycolours,bty='n',cex=2.5,title="snpmiss:")
	axis(side=3,at=nretainedinds,labels=indmissvector,las=2)
	mtext(side=1,"Retained individuals",line=3.5,cex=3)
	mtext(side=2,"Retained SNPs (k)",line=4.75,cex=3)
	mtext(side=3,"indmiss",line=6,cex=3)
	mtext(text=indmissvector,side=1,line=-0.1,at=nretainedinds,adj=0,cex=0.25,las=2)
	if(!is.null(export))
		{
		dev.off()
		if(!silent)
			{
			myplotname	<- paste("Data_quality",mylabel,sep=".")
			cat(paste("File called '",myplotname, "' written to directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	if(do_analysis)
		{
		setwd(mysambar$sambardir)
		colnames(snpmissmat)	<- indmissvector
		rownames(snpmissmat)	<- c(snpmissvector,"ninds")
		mysambar$snpmissmat		<<- snpmissmat
		write.table(snpmissmat,"Data_quality.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=FALSE)
		}
	setwd(my_wd)
	}
	
miss_sd<-function(popnames=mysambar$populations)
	{
	npops				<- length(popnames)
	if(npops>1)
		{
		popmiss 			<- snps[,grep("miss_",colnames(snps))]
		snps$sd_popmiss		<<- apply(popmiss,1,function(x) sd(x))
		}else{
		snps$sd_popmiss		<<- NA
		}
	snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	boxplot(snps$sd_popmiss~snps$filter)
	}

# 13-03-20: Not sure this plot is very useful. 
showmiss<-function(export=NULL,doindsfilter=TRUE,dosnpsfilter=FALSE)
	{
	ninds	<- nrow(inds)
	nsnps	<- nrow(snps)
	# next lines are to ensure that matrix does not contain more than 500 columns.
	if(nsnps>1000000)
		{
		return(cat("More than 1000000 SNPs. Omitting 'Missingdata.matrix'.",sep="\n"))
		}
	if(nsnps<=1000000)
		{
		winsize		<- 2000
		}
	if(nsnps<=500000)
		{
		winsize		<- 1000
		}
	if(nsnps<=100000)
		{
		winsize		<- 200
		}
	if(nsnps<=50000)
		{
		winsize		<- 100
		}
	my_wd	<- getwd()
	setwd(mysambar$QCdir)
	if(file.exists("Miss.matrix.txt"))
		{
		mymissmatrix		<- as.matrix(read.table("Miss.matrix.txt",header=FALSE))
		if(nrow(mymissmatrix)!=ninds)
			{
			mysambar$missmatrix	<<- NULL
			}else{
			mysambar$missmatrix	<<- mymissmatrix
			}
		}
	if(is.null(mysambar$missmatrix))
		{
		cat("Generating matrix with missing data points per individual...",sep="\n")
		mybreaks		<- seq(0,nsnps,winsize)
		nbreaks			<- length(mybreaks)
		mystartvec		<- mybreaks[1:(nbreaks-1)]
		mystartvec		<- mystartvec+1
		myendvec		<- mybreaks[2:nbreaks]
		nwin			<- length(mybreaks)-1
		mymissmatrix	<- matrix(NA,nrow=ninds,ncol=nwin)
		for(j in c(1:nwin))
			{
			mystart		<- mystartvec[j]
			myend		<- myendvec[j]
			mat 		<- as.matrix(mygenlight[,c(mystart:myend)])
			nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) 	# number of NA per individual
			mymissmatrix[,j]<- nNA/ncol(mat) 								# fraction of NA per individual
			}
		write.table(mymissmatrix,"Miss.matrix.txt",row.names=FALSE,col.names=FALSE,sep="\t",quote=FALSE)
		}
	myorder						<- order(inds$pop)
	indstemp					<- inds[myorder,]
	mymissmatrix				<- mymissmatrix[myorder,]
	mypopcols					<- indstemp$popcol
	if(doindsfilter)
		{
		mypopcols				<- mypopcols[indstemp$filter]
		mymissmatrix			<- mymissmatrix[indstemp$filter,]
		indstemp				<- indstemp[indstemp$filter,]
		}
	# create heatmap:
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- c(0,0.01,0.05,0.2,0.5,1)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	if(!is.null(export))
		{
		exportname	<- "Missingdata.matrix"
		mywidth		<- 20
		mywidth2	<- 1440 
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		}
	heatmap.2(mymissmatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,Colv=NA,scale="none",RowSideColors=mypopcols,breaks=myBreaks,col=myColours,dendrogram="none",trace="none")
	mytitle		<- "Proportion missing data"
	subtitle	<- paste("per window of ",winsize," SNPS",sep="")
	mtext(mytitle, side = 3, line = 1.5, cex = 3)
	mtext(subtitle, side = 3, line = 0, cex = 2)
	mtext("SNPs", side = 1, cex = 2, line = 3.5)
	mtext("Individuals", side = 4, cex = 2, line = 0.5)
	if(!is.null(export)){dev.off()}
	setwd(my_wd)
	}

# 03042017: could still incorporate this function, but not an essential analysis:
# minor allele frequency range per stack:
stackdata<-function(mypop="Barff",myfilter=snps$filter2)
	{
	if(!("stackID2" %in% colnames(snps)))
		{
		snps$stackID2	<- as.factor(as.character(snps$stackID))
		}
	mymaf				<- snps[,paste("maf",mypop,sep="_")]			
	mymin				<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=min)
	mymax				<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=max)
	stack_data			<- aggregate(mymaf[myfilter],by=list(as.factor(as.character(snps$stackID[myfilter]))),FUN=length)
	colnames(stack_data)		<- c("stackID2","stack_nsnps")
	stack_data$stack_mafrange	<- mymax$x-mymin$x   
	snpstemp			<<- merge(snps,stack_data,by="stackID2",all=TRUE)
	}
	
calcGC<-function()
	{
	# The rationale behind this function is that the distribution of major alleles reflects the distribution of nucleotides in the species genome. 
	if(!("GC" %in% colnames(snps)))
		{
		snps$GC	<<-	(snps$major2=="C")|(snps$major2=="G")
		}	
	}

calctransit<-function()
	{
	if(!("transit" %in% colnames(snps)))
		{
		snps$transit<<-	(snps$minor==1&snps$major==3)|(snps$minor==3&snps$major==1)|(snps$minor==2&snps$major==4)|(snps$minor==4&snps$major==2)
		}	
	}

chrlength_vs_nsnps<-function(export=NULL)
	{
	snpstemp	<- snps[,c("chr","chr2","placedcol","chrlength","nsnps")]
	snpstemp	<- unique(snpstemp)
	if(!any(snpstemp$chrlength!=0))
		{
		return(cat("No non-zero values found in the column snps$chrlength. Execution halted.",sep="\n"))  
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_length.vs.nsnps.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Chrom_length.vs.nsnps.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Chrom_length.vs.nsnps.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Chrom_length.vs.nsnps.wmf",family=mysambar$myfont,width=10,height=10)} 
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(snpstemp$chrlength,snpstemp$nsnps,col=snpstemp$placedcol,log="xy",pch=16,cex=2,yaxt='n',xaxt='n',xlab="Scaffold length (log bp)",ylab="log(# SNPs)")
	mypos	<- c(0,1,2,3,4,5,6,7,8)
	mypos2	<- 10^mypos
	axis(side=1,at=mypos2,labels=mypos)
	axis(side=2,at=mypos2,labels=mypos)
	legend("topleft",legend=c("chromosomes","unplaced"),bty='n',fill=c("black","red"),cex=3)
	if(!is.null(export)){dev.off()}
	}

barplotnsnps<-function(n_chroms=NULL,export=NULL)
	{
	if(is.null(n_chroms))
		{
		return(cat("ERROR: Provide value to n_chroms flag.",sep="\n"))
		}
	nuniqchrom	<- length(unique(snps$chr2))
	if(n_chroms>nuniqchrom)
		{
		return(cat("ERROR: value specified to n_chroms flag higher than number of unique values at snps$chr2 column. Not creating barplot with number of SNPs per chromosome/scaffold.",sep="\n"))
		}
	snpstemp	<- snps[snps$chr2<=n_chroms,]
	myn			<- table(snpstemp$chr2)
	snpstemp2	<- snps[snps$chr2<=n_chroms&snps$filter2,]
	myn2		<- table(snpstemp2$chr2)
	snpstemp3	<- snps[snps$chr2<=n_chroms&snps$filter,]
	myn3		<- table(snpstemp3$chr2)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_nsnps.eps",family=mysambar$myfont,width=12,height=6)}
		if(export=="pdf"){pdf("Chrom_nsnps.pdf",family=mysambar$myfont,width=12,height=6)}
		if(export=="png"){png("Chrom_nsnps.png",family=mysambar$myfont,width=1200,height=600)}
		if(export=="wmf"){win.metafile("Chrom_nsnps.wmf",family=mysambar$myfont,width=12,height=6)} 
		}
	par(mar=c(5,8,5,2),cex.axis=1.5,cex.lab=2,cex.main=3)
	xx<-barplot(myn,las=2,border="grey50",col="grey50",ylim=c(0,max(myn,na.rm=TRUE)*1.2))
	barplot(myn2,border="grey50",col="grey60",add=TRUE,xaxt='n',yaxt='n')
	barplot(myn3,border="grey50",col="white",add=TRUE,xaxt='n',yaxt='n')
	text(x = xx, y = myn,label=myn,col="black",cex=0.75,pos=3)
	mtext("# SNPs",side=2,line=5,cex=2.25)
	mtext("Chromosome index",side=1,line=3.5,cex=2.25)
	if(!is.null(export)){dev.off()}
	}

# function for sex determination based on heterozygosity level at X-chromosome
# required knowlegde: which chromosome is X-chromosome
plot_xhe<-function(export=NULL,xchrom=NULL,dofilter=TRUE,labels=TRUE,segsites=FALSE)
	{
	if(is.null(xchrom))
		{
		return(cat("ERROR: specify name of X-chromosome to xchrom flag.",sep="\n"))
		}
	if(!xchrom%in%snps$chr)
		{
		return(cat("ERROR: specified chromosome not present in snps$chr column.",sep="\n"))
		}
	if(dofilter)
		{
		snpsfilter	<-	snps$filter&snps$chr==xchrom
		}else{
		snpsfilter	<- 	snps$chr==xchrom
		}
	inds$het_Xchrom		<<- NA
	for (i in c(1:nrow(inds)))
		{
		mymatrix 			<- as.matrix(mygenlight[i,snpsfilter])
		inds$het_Xchrom[i]	<<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		}
	cat("X-chromosome heterozygosity have been stored in inds$het_chrom column.",sep="\n")
	if(segsites)
		{
		myhetero	<- inds$hetero
		}else{
		myhetero	<- inds$hetero_all
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("ChromX_hetero.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("ChromX_hetero.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("ChromX_hetero.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("ChromX_hetero.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(!labels)
		{
		plot(myhetero,inds$het_Xchrom,col=as.character(inds$popcol),pch=16,cex=2,xlab="Overall He",ylab="X-chrom He")
		}else{
		plot(myhetero,inds$het_Xchrom,col="white",pch=16,cex=2,xlab="Overall He",ylab="X-chrom He")
		text(myhetero,inds$het_Xchrom,inds$nr,col=as.character(inds$popcol),cex=1)
		}
	legend("topleft",legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=3)	
	if(!is.null(export)){dev.off()}
	}

# function to detect the X-chromosome (difference in heterozygosity between males and females):
chromhetero<-function(nchroms=NULL,export=NULL)
	{
	if("sex" %in% colnames(inds))
		{
		mycols	<- ifelse(as.character(inds$sex)=="M","blue",ifelse(as.character(inds$sex)=="unknown","black","red"))
		}else{
		return(cat("WARNING: No column called 'sex' (with gender information) in inds dataframe. Skipping plot showing male and female heterozygosities per chromosome.",sep="\n"))
		}
	if(is.null(nchroms))
		{
		return(cat("ERROR: Provide a value to the nchroms argument.",sep="\n"))
		}
	chromnames	<- vector()
	chromlengths<<- vector()
	chromhetM	<<- vector()
	chromhetF	<<- vector()
	for (i in c(1:nchroms))
		{
		mymatrix 		<- as.matrix(mygenlight[inds$sex=="M",snps$filter&snps$chr2==i])
		chromhetM[i]	<<- mean(apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)])))
		chromnames[i]	<- as.vector(snps$chr[snps$chr2==i][1])
		chromlengths[i]	<<- as.vector(snps$chrlength[snps$chr2==i][1])
		}
	for (i in c(1:nchroms))
		{
		mymatrix 	<- as.matrix(mygenlight[inds$sex=="F",snps$filter&snps$chr2==i])
		chromhetF[i]<<- mean(apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)])))
		}
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_hetero.eps",family=mysambar$myfont,width=12,height=6)}
		if(export=="pdf"){pdf("Chrom_hetero.pdf",family=mysambar$myfont,width=12,height=6)}
		if(export=="png"){png("Chrom_hetero.png",family=mysambar$myfont,width=1200,height=600)}
		if(export=="wmf"){win.metafile("Chrom_hetero.wmf",family=mysambar$myfont,width=12,height=6)} 
		}
	par(mar=c(5,8,5,2),cex.axis=1.5,cex.lab=2,cex.main=3)
	mymax	<- max(c(chromhetM,chromhetF),na.rm=TRUE)*1.1
	barplot(chromhetF,las=2,border="grey60",col="white",ylim=c(0,mymax),names.arg=c(1:length(chromhetM)))
	barplot(chromhetM,border="grey60",col="grey60",add=TRUE,xaxt='n',yaxt='n')
	mtext("Heterozygosity",side=2,line=5,cex=2.25)
	mtext("Chromosome index",side=1,line=3.5,cex=2.25)
	mtext("Mean male (grey) vs female (white) heterozygosity per chromosome",side=3,line=-1,cex=2)
	if(!is.null(export)){dev.off()}
	#
	# Determine x_chrom:
	myhediff	<- abs(chromhetF-chromhetM)
	mymaxdiff	<- max(myhediff,na.rm=TRUE)
	myxchrom	<- which(myhediff==mymaxdiff)
	mymeandiff	<- mean(myhediff[-1],na.rm=TRUE)
	#
	mychrs			<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
	mychrs2			<- mychrs[order(-mychrs$x),]
	if(mymaxdiff>5*mymeandiff)
		{
		myxchromname	<- chromnames[myxchrom]
		cat(paste("Putative X chromosome is ",myxchromname,".",sep=""),sep="\n")
		}
	#
	# Calculate X chrom heterozygosity per individual:
	inds$het_Xchrom		<<- NA
	for (i in c(1:nrow(inds)))
		{
		mymatrix 			<- as.matrix(mygenlight[i,snps$filter&snps$chr2==myxchrom])
		inds$het_Xchrom[i]	<<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		}
	snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	indstemp		<- inds[inds$filter,]
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Xchrom_hetero_boxplot.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Xchrom_hetero_boxplot.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Xchrom_hetero_boxplot_png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Xchrom_hetero_boxplot.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	boxplot(indstemp$het_Xchrom~indstemp$sex,col="grey90",border="grey50",outline=FALSE,xlab="Sex",ylab="Heterozygosity X-chrom")
	stripchart(het_Xchrom~sex,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("red","blue","black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
	#mtext("X-chrom He",side=2,line=2.5,cex=2)
	#mtext("Sex",side=1,line=3.5,cex=2)
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_hetero_vs_length.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Chrom_hetero_vs_length.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Chrom_hetero_vs_length.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Chrom_hetero_vs_length.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(chromlengths,chromhetF,pch=16,cex=3,xlab="Chromosome length",ylab="Heterozygosity",col="red",ylim=c(0,max(c(chromhetF,chromhetM))))
	points(chromlengths,chromhetM,pch=16,cex=3,col="blue")
	legend("bottomleft",legend=c("female","male"),bty='n',fill=c("red","blue"),cex=3)	
	if(!is.null(export)){dev.off()}
	#
	cat("A column called 'het_Xchrom', with X-chrom heterozygosity has been added to the inds dataframe.",sep="\n")
	}

plot_Ychrom<-function(minFmiss=0.8,y_chrom=NULL,export=NULL,minsnps=20,silent=TRUE)
	{
	if(is.null(y_chrom))
		{
		return(cat("ERROR: Provide the name of the Y chromosome to the flag y_chrom.",sep="\n"))
		}
	if(!any(snps$chr==y_chrom))
		{
		return(cat("ERROR: The specified chromosome does not occur in the SNP dataset (snps$chr) column.",sep="\n"))
		}
	nsnps	<- nrow(snps[snps$chr==y_chrom,])
	cat(paste("Number of SNPs on the Y-chromosome: ",nsnps,sep=""),sep="\n")
	if(nsnps<minsnps)
		{
		return(cat("ERROR: Too low amount of SNPs to reliable infer sex information based on Y-chromosome data.",sep="\n"))
		}
	# first part of the bear Y-chrom has 0 percent missing data in females (repetitive region?)
	# select SNPs which high amount of missing data in females:
	if("sex" %in% colnames(inds))
		{
		mat 			<- as.matrix(mygenlight[inds$sex=="F",snps$chr==y_chrom])
		}else{
		cat("No prior gender information for samples present in inds dataframe.",sep="\n")
		mat				<- as.matrix(mygenlight[,snps$chr==y_chrom])
		}
	nNA 			<- apply(mat,2,function(x) length(x[is.na(x)])) # number of NA per SNP
	snps$Y_missF	<<-nNA/nrow(mat)
	#
	# calculate proportion missing data for SNP subset:
	if(!any(snps$Y_missF>=minFmiss,na.rm=TRUE))
		{
		if(!silent){cat(max(snps$Y_missF,na.rm=TRUE),sep="\n")}
		return(cat("ERROR: No snps$Y_missF>=minFmiss. Choose a higher value of minFmiss.",sep="\n"))
		}
	mat2			<- as.matrix(mygenlight[,snps$Y_missF>=minFmiss&snps$chr==y_chrom])
	nNA2 			<- apply(mat2,1,function(x) length(x[is.na(x)])) # number of NA per inds
	inds$miss_Ychrom<<-nNA2/ncol(mat2) 
	#
	# determine sex based on proportion missing data for Y chromosome:
	inds$sex_Y		<<- ifelse(inds$miss_Ychrom<=0.25,"M",ifelse(inds$miss_Ychrom>=0.6,"F","unknown"))
	#
	# calculate individual heterozygosity for SNP subset:
	inds$het_Ychrom	<<- apply(mat2,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	#
	# calculate locus heterozygosity for SNP subset:
	if("sex" %in% colnames(inds))
		{
		mat3			<- as.matrix(mygenlight[inds$sex=="M",snps$Y_missF>=minFmiss&snps$chr==y_chrom])
		}else{
		mat3			<- as.matrix(mygenlight[,snps$Y_missF>=minFmiss&snps$chr==y_chrom])
		}
	nNA3 			<- apply(mat3,2,function(x) length(x[is.na(x)])) # number of NA per inds
	snps$het_Ychrom	<<- NA
	snps$het_Ychrom[snps$Y_missF>=minFmiss&snps$chr==y_chrom]	<<- nNA3/nrow(mat3)
	#
	snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	#
	if("sex" %in% colnames(inds))
		{
		mycols	<- ifelse(as.character(inds$sex)=="M","blue",ifelse(as.character(inds$sex)=="unknown","black","red"))
		}else{
		mycols	<- inds$popcol
		}
	#
	if(!silent){cat("Plotting Ychrom_missingness",sep="\n")}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Ychrom_missingness.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Ychrom_missingness.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Ychrom_missingness.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Ychrom_missingness.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	plot(inds$miss_Ychrom,col=mycols,pch=16,xlab="Individuals",ylab="Missing data Y-chrom",cex=2)
	if("sex" %in% colnames(inds)){legend("right",legend=c("male","female","unknown"),fill=c("blue","red","black"),bty='n',cex=3)}
	if(!is.null(export)){dev.off()}
	#
	if("sex" %in% colnames(inds))
		{
		if(!silent){cat("Plotting Ychrom_missingness_boxplot",sep="\n")}
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Ychrom_missingness_boxplot.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("Ychrom_missingness_boxplot.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("Ychrom_missingness_boxplot.png",family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile("Ychrom_missingness_boxplot.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
			par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
			}
		boxplot(inds$miss_Ychrom~inds$sex,col="grey90",border="grey50",outline=FALSE,xlab="Sex",ylab="Missing data Y-chrom")
		stripchart(miss_Ychrom~sex,data=inds,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("red","blue","black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
		if(!is.null(export)){dev.off()}
		}
	#
	if(!silent){cat("Plotting Ychrom_miss_vs_samplequality",sep="\n")}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Ychrom_miss_vs_samplequality.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Ychrom_miss_vs_samplequality.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Ychrom_miss_vs_samplequality.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Ychrom_miss_vs_samplequality.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	plot(inds$miss,inds$miss_Ychrom,ylim=c(0,1),xlim=c(0,1),pch=16,col=mycols,xlab="Missing data overall",ylab="Missing data Y-chrom",cex=2)
	if("sex" %in% colnames(inds)){legend("bottomright",legend=c("male","female","unknown"),fill=c("blue","red","black"),bty='n',cex=3)}
	if(!is.null(export)){dev.off()}
	#
	if("het_Xchrom"%in%colnames(inds))
		{
		if(!silent){cat("Plotting Y_vs_X_hetero",sep="\n")}
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Y_vs_X_hetero.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("Y_vs_X_hetero.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("Y_vs_X_hetero.png",family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile("Y_vs_X_hetero.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
			par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
			}
		plot(inds$het_Ychrom,inds$het_Xchrom,col=mycols,pch=16,xlim=c(0,1),ylim=c(0,0.5),xlab="Heterozygosity Y-chrom",ylab="Heterozygosity X-chrom",cex=2)
		if(!is.null(export)){dev.off()}
		}
	#
	if(!silent){cat("Plotting Ychrom_miss_vs_hetero",sep="\n")}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Ychrom_miss_vs_hetero.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Ychrom_miss_vs_hetero.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Ychrom_miss_vs_hetero.png",family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile("Ychrom_miss_vs_hetero.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		}
	plot(inds$miss_Ychrom,inds$het_Ychrom,col=mycols,pch=16,xlim=c(0,1),ylim=c(0,0.5),xlab="Missing data Y-chrom",ylab="Heterozygosity Y-chrom",cex=2)
	if("sex" %in% colnames(inds)){legend("bottomleft",legend=c("male","female","unknown"),fill=c("blue","red","black"),bty='n',cex=3)}
	if(!is.null(export))
		{
		dev.off()
		cat("Plots with proportion of missing data and missingness values have been written to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("A column called 'sex_Y', with sex determination of the samples based on levels of missing data of the Y-chromosome, has been added to the inds dataframe.",sep="\n")
		}
	}

plotscaffoldsize<-function(export=NULL,n_chroms=NULL,mychrs2=NULL)
	{
	if(!any(snps$pos!=0))
		{
		return(cat("WARNING: no information on genomic positions of SNP. Not creating 'Chrom_length' plots.",sep="\n"))
		}
	if(is.null(mychrs2))
		{
		mychrs			<- aggregate(snps$pos,by=list(snps$chr),FUN=max)
		mychrs2			<- mychrs[order(-mychrs$x),]
		}
	#
	if(!is.null(n_chroms))
		{
		minlength		<- as.numeric(as.character(mychrs2$x[n_chroms]))
		mychrs2$colour	<- ifelse(as.numeric(as.character(mychrs2$x))>=minlength,"black","red") 
		}else{
		mychrs2$colour	<- "black"
		}
	#mychrs2				<<- mychrs2
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Chrom_length.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Chrom_length.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Chrom_length.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Chrom_length.wmf",family=mysambar$myfont,width=10,height=10)} 
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(mychrs2$x,pch=16,col=mychrs2$colour,log="y",yaxt='n',ylab="Max SNP position (log bp)",xlab="Scaffold index")
	mypos	<- c(0,1,2,3,4,5,6,7,8)
	mypos2	<- 10^mypos
	axis(side=2,at=mypos2,labels=mypos)
	if(!is.null(n_chroms))
		{
		legend("topright",legend=c("chromosomes","unplaced"),bty='n',fill=c("black","red"),cex=3)
		}
	if(!is.null(export)){dev.off()}
	}

readpos<-function(export=NULL)
	{
	if(is.null(snps$readpos))
		{
		return()
		}
	if(any(is.na(snps$readpos)))
		{
		return()
		}
	mymax			<- max(snps$readpos)
	if(mymax<250)
		{
		mycounts		<- hist(snps$readpos,breaks=seq(0,mymax,1))
		mysd			<- sd(mycounts$counts[mycounts$counts!=0])
		mymean			<- mean(mycounts$counts[mycounts$counts!=0])
		mydev			<- mycounts$counts<(mymean+mysd)&mycounts$counts>(mymean-mysd)
		mylower			<- which(mydev==TRUE)[1]
		mydev2			<- rev(mydev)
		myupper			<- length(mydev2)-which(mydev2==TRUE)[1]+1
		snps$readpos2	<<- snps$readpos>=mylower&snps$readpos<=myupper
		snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		# plot:
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPalongreads.eps",family=mysambar$myfont,width=16,height=10)}
			if(export=="pdf"){pdf("SNPalongreads.pdf",family=mysambar$myfont,width=16,height=10)}
			if(export=="png"){png("SNPalongreads.png",family=mysambar$myfont,width=1260,height=720)}
			if(export=="wmf"){win.metafile("SNPalongreads.wmf",family=mysambar$myfont,width=16,height=10)}
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist(snps$readpos,breaks=seq(0,mymax,1),xlab="Position along read (bp)",ylab="Frequency",main="Distribution of snps along reads")
		hist(snps$readpos[!snps$readpos2],breaks=seq(0,mymax,1),add=TRUE,col="orange")
		mtext("dashed line = mean; solid lines = mean +/- sd", side = 3, line = -1, cex = 2)
		abline(mymean,0,lty=2)
		abline(mymean-mysd,0)
		abline(mymean+mysd,0)
		if(!is.null(export)){dev.off()}
		}
	}	

plotspacing<-function(export=NULL)
	{
	mymaxdist	<- max(snps$pos,na.rm=TRUE)
	if(mymaxdist>1000)
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.eps",family=mysambar$myfont,width=18,height=10)}
			if(export=="pdf"){pdf("SNPspacing.pdf",family=mysambar$myfont,width=18,height=10)}
			if(export=="png"){png("SNPspacing.png",family=mysambar$myfont,width=1296,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.wmf",family=mysambar$myfont,width=18,height=10)}
			}
		par(mfrow=c(1,2),mar=c(5,8,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist(snps$dist[snps$dist>1000],xlim=c(1000,1000000),breaks=1000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,1000000,250000)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("Frequency",side=2,cex=3,line=5)
		mtext("10 kb bins", side = 3, cex = 2.5, line = -1)
		hist((snps$dist),xlim=c(0,500),breaks=1000000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,500,100)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("0.01 kb bins", side = 3, cex = 2.5, line = -1)
		mtext("Distance between adjacent snps", side = 3, cex = 3.5, line = -3.5, outer=TRUE)
		if(!is.null(export)){dev.off()}
		}else{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("SNPspacing.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("SNPspacing.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5,8,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		hist((snps$dist),xlim=c(0,500),breaks=1000000,main="",xaxt='n',xlab="Distance (kb)",las=1,ylab="")
		mylabels<-seq(0,500,100)
		axis(side=1,at=mylabels,labels=mylabels/1000,lty=1,las=1)
		mtext("0.01 kb bins", side = 3, cex = 2.5, line = -1)
		mtext("Distance between adjacent snps", side = 3, cex = 3.5, line = -3.5, outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	#
	# indicate intra- and interread distances:
	if("sameread"%in%colnames(snps))
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("SNPspacing.intra_vs_interread.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("SNPspacing.intra_vs_interread.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("SNPspacing.intra_vs_interread.png",family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile("SNPspacing.intra_vs_interread.wmf",family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5.5,8,2.5,2),cex.axis=2.5,cex.lab=2.5,cex.main=2.5)
		hist(snps$dist[snps$dist<500&snps$sameread],breaks=seq(0,1000,10),xlim=c(0,500),las=1,ylab="",xlab="Distance (bp)",main="SNP spacing",col="grey")
		hist(snps$dist[snps$dist<500&!snps$sameread],breaks=seq(0,1000,10),add=TRUE)
		legend("topright",legend=c("same read","different read"),fill=c("grey","white"),bty='n',cex=2.5)
		if(!is.null(export)){dev.off()}
		}	
	}

distperchrom<-function(dothin=FALSE,export=NULL)
	{
	if(!"filter"%in%colnames(snps))
		{
		return(cat("Column snps$filter missing; (re)run filterdata() function.",sep="\n"))
		}
	# Table:
	nrchroms	<- length(unique(snps$chr[snps$placed]))
	if(nrchroms==0)
		{
		return(cat("No placed scaffolds. Omitting distperchrom table and plot.",sep="\n")) 
		}
	statsfunction 	<- function(x){c(mean = mean(x), std = sd(x), quantiles = quantile(x))}
	snpstemp		<- snps[order(snps$chr2),]
	distancetable	<- cbind(as.vector(table(as.vector(snpstemp$chr[snpstemp$dist2&snpstemp$placed]))),do.call(rbind,tapply(snpstemp$dist[snpstemp$dist2&snpstemp$placed],snpstemp$chr[snpstemp$dist2&snpstemp$placed],statsfunction)))
	distancetable	<- round(distancetable)
	colnames(distancetable)<-c("nsnps","mean","stdv","min","25%","median","75%","max")
	write.table(distancetable,"Distperchrom.txt",col.names=TRUE,row.names=TRUE,quote=FALSE)
	if(!dothin)
		{
		myselection<- snpstemp$filter2
		}else{
		myselection<- snpstemp$filter
		}
	# boxplot:
	if(!is.null(export))
		{
		plotname	<- ifelse(!dothin,"Chrom_SNPspacing.filtered","Chrom_SNPspacing.thinned")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=6,width=12)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=6,width=12)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=600,width=1200)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=6,width=12)}
		}
	myselection2<- snpstemp$placed&myselection
	mychroms	<- as.vector(snpstemp$chr2[myselection2])
	mydist		<- snpstemp$dist[myselection2]
	mydist[mydist==0]	<-NA
	mydata		<- data.frame("mychroms"=mychroms,"mydist"=mydist)
	boxplot(mydist~mychroms,las=2,col="white",border="white",outline=TRUE,xlab="",ylab="",yaxt="n",cex.lab=2,cex.axis=1.5,log="y")
	boxplot(mydist~mychroms,las=2,col="grey90",border="grey50",outline=FALSE,add=TRUE,xlab="",ylab="",yaxt="n",xaxt='n')
	stripchart(mydist~mychroms,data=mydata,vertical=TRUE,method="jitter",pch=16,cex=0.5,col="orange",bg="bisque",las=2,xlab="",ylab="",add=TRUE) 
	aty 		<- axTicks(2)
	atylog		<- log10(aty)
	axis(2,at=aty,labels=atylog,las=1,cex=2)
	mtext("Distance (log Mb)",side=2,line=2.5,cex=2)
	mtext("Chromosome index",side=1,line=3.5,cex=2)
	if(!is.null(export)){dev.off()}
	}

# replaced by distperchrom
plotspacingperchrom<-function(myyrange=c(0,500000),export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("SNPspacingperchrom.eps",family=mysambar$myfont,width=18,height=10)}
		if(export=="pdf"){pdf("SNPspacingperchrom.pdf",family=mysambar$myfont,width=18,height=10)}
		if(export=="png"){png("SNPspacingperchrom.png",family=mysambar$myfont,width=1296,height=720)}
		if(export=="wmf"){win.metafile("SNPspacingperchrom.wmf",family=mysambar$myfont,width=18,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=1.5,cex.lab=3,cex.main=3.5)
	boxplot(snps$dist[snps$placed]~as.vector(snps$chr[snps$placed]),ylim=myyrange,main="Distance between adjacent snps",xlab="Chromosome",ylab="Distance (bp)")
	if(!is.null(export)){dev.off()}
	}	
	
indsmissingness<-function(indthreshold=0.25,export=NULL,prior2snpfilter=TRUE,max_miss=NULL)
	{
	if(prior2snpfilter&is.null(max_miss))
		{
		# missingness per individual for all SNPs:
		if(!"miss"%in%colnames(inds))
			{
			mat 		<- as.matrix(mygenlight)
			nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
			inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
			}
		# which samples meet the predefined threshold?
		inds$fmiss	<<- inds$miss <= indthreshold
		# change column name:
		names(inds)[names(inds) == "fmiss"] <<- paste("fmiss",indthreshold,sep = "")
		inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	if((!prior2snpfilter)&is.null(max_miss))
		{
		# missingness per individual for retained SNPs:
		mat 		<- as.matrix(mygenlight[,snps$filter])
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss2 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		inds 		<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	if(!is.null(max_miss))
		{
		# missingness per individual for subset of SNPs with 'max_miss' missing data:
		mat 		<- as.matrix(mygenlight[,snps$miss<=max_miss])
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss3 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		inds 		<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	}

plot_indsmissingdata<-function(export=NULL,indthreshold=0.25)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("missingdatapersample.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("missingdatapersample.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("missingdatapersample.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("missingdatapersample.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,2,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(!("meandepth" %in% colnames(inds)))
		{
		hist(inds$miss,breaks=seq(0,1,0.01),main="Missing data per sample",xlab="Proportion of missing data points",ylab="Number of samples")
		hist(inds$miss[inds$miss>indthreshold],breaks=seq(0,1,0.01),add=T,col="red")
		}else{
		plot(inds$meandepth,inds$miss,pch=16,cex=2,main="",xlab="Read depth per sample",ylab="Missing data per sample",ylim=c(0,1))
		points(inds$meandepth[inds$miss>indthreshold],inds$miss[inds$miss>indthreshold],pch=16,cex=2,col="red")
		legend("topright",legend=c("FALSE","TRUE"),title="Pass filter",bty='n',fill=c("red","black"),cex=2)
		}
	if(!is.null(export)){dev.off()}
	}

snpsmissingness<-function(indthreshold=0.25,snpthreshold=0.1,popnames=mysambar$populations,sanity_check=TRUE)
	{
	indmissfilter			<- inds$miss<=indthreshold
	if(!any(indmissfilter))
		{
		return(cat("ERROR: no individuals retained after filtering on missing data points. Please try again with a less strict (i.e. higher) individual missingness filter threshold.",sep="\n")) 
		}
	#snps$misscount			<<- glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)										# for each locus, calculate number of individuals (from filtered subset) with missing data
	#snps$nonmissallelecount <<- 2*(nInd(mygenlight[indmissfilter,])-snps$misscount)									# The opposite of snps$misscount
	snps$nind				<<- nInd(mygenlight[indmissfilter,])
	snps$misscount			<<- 2*glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)									# 16-03-2021: for each locus, calculate number of alleles (from filtered subset) with missing data
	snps$nonmissallelecount <<- (2*nInd(mygenlight[indmissfilter,]))-snps$misscount										# 16-03-2021
	snps$miss				<<- glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)/nInd(mygenlight[indmissfilter,])	# as snps$misscount, but divided by length of indmissfilter, giving us a frequency:	
	snps$miss2				<<- glNA(mygenlight,alleleAsUnit=FALSE)/nInd(mygenlight)									# same, but now for all individuals, for comparison
	snps$fmiss				<<- snps$miss <= snpthreshold																# which loci meet the predefined threshold?			
	#
	if(sanity_check&any((2*snps$nind)!=snps$misscount+snps$nonmissallelecount))
		{
		return(cat("ERROR: absent and present allele counts does not add up to expected number for diploid datasets (i.e, 2x number of retained individuals). Please contact the developer of SambaR or set the flag sanity_check to FALSE.",sep="\n"))
		}
	#
	# change column name:
	names(snps)[names(snps) == "fmiss"] <<- paste("fmiss",snpthreshold,sep = "")
	# missingness per SNP per population:
	# Per population:
	for (i in (1:length(popnames)))
		{
		mypop			<- popnames[i]
		popfilter		<- indmissfilter&inds$pop==mypop
		if(!any(popfilter,na.rm=TRUE))
			{
			cat(paste("WARNING: Zero retained individuals for population ",mypop,". Please try again with a less strict (i.e. higher) individual missingness filter threshold.",sep=""),sep="\n") 
			snps$misscountpop	<<- 2*(nInd(mygenlight[indmissfilter,]))
			snps$misspop		<<- 1
			}else{
			snps$misscountpop	<<- 2*glNA(mygenlight[popfilter,],alleleAsUnit=FALSE)
			snps$misspop		<<- glNA(mygenlight[popfilter,],alleleAsUnit=FALSE)/nInd(mygenlight[popfilter,])
			}
		names(snps)[names(snps) == "misscountpop"] 	<<- paste("misscount",mypop,sep ="_")
		names(snps)[names(snps) == "misspop"] 		<<- paste("miss",mypop,sep ="_")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}
	
plot_snpsmissingdata<-function(snpthreshold=0.1,export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("missingdataperlocus.eps",family=mysambar$myfont,width=12,height=10)}
		if(export=="pdf"){pdf("missingdataperlocus.pdf",family=mysambar$myfont,width=12,height=10)}
		if(export=="png"){png("missingdataperlocus.png",family=mysambar$myfont,width=900,height=720)}
		if(export=="wmf"){win.metafile("missingdataperlocus.wmf",family=mysambar$myfont,width=12,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)	
	if(!("meandepth" %in% colnames(snps)))
		{
		hist(snps$miss,breaks=seq(0,1,0.01),main="",xlab="Proportion of missing data points",ylab="")
		hist(snps$miss[snps$miss>snpthreshold],breaks=seq(0,1,0.01),add=T,col="red")
		mtext("Number of loci",side=2,cex=3,line=7)
		}else{
		if(any(!is.na(snps$meandepth)))
			{
			plot(snps$meandepth,snps$miss,pch=16,cex=2,log='x',xlab="Read depth per SNP",ylab="Missing data per SNP",ylim=c(0,1))
			points(snps$meandepth[snps$miss>snpthreshold],snps$miss[snps$miss>snpthreshold],pch=16,cex=2,col="red")
			legend("topright",legend=c("FALSE","TRUE"),title="Pass filter",bty='n',fill=c("red","black"),cex=2)
			}else{
			hist(snps$miss,breaks=seq(0,1,0.01),main="",xlab="Proportion of missing data points",ylab="")
			hist(snps$miss[snps$miss>snpthreshold],breaks=seq(0,1,0.01),add=T,col="red")
			mtext("Number of loci",side=2,cex=3,line=7)
			}
		}
	if(!is.null(export)){dev.off()}
	}

snp_maf<-function(popnames=mysambar$populations,indthreshold=mysambar$indmissfilter,indfilter=NULL,do_subset=FALSE,silent=TRUE)	
	{
	if(is.null(indfilter))
		{
		if(is.null(indthreshold))
			{
			return(cat("ERROR: please provide a value to the indthreshold flag.",sep="\n"))
			}
		indfilter			<- inds$miss<=indthreshold
		}else{
		cat("Excluding individuals from the calculation as defined by input to the indfilter flag.",sep="\n")
		}
	# What is minor allele count and major allele count:
	snps$minorcount		<<- as.vector(glSum(mygenlight[indfilter,]))	#glSum counts number of second alleles
	snps$majorcount		<<- snps$nonmissallelecount-snps$minorcount	
	#
	# Calculate maf per locus:
	# Overall dataset:
	# snps$maf 			<<- glMean(mygenlight[indfilter,])		# glMean gives wrong estimate if data consists of 1 snp only (17-3-2021: not sure what I meant by '1 snp only'
	# snps$maf			<<- round(snps$minorcount/snps$nonmissallelecount,3)
	snps$maf			<<- snps$minorcount/snps$nonmissallelecount		# 17-03-2021: no rounding
	snps$maf[!is.finite(snps$maf)]	<<- NA
	# check for SNPs for with no data left after filtering: (this is captured by snps$polyfilter)
	# if(any(is.na(snps$maf)))
	#	{
	#	cat("WARNING: After filtering, no data retained for 1 or more snps",sep="\n")
	#	}
	if(any(snps$maf!=snps$minorcount/snps$nonmissallelecount,na.rm=TRUE))
		{
		return(cat("ERROR: minor allele frequency does not equal minor allele count divided by total allele count. Please contact the developer of SambaR.",sep="\n"))
		}
	#
	# Per population:
	popnoind			<- vector()
	for (i in (1:length(popnames)))
		{
		# popminor			<- as.vector(glSum(mygenlight[indfilter&inds$pop==popnames[i],]))
		# popmiss			<- glNA(mygenlight[indfilter&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		# popmiss			<- glNA(mygenlight[indfilter&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		# nind				<- nrow(inds[inds$pop==popnames[i]&inds$filter,])
		# popall			<- 2*nind-popmiss
		# snps$maftemp		<<- round(popminor/popall,3)			# this leads to ERROR when correcting maf (something about NA's)	
		mypop				<- popnames[i]
		if(!silent){cat(mypop,sep="\n")}
		popfilter			<- indfilter&inds$pop==mypop
		if(any(popfilter,na.rm=TRUE))
			{
			popmisscount		<- paste("misscount",popnames[i],sep="_")
			if(!popmisscount%in%colnames(snps))
				{
				return(cat("ERROR: popmisscount is missing from snps data frame. Did you run the snpsmissingness function?",sep="\n"))
				}
			npopind					<- nrow(inds[popfilter,])
			snps$actemp				<<- 2*npopind-as.vector(snps[,popmisscount])
			snps$mactemp			<<- as.vector(glSum(mygenlight[popfilter,]))
			#snps$maftemp 			<<- glMean(mygenlight[indfilter&inds$pop==popnames[i],])	# 17-03-2021: replaced with next line just to be consistent with calculation for metapopulation
			#snps$maftemp			<<- round(snps$mactemp/snps$actemp,3)
			snps$maftemp			<<- snps$mactemp/snps$actemp				# 17-03-2021: no rounding
			snps$maftemp[!is.finite(snps$maftemp)]	<<- NA
			#			
			if(any(is.na(snps$maftemp)))
				{
				cat(paste("WARNING: No data for 1 or more snps in population:",popnames[i],sep=" "),sep="\n")
				}
			if(any(snps$actemp%%1!=0,na.rm=TRUE))
				{
				return(cat("ERROR: unrounded population allele counts. Please contact the developer of SambaR.",sep="\n"))
				}
			if(any(snps$maftemp!=snps$mactemp/snps$actemp,na.rm=TRUE))
				{
				return(cat("ERROR: population minor allele frequency does not equal minor allele count divided by total allele count. Please contact the developer of SambaR.",sep="\n"))
				}
			if(do_subset)
				{
				# calculate minor allele frequency for two random subsets within population
				# needed for f-statistics
				if(npopind==1)
					{
					cat("WARNING: population contains 1 individual. Not possible to calculate minor allele frequency for within population subsets.",sep="\n")
					snps$actemp_a			<<- snps$actemp
					snps$actemp_b			<<- snps$actemp
					snps$mactemp_a			<<- snps$mactemp
					snps$mactemp_b			<<- snps$mactemp
					snps$maftemp_a			<<- snps$maftemp		
					snps$maftemp_b			<<- snps$maftemp
					}else{
					popgenlight				<- mygenlight[popfilter,]
					if(npopind%%2==0)
						{
						aindices				<- 1:(npopind/2)
						bindices				<- (1+npopind/2):npopind
						}else{
						aindices				<- 1:floor(npopind/2)
						bindices				<- ceiling(npopind/2):npopind
						}
					agenlight				<- popgenlight[aindices,]
					bgenlight				<- popgenlight[bindices,]
					amiss					<- 2*glNA(agenlight,alleleAsUnit=FALSE)
					bmiss					<- 2*glNA(bgenlight,alleleAsUnit=FALSE)
					snps$actemp_a			<<- 2*length(aindices)-amiss
					snps$actemp_b			<<- 2*length(bindices)-bmiss
					snps$mactemp_a			<<- as.vector(glSum(agenlight))
					snps$mactemp_b			<<- as.vector(glSum(bgenlight))
					snps$maftemp_a			<<- snps$mactemp_a/snps$actemp_a		
					snps$maftemp_b			<<- snps$mactemp_b/snps$actemp_b
					snps$maftemp_a[!is.finite(snps$maftemp_a)]	<<- NA
					snps$maftemp_b[!is.finite(snps$maftemp_b)]	<<- NA
					if(any(snps$actemp!=snps$actemp_a+snps$actemp_b,na.rm=TRUE))
						{
						#return(cat("ERROR: Allele counts of subsets do not add up to total allele count. Please contact the developer of SambaR.",sep="\n"))
						cat("WARNING: Allele counts of subsets do not add up to total allele count. Please contact the developer of SambaR.",sep="\n")
						}
					if(any(snps$mactemp!=snps$mactemp_a+snps$mactemp_b,na.rm=TRUE))
						{
						#return(cat("ERROR: Minor allele counts of subsets do not add up to total minor allele count. Please contact the developer of SambaR.",sep="\n"))
						cat("WARNING: Minor allele counts of subsets do not add up to total minor allele count. Please contact the developer of SambaR.",sep="\n")
						}
					}
				}
			}else{
			cat(paste("No individuals retained in population:",popnames[i],sep=" "),sep="\n")
			popnoind			<- c(popnoind,popnames[i])   
			snps$actemp			<<- NA
			snps$mactemp		<<- NA
			snps$maftemp 		<<- NA
			if(do_subset)
				{
				snps$actemp_a	<<- NA
				snps$actemp_b	<<- NA
				snps$mactemp_a	<<- NA
				snps$mactemp_b	<<- NA
				snps$maftemp_a	<<- NA		
				snps$maftemp_b	<<- NA
				}
			}
		names(snps)[names(snps) == "actemp"] 	<<- paste("ac",popnames[i],sep = "_")
		names(snps)[names(snps) == "mactemp"] 	<<- paste("mac",popnames[i],sep = "_")
		names(snps)[names(snps) == "maftemp"] 	<<- paste("maf",popnames[i],sep = "_")
		if(do_subset)
			{
			names(snps)[names(snps) == "actemp_a"] <<- paste("ac",popnames[i],"a",sep = "_")
			names(snps)[names(snps) == "mactemp_a"]<<- paste("mac",popnames[i],"a",sep = "_")
			names(snps)[names(snps) == "maftemp_a"]<<- paste("maf",popnames[i],"a",sep = "_")
			names(snps)[names(snps) == "actemp_b"] <<- paste("ac",popnames[i],"b",sep = "_")
			names(snps)[names(snps) == "mactemp_b"]<<- paste("mac",popnames[i],"b",sep = "_")
			names(snps)[names(snps) == "maftemp_b"]<<- paste("maf",popnames[i],"b",sep = "_")
			}
		}
	if(exists("mysambar"))
		{
		mysambar$popnoind		<<- popnoind
		}
	# if this function has been executed before, remove columns produced during previous execution:
	snps 					<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}

pheno_maf<-function(indthreshold=0.25)	
	{
	if(is.null(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	indfilter			<- inds$miss<=indthreshold
	snps$maf_pheno1 	<<- glMean(mygenlight[indfilter&inds$type,])
	snps$maf_pheno2 	<<- glMean(mygenlight[indfilter&(!inds$type),])
	# if this function has been executed before, remove columns produced during previous execution:
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	

snp_mymaf<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# snp_maf uses the function glMean.
	# glMean gives wrong estimates of maf when one or more samples don't have all genotypes (0,1,2) at least represented once in your subset of loci. 
	# If so, you might consider using this script, which is a bit slower:
	indfilter	<- inds$miss<=indthreshold
	mafmyway	<- vector()
	mymatrix	<- as.matrix(mygenlight[indmissfilter,])
	for (i in c(1:(ncol(mymatrix))))
		{
		temp1		<- mymatrix[,i]
		bool		<- !is.na(temp1)
		temp		<- temp1[bool]
		temp2		<- as.data.frame(table(temp))
		if(nrow(temp2)==3)
			{
			maf		<- (temp2[3,2]+((1/2)*temp2[2,2]))/(temp2[1,2]+temp2[2,2]+temp2[3,2])
			}
		if(nrow(temp2)==2)
			{
			if(temp2$temp[1]==0&temp2$temp[2]==1){maf	<- (1/2)*temp2[2,2]/(temp2[1,2]+temp2[2,2])}
			if(temp2$temp[1]==1&temp2$temp[2]==2){maf	<- ((1/2)*temp2[1,2]+temp2[2,2])/(temp2[1,2]+temp2[2,2])}
			if(temp2$temp[1]==0&temp2$temp[2]==2){maf	<- temp2[2,2]/(temp2[1,2]+temp2[2,2])}
			}
		if(nrow(temp2)==1)
			{
			if(temp2$temp[1]==0){maf	<- 0}
			if(temp2$temp[1]==1){maf	<- 0.5}
			if(temp2$temp[1]==2){maf	<- 1}
			}
		mafmyway[i]	<- maf
		}
	snps$mafmyway	<<- mafmyway
	}

correctmaf<-function(popnames=mysambar$populations,indthreshold=0.25,silent=TRUE,make_global=FALSE)
	{
	if(!"genlightname"%in%colnames(snps))
		{
		cat("WARNING: column snps$genlightname missing. Adding now.",sep="\n")
		snps$genlightname			<<- as.character(mygenlight$loc.names)
		}
	if(make_global)
		{
		snpsstart					<<- snps
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: before running correctmaf() function, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}		
	# Due to excluding datapoints, the allele which is listed as minor might have become major
	# For example: if you have: 1 2 2 0 0, and the last individual is removed, then the minor allele has become the major allele
	# this function makes the correction 
	indfilter						<- inds$miss<=indthreshold
	currentmaf						<- snps$maf
	currentmaf[is.na(currentmaf)]	<- 0		# Otherwise following error: Error in snps$minor[currentmaf > 0.5] <- mymajor[currentmaf > 0.5] : NAs are not allowed in subscripted assignments
	n_above0.5						<- length(currentmaf[currentmaf>0.5])
	if(n_above0.5==0)
		{
		return(cat("No snps with maf > 0.5. No need to correct maf.",sep="\n"))
		}
	# else we need to make the correction:
	if(!silent){cat("Editing minor and major columns in snps df...",sep="\n")}
	myminor							<- snps$minor
	mymajor							<- snps$major
	snps$minor[currentmaf>0.5]		<<- mymajor[currentmaf>0.5]
	snps$major[currentmaf>0.5]		<<- myminor[currentmaf>0.5]
	myminorcount					<- snps$minorcount
	mymajorcount					<- snps$majorcount
	snps$minorcount[currentmaf>0.5]	<<- mymajorcount[currentmaf>0.5] 
	snps$majorcount[currentmaf>0.5]	<<- myminorcount[currentmaf>0.5]
	snps$maf[currentmaf>0.5]		<<- (1-currentmaf)[currentmaf>0.5]
	for (j in popnames)
		{
		mypopmaf					<- snps[,names(snps) == paste("maf",j,sep="_")]
		snps[currentmaf>0.5,names(snps) == paste("maf",j,sep="_")]	<<- (1-mypopmaf)[currentmaf>0.5] 
		}
	if(!silent){cat("Editing data in genlight object...",sep="\n")}
	# edit data in genlight object:
	mymatrix					<- as.matrix(mygenlight)
	mymatrix1					<- mymatrix[,currentmaf>0.5]
	mymatrix2					<- mymatrix[,currentmaf<=0.5]
	tempmatrix					<- mymatrix1
	mymatrix1[tempmatrix==0]	<- 2
	mymatrix1[tempmatrix==2]	<- 0
	if(n_above0.5==1)
		{
		temp					<- as.matrix(mymatrix1)
		colnames(temp)			<- colnames(mymatrix)[currentmaf>0.5]
		mymatrix1				<- temp
		}
	mymatrix3					<- cbind(mymatrix1,mymatrix2)
	if(ncol(mymatrix3)!=ncol(mymatrix))
		{
		return(cat("ERROR: number of columns in new dataset does not correspond with old dataset.",sep="\n"))
		}
	mymatrix4					<- mymatrix3[,order(colnames(mymatrix3))]
	if(!silent){cat("Reordering...",sep="\n")}
	# now reorder matrix3 to order of snps in snps dataframe:
	# snpstemp					<- snps[order(snps$name),]
	snpstemp					<- snps[order(snps$genlightname),]	# 04-09-2020: instead of previous line
	# mymatrix5					<- mymatrix4[,order(as.numeric(snpstemp$chr),as.numeric(snpstemp$pos))]
	# mymatrix5					<- mymatrix4[,order(snpstemp$chr,as.numeric(snpstemp$pos))]
	mymatrix5					<- mymatrix4[,order(snpstemp$nr_neworder)]
	mygenlight					<<- as.genlight(mymatrix5)
	mygenlight@pop				<<- as.factor(inds$pop)
	# if this function has been executed before, remove columns produced during previous execution:
	snps 						<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	#
	if(make_global)
		{
		currentmaf					<<- currentmaf
		mymatrix					<<- mymatrix
		mymatrix1					<<- mymatrix1
		mymatrix2					<<- mymatrix2
		mymatrix3					<<- mymatrix3
		mymatrix4					<<- mymatrix4
		mymatrix5					<<- mymatrix5
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after running correctmaf() function, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
	}
	
# depreciated:
correctmaf_old<-function(popnames=mysambar$populations,indthreshold=0.25)
	{
	# Due to excluding datapoints, the allele which is listed as minor might have become major
	# For example: if you have: 1 2 2 0 0, and the last individual is removed, then the minor allele has become the major allele
	# this function makes the correction 
	indfilter	<- inds$miss<=indthreshold
	mymatrix	<- as.matrix(mygenlight)
	for (i in (1:(ncol(mymatrix))))
		{
		if (snps$maf[i]>0.5)
			{
			# edit snps-dataframe:
			myminor				<- snps$minor[i]
			mymajor				<- snps$major[i]
			snps$minor[i]		<<- mymajor
			snps$major[i]		<<- myminor
			myminorcount		<- snps$minorcount[i]
			mymajorcount		<- snps$majorcount[i]
			snps$minorcount[i]	<<- mymajorcount 
			snps$majorcount[i]	<<- myminorcount
			mymaf				<- snps$maf[i]
			snps$maf[i]			<<- 1-mymaf
			for (j in popnames)
				{
				mypopmaf		<- snps[i,names(snps) == paste("maf",j,sep="_")]
				snps[i,names(snps) == paste("maf",j,sep="_")]	<<- 1-mypopmaf 
				}
			# edit data in genlight object:
			temp				<- mymatrix[,i]
			temp[temp==0]		<- 3
			temp[temp==2]		<- 0
			temp[temp==3]		<- 2
			mymatrix[,i]		<- temp
			}
		}
	mygenlight		<<- as.genlight(mymatrix)
	mygenlight@pop	<<- as.factor(inds$pop)
	# Per population: (double?)
	#for (i in (1:length(popnames)))
	#	{
	#	snps$maftemp 	<<- glMean(mygenlight[indfilter&inds$pop==popnames[i],])
	#	names(snps)[names(snps) == "maftemp"] <<- paste("maf",popnames[i],sep = "_")
	#	}
	# if this function has been executed before, remove columns produced during previous execution:
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	
	
getpopmaf<-function(popnames=mysambar$populations,dofilter=TRUE,snpthreshold=0.1)
	{
	# It can happen that a certain allele is the minor allele in the meta population but the major allele in the subpopulation.
	# The maf_popname columns in the snp dataset define minor alleles based on the meta pop reference.
	# This function will create new columns (maf2_popname) which define minor allele based on the subpopulation.
	# This maf2-column is needed for intrapopulation analyses, such as sfs plot. 
	# For comparisons between populations, use maf-column rather than maf2-column.   
	inds$popmaf			<<- NA
	inds$popmaf_all		<<- NA
	inds$expHe			<<- NA
	inds$expHe_all		<<- NA
	popnames			<- as.vector(popnames) 
	for (i in (1:length(popnames)))
		{
		mymaf					<- snps[names(snps) == paste("maf",popnames[i],sep="_")]
		mymaf					<- as.vector(unlist(mymaf))
		snps$mymaf				<<- mymaf
		mymaf[is.na(mymaf)]		<- 0
		snps$mymaf[mymaf>0.5]	<<- 1-mymaf[mymaf>0.5] 
		if(!dofilter)
			{
			snpfilter				<- snps$miss<=snpthreshold
			myfilter1				<- snpfilter&is.finite(snps$mymaf)
			myfilter2				<- snpfilter&is.finite(snps$mymaf)&snps$mymaf>0		# ideally: snpfilter&is.finite(snps$mymaf)&snps$mymaf>0		# however, this causes problems if only a few individuals per population?
			}else{
			myfilter1				<- is.finite(snps$mymaf)
			myfilter2				<- is.finite(snps$mymaf)							# ideally: is.finite(snps$mymaf)&snps$mymaf>0				# however, this causes problems if only a few individuals per population?
			}
		inds$popmaf[inds$pop==popnames[i]]			<<- mean(snps$mymaf[myfilter2],na.rm=TRUE)
		inds$popmaf_all[inds$pop==popnames[i]]		<<- mean(snps$mymaf[myfilter1],na.rm=TRUE)
		inds$expHe[inds$pop==popnames[i]]			<<- mean(2*snps$mymaf[myfilter2]*(1-snps$mymaf[myfilter2]),na.rm=TRUE)				# all sites
		inds$expHe_all[inds$pop==popnames[i]]		<<- mean(2*snps$mymaf[myfilter1]*(1-snps$mymaf[myfilter1]),na.rm=TRUE)	
		names(snps)[names(snps) == "mymaf"] 		<<- paste("maf2",popnames[i],sep = "_")
		}
	snps$mymaf			<<- NULL
	# this crude approach (next two lines) gives different results:
	# inds$expHe2		<<- 2*(inds$popmaf*(1-inds$popmaf))				# all sites
	# inds$expHe_all2	<<- 2*(inds$popmaf_all*(1-inds$popmaf_all))		# include only sites which are segregating in the population to which the individual belongs
	inds 				<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}

snp_hetero<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1,make_global=FALSE,silent=TRUE)
	{
	if(is.null(snps$nonmissallelecount))
		{
		cat("WARNING: column snps$nonmissallelecount not found. Generating now...",sep="\n") 
		indmissfilter			<- inds$miss<=indthreshold
		snps$nind				<<- nInd(mygenlight[indmissfilter,])
		snps$misscount			<<- 2*glNA(mygenlight[indmissfilter,],alleleAsUnit=FALSE)									# 16-03-2021: for each locus, calculate number of alleles (from filtered subset) with missing data
		snps$nonmissallelecount <<- (2*nInd(mygenlight[indmissfilter,]))-snps$misscount										# 16-03-2021
		}
	# Locusspecific heterozygosities:
	indfilter	<- inds$miss <= indthreshold
	snpfilter	<- snps$miss <= snpthreshold
	mymatrix 	<- as.matrix(mygenlight[indfilter,])
	#snps$hetero	<<- apply(mymatrix,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	mymatrix[is.na(mymatrix)]	<- 3
	snps$hetero	<<- apply(mymatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
	# get genotype counts:
	n_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c!=3))))
	AA_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==0))))
	Aa_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==1))))
	aa_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==2))))
	#na_vector	<- as.vector(apply(mymatrix, 2, function(c)length(c[is.na(c)])))
	na_vector	<- as.vector(apply(mymatrix, 2, function(c)length(which(c==3))))
	snps$n		<<- n_vector
	snps$AA		<<- AA_vector	
	snps$Aa		<<- Aa_vector	
	snps$aa		<<- aa_vector	
	if(any(snps$n!=(snps$AA+snps$Aa+snps$aa)))
		{
		return(cat("ERROR: total number of genotypes not equal to the sum of AA, Aa and aa genotypes. Please contact the developer of SambaR.",sep="\n"))
		}
	if(any(snps$n!=(snps$nonmissallelecount/2)))
		{
		return(cat("ERROR: allele count does is not double the the total number of genotypes. Please contact the developer of SambaR.",sep="\n"))
		}
	# snps$mono	<<- snps$Aa+snps$aa==0		# 1801220: snps with no variation after filtering, but this is already captured by snps$polyfilter
	# optionally check if everything adds up:
	mysum		<- AA_vector+Aa_vector+aa_vector+na_vector
	mysum2		<- AA_vector+Aa_vector+aa_vector
	if(make_global)
		{
		myhetero2	<<- snps$Aa/mysum2			# if(snps$hetero!=snps$hetero2), something is wrong
		}
	# to compare observed genotypes with expected genotypes:
	snps$expAA	<<- round((1-snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expAa	<<- round(2*(snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expaa	<<- round(snps$maf*snps$maf*snps$nonmissallelecount/2)
	# Per population:
	for (i in (1:length(popnames)))
		{
		if(!silent){cat(popnames[i],sep="\n")}
		snps$nindtemp							<<- nrow(inds[indfilter&inds$pop==popnames[i],])
		matrixtemp								<- as.matrix(mygenlight[indfilter&inds$pop==popnames[i],])
		#snps$heterotemp						<<- apply(matrixtemp,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		matrixtemp[is.na(matrixtemp)]			<- 3		# because otherwise NA's are counted as 1.
		snps$ntemp								<<- apply(matrixtemp,2,function(z){length(which(z!=3))})
		snps$AAtemp								<<- apply(matrixtemp,2,function(z){length(which(z==0))})
		snps$Aatemp								<<- apply(matrixtemp,2,function(z){length(which(z==1))})
		snps$aatemp								<<- apply(matrixtemp,2,function(z){length(which(z==2))})
		if(any(snps$ntemp!=(snps$AAtemp+snps$Aatemp+snps$aatemp)))
			{
			return(cat("ERROR: total number of genotypes per population not equal to the sum of AA, Aa and aa genotypes. Please contact the developer of SambaR.",sep="\n"))
			}
		popac									<- as.vector(snps[,paste("ac",as.vector(popnames[i]),sep = "_")])							
		if(any(snps$ntemp!=(popac/2)))
			{
			#return(cat("ERROR: population allele count does is not double the the total number of genotypes. Please contact the developer of SambaR.",sep="\n"))
			cat("WARNING: population allele count does is not double the the total number of genotypes. Please contact the developer of SambaR.",sep="\n")
			}
		snps$heterotemp							<<- apply(matrixtemp,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		names(snps)[names(snps) == "nindtemp"]	<<- paste("nind",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "ntemp"] 	<<- paste("n",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "AAtemp"] 	<<- paste("AA",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "Aatemp"] 	<<- paste("Aa",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "aatemp"] 	<<- paste("aa",as.vector(popnames[i]),sep = "_")
		names(snps)[names(snps) == "heterotemp"]<<- paste("hetero",as.vector(popnames[i]),sep = "_")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}	

snp_hetero_old<-function(popnames=mysambar$populations,indthreshold=0.25,snpthreshold=0.1)
	{
	# Locusspecific heterozygosities:
	indfilter	<- inds$miss <= indthreshold
	snpfilter	<- snps$miss <= snpthreshold
	mymatrix 	<- as.matrix(mygenlight[indfilter,])
	snps$hetero	<<- apply(mymatrix,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
	for (i in (1:nrow(snps)))
		{
		temp2		<- mymatrix[,i]
		temp		<- temp2==0
		temp		<- ifelse(is.na(temp),FALSE,temp)
		snps$AA[i]	<<- length(temp[temp])
		snps$Aa[i]	<<- sum(temp2[temp2==1],na.rm=TRUE)
		snps$aa[i]	<<- 1/2*sum(temp2[temp2==2],na.rm=TRUE)
		#snps$hetero2[i]	<<- snps$Aa[i]/(snps$AA[i]+snps$Aa[i]+snps$aa[i])
		# if(snps$hetero!=snps$hetero2), something is wrong
		}
	# to compare observed genotypes with expected genotypes:
	#nrofinds	<- length(inds$nr[indmissfilter])
	snps$expAA	<<- round((1-snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expAa	<<- round(2*(snps$maf)*(1-snps$maf)*snps$nonmissallelecount/2)
	snps$expaa	<<- round(snps$maf*snps$maf*snps$nonmissallelecount/2)
	# Per population:
	for (i in (1:length(popnames)))
		{
		matrixtemp						<- as.matrix(mygenlight[indfilter&inds$pop==popnames[i],])
		# snps$heterotemp				<<- apply(matrixtemp,2,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		matrixtemp[is.na(matrixtemp)]	<- 3		# because otherwise NA's are counted as 1.
		snps$heterotemp					<<- apply(matrixtemp,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		names(snps)[names(snps) == "heterotemp"] <<- paste("hetero",as.vector(popnames[i]),sep = "")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}		
	
chrom_He_maf<-function(mychroms=NULL,addX=TRUE,export=NULL)
	{
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("MAF_He_perchrom.eps",family=mysambar$myfont,width=25,height=10)}
		if(export=="pdf"){pdf("MAF_He_perchrom.pdf",family=mysambar$myfont,width=25,height=10)}
		if(export=="png"){png("MAF_He_perchrom.png",family=mysambar$myfont,width=1800,height=720)}
		if(export=="wmf"){win.metafile("MAF_He_perchrom.wmf",family=mysambar$myfont,width=25,height=10)}
		}
	par(mfrow=c(2,1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,1,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	boxplot(snps$maf[snps$placed]~as.vector(snps$chr[snps$placed]),main="",xaxt='n',ylab="Minor allele frequencies")
	boxplot(snps$hetero[snps$placed]~as.vector(snps$chr[snps$placed]),main="",xlab="Chromosome",ylab="Heterozygosities")
	mtext("Chromosome",side=1,cex=2.5,line=3)
	if(!is.null(export)){dev.off()}
	}

# 16-11-2023: function to quickly reset filters without the need to recalculate them.
# i.e., specify which filters should be enabled, and which not.
resetfilters<-function(fmiss=TRUE,fkin=TRUE)
	{
	ninds	<- nrows(inds)
	nsnps	<- nrow(snps)
	#	
	if(fmiss)
		{
		indmissfilter	<- inds$missfilter
		snpmissfilter	<- snps$missfilter
		}else{
		indmissfilter	<- rep(TRUE,ninds)
		snpmissfilter	<- rep(TRUE,nsnps)
		}
	if(fkin)
		{
		indkinfilter	<- inds$kinfilter
		}else{
		indkinfilter	<- rep(TRUE,ninds)
		}
	}

filters<-function(indthreshold=0.25,snpthreshold=0.1,mac=2,kin_thres=NULL,mindistance=500,hefilter=TRUE,snpdepth_filter=TRUE,TsTv_filter=NULL,paralogthreshold1=0.5,paralogthreshold2=0.05,silent=TRUE,olddistfilter=FALSE,redo_kin=FALSE)
	{
	##### For individuals:
	# 05-03-2020: I decided not to filter on mean read depth per individual, because read depth is correlated to missingness, and therefore a read depth filter is redundant.
	inds$filter		<<- inds$miss<=indthreshold
	inds$filter2	<<- inds$filter		# back up for when using excludepop()
	inds$kinfilter	<<- TRUE
	inds$kinfilter2	<<- TRUE
	mynind			<- as.data.frame(table(inds$pop[inds$filter]))
	inds$pop_ninds	<<- NA
	for (i in c(1:nrow(inds)))
		{
		mypop				<- inds$pop[i]
		mypop2				<- which(mynind$Var1==mypop)
		inds$pop_ninds[i]	<<- mynind$Freq[mypop2]
		}
	#
	##### For snps:
	# missing data:
	snps$missfilter			<<- snps$miss<=snpthreshold
	# filter out paralogs (based on maf-he relationship):
	if(hefilter)
		{
		snps$hefilter		<<- (snps$maf<paralogthreshold2)|(snps$hetero<(paralogthreshold1*snps$maf+(2*snps$maf*(1-snps$maf))))
		# 25-3-2020: if snps$maf is NA, this results in NA-values. Replace:
		snps$hefilter[is.na(snps$hefilter)] <<- FALSE
		}else{
		snps$hefilter		<<- TRUE
		}
	# Is snp on different contig or at least certain number of bp away from previous snp?
	chrfilter				<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	chrfilter				<- c(TRUE,chrfilter[1:(length(chrfilter)-1)])
	if("dist" %in% colnames(snps))
		{
		if(olddistfilter)
			{
			# 29-06-2021: more correct
			snps$distfilter		<<- chrfilter|(snps$dist>=mindistance)
			}else{
			runthinfilter(binsize=mindistance)
			}
		}else{
		snps$distfilter		<<- TRUE
		}
	# Does snp have at least certain number of minor alleles?
	if(!is.null(mac))
		{
		snps$macfilter		<<- snps$minorcount >= mac
		}else{
		snps$macfilter		<<- TRUE
		}
	if(snpdepth_filter)
		{
		snps$depthfilter	<<- snps$depthfilter
		}else{
		snps$depthfilter	<<- TRUE
		}
	if(!is.null(TsTv_filter))
		{
		if(TsTv_filter!="Ts"&TsTv_filter!="Tv")
			{
			return(cat("ERROR: input to TsTv_filter flag should be either 'Ts' (to keep transitions only) and 'Tv' (to keep transversions only).",sep="\n")) 
			}
		if(TsTv_filter=="Ts")
			{
			snps$tstvfilter	<<- snps$transit
			}else{
			snps$tstvfilter	<<- !snps$transit
			}
		}else{
		snps$tstvfilter		<<- TRUE
		}
	if(!"polyfilter" %in% colnames(snps))
		{
		cat("WARNING: column snps$polyfilter absent. Creating now...",sep="\n")
		snps$polyfilter		<<- glMean(mygenlight)>0
		}
	if(!silent){cat("Setting overall filter.",sep="\n")}
	# Set overall filters:
	snps$filter2		<<- snps$missfilter&snps$hefilter&snps$macfilter&snps$uniqpos&snps$depthfilter&snps$tstvfilter&snps$polyfilter
	snps$filter			<<- snps$filter2&snps$distfilter
	if(!silent){cat("Overall filters set.",sep="\n")}
	# The following lines are necessary to present the error: Error in if (!any(snps$filter)) { : missing value where TRUE/FALSE needed
	# Although probably if there is a NA, the problem was earlier.
	snps$filter[is.na(snps$filter)]		<<- FALSE	
	snps$filter2[is.na(snps$filter2)]	<<- FALSE	
	#
	# remove duplicate columns:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	#
	# For kinship filtering we use only SNPs which passed quality control:
	if(is.null(kin_thres))
		{
		cat("Not including relatedness filter, because the user did not specify a kinship threshold.",sep="\n")
		}else{
		cat("Performing relatedness calculations. This may take a while, depending on the number of individuals.",sep="\n")
		calckin(do_overwrite=redo_kin)
		if(mysambar$calckinerror){return(cat("ERROR: kinship calculations encountered a problem (see previous lines).",sep="\n"))}
		kinfilter(mythres=kin_thres)
		setwd(mysambar$QCdir)
		}
	# remove duplicate columns:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	#
	mysambar$populations	<<- mysambar$populations2
	mysambar$mycolours		<<- mysambar$mycolours2
	#
	cat("Updating inds2 dataframe...",sep="\n")
	indstemp1			<- inds[,c("name","filter")]	
	colnames(indstemp1)	<- c("name1","filter1")
	indstemp2			<- inds[,c("name","filter")]	
	colnames(indstemp2)	<- c("name2","filter2")
	inds2merged			<- merge(inds2,indstemp1,by="name1")	
	if(nrow(inds2merged)!=nrow(inds2))
		{
		inds2			<<- inds2
		return(cat("ERROR: unexpected number of rows of inds2 dataframe after adding filter1 column. Contact developer of SambaR.",sep="\n"))
		}
	inds2merged2		<- merge(inds2merged,indstemp2,by="name2")	
	if(nrow(inds2merged2)!=nrow(inds2))
		{
		inds2			<<- inds2
		return(cat("ERROR: unexpected number of rows of inds2 dataframe after adding filter2 column. Contact developer of SambaR.",sep="\n"))
		}
	inds2				<<- inds2 
	inds2$filter		<<- inds2$filter1&inds2$filter2
	}

plotfilters<-function(export=NULL,plotdiscarded=TRUE)
	{
	filterdf<-snps[,c("polyfilter","missfilter","hefilter","distfilter","macfilter","tstvfilter","filter","filter2")]
	#
	if(plotdiscarded)
		{
		plottitle		<- "Number of discarded SNPs"
		}else{
		plottitle		<- "Number of retained SNPs"
		}
	mymatrix			<- matrix(NA,nrow=8,ncol=8)
	colnames(mymatrix)	<- c("poly","miss","he","dist","mac","tstv","all","all2")
	rownames(mymatrix)	<- c("poly","miss","he","dist","mac","tstv","all","all2")
	for(i in c(1:8))		# per row
		{
		for(j in c(1:8))	# per column
			{
			filter1			<- filterdf[,i]
			filter2			<- filterdf[,j]
			if(i<j)			# above diagonal
				{
				if(plotdiscarded)
					{
					mymatrix[i,j]	<- length(which((!filter1)|(!filter2)))	
					}else{
					mymatrix[i,j]	<- length(which(filter1&filter2))
					}
				}
			if(i==j)
				{
				if(plotdiscarded)
					{
					mymatrix[i,j]	<- length(which(!filter1))
					}else{
					mymatrix[i,j]	<- length(which(filter1))
					}
				}
			}
		}
	# mymatrix	<<- mymatrix	# 30-06-2023: added hashtag
	#
	# create heatmap showing number of filter data:
	if(!is.null(export))
		{
		plotname	<- ifelse(plotdiscarded,"Filterclasses_discarded","Filterclasses_retained")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=12,height=11)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=12,height=11)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=1200,height=1100)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=12,height=11)}
		}
	# define colours:
	mymax		<- max(mymatrix,na.rm=TRUE)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- seq(0,1000,100)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	# create heatmap:
	heatmap.2(lwid=c(0.5,4),lhei=c(0.5,4),mymatrix,cellnote=ifelse(!is.na(mymatrix),mymatrix,""),notecol="black",adjRow = c(0.5,0.5),adjCol=c(NA,0.5),notecex=2.5,cex.lab=2,cexRow=2.5,cexCol=2.5,Colv=FALSE,Rowv=FALSE,scale="none",dendrogram="none",key=FALSE,col=myColours,keysize=1,trace="none",ylab = "",xlab = "",srtCol=45,srtRow=45)
	mtext(plottitle, side = 3, line = 0.5, cex = 3)
	if(!is.null(export)){dev.off()}
	}

ind_maf<-function(popnames=mysambar$populations,allsites=FALSE,popcorrect=TRUE,silent=TRUE)	
	{
	# This function calculates the average number of minor alleles (relative to metapopulation) per locus.
	# For each locus (2 alleles) the outcome can be: 
	# 0/2 = 0
	# 1/2 = 0.5
	# 2/2 = 1
	# This is averaged over all loci. Say for example we have the following genotype score for 10 loci:
	# 1 0 0 1 
	# Then we: (1 + 1)/8 = 0.25. 
	# So each locus 25 percent of observing a minor allele, according to calculations. 
	# This is correct, because the probabilities per locus are 0.5, 0, 0, 0.5. 
	# As a side note: we observe 50 percent heterozygous loci. This is a slight he-excess, because expected heterozygosity is: 2*0.25*0.75 = 0.375.  
	#   	
	# If allsites = TRUE, maf is calculated for all sites, including sites which are not segregating within the population to which the individual belongs
	# If allsites = TRUE, results will be stored in column inds_maf_all
	# If allsites = FALSE (default), maf is calculated for segregating sites only
	# If allsites = FALSE (default), results will be stored in column inds_maf
	indmaf					<- rep(NA,nrow(inds))
	nsegsites1				<- rep(NA,nrow(inds))
	nsegsites2				<- rep(NA,nrow(inds))
	nsegsites3				<- rep(NA,nrow(inds))
	nsegsites4				<- rep(NA,nrow(inds))
	n0_meta					<- rep(NA,nrow(inds))
	n1_meta					<- rep(NA,nrow(inds))
	n2_meta					<- rep(NA,nrow(inds))
	ntotal					<- rep(NA,nrow(inds))
	#
	n0_pop					<- rep(NA,nrow(inds))
	n1_pop					<- rep(NA,nrow(inds))
	n2_pop					<- rep(NA,nrow(inds))
	#
	for (i in (1:(nrow(inds))))
		{
		if(!silent){cat(i,sep="\n")}
		if(!silent){cat(as.vector(inds$name[i]),sep="\n")}
		mypop				<- as.vector(inds$pop[i])
		if(allsites)
			{
			temp			<- as.matrix(mygenlight[i,snps$filter])
			mymaf1			<- snps[snps$filter,names(snps)==paste("maf",mypop,sep="_")]
			mymaf2			<- snps[snps$filter,names(snps)==paste("maf2",mypop,sep="_")]
			}else{
			mypop			<- inds$pop[i]
			mypopmaf		<- snps[,names(snps) == paste("maf",mypop,sep="_")] 	
			mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
			temp			<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0])
			mymaf1			<- snps[snps$filter&mypopmaf>0,names(snps)==paste("maf",mypop,sep="_")]
			mymaf2			<- snps[snps$filter&mypopmaf>0,names(snps)==paste("maf2",mypop,sep="_")]
			nsegsites1[i]	<- ncol(temp)
			nsegsites2[i]	<- length(temp[!is.na(temp)])
			temp2			<- as.matrix(mygenlight[i,snps$hefilter&mypopmaf>0])
			nsegsites3[i]	<- ncol(temp2)
			nsegsites4[i]	<- length(temp2[!is.na(temp2)])
			}
		temp2	<- as.data.frame(table(temp))
		# number of 1's (heterozygous sites): 	(length(z[z==1])-(length(z)-length(z[!is.na(z)]))
		# indmaf[i]			<- apply(temp,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)]))+2*(length(z[z==2])-(length(z)-length(z[!is.na(z)]))))/(2*length(z[!is.na(z)])))
		# the apply-function works fine, but this one is easier to understand:
		#
		# 22-02-2021: calculate n0, n1 and n2 using estimate of minor allele based on metapopulation:
		temp3					<- temp[!is.na(temp)]
		n0_meta[i]				<- length(temp3[temp3==0])
		n1_meta[i]				<- length(temp3[temp3==1])
		n2_meta[i]				<- length(temp3[temp3==2])
		if(!silent){cat(paste("n2_meta: ", n2_meta[i],sep=""),sep="\n")}
		#
		# calculate n0, n1 and n2 after correction for minor alleles which flipped over in subpopulation to becoming major allele:
		# Note: if sample sizes are small, this can result in biased estimates
		temp4					<- temp
		temp5					<- temp
		temp5[(mymaf1!=mymaf2)&temp4==2]<- 0
		temp5[(mymaf1!=mymaf2)&temp4==0]<- 2
		temp3					<- temp5[!is.na(temp5)]
		n0_pop[i]				<- length(temp3[temp3==0])
		n1_pop[i]				<- length(temp3[temp3==1])
		n2_pop[i]				<- length(temp3[temp3==2])
		if(!silent){cat(paste("n2_pop: ", n2_pop[i],sep=""),sep="\n")}
		# calculate average proportion of minor alleles (based on correction of minor allele):
		ntotal[i]			<- length(temp3)
		indmaf[i]			<- sum(temp3)/(2*length(temp3))		# 2 alleles per locus, so hence times 2
		}
	if(allsites)
		{
		inds$maf_all		<<- indmaf
		inds$n0_meta		<<- n0_meta
		inds$n1_meta		<<- n1_meta
		inds$n2_meta		<<- n2_meta
		inds$ndata			<<- ntotal
		inds$n0_pop			<<- n0_pop
		inds$n1_pop			<<- n1_pop
		inds$n2_pop			<<- n2_pop
		inds$allgeno		<<- inds$n0_pop>0&inds$n1_pop>0&inds$n2_pop>0
		inds$allgeno2		<<- inds$n0_pop>0&inds$n2_pop>0
		}else{
		inds$n0_meta_seg	<<- n0_meta
		inds$n1_meta_seg	<<- n1_meta
		inds$n2_meta_seg	<<- n2_meta
		inds$maf			<<- indmaf
		inds$nsegsites1		<<- nsegsites1
		inds$nsegsites2		<<- nsegsites2
		inds$nsegsites3		<<- nsegsites3
		inds$nsegsites4		<<- nsegsites4
		}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}

# This function is executed by the importdata() function in order to create a preliminary He_vs_miss plot which can be consulted by users before running the filterdata() function:  
# It calculates temporary inds$hetero values
indhetero_allsnps<-function()
	{
	# Calculates individual heterozygosities:
	indhet			<- rep(NA,nrow(inds))
	indnsites2		<- rep(NA,nrow(inds))
	for (i in (1:(nrow(inds))))
		{
		mymatrix 		<- as.matrix(mygenlight[i,])
		# the next seemingly complicated formula is necessary because NA are counted as 1's.
		indhet[i]		<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
		indnsites2[i]	<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
		}
	inds$hetero_all		<<- indhet
	inds$hetero			<<- indhet
	inds$nsites2		<<- indnsites2
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}	

ind_hetero<-function(popnames=mysambar$populations,chrominfo=FALSE,allsites=FALSE)
	{
	# Calculates individual heterozygosities:
	indhet		<- rep(NA,nrow(inds))
	indhet2		<- rep(NA,nrow(inds))
	indhetX		<- rep(NA,nrow(inds))
	indnsites1	<- rep(NA,nrow(inds))
	indnsites2	<- rep(NA,nrow(inds))
	indnsites_nofilter	<- rep(NA,nrow(inds))
	indnsites_filter2	<- rep(NA,nrow(inds))
	for (i in (1:(nrow(inds))))
		{
		if(chrominfo)
			{
			if(allsites)
				{
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&snps$chr!="X"])
				Xmatrix		<- as.matrix(mygenlight[i,snps$filter&snps$chr=="X"])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2&snps$chr!="X"])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter&snps$chr!="X"])
				}else{
				mypop		<- inds$pop[i]
				mypopmaf	<- snps[,names(snps) == paste("maf",mypop,sep="_")]
				mypopmaf[is.na(mypopmaf)]	<- 0	# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&snps$chr!="X"&mypopmaf>0])
				Xmatrix		<- as.matrix(mygenlight[i,snps$filter&snps$chr=="X"&mypopmaf>0])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2&snps$chr!="X"&mypopmaf>0])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter&snps$chr!="X"&mypopmaf>0])
				}
			# the next seemingly complicated formula is necessary because NA are counted as 1's.
			# the formula has the following structure:
			# ((number of He-sites) - (number of sites with missing data))/(number of sites without missing data) 
			# For example, the following vector: 2 0 NA 1 1 NA
			# would result in:
			# 4 - (4 - 2))/4				
			indnsites1[i]			<- apply(mymatrix,1,function(z) length(z))
			indnsites2[i]			<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
			indhet[i]				<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indhetX[i]				<- apply(Xmatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indnsites_filter2[i]	<- apply(mymatrix2,1,function(z) length(z[!is.na(z)]))
			indnsites_nofilter[i]	<- apply(mymatrix3,1,function(z) length(z[!is.na(z)]))
			}else{
			if(allsites)
				{
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter])
				}else{
				mypop		<- inds$pop[i]
				mypopmaf	<- snps[,names(snps) == paste("maf",mypop,sep="_")]
				mypopmaf[is.na(mypopmaf)]	<- 0		# 09-07-2019: to prevent ERROR: 'ERROR in 1:nLoc(x) : NA/NaN argument'
				mymatrix 	<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0])
				mymatrix2	<- as.matrix(mygenlight[i,snps$filter2&mypopmaf>0])
				mymatrix3	<- as.matrix(mygenlight[i,snps$hefilter&mypopmaf>0])
				}
			# the next seemingly complicated formula is necessary because NA are counted as 1's.
			indnsites1[i]	<- apply(mymatrix,1,function(z) length(z))
			indnsites2[i]	<- apply(mymatrix,1,function(z) length(z[!is.na(z)]))
			indhet[i]		<- apply(mymatrix,1,function(z) (length(z[z==1])-(length(z)-length(z[!is.na(z)])))/length(z[!is.na(z)]))
			indnsites_filter2[i]	<- apply(mymatrix2,1,function(z) length(z[!is.na(z)]))
			indnsites_nofilter[i]	<- apply(mymatrix3,1,function(z) length(z[!is.na(z)]))
			}
		}
	if(!allsites)	{inds$hetero				<<- indhet}
	if(!allsites)	{inds$hetero[inds$popmaf==0]<<- 0}		# necessary because of line: mymatrix 	<- as.matrix(mygenlight[i,snps$filter&mypopmaf>0]) 
	if(allsites)	{inds$nsites1				<<- indnsites1}
	if(allsites)	{inds$nsites2				<<- indnsites2}
	if(allsites)	{inds$hetero_all			<<- indhet}
	if(allsites)	{inds$nsites_filter2		<<- indnsites_filter2}
	if(allsites)	{inds$nsites_nofilter		<<- indnsites_nofilter}
	if(!allsites)	{inds$nsegsites_filter2		<<- indnsites_filter2}
	if(!allsites)	{inds$nsegsites_nofilter	<<- indnsites_nofilter}
	if(chrominfo)	{inds$heteroX				<<- indhetX}
	if(allsites&&chrominfo)	{inds$heteroX_all	<<- indhetX}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	}	

plotlocusdepth<-function(export=FALSE)
	{
	myscores	<- snps$meandepth[!is.na(snps$meandepth)]
	temp		<- myscores[myscores<quantile(myscores,0.995)]
	mythreshold	<- qnorm((1-0.05/length(myscores)), mean = mean(temp,na.rm=TRUE), sd = sd(temp,na.rm=TRUE), lower.tail = TRUE, log.p = FALSE)
	hs			<- hist(log(myscores),breaks=1000)
	if(export){pdf("Locusdepth.pdf")}
	par(layout(matrix(c(1,1,1,1,1,1,1,1,2),1,9)),mar=c(2,0,2,0),oma=c(3,7,2,2))
	plot(myscores,log="y",cex=0.75,pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(c(1:length(myscores))[myscores>mythreshold],myscores[myscores>mythreshold],cex=0.75,pch=16,col="red")
	abline(h=mythreshold,lty=2)
	mtext("Mean read depth",side=2,line=4,cex=2)
	mtext("SNP index",side=1,line=4,cex=2)
	# add histogram on the side
	plot(NA, type='n', axes=FALSE, yaxt='n',xlab='',ylab=NA,main=NA,xlim=c(0,max(hs$counts)),ylim=c(1,length(hs$counts)))
	arrows(rep(0,length(hs$counts)),1:length(hs$counts),hs$counts,1:length(hs$counts),length=0,angle=0,lwd=2,col="grey")
	if(export){dev.off()}
	}

plotHe_perind<-function(export=NULL,genomehe=FALSE)
	{
	ninds	<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		plotname	<- ifelse(genomehe,"Genomehe_per_ind","He_per_ind")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=ninds*0.25,width=15)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=ninds*0.25,width=15)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=ninds*25,width=1500)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=ninds*0.25,width=15)}
		}
	indstemp	<- inds[order(inds$pop),]
	if(!genomehe)
		{
		myhe	<- indstemp$hetero_all
		}else{
		myhe	<- indstemp$genomehe
		}
	barplot(myhe[indstemp$filter],col=indstemp$popcol[indstemp$filter],border=indstemp$popcol[indstemp$filter],horiz=TRUE,names.arg=indstemp$nr[indstemp$filter],las=1)	
	if(!genomehe)
		{
		mtext(side=1,"Heterozygosity",line=3,cex=3)
		}else{
		mtext(side=1,"Genome wide heterozygosity",line=3,cex=3)
		}
	if(!is.null(export)){dev.off()}
	}

barplotF_perind<-function(export=NULL)
	{
	ninds	<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		plotname	<- "Inbreeding_per_ind"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=ninds*0.25,width=15)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=ninds*0.25,width=15)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=ninds*25,width=1500)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=ninds*0.25,width=15)}
		}
	indstemp	<- inds[order(inds$pop),]
	barplot(indstemp$obshomo[indstemp$filter],col=indstemp$popcol[indstemp$filter],border=indstemp$popcol[indstemp$filter],horiz=TRUE,names.arg=indstemp$nr[indstemp$filter],las=1)
	myauto	<- indstemp$F[indstemp$filter]*indstemp$nsites5[indstemp$filter]
	myauto	<- ifelse(myauto<0,0,myauto)
	barplot(myauto,add=TRUE,col="grey90",border=indstemp$popcol[indstemp$filter],horiz=TRUE)
	mtext(side=1,"Number of autozygous (light grey) and non-autozygous (colour) homozygous sites",line=2.5,cex=2)
	if(!is.null(export)){dev.off()}
	}
	
retainedsites_perpop<-function(export=NULL)
	{
	npops	<- length(mysambar$populations)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Retainedsites.perpop.eps",family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="pdf"){pdf("Retainedsites.perpop.pdf",family=mysambar$myfont,width=npops*2.5,height=6)}
		if(export=="png"){png("Retainedsites.perpop.png",family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile("Retainedsites.perpop.wmf",family=mysambar$myfont,width=npops*2.5,height=6)}
		}
	par(mar=c(4,8,0.5,0.5))
	boxplot(inds$nsites2[inds$filter]~inds$pop[inds$filter],col=mysambar$mycolours[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,pch=16)
	mtext(side=2,"Number of retained sites",line=5,cex=2)
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

retainedinds_perpop<-function(export=NULL,popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	nindsperpop	<- vector()
	for(k in c(1:npops))
		{
		nindsperpop[k]	<- nrow(inds[as.character(inds$pop)==as.character(popnames[k])&inds$filter,])
		}
	if(length(nindsperpop)!=length(mysambar$mycolours))
		{
		return(cat("ERROR: number of populations does not correspond with number of colours.",sep="\n"))
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Retainedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Retainedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Retainedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Retainedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nindsperpop,col=mysambar$mycolours,border=mysambar$mycolours,space=0.1,horiz=TRUE,main="Retained individuals",names.arg=popnames,las=1)
	if(!is.null(export)){dev.off()}
	}	

discardedinds_perpop<-function(export=NULL,popnames=mysambar$poporder2,popcolours=mysambar$colorder2)
	{
	npops		<- length(popnames)
	nindsperpop	<- vector()
	for(k in c(1:npops))
		{
		nindsperpop[k]	<- nrow(inds[as.character(inds$pop)==as.character(popnames[k])&(!inds$filter),])
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Discardedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Discardedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Discardedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Discardedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,8,2.5,2.5))
	barplot(nindsperpop,col=popcolours,border=popcolours,space=0.1,horiz=TRUE,main="Discarded individuals",names.arg=popnames,las=1)
	if(!is.null(export)){dev.off()}
	}

indsfilter_perpop<-function(export=NULL,popnames=mysambar$poporder2,popcolours=mysambar$colorder2,leftmargin=8.5)
	{
	npops					<- length(popnames)
	nretainedperpop			<- vector()
	for(k in c(1:npops))
		{
		nretainedperpop[k]	<- nrow(inds[as.character(inds$pop)==as.character(popnames[k])&(inds$filter),])
		}
	ndiscardedperpop		<- vector()
	for(k in c(1:npops))
		{
		ndiscardedperpop[k]	<- -(nrow(inds[as.character(inds$pop)==as.character(popnames[k])&(!inds$filter),]))
		}	
	mymin	<- min(ndiscardedperpop)-1
	mymax	<- max(nretainedperpop)+1
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Discardedinds.perpop.eps",family=mysambar$myfont)}
		if(export=="pdf"){pdf("Discardedinds.perpop.pdf",family=mysambar$myfont)}
		if(export=="png"){png("Discardedinds.perpop.png",family=mysambar$myfont)}
		if(export=="wmf"){win.metafile("Discardedinds.perpop.wmf",family=mysambar$myfont)}
		}
	par(mar=c(4,leftmargin,2.5,2.5))
	barplot(nretainedperpop,col=popcolours,border=popcolours,space=0.1,horiz=TRUE,main="Discarded (-) and retained (+) individuals",names.arg=popnames,las=1,xlim=c(mymin,mymax))
	barplot(ndiscardedperpop,col=popcolours,border=popcolours,space=0.1,horiz=TRUE,add=TRUE)
	abline(v=0)
	if(!is.null(export)){dev.off()}
	}
	
plot_number_segregating_sites<-function(popnames=mysambar$populations,export=NULL,dofilter=FALSE)
	{
	if(dofilter)
		{
		mysegsites	<- inds$nsegsites2
		mytotalsites<- inds$nsites2
		}else{
		mysegsites	<- inds$nsegsites_nofilter
		mytotalsites<- inds$nsites_nofilter
		}
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		mystring	<- ifelse(dofilter,"retained","all")
		if(export=="eps"){postscript(paste("Segregatingsites",mystring,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("Segregatingsites",mystring,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("Segregatingsites",mystring,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("Segregatingsites",mystring,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	mymin					<- (min(c(min(mytotalsites),min(mysegsites))))/1000
	mymax					<- (max(c(max(mytotalsites),max(mysegsites))))/1000
	if(!dofilter)
		{
		plot(mytotalsites[inds$filter]/1000,mysegsites[inds$filter]/1000,xlim=c(mymin,mymax),ylim=c(mymin,mymax),main="Proportion segregating sites",xlab="# All sites (x 1000)",ylab="# Segregating sites (x 1000)",cex=2.5)
		}else{
		plot(mytotalsites[inds$filter]/1000,mysegsites[inds$filter]/1000,xlim=c(mymin,mymax),ylim=c(mymin,mymax),main="Proportion segregating sites",xlab="# Retained sites (x 1000)",ylab="# Retained segregating sites (x 1000)",cex=2.5)
		}
	for (j in c(1:length(popnames)))
		{
		mypop				<- popnames[j]
		points(mytotalsites[inds$pop==mypop&inds$filter]/1000,mysegsites[inds$pop==mypop&inds$filter]/1000,col=mysambar$mycolours[j],pch=16,cex=2.5)
		points(mytotalsites[inds$pop==mypop&!inds$filter]/1000,mysegsites[inds$pop==mypop&!inds$filter]/1000,col=mysambar$mycolours[j],cex=2.5)
		}
	lines(c(-1000,nrow(snps)),c(-1000,nrow(snps)))
	legend("topleft",legend=popnames,bty='n',fill=unique(inds$popcol),cex=2)
	if(!is.null(export)){dev.off()}
	}
	
mysummarytable<-function()
	{
	options(scipen=999)	# no scientific notation
	if("dist" %in% colnames(snps))
		{
		mydf				<- as.data.frame(matrix(NA,nrow=8,ncol=3))
		rownames(mydf)		<- c("Number of individuals","Number of SNPs","Percentage of SNPs with maf >= 0.05","Mean spacing between SNPs","Median spacing between SNPs","Mean proportion of missing data per individual","GC content","Transition vs transversion ratio")
		colnames(mydf)		<- c("Before filtering","After filtering","After thinning")
		for(i in (c(1:3)))
			{
			if(i==1){snpstemp<-snps;indstemp<-inds}
			if(i==2){snpstemp<-snps[snps$filter2,];indstemp<-inds[inds$filter,]}
			if(i==3){snpstemp<-snps[snps$filter,];indstemp<-inds[inds$filter,]}
			mydf[1,i]		<- nrow(indstemp)
			mydf[2,i]		<- nrow(snpstemp)
			mydf[3,i]		<- 100*nrow(snpstemp[snpstemp$maf>=0.05,])/nrow(snpstemp)
			mydf[4,i]		<- mean(snpstemp$dist,na.rm=TRUE)
			mydf[5,i]		<- median(snpstemp$dist,na.rm=TRUE)
			mydf[6,i]		<- mean(indstemp$miss,na.rm=TRUE)
			mydf[7,i]		<- nrow(snpstemp[snpstemp$GC,])/(nrow(snpstemp))
			mydf[8,i]		<- nrow(snpstemp[snpstemp$transit,])/(nrow(snpstemp[!snpstemp$transit,]))
			}
		}else{
		mydf				<- as.data.frame(matrix(NA,nrow=6,ncol=2))
		rownames(mydf)		<- c("Number of individuals","Number of SNPs","Percentage of SNPs with maf >= 0.05","Mean proportion of missing data per individual","GC content","Transition vs transversion ratio")
		colnames(mydf)		<- c("Before filtering","After filtering")
		for(i in (c(1:2)))
			{
			if(i==1){snpstemp<-snps;indstemp<-inds}
			if(i==2){snpstemp<-snps[snps$filter2,];indstemp<-inds[inds$filter,]}
			if(i==3){snpstemp<-snps[snps$filter,];indstemp<-inds[inds$filter,]}
			mydf[1,i]		<- nrow(indstemp)
			mydf[2,i]		<- nrow(snpstemp)
			mydf[3,i]		<- 100*nrow(snpstemp[snpstemp$maf>=0.05,])/nrow(snpstemp)	
			mydf[4,i]		<- mean(indstemp$miss,na.rm=TRUE)
			mydf[5,i]		<- nrow(snpstemp[snpstemp$GC,])/(nrow(snpstemp))
			mydf[6,i]		<- nrow(snpstemp[snpstemp$transit,])/(nrow(snpstemp[!snpstemp$transit,]))
			}
		}
	mydf				<- round(mydf,2)
	write.table(mydf,"SambaR.summarystats.txt",row.names=TRUE,col.names=TRUE,quote=FALSE,sep="\t")
	}	

plotminor<-function(export=NULL)
	{	
	if(!"filter"%in%colnames(snps))
		{
		return(cat("ERROR: column 'snps$filter' missing. First run filterdata() function.",sep="\n"))
		}
	if(length(table(snps$minor[snps$minor!=0&!is.na(snps$minor)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor column. Omitting minor allele histogram.",sep="\n"))
		}
	if(length(table(snps$major[snps$major!=0&!is.na(snps$major)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major column. Omitting minor allele histogram.",sep="\n"))
		}
	if(length(table(snps$minor2[snps$minor2!=0&!is.na(snps$minor2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor2 column. Omitting minor allele histogram.",sep="\n"))
		}
	if(length(table(snps$major2[snps$major2!=0&!is.na(snps$major2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major2 column. Omitting minor allele histogram.",sep="\n"))
		}
	graphics.off()
	myminor		<- as.character(snps$minor2)
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Minoralleles.pdf",width=16,height=6)}	
		if(export=="pdf"){pdf("Minoralleles.pdf",width=16,height=6)}
		if(export=="png"){png("Minoralleles.png",width=1260,height=600)}
		if(export=="wmf"){win.metafile("Minoralleles.wmf",width=16,height=6)}
		}
	par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	mytable	<-table(myminor)
	mytable	<- round(mytable/1000,1)
	mymax<-(max(mytable)+5)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),xlab="",ylab="",las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("Before filtering",side=3,cex=2,line=-1.5)
	mtext("Number of SNPs (x 1000)",side=2,line=3.5,cex=2)
	mytable<-table(myminor[snps$filter2])
	mytable<- round(mytable/1000,1)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("After filtering",side=3,cex=2,line=-1.5)
	mtext("Nucleotide",side=1,cex=2,line=3.5)
	mytable<-table(myminor[snps$filter])
	mytable<- round(mytable/1000,1)
	xx<-barplot(mytable,col=c("darkred","blue","gold","darkgreen"),ylim=c(0,mymax),xlab="",las=1)
	text(x = xx, y = mytable,label=mytable,pos=3,col="black",cex=2.5)
	mtext("After filtering and thinning",side=3,cex=2,line=-1.5)
	mtext("Distribution of minor alleles",side=3,outer=TRUE,cex=2,line=-3.5)
	if(!is.null(export)){dev.off()}
	}

plottransits<-function(filter=FALSE,thin=FALSE,export=NULL)
	{
	if(length(table(snps$minor[snps$minor!=0&!is.na(snps$minor)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(length(table(snps$major[snps$major!=0&!is.na(snps$major)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(length(table(snps$minor2[snps$minor2!=0&!is.na(snps$minor2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$minor2 column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(length(table(snps$major2[snps$major2!=0&!is.na(snps$major2)]))<4)
		{
		return(cat("WARNING: not all 4 alleles (A,C,G,T) present in snps$major2 column. Omitting transition-transversion matrix.",sep="\n"))
		}
	if(filter)			{mytable	<- table(as.vector(snps$major2[snps$filter2&!is.na(snps$minor2)]),as.vector(snps$minor2[snps$filter2&!is.na(snps$minor2)]))}
	if(thin)			{mytable	<- table(as.vector(snps$major2[snps$filter&!is.na(snps$minor2)]),as.vector(snps$minor2[snps$filter&!is.na(snps$minor2)]))}
	if(!(filter|thin))	{mytable	<- table(as.vector(snps$major2[!is.na(snps$minor2)]),as.vector(snps$minor2[!is.na(snps$minor2)]))}
	if(nrow(mytable)<2|ncol(mytable)<2)
		{
		return()			#return(cat("Only 1 allele type (A,C,G or T) as minor or major allele. Skipping transition/transversion plots.",sep="\n"))
		}
	mymax		<- max(mytable)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myBreaks	<- seq(0,mymax,(mymax/10))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		if(filter)
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.filtered.wmf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.filtered.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.filtered.wmf",width=10,height=10)}
			# png returns blank file
			}
		if(thin)
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.thinned.wmf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.thinned.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.thinned.wmf",width=10,height=10)}
			# png returns blank file
			}
		if(!(filter|thin))
			{
			if(export=="eps"){postscript("Transitions_vs_transversions.nofilter.pdf",width=10,height=10)}
			if(export=="pdf"){pdf("Transitions_vs_transversions.nofilter.pdf",width=10,height=10)}
			if(export=="wmf"){win.metafile("Transitions_vs_transversions.nofilter.wmf",width=10,height=10)}
			# png returns blank file
			}
		}
	heatmap.2(lwid=c(0.5,4),lhei=c(0.5,4),mytable,cellnote=ifelse(mytable>0,mytable,""),notecol="black",adjRow = c(0.5,NA),adjCol=c(NA,0.5),notecex=3,cex.lab=2,cexRow=3,cexCol=3,Colv=FALSE,Rowv=FALSE,scale="none",dendrogram="none",key=FALSE,col=myColours,keysize=1.5,trace="none",ylab = "",xlab = "",srtCol=0)
	mtext("Minor allele", side = 1, cex = 3, line = 3.75)
	mtext("Major allele", side = 4, cex = 3, line = 0.75)
	mtext("Transitions vs transversions", side = 3, line = 2, cex = 3)
	if(filter){mtext("After filtering", side = 3, line = -0.5, cex = 2.5)}
	if(thin){mtext("After thinning", side = 3, line = -0.5, cex = 2.5)}
	if(!(filter|thin)){mtext("Before filtering", side = 3, line = -0.5, cex = 2.5)}
	if(!is.null(export)){dev.off()}
	}
	
plotfiltermaf<-function(popnames=mysambar$populations,yrange=NULL,export=NULL)
	{
	popnames	<- as.vector(popnames)
	npops		<- length(popnames)
	mycolours	<- as.vector(unique(inds$popcol))
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("MAFperpop.pdf",width=(npops)+1*8+1,height=9)}	
		if(export=="pdf"){pdf("MAFperpop.pdf",width=(npops)+1*8+1,height=9)}
		if(export=="png"){png("MAFperpop.png",width=(npops+1)*800+100,height=900)}
		if(export=="wmf"){win.metafile("MAFperpop.wmf",width=(npops+1)*8+1,height=9)}
		}
	if(is.null(yrange))
		{
		c(0,(nrow(snps[snps$filter,])/3))
		}
	par(mfrow=c(1,length(popnames)+1),mar=c(5,6,5,2),cex.axis=1.75,cex.lab=2,cex.main=2.25)
	hist(snps$maf[snps$filter],40,main = "",ylim=yrange,xlab=NULL)
	mtext("MAF",side=1,line=3.5,cex=2)	
	title("Metapop",line=-3,cex=2.5)
	for (i in (1:length(popnames)))
		{
		#cat(popnames[i],sep="\n")
		maftemp <- glMean(mygenlight[inds$filter&inds$pop==popnames[i],snps$filter])
		hist(maftemp,40,main ="",ylim=yrange,xlab=NULL,col=mycolours[i],xlim=c(0,1))
		mtext("MAF",side=1,line=3.5,cex=2)	
		title(popnames[i],line=-3,cex=2.5)
		}
	#mtext("Locus specific minor allele frequencies", side = 1, outer = TRUE,line=-2,cex=2)		# not handy if user wants to subselect tiles from the plot
	#mtext("MAF per population", side = 3, outer = TRUE,line=-4.5,cex=3.5)						# not handy if user wants to subselect tiles from the plot
	if(!is.null(export)){dev.off()}
	}	

histo_locusHe<-function(popnames=mysambar$populations,yrange=NULL,mysubtitle=NULL,export=NULL)
	{
	popnames	<- as.vector(popnames)
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Heperpop.pdf",width=npops*6,height=7)}	
		if(export=="pdf"){pdf("Heperpop.pdf",width=npops*6,height=7)}
		if(export=="png"){png("Heperpop.png",width=npops*600,height=720)}
		if(export=="wmf"){win.metafile("Heperpop.wmf",width=npops*6,height=7)}
		}
	par(mfrow=c(1,length(popnames)+1),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(is.null(yrange))
		{
		yrange	<- c(0,(nrow(snps[snps$filter,])/3))
		}
	hist(snps$hetero[snps$filter],40,main = "",ylim=yrange,xlab=NULL,xlim=c(0,1))
	mtext("He",side=1,line=3.5,cex=2)
	title("Metapop",line=-3,cex=2.5)
	for (i in (1:length(popnames)))
		{
		snps 		<<- snps[, !duplicated(colnames(snps))]
		heterotemp	<- snps[names(snps) == paste("hetero",as.vector(popnames[i]),sep = "_")]	# 16-03-2021: added underscore
		heterotemp	<- as.vector(heterotemp[,1])
		heterotemp	<- heterotemp[snps$filter]
		hist(heterotemp,40,main ="",ylim=yrange,xlab=NULL,col=mycolours[i],xlim=c(0,1))
		mtext("He",side=1,line=3.5,cex=2)	
		title(popnames[i],line=-3,cex=2.5)
		}
	#mtext("Locus specific heterozygosity", side = 1, outer = TRUE, line=-2, cex=2)			# not handy if user wants to subselect tiles from the plot
	#mtext("Heterozygosity per population", side = 3, outer = TRUE, line=-4.5, cex=3.5)		# not handy if user wants to subselect tiles from the plot
	if(!is.null(mysubtitle))
		{
		mtext(mysubtitle, side = 3, outer = TRUE,line=-3.5)
		}
	if(!is.null(export)){dev.off()}
	}

boxplot_locusHe<-function(export=NULL,popnames=mysambar$populations)
	{
	npops	<- length(popnames)
	if(npops==1)
		{
		return(cat("Only 1 population. Sambar will not generate boxplot with heterozygosity per population.",sep="\n"))
		}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("LocusHe.perpop.boxplot.eps",family=mysambar$myfont,width=npops*2,height=6)}
		if(export=="pdf"){pdf("LocusHe.perpop.boxplot.pdf",family=mysambar$myfont,width=npops*2,height=6)}
		if(export=="png"){png("LocusHe.perpop.boxplot.png",family=mysambar$myfont,width=npops*360,height=720)}
		if(export=="wmf"){win.metafile("LocusHe.perpop.boxplot.wmf",family=mysambar$myfont,width=npops*2,height=6)}
		}
	par(mar=c(4,5,0.5,0.5))
	# 
	# create new dataframe, with one column popname, and other column He-estimates:
	temp	<- snps[snps$filter,names(snps)!="hetero"]
	temp	<- temp[, grep("hetero", names(temp))]
	# 11-06-2021: included next lines to removed imputed_He columns, which otherwise cause an error:
	imputecolumns			<- grep("imputed_hetero",colnames(temp))
	if(length(imputecolumns)>0)
		{
		temp					<- temp[,-imputecolumns]
		}
	myhe	<- as.vector(unlist(temp))
	mypops	<- rep(popnames,each=nrow(temp))
	mydf	<- data.frame(pop=mypops,hetero=myhe)
	boxplot(mydf$hetero~mydf$pop,col=mysambar$mycolours[order(mysambar$populations)],las=1,xlab="",ylab="",cex.axis=1.5,pch=16)
	# add means:
	mymeans <- aggregate(hetero ~ pop, mydf, mean)
	points(c(1:npops),mymeans$hetero,pch=16,col="white",cex=1)
	mtext(side=2,"Locus heterozygosity",line=3.5,cex=2)
	mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}	

# not used by filter wrapper function:
plotHe<-function(popnames=mysambar$populations)
	{
	npops	<- length(popnames)
	par(mfrow=c(1,4))
	mydf	<- snps[snps$filter,c("maf","hetero")]
	mydf	<- unique(mydf)
	x		<- seq(0,1,0.01)
	y		<- 2*x*(1-x)
	plot(mydf,ylim=c(0,1),xlim=c(0,1))
	lines(x,y,col="red",lwd=2)
	for(i in c(1:npops))
		{
		mypop	<- popnames[i]
		mydf	<- snps[snps$filter,c(paste("maf",mypop,sep="_"),paste("hetero",mypop,sep=""))]
		mydf	<- unique(mydf)
		plot(mydf,ylim=c(0,1),xlim=c(0,1))
		lines(x,y,col="red",lwd=2)
		}
	}

# De Finetti diagram (the height difference between 0.5 and the mean at maf=0.5, represents the Wahlund effect): 
plotparalogs<-function(export=NULL,removeduplicates=TRUE,dothin=FALSE,silent=TRUE,dofilter=FALSE)
	{
	if(dofilter)
		{
		snpsfilter	<- snps$filter
		}else{
		snpsfilter	<- rep(TRUE,nrow(snps))
		}
	if(removeduplicates)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf		<- snps[snpsfilter,c("maf","hetero","hefilter")]
		mydf		<- unique(mydf)
		mymaf		<- mydf$maf
		myhe		<- mydf$hetero
		hefilter	<- mydf$hefilter
		}else{
		mymaf		<- snps$maf[snpsfilter]
		myhe		<- snps$hetero[snpsfilter]
		hefilter	<- snps$hefilter[snpsfilter]
		}
	create_plot		<- TRUE
	if(dothin)
		{
		if(length(mymaf)>5000)
			{
			mydata		<- data.frame(mymaf,myhe,hefilter)
			mydata2		<- mydata[sample(nrow(mydata),5000),]
			mymaf		<- mydata2$mymaf
			myhe		<- mydata2$myhe
			hefilter	<- mydata2$hefilter
			}else{
			if(!silent)
				{
				cat("Less than 5000 SNPs with unique maf-He scores. No need to thin He_vs_maf plot.",sep="\n")
				}
			create_plot	<- FALSE
			}
		}
	#
	if(create_plot)
		{
		graphics.off()
		if(!is.null(export))
			{
			plotname	<- ifelse(dothin,"He_vs_maf.thinned","He_vs_maf")
			if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		plot(mymaf[hefilter],myhe[hefilter],pch=16,cex=1,xlab="Locus specific minor allele frequency",ylab="Locus specific heterozygosity",ylim=c(0,1),main="Identification of paralogs")
		points(mymaf[!hefilter],myhe[!hefilter],pch=16,cex=1,col="red",xlab="Locus specific minor allele frequency",ylab="Locus specific heterozygosity",ylim=c(0,1))
		legend("topleft",legend=c("FALSE","TRUE"),title="Pass He filter",bty='n',fill=c("red","black"),cex=3)
		if(!is.null(export)){dev.off()}
		}
	}

He_vs_readdepth<-function(export=NULL,mindepth=NULL,popnames=mysambar$populations,allsites=TRUE,legendcex=3)
	{
	graphics.off()
	if(allsites)
		{
		myhetero	<- inds$hetero_all
		}else{
		myhetero	<- inds$hetero
		}
	for(i in c(1:2))
		{
		if(!is.null(export))
			{
			mylabel	<- ifelse(i==1,"filter","pop")
			mylabel2<- ifelse(allsites,"allsites","segregatingsites")
			if(export=="eps"){postscript(paste("He_vs_readdepth_ind",mylabel2,mylabel,"eps",sep="."),family=mysambar$myfont,width=11,height=10)}
			if(export=="pdf"){pdf(paste("He_vs_readdepth_ind",mylabel2,mylabel,"pdf",sep="."),family=mysambar$myfont,width=11,height=10)}
			if(export=="png"){png(paste("He_vs_readdepth_ind",mylabel2,mylabel,"png",sep="."),family=mysambar$myfont,width=800,height=720)}
			if(export=="wmf"){win.metafile(paste("He_vs_readdepth_ind",mylabel2,mylabel,"wmf",sep="."),family=mysambar$myfont,width=11,height=10)}
			}
		par(mar=c(5,8,5,1.5),cex.axis=2.5,cex.lab=3)
		if(i==1)
			{
			plot(inds$meandepth[inds$hetero<0.5],myhetero[inds$hetero<0.5],pch=16,cex=3,log="x",xlab="Mean read depth",ylab="",las=1)
			points(inds$meandepth[(!inds$filter)&inds$hetero<0.5],myhetero[(!inds$filter)&inds$hetero<0.5],pch=16,cex=3,col="red")
			legend("topleft",legend=c("FALSE","TRUE"),title="Retained:",bty='n',fill=c("red","black"),cex=legendcex)
			}else{
			plot(inds$meandepth[inds$hetero<0.5],myhetero[inds$hetero<0.5],pch=16,cex=3,log="x",xlab="Mean read depth",ylab="",las=1,col=inds$popcol[inds$hetero<0.5])
			legend("topleft",legend=popnames,bty='n',fill=mysambar$mycolours,cex=legendcex)
			}
		if(!is.null(mindepth))
			{
			abline(v=mindepth,lty=2,lwd=2,col="grey50")
			}
		if(allsites)
			{	
			mtext("He_allsites",side=2,line=5.5,cex=3.25)
			}else{
			mtext("He_segregating",side=2,line=5.5,cex=3.25)
			}
		if(!is.null(export)){dev.off()}
		}
	}

plotgenotri<-function(export=NULL,allsites=FALSE)
	{
	# package: ade4
	if(allsites)
		{
		if(any(!c("n0_meta","n1_meta","n2_meta")%in%colnames(inds)))
			{
			return(cat("ERROR: Columns 'n0_meta','n1_meta' and/or 'n2_meta' missing from inds dataframe. Not creating Genocounts triangle plot.",sep="\n"))
			}
		mydf			<-inds[,c("n0_meta","n1_meta","n2_meta")]
		}else{
		if(any(!c("n0_meta_seg","n1_meta_seg","n2_meta_seg")%in%colnames(inds)))
			{
			return(cat("ERROR: Columns 'n0_meta'_seg,'n1_meta_seg' and/or 'n2_meta_seg' missing from inds dataframe. Not creating Genocounts triangle plot.",sep="\n"))
			}
		mydf			<-inds[,c("n0_meta_seg","n1_meta_seg","n2_meta_seg")]
		#plot((inds$n0_meta_seg+inds$n1_meta_seg+inds$n2_meta_seg),inds$n0_meta_seg,col=inds$popcol,pch=16,cex=2)
		#plot((inds$n0_meta_seg+inds$n1_meta_seg+inds$n2_meta_seg),inds$n1_meta_seg/(inds$n0_meta_seg+inds$n1_meta_seg+inds$n2_meta_seg),col=inds$popcol,pch=16,cex=2)
		}
	mydf			<-mydf/rowSums(mydf)
	mydf			<<- mydf
	colnames(mydf)	<- c("AA","Aa","aa")
	#
	if(!is.null(export))
		{
		mylabel	<- ifelse(allsites,"allsites","segsites")
		if(export=="eps"){postscript(paste("Genocounts_triangle",mylabel,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10)}
		if(export=="pdf"){pdf(paste("Genocounts_triangle",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
		if(export=="png"){png(paste("Genocounts_triangle",mylabel,"png",sep="."),family=mysambar$myfont,width=750,height=720)}
		if(export=="wmf"){win.metafile(paste("Genocounts_triangle",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
		}
	par(cex=2.5)
	mybool			<- apply(mydf,1,function(x){any(is.na(x))})
	wtriangleplot 	<- triangle.plot(mydf[!mybool,],sub=TRUE,show.position=FALSE)
	points(wtriangleplot,col=inds$popcol[!mybool],cex=2.5,pch=16)
	if(!is.null(export)){dev.off()}
	}

He_vs_miss<-function(export=NULL,popnames=mysambar$populations,allsites=TRUE,maxmiss=NULL,minsites=250,legendpos="topright",do_curve=TRUE,symbolsize=3,legendcex=3)
	{
	npops	<- length(popnames)
	graphics.off()
	if(!"miss"%in%colnames(inds))
		{
		mat 		<- as.matrix(mygenlight)
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		inds$miss 	<<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		}
	if(length(inds$miss[inds$nsites2>=minsites])==0)
		{
		return(cat("Zero individuals with more retained datapoints than defined by minsites flag. Omitting He_vs_miss plot.",sep="\n"))
		}
	if(max(inds$miss[inds$nsites2>=minsites],na.rm=TRUE)==0)
		{
		return(cat("No missing datapoints. Omitting He_vs_miss plot.",sep="\n"))
		}
	if(allsites)
		{
		myhetero	<- inds$hetero_all
		myhetero	<- ifelse(!is.finite(myhetero),0,myhetero)
		}else{
		myhetero	<- inds$hetero
		myhetero	<- ifelse(!is.finite(myhetero),0,myhetero)
		}
	for(i in c(1:2))
		{
		ndata	<- length(which(inds$nsites2>=minsites))
		if(ndata<=(npops*3))
			{
			return(cat("Insufficient number of individuals with required number of SNPs (defined by 'minsites'-flag). Omitting 'He_vs_miss' plot.",sep="\n"))  
			}
		if(!is.null(export))
			{
			mylabel	<- ifelse(i==1,"filter","pop")
			mylabel2<- ifelse(allsites,"allSNPs","segregatingsites")
			if(export=="eps"){postscript(paste("He_vs_miss_ind",mylabel2,mylabel,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10)}
			if(export=="pdf"){pdf(paste("He_vs_miss_ind",mylabel2,mylabel,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
			if(export=="png"){png(paste("He_vs_miss_ind",mylabel2,mylabel,"png",sep="."),family=mysambar$myfont,width=750,height=720)}
			if(export=="wmf"){win.metafile(paste("He_vs_miss_ind",mylabel2,mylabel,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10)}
			}
		par(mar=c(5,8,5,1.5),cex.axis=2.5,cex.lab=3)
		if(i==1)
			{
			plot(inds$miss[inds$nsites2>=minsites],myhetero[inds$nsites2>=minsites],pch=16,cex=symbolsize,log="x",xlab="indmiss (proportion missing data)",ylab="",las=1)
			if("filter"%in%colnames(inds))
				{
				points(inds$miss[(!inds$filter)&inds$nsites2>=minsites],myhetero[(!inds$filter)&inds$nsites2>=minsites],pch=16,cex=symbolsize,col="red")
				legend("bottomleft",legend=c("FALSE","TRUE"),title="Retained:",bty='n',fill=c("red","black"),cex=legendcex)
				}
			}else{
			plot(inds$miss[inds$nsites2>=minsites],myhetero[inds$nsites2>=minsites],pch=16,cex=symbolsize,log="x",xlab="Proportion missing data",ylab="",las=1,col=inds$popcol[inds$nsites2>=minsites])
			}
		if(!is.null(maxmiss))
			{
			abline(v=maxmiss,lty=2,lwd=2,col="grey50")
			}
		if(allsites)
			{	
			mtext("He (over all sites in SNP data)",side=2,line=5.5,cex=3.25)
			}else{
			mtext("He (over segregating sites)",side=2,line=5.5,cex=3.25)
			}
		if(i==2)
			{
			for(j in c(1:npops))
				{
				mypop	<- popnames[j]
				mycol	<- mysambar$mycolours[j]
				#if("filter"%in%colnames(inds))
				#	{
				#	myselection	<- inds$nsites2>=minsites&is.finite(myhetero)&inds$pop==mypop&inds$filter
				#	}else{
					myselection	<- inds$nsites2>=minsites&is.finite(myhetero)&inds$pop==mypop
				#	}
				ndata	<- length(which(myselection))
				if(ndata>2)
					{
					x		<- inds$miss[myselection]
					y		<- myhetero[myselection]
					y		<- y[is.finite(x)]
					x		<- x[is.finite(x)]		
					n_xvalues<- length(unique(inds$miss[inds$pop==mypop]))
					if(n_xvalues>2&do_curve)
						{
						lm.out 	<- lm(y ~ x)
						mymissvec<-inds$miss[inds$pop==mypop]
						missmin	<-min(mymissvec,na.rm=TRUE)
						mystepsize<-ifelse(missmin>0.005,0.01,ifelse(missmin<0.001,0.00005,0.001))
						newx 	<- seq(min(x),max(x),by = mystepsize)
						conf_int<- predict(lm.out,newdata=data.frame(x=newx),interval="confidence",level = 0.95)
						colfunc <- colorRampPalette(c("grey",mycol))
						mycol2	<- colfunc(3)[2]
						polygon(c(newx,rev(newx)),c(conf_int[,2],rev(conf_int[,3])),col=mycol2,border=NA)
						lines(newx,conf_int[,1],col=mycol,lwd=1)
						}
					}
				}
			points(inds$miss[inds$nsites2>=minsites],myhetero[inds$nsites2>=minsites],pch=16,cex=symbolsize,col=inds$popcol[inds$nsites2>minsites])
			legend(legendpos,legend=popnames,bty='n',fill=mysambar$mycolours,cex=legendcex)
			}
		mtext("Sample heterozygosity",side=3,line=0.5,cex=3.25)
		if(!is.null(export)){dev.off()}
		}
	}

plotperpool<-function(popnames=mysambar$populations)
	{
	if("pool"%in%colnames(inds))
		{
		npops		<- length(popnames)
		mycolours	<- mysambar$mycolours[1:npops]
		# heterozygosity:
		mymax		<- max(inds$hetero,na.rm=TRUE)
		pdf("He_perpool.pdf",width=5,height=npops*1.25)
		par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			boxplot(inds$hetero[inds$pop==mypop]~inds$pool[inds$pop==mypop],col=mycolours[j],ylim=c(0,mymax),las=1,border=mycolours[j])
			}
		mtext("Sequencing pool",side=1,outer=TRUE,line=0.5)
		mtext("Sample heterozygosity",side=2,outer=TRUE,line=-0.75)
		dev.off()
		# missingness:
		mymax		<- max(inds$miss,na.rm=TRUE)
		pdf("Missingness_perpool.pdf",width=5,height=npops*1.25)
		par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			boxplot(inds$miss[inds$pop==mypop]~inds$pool[inds$pop==mypop],col=mycolours[j],ylim=c(0,mymax),las=1,border=mycolours[j])
			}
		mtext("Sequencing pool",side=1,outer=TRUE,line=0.5)
		mtext("Proportion missing data",side=2,outer=TRUE,line=-0.75)
		dev.off()
		}
	}

plotplinkF<-function(export=NULL,plotname="Plink_inbreeding",addlabels=TRUE)
	{
	setwd(mysambar$inputfilesdir)
	if(file.exists("plink.het"))
		{
		plinkf		<- read.table("plink.het",header=TRUE)
		}else{
		cat("ERROR: file called 'plink.het' missing from directory:",sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Did you run the command: 'plink --file metapop.filter2.miss0.letter --het'? See the SambaR manual for more instructions.",sep="\n"))
		}
	plinkf$FID		<- NULL
	colnames(plinkf)<- c("name","O.HOM","E.HOM","N.NM","plinkF")
	indstemp 		<- merge(x = inds, y = plinkf, by = "name", all = TRUE)
	if(any(rownames(as.matrix(mygenlight))!=indstemp$name))
		{
		return(cat("ERROR: after merging the row names of the genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	inds	<<- indstemp
	#
	# PLOT:
	npops		<- length(mysambar$populations)
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,sep="."),family=mysambar$myfont,width=npops*mywidth+3,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+3,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+300,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+3,height=8)}
		}
	par(oma=c(9,8,1,4),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	y_lim	<- c(min(indstemp$plinkF,na.rm=TRUE),1.025*max(indstemp$plinkF,na.rm=TRUE))
	boxplot(indstemp$plinkF~indstemp$poporder,border=mysambar$colorder2,log=mylog,col="grey90",las=2,xlab="",ylab="",cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim)
	stripchart(plinkF~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=3,col=mysambar$colorder2,bg="bisque",add=TRUE)
	if(addylabel)
		{	
		mtext(side=2,"Inbreeding coefficient",line=4,cex=2.75,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(addlabels)
		{
		mtext("He-deficit",side=4,at=0.01,adj=0,line=0.5,cex=1.5)
		mtext("He-excess",side=4,at=-0.01,adj=1,line=0.5,cex=1.5)
		abline(h=0,lty=3)
		}
	if(!is.null(export)){dev.off()}
	}
	
plot_F<-function(export=FALSE,popnames=mysambar$populations,addlabels=TRUE,myfvalues=NULL)
	{
	npops		<- length(popnames)
	if(is.null(myfvalues))
		{
		myfvalues	<- snps[snps$filter,paste("F",mysambar$populations,sep="_")]
		}
	if(export){pdf("Fixationindex_perlocus.pdf",width=npops*2.5,height=6)}
	par(cex.axis=1.5,mar=c(3,6,1,2))
	boxplot(myfvalues, use.cols = TRUE,col=mysambar$mycolours,names=mysambar$populations,outline=FALSE,las=1)
	mtext("Locus specific FIS",side=2,line=3.75,cex=1.75)
	if(addlabels)
		{
		mtext("He-deficit",side=4,at=0.01,adj=0,line=0.5,cex=1.5)
		mtext("He-excess",side=4,at=-0.01,adj=1,line=0.5,cex=1.5)
		abline(h=0,lty=3)
		}
	if(export){dev.off()}
	}

calc_indF<-function(popnames=mysambar$populations,correctmaf=FALSE,silent=TRUE)
	{
	# Correctmaf: calculate F based on minor allele frequency over the population excluding the individual under investigation
	#
	# The individual inbreeding coefficient F is the probability that the two alleles at a locus are identical by descent (IBD).
	# 15-4-2020: Here I use the formula: F = (obshomo - exphomo)/(nsites - exphomo)
	# as described in: Kardos et al, 2015 Measuring individual inbreeding in the age of genomics: marker-based measures are better than pedigrees
	# why does this formula work?
	# it works because F can also be defined as the proportion of expected heterozygous sites (in case of no inbreeding) which are homozygous due to inbreeding.
	# let's consider this example:
	# say diploid individual A consists of 10 sites, of which 6 are heterozygous (so heterozygosity = 0.6)
	# by selfing individual A produces individual B
	# individual B wil most likely have 4 + 0.5*6 = 7 homozygous sites
	# furthermore, assuming all sites of individual A are not identical by descent (just identical by state (IBS) in case of homozygous sites), then:
	# individual B will most likely have 0.5*10 = 5 autozygous sites
	# of these 5 autozygous sites, 3 were heterozygous in individual A, and 2 were homozygous.
	# of all other individuals in the population are not inbred, and on average have the same genotype as individual A, then:
	# according to the formula we get:
	# individual A: F = (4 - 4)/(10 - 4) = 0/6 = 0.0
	# individual B: F = (7 - 4)/(10 - 4) = 3/6 = 0.5
	# From the pedigree we know indeed that F should be 0.5. (And it also makes sense in the sense that 50 percent of expected heterozygous sites are homozygous due to inbreeding).
	#
	# Note that with 10 sites only, small stochastic deviations can lead to high F values.
	# So we also need to calculate whether the deviation from expected values is significant using a chi-squared test.
	#
	# Also note that if we calculate expected homozygosity based on input which includes the individual we examine, the outcome will be biased.
	# so say that in the example above, the population consists of two individuals only, namely A and B, then the expected homozygosity (when defined as the average of the population) would be: 5.5 sites (i.e mean of 7 and 4).
	# In that case the formula would become:
	# individual A: F = (4 - 5.5)/(10 - 5.5) = -1.5/4.5 = -0.33
	# individual B: F = (7 - 5.5)/(10 - 5.5) = 1.5/4.5 = 0.33
	# So the inclusion of inbred individuals in the calculation of expected H, leads to an underestimate of F, and can make other individuals look outbred
	# If you have big sample sizes, then a few inbred individuals will not change the expected homozygosity massively.
	# But especially with small sample sizes, inbred individuals can biased exphomo upwards, and therefore F downwards.
	#
	# Note: plink --het gives slightly different outcomes (at least when SambaR does not exclude examined individuals when calculated expected homo).  
	#
	# This is not part of it but used by other functions (?)
	if(!"expHe"%in%colnames(inds))
		{
		# 29-03-2024: replaced following lines:
		# inds$expHe		<<- 2*(inds$popmaf*(1-inds$popmaf))				# all sites
		# inds$expHe_all	<<- 2*(inds$popmaf_all*(1-inds$popmaf_all))		# include only sites which are segregating in the population to which the individual belongs
		cat("WARNING: column expHe not present. Rerunning getpopmaf function...",sep="\n")
		getpopmaf(snpthreshold=mysambar$snpmissfilter)
		}
	#
	npops			<- length(popnames)
	ninds			<- nrow(inds)
	mymatrix		<- as.matrix(mygenlight[,snps$filter])
	snpstemp		<- snps[snps$filter,]
	obshomo			<- vector()
	exphomo			<- vector()
	nsitesvec		<- vector()
	fvector			<- vector()
	pvaluevec		<- vector()
	fchi2vec		<- vector()
	fpvec			<- vector()
	for(j in c(1:ninds))
		{
		if(!silent){cat(j,sep="\n")}
		mygeno		<- as.vector(mymatrix[j,])
		indpop		<- as.vector(inds$pop[j])
		if(!silent){cat(as.vector(inds$name[j]),sep="\n")}
		if(!silent){cat(indpop,sep="\n")}
		if(!correctmaf)
			{
			indpopmaf			<- as.vector(snpstemp[,paste("maf",indpop,sep="_")])
			}else{
			if(!inds$filter[j])
				{
				# if set to FALSE, individual is not included in analyses, so it's genotype has not been considered when calculating population allele frequency
				# no need to correct
				indpopmaf			<- as.vector(snpstemp[,paste("maf",indpop,sep="_")])
				}else{
				# 05-04-2020: correct population allele frequency estimate by excluding examined individual:
				indpopmafs			<- as.vector(snpstemp[,paste("maf",indpop,sep="_")])
				indpopnr			<- which(popnames==indpop)
				indpopsize			<- nrow(inds[inds$pop==indpop&inds$filter,])
				indpopmacs			<- round(indpopmafs*indpopsize*2)		# 07-05-2020: if I do not round, I get strange values for new mafs, like -0.00000000000000005551115 instead of 0 
				indgeno2			<- as.vector(mygeno)
				indgeno2[is.na(indgeno2)]	<- 3	# because NA-values can be interpreted as 1			
				if(length(indgeno2)!=length(indpopmacs))
					{
					return(cat("ERROR: length indgeno2 does not equal length indpopmacs. Please contact developer of SambaR.",sep="\n"))
					}
				newnralleles		<- 2*(indpopsize-1)
				indpopmaf			<- ifelse(indgeno2==3,indpopmafs,ifelse(indgeno2==2,(indpopmacs-2)/newnralleles,ifelse(indgeno2==1,(indpopmacs-1)/newnralleles,indpopmacs/newnralleles)))
				if(any(indpopmaf[!is.na(indpopmaf)]<0))
					{
					testpopmacs		<<- indpopmacs
					testnrnewalleles<<- newnralleles
					testgeno		<<- mygeno	
					oldmafs			<<- indpopmafs
					newmafs			<<- indpopmaf
					return(cat("ERROR: corrected minor allele frequency below 0. Please contact developer of SambaR.",sep="\n"))
					}
				if(any(indpopmaf[!is.na(indpopmaf)]>1))
					{
					testgeno		<<- mygeno
					oldmafs			<<- indpopmafs
					newmafs			<<- indpopmaf
					return(cat("ERROR: corrected minor allele frequency above 1. Please contact developer of SambaR.",sep="\n"))
					}
				}
			}
		# expected number of homozygous sites:
		indpopmaf	<- indpopmaf[!is.na(mygeno)]
		exphomo[j]	<- sum((indpopmaf^2+(1-indpopmaf)^2))		
		# observed number of homozygous sites:
		mygeno		<- mygeno[!is.na(mygeno)]
		nsitesvec[j]<- length(mygeno)
		obshomo[j]	<- length(mygeno[mygeno!=1])
		fvector[j]	<- (obshomo[j]-exphomo[j])/(nsitesvec[j]-exphomo[j])
		fchi2vec[j] <- ((obshomo[j]-exphomo[j])^2)/exphomo[j]
		fpvec[j]	<- pchisq(fchi2vec[j],df=1,lower.tail=FALSE)
		}
	if(!correctmaf)
		{
		inds$obshomo	<<- obshomo
		inds$exphomo	<<- exphomo
		inds$nsites5	<<- nsitesvec
		inds$F			<<- fvector
		inds$F_chi2		<<- fchi2vec
		inds$F_pvalue	<<- round(fpvec,6)
		}else{
		inds$obshomo2	<<- obshomo
		inds$exphomo2	<<- exphomo
		inds$nsites5	<<- nsitesvec
		inds$F2			<<- fvector
		inds$F_chi2_2	<<- fchi2vec
		inds$F_pvalue2	<<- round(fpvec,6)
		}
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	if(!correctmaf)
		{
		tempdf	<- inds[,c("name","pop","miss","obshomo","exphomo","nsites5","F","F_chi2","F_pvalue")]
		colnames(tempdf)<-c("name","pop","miss","obshomo","exphomo","nsites","F","F_chi","pvalue")
		write.table(tempdf,"F_uncorrected.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
		cat("A file with uncorrected inbreeding estimates has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}else{
		tempdf	<- inds[,c("name","pop","miss","obshomo2","exphomo2","nsites5","F","F_chi2","F_pvalue")]
		colnames(tempdf)<-c("name","pop","miss","obshomo","exphomo","nsites","F","F_chi","pvalue")
		write.table(tempdf,"F_corrected.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
		cat("A file with corrected inbreeding estimates has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

plot_indF<-function(export=NULL,addylabel=TRUE,logy=FALSE,plotname="Inbreeding",silent=TRUE,Fcorrect=FALSE)
	{
	indstemp	<- droplevels(inds[inds$filter,])
	npops		<- length(mysambar$populations)
	if(!silent){cat("Opening device...",sep="\n")}
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=800)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		}
	if(!silent){cat("Setting parameters...",sep="\n")}
	par(oma=c(9,7,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	if(!Fcorrect)
		{
		if(!silent){cat("boxplot...",sep="\n")}
		ymin		<- min(indstemp$F,na.rm=TRUE)
		ymin		<- ifelse(ymin<(-1),ymin,-1)
		ymax		<- max(indstemp$F,na.rm=TRUE)
		ymax		<- ifelse(ymax>1,ymax,1)
		boxplot(indstemp$F~indstemp$poporder,border="white",col="white",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=TRUE,ylim=c(ymin,ymax))
		if(!silent){cat("boxplot2...",sep="\n")}
		boxplot(indstemp$F~indstemp$poporder,border=mysambar$colorder,xlab="",ylab="",xaxt='n',yaxt='n',col="grey90",add=TRUE,outline=FALSE)
		if(!silent){cat("stripchart...",sep="\n")}
		indstemp1	<- indstemp[indstemp$F_pvalue<=0.05,]
		indstemp2	<- indstemp[indstemp$F_pvalue>0.05,]
		stripchart(F~poporder,data=indstemp1,vertical=TRUE,method="jitter",pch=16,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		stripchart(F~poporder,data=indstemp2,vertical=TRUE,method="jitter",pch=1,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		#axis(side=1,mysambar$populations,at=seq(1:npops),las=2,cex=1.5)
		}else{
		if(!silent){cat("boxplot...",sep="\n")}
		ymin		<- min(indstemp$F2,na.rm=TRUE)
		ymin		<- ifelse(ymin<(-1),ymin,-1)
		ymax		<- max(indstemp$F2,na.rm=TRUE)
		ymax		<- ifelse(ymax>1,ymax,1)
		boxplot(indstemp$F2~indstemp$poporder,border="white",col="white",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=TRUE,ylim=c(ymin,ymax))
		if(!silent){cat("boxplot2...",sep="\n")}
		boxplot(indstemp$F2~indstemp$poporder,border=mysambar$colorder,xlab="",ylab="",xaxt='n',yaxt='n',col="grey90",add=TRUE,outline=FALSE)
		if(!silent){cat("stripchart...",sep="\n")}
		indstemp1	<- indstemp[indstemp$F_pvalue2<=0.05,]
		indstemp2	<- indstemp[indstemp$F_pvalue2>0.05,]
		stripchart(F2~poporder,data=indstemp1,vertical=TRUE,method="jitter",pch=16,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		stripchart(F2~poporder,data=indstemp2,vertical=TRUE,method="jitter",pch=1,cex=2.5,xlab="",ylab="",col=mysambar$colorder,bg="bisque",add=TRUE)
		#axis(side=1,mysambar$populations,at=seq(1:npops),las=2,cex=1.5)
		}
	legend("topleft",legend=c("p(X^2)<0.05","p(X^2)>0.05"),pch=c(16,1),cex=2,bty='n')
	if(addylabel)
		{	
		mtext(side=2,"Inbreeding coefficient",line=4.5,cex=2.75,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}	

plotscatter_indF<-function(export=NULL,popnames=mysambar$populations,dolabels=FALSE,Fcorrect=FALSE,legendcex=2.5)
	{
	npops	<- length(popnames)
	graphics.off()
	if(!is.null(export))
		{
		plotname	<- ifelse(dolabels,"Inbreeding.scatter.indnr","Inbreeding.scatter")
		correctlabel<- ifelse(Fcorrect,"corrected_maf","not_corrected_maf")
		if(export=="eps"){postscript(paste(plotname,correctlabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,correctlabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,correctlabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,correctlabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	if(!Fcorrect)
		{
		exphomo		<- inds$exphomo
		obshomo		<- inds$obshomo
		exphetero	<- inds$exphetero
		}else{
		exphomo		<- inds$exphomo2
		obshomo		<- inds$obshomo2
		exphetero	<- inds$exphetero2
		}
	mymin	<- min(c(exphomo[inds$filter],obshomo[inds$filter]),na.rm=TRUE)
	mymax	<- max(c(exphomo[inds$filter],obshomo[inds$filter]),na.rm=TRUE)
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(exphomo[inds$filter],obshomo[inds$filter],col="white",xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="Expected homozygous sites",ylab="Observed homozygous sites")
	if(!dolabels)
		{
		lines(c(0.5*mymin,2*mymax),c(0.5*mymin,2*mymax),col="grey")
		points(exphomo[inds$filter],obshomo[inds$filter],col=inds$popcol[inds$filter],pch=16,cex=3)
		}else{
		lines(c(0.5*mymin,2*mymax),c(0.5*mymin,2*mymax),col="grey")
		text(exphomo[inds$filter],obshomo[inds$filter],inds$nr[inds$filter],cex=1.5,col=inds$popcol[inds$filter])
		}
	legend("bottomright",legend=popnames,fill=mysambar$mycolours[1:npops],cex=legendcex,bty='n')
	if(!is.null(export)){dev.off()}
	}

heall_vs_he<-function(export=NULL,showlabels=FALSE,popnames=mysambar$populations,legendcex=2)
	{
	mymax	<- max(c(inds$hetero_all[inds$filter],inds$hetero[inds$filter]),na.rm=TRUE)
	mymin	<- min(c(inds$hetero_all[inds$filter],inds$hetero[inds$filter]),na.rm=TRUE)
	#
	if(!is.null(export))
		{
		plotname		<- "He.all_vs_He.segregating"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(showlabels)
		{
		plot(inds$hetero_all[inds$filter],inds$hetero[inds$filter],pch=16,col="white",pch=16,cex=2.5,xlab="He (all sites)",ylab="He (segregating sites)")
		text(inds$hetero_all[inds$filter],inds$hetero[inds$filter],inds$nr[inds$filter],col=inds$popcol[inds$filter],cex=2.5)
		}else{
		plot(inds$hetero_all[inds$filter],inds$hetero[inds$filter],pch=16,col=inds$popcol[inds$filter],cex=3,xlab="He (all sites)",ylab="He (segregating sites)")
		}
	legend("topleft",legend=popnames,fill=mysambar$mycolours,cex=legendcex,bty='n')
	if(!is.null(export)){dev.off()}
	}

FvsHe<-function(export=NULL,showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=2)
	{
	graphics.off()
	if(Fcorrect)
		{
		myF	<- inds$F2
		}else{
		myF	<- inds$F
		}
	mymax	<- max(myF,na.rm=TRUE)
	mymax	<- ifelse(mymax<1,1,mymax)
	mymin	<- min(myF,na.rm=TRUE)
	mymin	<- ifelse(mymin>-1,-1,mymin)
	#
	myxmax	<- max(inds$hetero[inds$filter],na.rm=TRUE)
	if(!is.null(export))
		{
		plotname		<- ifelse(Fcorrect,"Inbreeding_FcorrectedvsHe","Inbreeding_FvsHe")
		symbollabel		<- ifelse(showlabels,"labels","points")
		if(export=="eps"){postscript(paste(plotname,symbollabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,symbollabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,symbollabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,symbollabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(showlabels)
		{
		plot(inds$hetero[inds$filter],myF[inds$filter],col="white",pch=16,cex=2.5,xlab="He (segregating sites only)",ylab="Inbreeding coefficient",ylim=c(mymin,mymax),xlim=c(0,myxmax),main="F vs He")
		text(inds$hetero[inds$filter],myF[inds$filter],inds$nr[inds$filter],col=inds$popcol[inds$filter],cex=2.5)
		}else{
		plot(inds$hetero[inds$filter],myF[inds$filter],col=inds$popcol[inds$filter],pch=16,cex=2.5,xlab="He (segregating sites only)",ylab="Inbreeding coefficient",ylim=c(mymin,mymax),xlim=c(0,myxmax),main="F vs He")
		}
	legend("topright",legend=popnames,fill=mysambar$mycolours,cex=legendcex,bty='n')
	if(!is.null(export)){dev.off()}
	}

testF<-function()
	{
	# create an inbred individual artificially by crossing an individual with itself:
	indstemp			<- inds
	newindnr			<- nrow(inds)+1
	indstemp[newindnr,]	<- inds[1,]
	indstemp$nr[newindnr]	<- newindnr 
	adultgeno				<- as.vector(as.matrix(mygenlight[1,]))
	#
	# create inbred individual:
	adultgeno[is.na(adultgeno)]	<- 3
	meiosevec			<- sample(c(0,1,1,2),length(adultgeno),replace=TRUE)
	navec				<- rep(NA,length(adultgeno))
	newgeno				<- ifelse(adultgeno==3,navec,ifelse(adultgeno==1,meiosevec,adultgeno))
	#
	# add to genlight:
	mymatrix			<- as.matrix(mygenlight)
	mymatrix			<- rbind(mymatrix,newgeno)
	mygenlight			<<- as.genlight(mymatrix)
	inds				<<- indstemp
	#
	# calculate true inbreeding coefficient (true proportion of autozygosity) and homozygosity:
	# Proportion of homozygous sites for a given individual consists of two components:
	# - sites which are homozygous due to being autozygous (Identical By Descent)
	# - sites which are not autozygous but still homozygous by chance
	# The proportion of IBD sites is estimated by the inbreeding coefficient F.
	# The proportion of sites which are not IBD is therefore 1-F.
	# And therefore, the total proportion of homozygous sites for an individual are given by:
	# Prop_homo = Pr_IBD + (1 - Pr_IBD)*(p2+q2)
	# Prop_homo = F + (1-F)(p2+q2)
	nauto				<<- length(adultgeno[adultgeno==0|adultgeno==2])
	phomo_auto			<<- nauto/length((adultgeno[adultgeno!=3]))		# This is the true inbreeding coefficient F (i.e. proportion of autozygosity). Run calc_indF to compare with estimated F. 
	nhomo_not_auto		<<- length(newgeno[(newgeno==0|newgeno==2)&adultgeno==1])
	phomo_not_auto		<<- nhomo_not_auto/length((adultgeno[adultgeno!=3])) 
	phomo_exp			<<- phomo_auto+phomo_not_auto
	newgeno2			<- newgeno
	newgeno2[is.na(newgeno2)]	<- 3			
	phomo_obs			<<- length(newgeno[newgeno!=1&newgeno!=3])/length(newgeno[newgeno!=3])
	# For one test run I found:
	# True autozygosity (phomo_auto): 0.62
	# Estimated autozygosity (by calc_indF): 0.46
	# So the inbreeding coefficient seems to underestimate 
	}

# 16-4-2020: depreciated:	
plot_indF_old<-function(popnames=mysambar$populations,export=NULL)
	{
	# plot:
	mycolours		<- mycolours[1:npops]
	graphics.off()
	if(!is.null(export)&("vioplot" %in% (.packages())))
		{
		if(export=="eps"){postscript("Inbreeding.pdf",width=npops*2.5,height=7)}	
		if(export=="pdf"){pdf("Inbreeding.pdf",width=npops*2.5,height=7)}
		if(export=="png"){png("Inbreeding.png",width=npops*250,height=720)}
		if(export=="wmf"){win.metafile("Inbreeding.wmf",width=npops*2.5,height=7)}
		}
	par(mar=c(5,7,5,2),cex.axis=2,cex.lab=2.5,cex.main=3,las=1)
	if(allsites)
		{
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(inds$F_all[is.finite(inds$F)&inds$filter]),max(inds$F_all[is.finite(inds$F)&inds$filter])),xaxt="n",xlab="",ylab="")	
		}else{
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(inds$F[is.finite(inds$F)&inds$filter]),max(inds$F[is.finite(inds$F)&inds$filter])),xaxt="n",xlab="",ylab="")	
		}
	for (i in c(1:npops))
		{
		mypop			<- popnames[i]
		if(allsites)
			{
			vioplot(inds$F_all[inds$filter&inds$pop==mypop&is.finite(inds$F_all)&!is.na(inds$F_all)],at=i,add=TRUE,col=mycolours[i])
			}else{
			vioplot(inds$F[inds$filter&inds$pop==mypop&is.finite(inds$F)&!is.na(inds$F)],at=i,add=TRUE,col=mycolours[i])
			}
		}
	axis(side=1,at=seq(1,npops),labels=popnames,lty=1,las=1,cex.axis=1.75)
	mtext("Population",1,line=3,cex=2.25)
	mtext("Inbreeding coefficient",3,line=1.5,cex=2.5)
	mtext("F (1 - Hobs/Hexp)",2,line=4.5,cex=2.5,las=0)
	if(!is.null(export)&("vioplot" %in% (.packages()))){dev.off()}
	# if this function has been executed before, remove columns produced during previous execution:
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

expHe_vs_He<-function(popnames=mysambar$populations,export=NULL,allsites=FALSE,legendcex=2)
	{
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		exportname	<- ifelse(allsites,"expHe_vs_He.allsites","expHe_vs_He.segregatingsites")
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	if(allsites)
		{
		mymaf	<- inds$popmaf_all
		myhetero<- inds$hetero_all
		}else{
		mymaf	<- inds$popmaf
		myhetero<- inds$hetero
		}
	plot(mymaf[inds$filter],myhetero[inds$filter],xlab="Observed sample maf",ylab="Observed sample He",cex=2,ylim=c(0,0.5))
	for (j in c(1:length(popnames)))
		{
		mypop				<- popnames[j]
		points(mymaf[inds$pop==mypop&inds$filter],myhetero[inds$pop==mypop&inds$filter],col=mysambar$mycolours[j],pch=16,cex=2)
		points(mymaf[inds$pop==mypop&!inds$filter],myhetero[inds$pop==mypop&!inds$filter],col=mysambar$mycolours[j],cex=2)
		}
	# add line showing expected values:
	temp	<- seq(0,1,0.01)
	temp2	<- 2*temp*(1-temp)
	lines(temp,temp2,col="black",lwd=2)
	# add legend:
	legend("topleft",legend=popnames,bty='n',fill=mysambar$mycolours,cex=legendcex)
	if(!is.null(export)){dev.off()}
	}

missingness_perpop<-function(export=NULL,addylabel=TRUE,logy=FALSE)
	{
	npops		<- length(mysambar$populations)
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		mylabel	<- ifelse(addylabel,ifelse(logy,"perpop.log","perpop"),ifelse(logy,"perpop.log.no_ylabel","perpop.no_ylabel"))
		if(export=="eps"){postscript(paste("Missingdata",mylabel,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste("Missingdata",mylabel,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste("Missingdata",mylabel,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste("Missingdata",mylabel,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=8)}
		}
	par(oma=c(9,8,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	mylog	<- ifelse(logy,"y","")
	y_lim	<- c(min(inds$miss,na.rm=TRUE),1.025*max(inds$miss,na.rm=TRUE))
	boxplot(inds$miss~inds$poporder,border=mysambar$colorder2,log=mylog,col="grey90",las=2,xlab="",ylab="",cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim)
	stripchart(miss~poporder,data=inds,vertical=TRUE,method="jitter",pch=16,cex=3,col=mysambar$colorder2,bg="bisque",add=TRUE)
	if(addylabel)
		{	
		#mtext(side=2,"Proportion missing data",line=3.75,cex=2)
		yline	<- ifelse(logy,5.5,4)
		mtext(side=2,"Proportion missing data",line=yline,cex=2.75,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

popboxplot<-function(export=NULL,exportname="popboxplot",ylabel=NULL,logy=FALSE,myscore=NULL,popvector=NULL,addstripchart=TRUE,y_lim=NULL,yline=NULL,mycex=2,labcex=2.5,plottitle=NULL,y_line=5.5,mywidth=0.5,myheight=9,x_axt="s")
	{
	if(is.null(myscore))
		{
		return(cat("ERROR: Please define (existing) input values to the myscore flag.",sep="\n"))
		}
	if(is.null(popvector))
		{
		return(cat("ERROR: Please specify (existing) population vector.",sep="\n"))
		}
	if(length(myscore)!=length(popvector))
		{
		return(cat("ERROR: Lengths of myscore vector and popvector do not correspond.",sep="\n"))
		}
	npops		<- length(mysambar$populations)
	npops2		<- length(unique(popvector))
	if(npops2!=npops)
		{
		return(cat(paste("ERROR: found more populations in popvector (",npops2,") than expected based on length of mysambar$populations (",npops,"). Perhaps run the excludepop() function?.",sep=""),sep="\n"))
		}
	popvector2		<- factor(popvector,levels=mysambar$poporder)
	if(!is.null(export))
		{
		mywidth2	<- mywidth*100
		myheight2	<- myheight*100
		mylabel		<- ifelse(!is.null(ylabel),ifelse(logy,"perpop.log","perpop"),ifelse(logy,"perpop.log.no_ylabel","perpop.no_ylabel"))
		if(export=="eps"){postscript(paste(exportname,mylabel,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=myheight)}
		if(export=="pdf"){pdf(paste(exportname,mylabel,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=myheight)}
		if(export=="png"){png(paste(exportname,mylabel,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(exportname,mylabel,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=myheight)}
		}
	par(oma=c(11,8,2,1),mar=c(8,0.5,0.5,0.5),cex.axis=labcex,cex.lab=labcex)
	mylog	<- ifelse(logy,"y","")
	if(is.null(y_lim))
		{
		y_lim	<- c(min(myscore,na.rm=TRUE),1.025*max(myscore,na.rm=TRUE))
		}
	if(addstripchart)
		{
		boxplot(myscore~popvector2,border=mysambar$colorder,log=mylog,col="grey90",las=2,xlab="",ylab="",pch=16,outline=FALSE,ylim=y_lim,xaxt=x_axt)
		stripchart(myscore~popvector2,data=inds,vertical=TRUE,method="jitter",pch=16,cex=mycex,col=mysambar$colorder,bg="bisque",add=TRUE)
		}else{
		boxplot(myscore~popvector2,border=mysambar$colorder,log=mylog,col="grey90",las=2,xlab="",ylab="",pch=16,outline=TRUE,ylim=y_lim)
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,line=0.1,cex=1.75,outer=TRUE,las=0)
		}
	if(!is.null(ylabel))
		{	
		#yline	<- ifelse(logy,5.5,5)
		mtext(side=2,ylabel,line=y_line,cex=3.25,outer=TRUE,las=0)
		}
	if(!is.null(yline))
		{
		#cat("Adding abline...",sep="\n")
		abline(h=yline,lty=2,lwd=1)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}


groupplot<-function(export=NULL,plotlabel="poptype",ylabel=NULL,indscore=NULL,groupvector=NULL,grouplevels=NULL,indfilter=NULL,yrange=NULL)
	{
	if(is.null(indscore)|is.null(groupvector)|is.null(grouplevels)|is.null(indfilter))
		{
		return(cat("ERROR: Please define input values to the flags indscore, groupvector, grouplevels, and indfilter.",sep="\n"))
		}
	if(!groupvector%in%colnames(inds))
		{
		return(cat("ERROR: groupvector column name not present in inds dataframe.",sep="\n"))
		}
	if(!indscore%in%colnames(inds))
		{
		return(cat("ERROR: indscore column name not present in inds dataframe.",sep="\n"))
		}
	indstemp				<- droplevels(inds[indfilter,c("pop","popcol",indscore,groupvector)])
	colnames(indstemp)		<- c("pop","popcol","indscore","group")
	indstemp$groupfactor	<- factor(as.character(indstemp$group),levels=grouplevels) 
	#
	ngroups					<- length(grouplevels)
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		plotname		<- "Group_boxplot"
		if(export=="eps"){postscript(paste(plotname,plotlabel,"eps",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,plotlabel,"pdf",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,plotlabel,"png",sep="."),family=mysambar$myfont,width=ngroups*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,plotlabel,"wmf",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		}
	par(oma=c(9,8,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	if(is.null(yrange))
		{
		yrange		<- c(min(indstemp$indscore,na.rm=TRUE),max(indstemp$indscore,na.rm=TRUE))
		}
	boxplot(indstemp$indscore~indstemp$groupfactor,las=2,border="grey50",outline=FALSE,ylim=yrange,col="grey90",xlab="",ylab="",cex.axis=2.5,pch=16)
	for(i in c(1:length(mysambar$populations)))
		{
		mypop		<- mysambar$populations[i]
		mycolour	<- mysambar$mycolours[i] 
		indstemp2	<- indstemp[as.character(indstemp$pop)==mypop,]
		stripchart(indscore~groupfactor,data=indstemp2,vertical=TRUE,method="jitter",pch=16,cex=3,xlab="",ylab="",col=mycolour,bg="bisque",add=TRUE)
		}
	if(!is.null(ylabel))
		{	
		mtext(side=2,ylabel,line=5.5,cex=3,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

grouppopboxplot<-function(export=NULL,plotlabel="poppairs",addyaxis=TRUE,ylabel=NULL,yscore=NULL,groupvector=NULL,grouplevels=NULL,popfilter=NULL,symbolcex=2.5,mycol="grey25",mybg="orangered2",yrange=NULL,mylas=2,mywidth=0.75,axiscex=2.75,plottitle=NULL,myline=5.5)
	{
	if(is.null(yscore)|is.null(groupvector)|is.null(grouplevels)|is.null(popfilter))
		{
		return(cat("ERROR: Please define input values to the flags yscore, groupvector, grouplevels, and popfilter.",sep="\n"))
		}
	if(!groupvector%in%colnames(pops2))
		{
		return(cat("ERROR: groupvector column name not present in inds dataframe.",sep="\n"))
		}
	if(!yscore%in%colnames(pops2))
		{
		return(cat("ERROR: yscore column name not present in inds dataframe.",sep="\n"))
		}
	popstemp				<- droplevels(pops2[popfilter,c(yscore,groupvector)])
	colnames(popstemp)		<- c("yscore","group")
	popstemp$groupfactor	<- factor(as.character(popstemp$group),levels=grouplevels) 
	#
	ngroups					<- length(grouplevels)
	if(!is.null(export))
		{
		mywidth2		<- mywidth*100
		plotname		<- "Group_popboxplot"
		if(export=="eps"){postscript(paste(plotname,plotlabel,"eps",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,plotlabel,"pdf",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,plotlabel,"png",sep="."),family=mysambar$myfont,width=ngroups*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,plotlabel,"wmf",sep="."),family=mysambar$myfont,width=ngroups*mywidth+2,height=8)}
		}
	par(oma=c(9,8,2,1),mar=c(5,0.5,0.5,0.5),cex.axis=axiscex)
	if(is.null(yrange))
		{
		yrange		<- c(min(popstemp$yscore,na.rm=TRUE),max(popstemp$yscore,na.rm=TRUE))
		}
	myyaxt			<- ifelse(addyaxis,"s","n")
	boxplot(popstemp$yscore~popstemp$groupfactor,las=mylas,border="grey50",outline=FALSE,ylim=yrange,col="grey90",xlab="",ylab="",cex.axis=axiscex-0.5,pch=16,yaxt=myyaxt)
	stripchart(yscore~groupfactor,data=popstemp,vertical=TRUE,method="jitter",pch=21,cex=symbolcex,xlab="",ylab="",col=mycol,bg=mybg,add=TRUE)
	if(!is.null(ylabel))
		{	
		mtext(side=2,ylabel,line=myline,cex=axiscex-0.25,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,cex=axiscex-0.25,line=0.25)
		}
	if(!is.null(export)){dev.off()}
	}
	
indheboxplot<-function(export=NULL,plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="He-sites in SNP data",yline=4.5)
	{
	indstemp			<- droplevels(inds[inds$filter,c("poporder",heteroscore)])
	colnames(indstemp)	<- c("poporder","heteroscore")
	#indstemp$pop2		<- as.character(indstemp$pop)
	npops				<- length(mysambar$populations)
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=npops*mywidth+2,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=npops*mywidth2+200,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=npops*mywidth+2,height=8)}
		}
	par(oma=c(9,7,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	boxplot(indstemp$heteroscore~indstemp$poporder,border=mysambar$colorder,col="grey90",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=FALSE,ylim=c(0,max(indstemp$heteroscore,na.rm=TRUE)))
	stripchart(heteroscore~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2.5,col=mysambar$colorder,bg="bisque",add=TRUE)
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	#mtext(side=1,"Sample",line=6.5,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

thindata<-function(mindistance=500)
	{
	for (i in (1:nrow(snps)))
		{
		snps$distfilter[i]	<<- ifelse(snps$dist[i]>=mindistance,TRUE,FALSE) 
		}
	snps$distfilter			<<- ifelse(is.na(distfilter),FALSE,distfilter)
	}	

stacks_demultiplex<-function(plotretained=TRUE,QC=FALSE)
	{
	x		<- read.table("I:/PhD/Reindeer/Processradtagsoutput_nosums.txt",header=TRUE)
	x$Pool2	<- gsub("Pool","",x$Pool)
	mylanes	<- as.vector(unique(x$Sequencing_Lane))
	x$Sequencing_Lane2	<- NA
	for(j in c(1:length(mylanes)))
		{
		mylane		<- mylanes[j]
		x$Sequencing_Lane2[x$Sequencing_Lane==mylane]<-j
		}
	x$Pool3<-paste(x$Sequencing_Lane2,x$Pool2,sep=".")
	# retained reads:
	if(plotretained)
		{
		if(QC)
			{
			pdf("Retainedreads.QC.pdf",width=12,height=12)
			par(mfrow=c(2,2),oma=c(0,2,0,1))
			boxplot((x$LowQuality/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion low quality reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot((x$NoRadTag/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion reads with no barcode",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(((x$Unpaired_forward+x$Unpaired_reverse)/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion reads with no barcode",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(((x$Read_pairs*2)/x$Total_Reads)~(x$Pool2+x$Sequencing_Lane2),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion retained reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			dev.off()
			}else{
			pdf("Retainedreads.overall2.pdf",width=12,height=6)
			par(mfrow=c(1,2),oma=c(0,2,0,0))
			boxplot(((x$Read_pairs*2)/x$Total_Reads)~(x$Pool3),ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Proportion retained reads",side=2,line=4,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			boxplot(x$Read_pairs/1000000~x$Pool3,ylab="",xlab="",col="grey80",cex.axis=1.5,cex.lab=2,las=2)
			mtext("Retained read pairs (x 1M)",side=2,line=2.5,cex=2)	
			mtext("Sequencing pool",side=1,line=3.5,cex=2)
			dev.off()
			}
		}
	# Read depth per locus vs total read depth:
	y				<- x[order(x$ID),]
	inds$pool		<- y$Pool3
	inds$nreadpairs	<- y$Read_pairs
	pdf("Mean.vs.total.readdepth.pdf",height=6,width=12)
	par(mfrow=c(1,2),oma=c(0,2,0,0))
	plot(inds$nreadpairs/1000000,inds$meandepth,ylab="",xlab="",pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(inds$nreadpairs[!inds$filter]/1000000,inds$meandepth[!inds$filter],pch=16,col="red")
	mtext("Mean read depth",side=2,line=3,cex=2)	
	mtext("Number of read pairs (x 1M)",side=1,line=3,cex=2)
	plot(inds$meandepth,inds$miss,ylab="",xlab="",pch=16,cex.axis=1.5,cex.lab=2,las=1)
	points(inds$meandepth[!inds$filter],inds$miss[!inds$filter],pch=16,col="red")
	mtext("Proportion missing data",side=2,line=3,cex=2)	
	mtext("Mean read depth",side=1,line=3,cex=2)
	dev.off()
	}


plotn2<-function(export=NULL)
	{
	if(!is.null(export))
		{
		plotname	<- "Genocounts_n2meta_vs_n2pop"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	mylim	<- c(0,max(c(inds$n2_meta,inds$n2_pop)))
	plot(inds$n2_meta,inds$n2_pop,col=inds$popcol,pch=16,cex=2.5,xlab="relative to metapopulation",ylab="relative to subpopulation",ylim=mylim,xlim=mylim,main="# minor homozygous genotypes")
	lines(c(0,1000000),c(0,1000000),lty=2)
	legend("topright",legend=mysambar$populations2,bty='n',fill=mysambar$mycolours2,cex=2)
	if(!is.null(export)){dev.off()}
	}

plotgenocounts<-function(popnames=mysambar$populations,export=FALSE,myout=NULL,addlabels=TRUE,make_global=FALSE)
	{
	npops			<- length(popnames)
	if(is.null(myout))
		{
		myout			<- matrix(NA,ncol=4,nrow=npops)
		rownames(myout)	<- popnames
		for (j in c(1:npops))
			{
			mypop		<- popnames[j]
			# cat(mypop,sep="\n")
			mymaf		<- snps[,paste("maf",mypop,sep="_")]
			mymaf[is.na(mymaf)]	<- 0
			mymat		<- as.matrix(mygenlight[inds$filter&inds$pop==mypop,mymaf>0&snps$filter,])
			n0			<- length(mymat[mymat==0&!is.na(mymat)])
			n1			<- length(mymat[mymat==1&!is.na(mymat)])
			n2			<- length(mymat[mymat==2&!is.na(mymat)])
			nall		<- length(mymat[!is.na(mymat)])
			myout[j,1]	<- n0/nall
			myout[j,2]	<- n1/nall
			myout[j,3]	<- n2/nall
			myout[j,4]	<- (n1+2*n2)/(2*nall)
			}
		myout			<- as.data.frame(myout)
		colnames(myout)	<- c("n0","n1","n2","maf") 
		myout$prop		<- myout$n2/myout$n1
		}else{
		myout	<- myout
		}
	# plot:
	myout2			<- t(myout[,c(1:3)])
	if(make_global)
		{
		myout			<<- myout
		myout2			<<- myout2
		}
	npops			<- length(popnames)
	if(npops>1)
		{
		x			<- matrix(0,ncol=npops,nrow=npops*3)
		for(j in c(1:npops))
			{
			mydata	<- myout2[,j]
			x[(j*3-2):(j*3),j]	<- mydata
			}
		}else{
		x			<- myout2
		}
	mycolours		<- mysambar$mycolours[1:npops]
	mycols			<- vector()
	for(j in c(1:npops))
		{
		mycol	<- mycolours[j]
		colfunc <- colorRampPalette(c("grey",mycol))
		mycol2	<- colfunc(3)
		mycols	<- c(mycols,mycol2)
		}
	if(export)
		{
		if(addlabels)
			{
			pdf("Genocounts.withlabels.pdf")
			}else{
			pdf("Genocounts.pdf")
			}
		}
	testx		<<- x
	par(mar=c(4,10,2.5,2.5))
	xx<-barplot(x,col=mycols,border=NA,space=0.1,horiz=TRUE,names.arg=popnames,las=1,cex.names=1.5)
	if(addlabels)
		{
		for(j in c(1:npops))
			{
			poppoints	<- x[,j]
			poppoints	<- poppoints[poppoints!=0]
			poppoints	<- cumsum(poppoints)
			barmid		<- xx[j]
			text(poppoints,barmid,labels = c(0,1,2),adj=1,cex=1.5)
			}
		mtext("Genotype proportions",side=3,line=0.5,cex=2)
		mtext("0: homozygous major; 1: heterozygous; 2: homozygous minor",side=3,line=-0.75,cex=1)
		}
	if(export){dev.off()}
	}

plotgenocounts_inds<-function(export=FALSE,addlabels=TRUE,make_global=FALSE,metapop=TRUE)
	{
	indstemp		<- inds[inds$filter,]
	indstemp		<- indstemp[order(indstemp$pop),]
	if(metapop)
		{
		myout			<- indstemp[indstemp$filter,c("n0_meta","n1_meta","n2_meta")]
		}else{
		myout			<- indstemp[indstemp$filter,c("n0_pop","n1_pop","n2_pop")]
		}
	myout			<- myout/(indstemp$nsites2)
	myout2			<- t(myout)
	if(make_global)
		{
		myout			<<- myout
		myout2			<<- myout2
		}
	ninds			<- nrow(myout)
	#indnames		<- indstemp$nr[indstemp$filter]
	indnames		<- indstemp$name[indstemp$filter]
	if(ninds>1)
		{
		x			<- matrix(0,ncol=ninds,nrow=ninds*3)
		for(j in c(1:ninds))
			{
			mydata	<- myout2[,j]
			x[(j*3-2):(j*3),j]	<- mydata
			}
		}else{
		x			<- myout2
		}
	mycolours		<- indstemp$popcol
	mycols			<- vector()
	for(j in c(1:ninds))
		{
		mycol	<- mycolours[j]
		colfunc <- colorRampPalette(c("grey",mycol))
		mycol2	<- colfunc(3)
		mycols	<- c(mycols,mycol2)
		}
	# plot:
	if(export)
		{
		plotlabel1	<- ifelse(addlabels,"withlabels","nolabels")
		plotlabel2	<- ifelse(metapop,"metapop","subpop")
		pdf(paste("Genocounts_inds",plotlabel1,plotlabel2,"pdf",sep="."),height=ninds*0.25,width=15)
		}
	par(mar=c(4,10,2.5,2.5))
	xx<-barplot(x,col=mycols,border=NA,space=0.1,horiz=TRUE,names.arg=indnames,las=1,cex.names=0.75)
	if(addlabels)
		{
		for(j in c(1:ninds))
			{
			poppoints	<- x[,j]
			poppoints	<- poppoints[poppoints!=0]
			poppoints	<- cumsum(poppoints)
			barmid		<- xx[j]
			text(poppoints,barmid,labels = c(0,1,2),adj=1,cex=1.5)
			}
		mtext("Genotype proportions",side=3,line=-0.5,cex=3.5)
		mtext("0: homozygous major; 1: heterozygous; 2: homozygous minor",side=3,line=-3,cex=2.5)
		}
	if(export){dev.off()}
	}

plotmapping<-function(export=FALSE,input1="alignmentscores.reinasref.txt",input2="alignmentscores.cowasref.txt",myrefs=c("reindeer","cow"),plotcols=c("grey","black"))
	{
	if(export){pdf("Mapping_scores.pdf")}
	x<-read.table(input1)
	colnames(x)	<- c("sample","mapped","concordant")
	y<-read.table(input2)
	colnames(y)	<- c("sample","mapped","concordant")
	plot(inds$nreadpairs/1000000,x$mapped,las=1,pch=16,xlab="",ylab="",col=plotcols[1])
	mtext("Mapped reads (%)",side=2,line=2.5,cex=2)	
	mtext("Number of read pairs (x 1M)",side=1,line=3,cex=2)
	points(inds$nreadpairs/1000000,x$concordant,col=plotcols[1])
	points(inds$nreadpairs/1000000,y$mapped,pch=16,col=plotcols[2])
	points(inds$nreadpairs/1000000,y$concordant,col=plotcols[2])
	legend("bottomright",fill=plotcols,legend=myrefs,bty='n',cex=1.5)
	if(export){dev.off()}
	mymeans	<<- c(mean(x$mapped), mean(x$concordant), mean(y$mapped), mean(y$concordant))
	mysd	<<- c(sd(x$mapped), sd(x$concordant), sd(y$mapped), sd(y$concordant))
	# The inputfiles were generated on Linux using the commands:
	# cat ./*mapped.txt > allsamples.reinasref.mappedcounts.txt
	# cat ./*paired.txt > allsamples.reinasref.pairedcounts.txt
	# ls -1 ./*verysensitive.bam > samfiles.txt
	# sed -i 's/bam/sam/g' samfiles.txt 
	# sed 's/.reinasref.verysensitive.sam//g' samfiles.txt > mysamples.txt
	# sed -i 's/\.\///g' mysamples.txt
	# paste mysamples.txt allsamples.reinasref.mappedcounts.txt allsamples.reinasref.pairedcounts.txt > allsamples.alignmentscores.txt
	# cat ./*mapped.txt > allsamples.cowgenome.mappedcounts.txt
	# cat ./*paired.txt > allsamples.cowgenome.pairedcounts.txt
	# ls -1 ./*verysensitive.bam > samfiles.txt
	# sed -i 's/bam/sam/g' samfiles.txt 
	# sed 's/.cowgenome.verysensitive.sam//g' samfiles.txt > mysamples.txt
	# sed -i 's/\.\///g' mysamples.txt
	# paste mysamples.txt allsamples.cowgenome.mappedcounts.txt allsamples.cowgenome.pairedcounts.txt > allsamples.alignmentscores.txt
	}
	
# End of data preparation	
############################################################################################################	









############################################################################################################
# Population structure analyses

# 22-0-2024: still to be implemented:
# Rphylip: Rcontml
# Felsenstein, J. (1981) Maximum likelihood estimation of evolutionary trees from continuous characters. American Journal of Human Genetics, 25, 471-492.

# This function executes all population structure analyses at once:
findstructure<-function(quickrun=TRUE,add_legend=TRUE,my_bg="white",axis_col="black",legend_pos="bottomright",legend_cex=3,my_legend=mysambar$poporder,my_legendcol=mysambar$colorder,Kmin=2,Kmax=6,pop_order=mysambar$poporder,short_pop=NULL,print_name=inds$name,do_nei=TRUE,plot_nei=TRUE,do_maps=FALSE,do_tree=TRUE,dogenindtrees=FALSE,do_MPtree=TRUE,do_MLtree=FALSE,do_pathlength=FALSE,do_perpop=FALSE,do_pi=TRUE,do_dapc=FALSE,dapc_ellipse=FALSE,dapc_ellipse_level=0.5,do_subsets=FALSE,doBAPT=TRUE,do_indca=TRUE,do_popca=TRUE,do_pca=TRUE,do_mds=TRUE,onlyLEA=FALSE,max_node_label=80,symbol_size=3,colour_vector=NULL,silent=TRUE,do_tess=FALSE,do_phylonetwork=FALSE,do_network=FALSE,do_continue=FALSE,axis_1=1,axis_2=2,domirroraxis=c(FALSE,FALSE),LEAperpop=FALSE,LEAheightfactor=0.75,LEAwidthfactor=0.1,LEAaxiscex=1.5,LEAlabelcex=1.75,LEAyaxiscex=1.25,LEAylabel=NULL,shortpop_nr_chars=3,do_dc=TRUE,marine_dataset=FALSE,dapc_heatmap=TRUE)
	{
	# edit 19-06-2022:
	if(do_tess|do_network|marine_dataset)	
		{
		cat("ERROR: as of SambaR version 1.08, geographic maps are no longer created as part of the findstructure function, but instead by the new wrapper function 'createmaps()'.",sep="\n")
		return(cat("Run the findstructure function with the flags 'dotess', 'do_network' and 'marine_dataset' set to FALSE.",sep="\n"))	
		}
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		# This would lead to error message: Error in 1:nLoc(x) : NA/NaN argument.
		# a quick and dirty way of working around this would be to type:
		# inds$filter[is.na(inds$filter)]	<- FALSE
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	my_packages	<- c("adegenet","ape","poppr","LEA","StAMPP")
	for (i in c(1:length(my_packages)))
		{
		my_package	<- my_packages[i]
		if(my_package %in% (.packages()) == FALSE)
			{
			if(do_continue)
				{
				cat(paste("WARNING: essential package ",my_package," not installed or loaded. Continuing anyway, to see how far we get before running into an error.",sep=""),sep="\n")
				}else{
				return(cat(paste("ERROR: essential package ",my_package," not installed or loaded. Please rerun the getpackages function or try to install/load this package yourself. Alternatively run findstructure(do_continue=TRUE) to see how far you can get before running into an error.",sep=""),sep="\n"))
				}
			}
		}
	nsnps	<- nrow(snps[snps$filter,])
	if(nsnps<500)
		{
		if(do_continue)
			{
			cat(paste("WARNING: only ",nsnps," SNPs retained after filtering. This might give low resolution, or even lead to errors when running pcoa analyses. Continue anyway...",sep=""),sep="\n")
			}else{
			return(cat(paste("WARNING: only ",nsnps," SNPs retained after filtering. This might give low resolution, or even lead to errors when running pcoa analyses. Consider using less strict filter settings. Alternatively run findstructure(do_continue=TRUE) to continue anyway.",sep=""),sep="\n"))
			}	
		}
	#
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	popnames	<- mysambar$populations
	# 26-01-2023: removing following lines, as reordering should be done with reorderpop function
	# pop_order should be a vector with all population names.
	#if(!is.null(pop_order))
	#	{
	#	cat("Redefining order of populations as specified by pop_order flag.",sep="\n") 
	#	cat("Expected population names:",sep="\n")
	#	cat(popnames,sep=", ")
	#	cat("",sep="\n")
	#	if(length(pop_order)!=length(popnames))
	#		{
	#		return(cat("ERROR: vector input to pop_order argument is not the same length as vector input to popnames argument.",sep="\n"))
	#		}
	#	if(length(pop_order)!=length(popnames))
	#		{
	#		return(cat("ERROR: vector input to pop_order argument is not the same length as vector input to popnames argument.",sep="\n"))
	#		}
	#	if(any(!pop_order%in%popnames))
	#		{
	#		return(cat("ERROR: One or more population names listed in pop_order vector are not present in popnames argument.",sep="\n"))
	#		}
	#	if(any(!popnames%in%pop_order))
	#		{
	#		return(cat("ERROR: One or more population names listed in popnames vector are not present in pop_order argument.",sep="\n"))
	#		}
	#	npops			<- length(pop_order)
	#	my_order		<- vector()
	#	inds$poporder	<- NA
	#	for (k in c(1:npops))
	#		{
	#		my_pop			<- pop_order[k]
	#		my_order[k]		<- which(popnames==my_pop)
	#		inds$poporder[inds$pop==my_pop]	<<- k  
	#		}
	#if(is.null(my_legend))
	#	{
	#	cat("Redefining colour order used for legends of pcoa and pca plots...",sep="\n")
	#	my_legend		<- pop_order
	#	my_legendcol	<- rep(NA,length(pop_order))
	#	for(k in c(1:length(my_legend)))
	#		{
	#		mypop			<- as.character(my_legend[k])
	#		my_legendcol[k]	<- mysambar$mycolours2[mysambar$populations2==mypop]
	#		}
	#	}
	# legend_pos can be either topleft, top, topright, left, center, right, bottomleft, bottom, or bottomright
	setwd(mysambar$structuredir)
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	cat("If you receive the error 'Error in file(file, ifelse(append,'a','w')): cannot open the connection', this might be because a txt.file with dc-scores is open in a file viewer.",sep="\n")
	cat("Close this file, or else run the findstructure function with the flag do_dc set to FALSE.",sep="\n")
	#
	# do analyses:
	if(do_phylonetwork)
		{
		# 17-10-2022: experimental:
		# FOR INDIVIDUALS, ALLELE SHARING:
		calcpi(pi_per_pop=FALSE)
		pidf		<- mysambar$pidf_metalist[[1]]
		mymat		<- df2mat(mydf=pidf,myinds=inds$nr[inds$filter],indnames=inds$name[inds$filter],mypops=inds$pop[inds$filter],myscore="ASD",doheatmap=TRUE,twosided=FALSE,above_diagonal=TRUE,exportprefix="Rawdistance_matrix.ind",plot_title="Raw genetic distance (%)")
		# run analyses:
		neighbournetwork(mydistmat=mymat,do_analysis=TRUE,plotname="Phylonetwork_neighbornet_pi",mylwd=0.5,doexport=FALSE,mynetwork=NULL,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1,addlegend=TRUE,legendpos="bottomright",legendcex=1.25)
		# export:
		neighbournetwork(mydistmat=mymat,do_analysis=FALSE,plotname="Phylonetwork_neighbornet_pi",mylwd=0.5,doexport=TRUE,mynetwork=mysambar$phylonetwork,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1,addlegend=TRUE,legendpos="bottomright",legendcex=1.25)
		#
		# FOR INDIVIDUALS, NEI:
		# create matrix:
		ind_neimatrix()
		# run analyses:
		neighbournetwork(mydistmat=mysambar$indneimatrix,do_analysis=TRUE,plotname="Phylonetwork_neighbornet_nei",mylwd=0.5,doexport=FALSE,mynetwork=NULL,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1,addlegend=TRUE,legendpos="bottomright",legendcex=1.25)
		# plot:
		neighbournetwork(mydistmat=mysambar$indneimatrix,do_analysis=FALSE,plotname="Phylonetwork_neighbornet_nei",mylwd=0.5,doexport=TRUE,mynetwork=mysambar$phylonetwork,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1,addlegend=TRUE,legendpos="bottomright",legendcex=1.25)
		#
		# FOR POPULATIONS, NEI:
		pop_neimatrix(export="pdf")
		popnetwork(mydistmat=mymat,do_analysis=TRUE,plotname="Phylonetwork_neighbornet_pop_nei",mylwd=0.5,doexport=TRUE,mynetwork=NULL,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1.5,addlegend=TRUE,legendpos="bottomright",legendcex=1.25)
		}
	if(!onlyLEA)
		{
		if(quickrun)
			{
			cat("Creating matrix with Nei's genetic distance for pairwise individual comparisons...",sep="\n")
			cat("Calculating Nei's genetic distance...",sep="\n")
			ind_neimatrix()
			if(plot_nei)
				{
				cat("Plotting matrix with Nei's genetic distances. In case you run into an error, set the flag 'plot_nei' to FALSE.",sep="\n")
				plotindmatrix(n_bins=6,export="pdf",add_lab=FALSE,ind_matrix=mysambar$indneimatrix,export_name="Neimatrix.ind",plottitle="Nei's genetic distance (D)")
				}
			cat("Creating pcoa plot with various genetic distances...",sep="\n")
			if(!silent){cat("Nei's genetic distance...",sep="\n")}
			mysambar$p	<<- ape_pcoa(return_object=TRUE,labels=FALSE,method="nei",mybg=my_bg,axiscol=axis_col,export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
			if(!silent){cat("Plotting loadings...",sep="\n")}
			plotloadings(exporttype="pdf",myloadings=mysambar$p$vectors,myperc=mysambar$pcoaperc,plotname="PCoA_nei")
			if(!silent){cat("Euclidean distance...",sep="\n")}
			mysambar$p	<<- ape_pcoa(return_object=TRUE,labels=FALSE,method="euclidean",mybg=my_bg,axiscol=axis_col,export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
			if(!silent){cat("Plotting loadings...",sep="\n")}
			plotloadings(exporttype="pdf",myloadings=mysambar$p$vectors,myperc=mysambar$pcoaperc,plotname="PCoA_euclidean")
			if(!silent){cat("Allele sharing distance...",sep="\n")}
			mysambar$p	<<- ape_pcoa(return_object=TRUE,labels=FALSE,method="pi",mybg=my_bg,axiscol=axis_col,export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
			if(!silent){cat("Plotting loadings...",sep="\n")}
			plotloadings(exporttype="pdf",myloadings=mysambar$p$vectors,myperc=mysambar$pcoaperc,plotname="PCoA_pi")
			if(!silent){cat("Allele sharing distance  (labels)...",sep="\n")}
			ape_pcoa(labels=TRUE,printname=print_name,method="pi",mybg=my_bg,axiscol=axis_col,export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
			multiplot_pcoa_axes(exporttype="pdf",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			multiplot_pcoa_axes(exporttype="pdf",mymethod="pi",dolabels=TRUE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			multiplot_pcoa_axes(exporttype="pdf",mymethod="pi",dolabels=TRUE,print_miss=TRUE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			if("SNPRelate"%in%(.packages())&do_pca)
				{
				cat("Creating pca plot using snprelate...",sep="\n")
				cat("If you receive an error shortly after this line, rerun the findstructure function with the flag do_pca set to FALSE.",sep="\n")
				snprelate_pca(export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
				snprelate_pca(export="pdf",axis1=axis_1,axis2=axis_2,labels=TRUE,printname=print_name,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
				file.remove("my.gds")
				}else{
				cat("Package 'SNPrelate' not installed and/or loaded. Not creating snprelate-based PCA plots.",sep="\n")
				}
			#
			cat("Creating matrix with Nei's genetic distance for pairwise population comparisons...",sep="\n")
			pop_neimatrix(export="pdf")
			if(length(mysambar$populations)>3)
				{
				cat("Hierarchical structuring of populations based on Nei's genetic distance (i.e. using NJ function of phangorn package)...",sep="\n")
				getpoptree(exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
				poppcoa(pscores=NULL,popmat=mysambar$popneimatrix,method="nei",export="pdf")
				poppcoa(pscores=NULL,popmat=mysambar$popneimatrix,method="nei",export="png")
				}
			#	
			if(do_tree)
				{
				# Euclidean distance:
				cat("Hierarchical structuring of individuals based on Euclidean genetic distance (i.e. using bitwise.dist function of poppr package)...",sep="\n")
				cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'do_tree' flag set to false (i.e. findstructure(do_tree=FALSE)).",sep="\n")
				getindtree(export="pdf",do_analysis=TRUE,nbootstrap=0,mymethod="NJ",mydistance="euclidean",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				getindtree(export="pdf",do_analysis=TRUE,nbootstrap=0,mymethod="bionj",mydistance="euclidean",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				getindtree(export="pdf",do_analysis=TRUE,nbootstrap=0,mymethod="bionj",mydistance="euclidean",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=FALSE,tiplabels=FALSE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength,tipdots=TRUE,legendpos="topleft")
				getindtree(export="pdf",do_analysis=TRUE,nbootstrap=0,mymethod="OLS",mydistance="euclidean",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				#				
				# Allele sharing distance (note: ASD not the same as sequence dissimilarity calculated by SambaR's calcpi function (?)):
				# getindtree(export="pdf",do_analysis=TRUE,mymethod="bioNJ",mydistance="ASD",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				# getindtree(export="pdf",do_analysis=TRUE,mymethod="bionj",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=FALSE,calc_parsimony=FALSE,calc_likelihood=FALSE,silent=FALSE,legendpos="topleft")
				#
				# sequence dissimilarity (generated with SambaR's calcpi function):
				cat("Hierarchical structuring of individuals based on sequence dissimilarity score (i.e. using calcpi function of SambaR package)...",sep="\n")
				getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				getindtree(export="pdf",do_analysis=TRUE,mymethod="bionj",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				getindtree(export="pdf",do_analysis=TRUE,mymethod="OLS",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards",dopathlength=do_pathlength)
				pi_OLS_tree		<- mysambar$mytree
				#
				plotindmatrix(n_bins=6,export="pdf",add_lab=FALSE,ind_matrix=mysambar$pimatrix,export_name="Pimatrix.ind",plottitle="Sequence dissimilarity (pi)")
				plotindmatrix(n_bins=8,export="pdf",add_lab=FALSE,ind_matrix=mysambar$pimatrix,export_name="Pimatrix.ind",plottitle="Sequence dissimilarity (pi)")
				#
				#if("ndiffpersite"%in%colnames(pops2))
				#	{
				#	poppimatrix	<- pops2matrix(myscore="ndiffpersite",dofilter=TRUE,plot_label="Pimatrix.pop")
				#	getpoptree(exportlabel="pi",mymatrix=poppimatrix,donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
				#	}
				if(do_MPtree)
					{
					mptree(starttree=pi_OLS_tree,starttree_distance="pi",starttree_method="OLS",mpsearch="NNI")
					#mptree(mpsearch="ratchet")
					}
				if(do_MLtree)
					{
					mltree(starttree=pi_OLS_tree,starttree_distance="pi",starttree_method="OLS",dobootstrap=FALSE,mutationmodel="JC")
					}
				if(dogenindtrees)
					{
					# other distance measures  (i.e., 'nei.dist', 'rogers.dist', 'edwards.dist', 'reynolds.dist') need genind object:
					cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
					genlight2genind(input=mygenlight,add2sambar=TRUE)
					#
					# Edwards genetic distance:			
					cat("Hierarchical structuring of individuals based on Edwards genetic distance (i.e. using edwards.dist function of poppr package)...",sep="\n")
					cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
					getindtree(export="pdf",do_analysis=TRUE,nbootstrap=100,mymethod="NJ",mydistance="edwards.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					#
					# Nei's genetic distance:
					# cat("Creating NJ tree based on Nei's genetic distance (i.e. using nei.dist function of poppr package)...",sep="\n")
					# getindtree(export="pdf",do_analysis=TRUE,nbootstrap=100,mymethod="NJ",mydistance="nei.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					# getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="nei.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					#
					# Rogers genetic distance (not used here, because of high computation time):
					# cat("Creating NJ tree based on Rogers genetic distance (i.e. using rogers.dist function of poppr package)...",sep="\n")
					# cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
					# getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="rogers.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					# getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="rogers.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					#
					# Reynold's distance (not used here, because very long tip branch lengths (even for duplicated samples), obscures internal nodes (perhaps because not suitable for sample data, only for allele frequencies?):
					# cat("Creating NJ tree based on Rogers genetic distance (i.e. using rogers.dist function of poppr package)...",sep="\n")
					# cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
					# getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="reynolds.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					# getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="reynolds.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
					}
				}
			if(do_subsets)
				{
				# find subsets containing SNPs with highest standard deviation of MAF
				# create pcoa-plots
				# export ped and map-files to inputfilesdir
				if(nrow(snps[snps$filter,])>500)
					{	
					cat("Creating pcoa plots based on Hamming's genetic distance using subsets of highly differentiated SNPs...",sep="\n")
					cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
					if(length(mysambar$populations)>1)
						{
						plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(500,375,250,125),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						}
					}
				# for even smaller subsets:
				if(nrow(snps[snps$filter,])>100)
					{	
					cat("Creating pcoa plots based on Hamming's genetic distance using even even smaller subsets of highly differentiated SNPs...",sep="\n")
					cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
					if(length(mysambar$populations)>1)
						{
						# subsets containing SNPs with highest standard deviation of MAF:
						plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						}
					}
				cat("PED and MAP-files with subsets of highly differentiated SNPs have been exported to the inputfiles directory.",sep="\n")
				}
			if("LEA" %in% (.packages()) == FALSE)
				{
				cat("Package LEA not installed or loaded. Skipping LEA admixture analyses.",sep="\n")
				}else{
				cat("Creating admixture barplot using LEA...",sep="\n")
				runLEA(mindemes=Kmin,maxdemes=Kmax,poporder=pop_order)
				LEAceplot(export="pdf",mindemes=Kmin,maxdemes=Kmax)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,dolabelcol=TRUE,addindname=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,dolabelcol=TRUE,addindname=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,dolabelcol=FALSE,addindname=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,dolabelcol=FALSE,addindname=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
				#
				# full population name (axiscex and shortpop_nrchars):
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",borderlwd=1,bordercol="white",dolabelcol=TRUE,popnames=mysambar$populations,poporder=mysambar$poporder,addindname=FALSE,order_on_longitude=FALSE,shortpop_nrchars=12,heightfactor=LEAheightfactor,addindnr=FALSE,axiscex=0.75)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",borderlwd=1,bordercol="white",dolabelcol=FALSE,popnames=mysambar$populations,poporder=mysambar$poporder,addindname=FALSE,order_on_longitude=FALSE,shortpop_nrchars=12,heightfactor=LEAheightfactor,addindnr=FALSE,axiscex=0.75)
				if(("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
					{
					if(any(is.na(inds$longitude))|any(is.na(inds$latitude)))
						{
						cat("No missing values allowed in longitude and latitude column.",sep="\n")
						cat("SambaR will not order LEA structure plots by longitude.",sep="\n")
						}else{
						if(!silent){cat("LEAstructureplot by longitude",sep="\n")}
						runLEA(mindemes=Kmin,maxdemes=Kmax,order_on_longitude=TRUE)
						LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,dolabelcol=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
						LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,dolabelcol=FALSE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
						}
					}
				}
			if(do_maps)
				{
				cat("Running createmaps() function because the flag do_maps is set to TRUE. This function can also be run independent.",sep="\n")
				createmaps(K_max=Kmax,radius_ratio=30,marine_data=marine_dataset,dotess=FALSE,dolea=FALSE,dodapc=FALSE,domantel=FALSE,plot_per_pop=FALSE,perc_vector=c(20,40,60,80,95))
				}
			# reset working directory to default:
			setwd(mysambar$inputdatadir)
			cat("Finished structure analyses. Because the flag quickrun is set to TRUE, only a subset of analyses were run (namely PCoA, phylogeny, admixture).",sep="\n")
			return(cat("For additional analyses (e.g. DAPC, MDS, CA, BAPT) and to run PCoA, phylogenetic and admixture analyses with various settings and for multiple data subsets, set the flag quickrun to FALSE.",sep="\n"))
			# END OF QUICK RUN
			}
		if(do_pi)
			{
			cat("Creating pcoa plot based on pairwise sequence similarity using Sambar functions and Ape...",sep="\n")
			if(!silent){cat("calcpi",sep="\n")}
			calcpi(pi_per_pop=FALSE)
			calcpi(pi_per_pop=TRUE)
			if(!silent){cat("ape_pcoa",sep="\n")}
			cat("If you receive an error after this line, rerun findstructure with the flag 'do_pi' set to FALSE (i.e., findstructure(do_pi=FALSE)).",sep="\n") 
			ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="pi",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size)}
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,missvector=inds$miss,method="pi",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,missvector=inds$miss,method="pi",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,missvector=inds$miss,method="pi",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,missvector=inds$miss,method="pi",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			#
			#multiplot_pcoa_axes(exporttype="eps",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			#multiplot_pcoa_axes(exporttype="pdf",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			#multiplot_pcoa_axes(exporttype="png",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			#if(mysambar$os=="Windows"){multiplot_pcoa_axes(exporttype="wmf",mymethod="pi",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))}
			}
		if(do_nei)
			{
			cat("Creating Nei's genetic distance matrix...",sep="\n")
			ind_neimatrix(export=NULL)
			if(plot_nei)
				{
				cat("Plotting matrix with Nei's genetic distances. In case you run into an error, set the flag 'plot_nei' to FALSE.",sep="\n")
				plotindmatrix(export="eps")
				plotindmatrix(export="pdf")
				plotindmatrix(export="png")
				if(mysambar$os=="Windows"){plotindmatrix(export="wmf")}
				}
			cat("Creating pcoa plot based on Nei's genetic distance using StAMPP and Ape...",sep="\n")
			cat("If you receive an error after this line, rerun findstructure with the flag 'do_nei' set to FALSE (i.e., findstructure(do_nei=FALSE)).",sep="\n")  
			ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="nei",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			#
			multiplot_pcoa_axes(exporttype="eps",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			multiplot_pcoa_axes(exporttype="pdf",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			multiplot_pcoa_axes(exporttype="png",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
			if(mysambar$os=="Windows"){multiplot_pcoa_axes(exporttype="wmf",mymethod="nei",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))}
			if(do_subsets)
				{
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				if(nrow(snps[snps$filter,])>500)
					{
					cat("Creating pcoa plots based on Nei's genetic distance using small subsets of loci...",sep="\n")
					if(length(mysambar$populations)>1)
						{
						# subsets containing SNPs with highest standard deviation of MAF:
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=TRUE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=TRUE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						}
					# random subset:
					plotmulti_pcoa(mymethod="nei",export="pdf",do_legend=TRUE)
					plotmulti_pcoa(mymethod="nei",export="pdf",do_legend=FALSE)
					}
				if(nrow(snps[snps$filter,])>100)
					{	
					cat("Creating pcoa plots based on Nei's genetic distance using even smaller subsets of loci...",sep="\n")
					cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
					# for even smaller subsets:
					if(length(mysambar$populations)>1)
						{
						# subsets containing SNPs with highest standard deviation of MAF:
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
						}
					# random subset:
					plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),do_legend=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="nei",export="pdf",nloci=c(100,50,25,10),do_legend=FALSE,dodc=do_dc)
					}
				}
			}
		cat("Creating pcoa plot based on Hamming's genetic distance using poppr and Ape...",sep="\n")
		ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		if(mysambar$os=="Windows"){ape_pcoa(labels=FALSE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
		ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
		ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="eps",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="pdf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="png",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
		if(mysambar$os=="Windows"){ape_pcoa(labels=TRUE,axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,method="hamming",missvector=inds$miss,mybg=my_bg,axiscol=axis_col,export="wmf",mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
		#
		multiplot_pcoa_axes(exporttype="eps",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
		multiplot_pcoa_axes(exporttype="pdf",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
		multiplot_pcoa_axes(exporttype="png",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))
		if(mysambar$os=="Windows"){multiplot_pcoa_axes(exporttype="wmf",mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=add_legend,poslegend=legend_pos,cex_legend=legend_cex,mirroraxis=rep(FALSE,6))}
		if(length(mysambar$populations)>1&do_perpop)
			{
			cat("Creating pcoa plots based on Hamming's genetic distance for each population separately...",sep="\n")
			cat("If you receive an error after this line, rerun the findstructure function with the flag do_perpop set to FALSE (i.e: findstructure(do_perpop=FALSE)).",sep="\n")
			ape_pcoa_pop(popnames=mysambar$populations,exporttype="pdf",my_method="hamming")
			}
		if(do_subsets)
			{
			if(max(snps$miss,na.rm=TRUE)>0.03)
				{
				cat("Creating pcoa plots based on Hamming's genetic distance using various SNP filter settings...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				# 14-04-2020: Thomas received here the error (which I still need to fix): 'Error in min(D.eig$values): invalid 'type' (complex) of argument 
				multiplot_pcoa(mymethod="hamming",exporttype="pdf")
				multiplot_pcoa(mymethod="hamming",dolabels=TRUE,exporttype="pdf")
				multiplot_pcoa(mymethod="hamming",dolabels=TRUE,print_miss=TRUE,exporttype="pdf")
				plotmiss_vs_p(mymethod="hamming",exporttype="pdf")
				#
				cat("Creating pcoa plots based on Hamming's genetic distance for all individuals (also non_retained individuals) using various SNP filter settings...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				pcoa_allinds(mymethod="hamming",exporttype="pdf")
				pcoa_allinds(mymethod="hamming",exporttype="pdf",dolabels=TRUE)
				pcoa_allinds(mymethod="hamming",exporttype="pdf",dolabels=TRUE,print_miss=TRUE)
				}
			if(nrow(snps[snps$filter,])>500)
				{
				cat("Creating pcoa plots based on Hamming's genetic distance using small subsets of loci...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				if(length(mysambar$populations)>1)
					{
					# subsets containing SNPs with highest standard deviation of MAF:
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					}
				# random subsets:
				plotmulti_pcoa(mymethod="hamming",export="pdf",do_legend=TRUE,dodc=do_dc)
				plotmulti_pcoa(mymethod="hamming",export="pdf",do_legend=FALSE,dodc=do_dc)
				}
			if(nrow(snps[snps$filter,])>100)
				{	
				cat("Creating pcoa plots based on Hamming's genetic distance using even smaller subsets of loci...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				if(length(mysambar$populations)>1)
					{
					# subsets containing SNPs with highest standard deviation of MAF:
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=TRUE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=TRUE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),randomsubset=FALSE,do_legend=FALSE,no_fixed=FALSE,no_miss=FALSE,dodc=do_dc)
					}
				# random subsets:
				plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),do_legend=TRUE,dodc=do_dc)
				plotmulti_pcoa(mymethod="hamming",export="pdf",nloci=c(100,50,25,10),do_legend=FALSE,dodc=do_dc)
				}
			}
		if(do_tree)
			{
			cat("Creating NJ tree based on Hamming's genetic distance (i.e. using bitwise.dist function of poppr package)...",sep="\n")
			cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'do_tree' flag set to false (i.e. findstructure(do_tree=FALSE)).",sep="\n")
			#cat("A second option is to rerun the filterdata() function with different filter options (include more SNPs) and then try the findstructure function again.",sep="\n")
			#08-03-2020: above lines are redundant after including inds$allgeno filter.
			getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="NJ",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			cat("Creating UPGMA tree based on Hamming's genetic distance (i.e. using bitwise.dis function of poppr package)...",sep="\n")
			getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="phylogram",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="rightwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=FALSE,mymethod="upgma",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=FALSE,mylwd=3,addnodelabels=FALSE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			#
			# sequence dissimilarity (generated with SambaR's calcpi function):
			cat("Creating NJ and upgma trees based on sequence dissimilarity score (i.e. using calcpi function of SambaR package)...",sep="\n")
			getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=TRUE,mymethod="ward.D",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			getindtree(export="pdf",do_analysis=TRUE,mymethod="ward.D2",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			# getindtree(export="pdf",do_analysis=TRUE,mymethod="complete",mydistance="pi",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
			plotindmatrix(n_bins=6,export="pdf",add_lab=FALSE,ind_matrix=mysambar$pimatrix,export_name="Pimatrix.ind",plottitle="Sequence dissimilarity (pi)")
			plotindmatrix(n_bins=8,export="pdf",add_lab=FALSE,ind_matrix=mysambar$pimatrix,export_name="Pimatrix.ind",plottitle="Sequence dissimilarity (pi)")
			#	
			if(dogenindtrees)
				{
				# other distance measures  (i.e., 'nei.dist', 'rogers.dist', 'edwards.dist', 'reynolds.dist') need genind object:
				cat("If you receive an error after this line, rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
				genlight2genind(input=mygenlight,add2sambar=TRUE)
				# Nei's genetic distance:
				cat("Creating NJ and upgma trees based on Nei's genetic distance (i.e. using nei.dist function of poppr package)...",sep="\n")
				cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
				getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="nei.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="nei.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				# Edwards genetic distance:			
				cat("Creating NJ and upgma trees based on Edwards's genetic distance (i.e. using edwards.dist function of poppr package)...",sep="\n")
				cat("If you receive an error after this line (for example about 'ploidy' issues), rerun the findstructure function with the 'dogenindtrees' flag set to false (i.e. findstructure(dogenindtrees=FALSE)).",sep="\n")
				getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="edwards.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="edwards.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				# Rogers genetic distance (not used here, because of high computation time):
				# getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="rogers.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				# getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="rogers.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				# Reynold's distance (not used here, because very long tip branch lengths (even for duplicated samples), obscures internal nodes:
				# getindtree(export="pdf",do_analysis=TRUE,mymethod="NJ",mydistance="reynolds.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				# getindtree(export="pdf",do_analysis=TRUE,mymethod="upgma",mydistance="reynolds.dist",mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=max_node_label,nodelabelcex=1.5,showpop=FALSE,mydirection="upwards")
				}
			if(length(mysambar$populations)>3)
				{
				cat("Calculating Nei's genetic distance between populations using stamppNeisD function of the package 'StAMPP'...",sep="\n")
				pop_neimatrix(export=NULL)
				# 22-09-2021:
				cat("Creating population phylogenies. If you receive an error after this line, set the flag dopoptree to FALSE.",sep="\n") 
				getpoptree(exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
				getpoptree(exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
				getpoptree(exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
				getpoptree(exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
				write.tree(mysambar$poptree,file=paste("Poptree.neiD.newick.txt",sep="."),digits=0,tree.names=FALSE)
				}
			}
		if(do_popca)
			{
			if(length(mysambar$populations)>=3)
				{
				cat("Executing correspondence analysis for populations...",sep="\n")
				cat("If you run into an error shortly after this line, rerun the findstructure function with the flag do_popca set to FALSE.",sep="\n")
				if(nrow(snps[snps$filter,])<100000)
					{
					if(!silent){cat("makeinputfca",sep="\n")}
					makeinputfca()
					if(!silent){cat("run_ca for populations",sep="\n")}
					run_ca(mydf=mysambar$fca_input,perpop=TRUE,doall=FALSE,dodc=do_dc)
					if(!silent){cat("plot_ca for populations",sep="\n")}
					plot_ca(addlegend=FALSE,export="eps",symbolsize=symbol_size)
					plot_ca(addlegend=FALSE,export="pdf",symbolsize=symbol_size)
					plot_ca(addlegend=FALSE,export="png",symbolsize=symbol_size)
					if(mysambar$os=="Windows"){plot_ca(addlegend=FALSE,export="wmf",symbolsize=symbol_size)}
					plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="eps",symbolsize=symbol_size)
					plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="pdf",symbolsize=symbol_size)
					plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="png",symbolsize=symbol_size)
					if(mysambar$os=="Windows"){plot_ca(addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="wmf",symbolsize=symbol_size)}
					}else{
					cat("More than 100.000 SNPs present in retained dataset. For sake of computation time, skipping correspondence analyses for populations.",sep="\n")
					}
				}else{
				cat("Currently less than 3 population defined. Skipping correspondence analysis for populations.",sep="\n")
				}
			}
		if(do_indca)
			{
			cat("Executing correspondence analysis for individuals...",sep="\n")
			cat("If you run into an error shortly after this line, rerun the findstructure function with the flag do_indca set to FALSE.",sep="\n")
			if(!silent){cat("makeinputfca_ind",sep="\n")}
			makeinputfca_ind()
			if(!silent){cat("run_ca for individuals",sep="\n")}
			run_ca(mydf=mysambar$fca_input_ind,perpop=FALSE,doall=FALSE)
			if(!silent){cat("plot_ca for individuals",sep="\n")}
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="eps",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="pdf",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="png",symbolsize=symbol_size)
			if(mysambar$os=="Windows"){plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,export="wmf",symbolsize=symbol_size)}
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="eps",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="pdf",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="png",symbolsize=symbol_size)
			if(mysambar$os=="Windows"){plot_ca(perpop=FALSE,doall=FALSE,addlegend=FALSE,dolabels=TRUE,export="wmf",symbolsize=symbol_size)}
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="eps",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="pdf",symbolsize=symbol_size)
			plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="png",symbolsize=symbol_size)
			if(mysambar$os=="Windows"){plot_ca(perpop=FALSE,doall=FALSE,addlegend=TRUE,legendpos=legend_pos,legendcex=legend_cex,export="wmf",symbolsize=symbol_size)}
			}
		if("SNPRelate"%in%(.packages())&do_pca)
			{
			cat("Creating pca plot using snprelate...",sep="\n")
			cat("If you receive an error shortly after this line, rerun the findstructure function with the flag do_pca set to FALSE.",sep="\n")
			snprelate_pca(export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=FALSE)
			snprelate_pca(export="eps",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)	
			snprelate_pca(export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			snprelate_pca(export="png",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){snprelate_pca(export="wmf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			snprelate_pca(export="eps",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)	
			snprelate_pca(export="pdf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			snprelate_pca(export="png",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			if(mysambar$os=="Windows"){snprelate_pca(export="wmf",axis1=axis_1,axis2=axis_2,do_mirror=domirroraxis,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=add_legend,labels=TRUE,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)}
			if(do_subsets)
				{
				cat("Creating pca plot using snprelate using various SNP filter settings...",sep="\n")
				cat("If you receive an error after this line, rerun the findstructure function with the flag do_subsets set to FALSE (i.e: findstructure(do_subsets=FALSE)).",sep="\n")
				multisnprelate_pca(dolabels=FALSE,exporttype="pdf",dolegend=add_legend,poslegend=legend_pos,cex_legend=4,size_symbol=4,maxmiss=0.01)
				}
			file.remove("my.gds")
			}else{
			cat("Package 'SNPrelate' not installed and/or loaded. Not creating snprelate based PCA plots.",sep="\n")
			}
		if(do_mds)
			{
			cat("Creating multidimensional scaling (MDS) plots...",sep="\n")
			if(!silent){cat("bothMDS",sep="\n")}
			bothMDS(exporttype="pdf",rundc=FALSE)
			if(!silent){cat("doMDS",sep="\n")}
			doMDS(labels=TRUE,nonmetric=TRUE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			doMDS(labels=TRUE,nonmetric=FALSE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			doMDS(labels=FALSE,nonmetric=TRUE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			doMDS(labels=FALSE,nonmetric=FALSE,export="pdf",addlegend=add_legend,legendpos=legend_pos,legendcex=legend_cex,symbolsize=symbol_size,dodc=do_dc)
			}
		if(do_dapc)
			{
			cat("Creating dapc plots...",sep="\n")	
			cat("If you receive an error soon after thin line, set the flag 'do_dapc' to FALSE.",sep="\n")
			genlight2genind()
			if(!silent){cat("Conversion to genind object finished. Running now adegenet_dapc",sep="\n")}
			multi_adegenet_dapc(export="pdf",thresvector=c(20,50,80,95),max_clusters=Kmax,add_ellipse=dapc_ellipse,ellipse_level=dapc_ellipse_level,legendadd=add_legend,poslegend=legend_pos,cexlegend=legend_cex,symsize=symbol_size,rundc=do_dc,plot_heatmap=dapc_heatmap)
			}
		if(length(mysambar$populations)>1&doBAPT)
			{
			popnind	<- as.vector(table(inds$pop[inds$filter]))
			if(all(popnind>1))
				{
				cat("Calculating Bayesian assignment probabilities...",sep="\n")
				cat("If the calculation takes too long, or produces errors, rerun the findstructure function with the flag 'doBAPT' set to FALSE.",sep="\n")
				assign2pop()
				if(mysambar$ndata_popassign>1)
					{
					if(!silent){cat("plotassign2pop",sep="\n")}
					plotassign2pop(export="eps",addsamplenr=TRUE)
					plotassign2pop(export="pdf",addsamplenr=TRUE)
					plotassign2pop(export="png",addsamplenr=TRUE)
					if(mysambar$os=="Windows"){plotassign2pop(export="wmf",addsamplenr=TRUE)}
					plotassign2pop(export="eps",addsamplenr=FALSE)
					plotassign2pop(export="pdf",addsamplenr=FALSE)
					plotassign2pop(export="png",addsamplenr=FALSE)
					if(mysambar$os=="Windows"){plotassign2pop(export="wmf",addsamplenr=FALSE)}
					if(!silent){cat("plotassign2pop_hetero",sep="\n")}
					# 28-05-2021: replaced by triangle plot:
					#plotassign2pop_hetero()
					if(!silent){cat("multi_assign2pop",sep="\n")}
					if(mysambar$ndata_popassign>50&mysambar$ndata_popassign<=250)
						{
						multi_assign2pop(nsnp_vector=c(10,20,30,40,50),exporttype="pdf")
						multi_assign2pop(nsnp_vector=c(10,20,30,40,50),exporttype="pdf",top_popmaf_sd=TRUE)
						}
					if(mysambar$ndata_popassign>250)
						{
						multi_assign2pop(nsnp_vector=c(50,100,150,200,250),exporttype="pdf")
						multi_assign2pop(nsnp_vector=c(50,100,150,200,250),exporttype="pdf",top_popmaf_sd=TRUE)
						}
					multi_assign2pop(exporttype="pdf")
					multi_assign2pop(exporttype="pdf",top_popmaf_sd=TRUE)
					}
				}else{
				cat("Skipping Bayesian population assignment test because one or more populations contain 1 individual only.",sep="\n")
				}
			}else{
			cat("Skipping Bayesian population assignment test either only 1 populations defined or because the flag doBAPT is set to FALSE.",sep="\n")
			}
		}
	if("LEA" %in% (.packages()) == FALSE)
		{
		cat("Package LEA not installed or loaded. Skipping LEA admixture analyses.",sep="\n")
		}else{
		cat("Creating admixture barplot using LEA...",sep="\n")
		runLEA(mindemes=Kmin,maxdemes=Kmax,poporder=pop_order)
		if(!silent){cat("Plotting cross-entropy criterion...",sep="\n")}
		LEAceplot(export="eps",mindemes=Kmin,maxdemes=Kmax)
		LEAceplot(export="pdf",mindemes=Kmin,maxdemes=Kmax)
		LEAceplot(export="png",mindemes=Kmin,maxdemes=Kmax)
		if(mysambar$os=="Windows"){LEAceplot(export="wmf",mindemes=Kmin,maxdemes=Kmax)}
		if(!silent){cat("eps",sep="\n")}
		LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="eps",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="eps",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		if(!silent){cat("pdf",sep="\n")}
		LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,addindname=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		#if(!silent){cat("png",sep="\n")}
		#LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="png",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		#LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="png",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
		if(!silent){cat("wmf",sep="\n")}
		if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
		if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
		#
		# full population name (axiscex and shortpop_nrchars):
		LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",borderlwd=1,bordercol="white",dolabelcol=TRUE,popnames=mysambar$populations,poporder=mysambar$poporder,addindname=FALSE,order_on_longitude=FALSE,shortpop_nrchars=12,heightfactor=LEAheightfactor,addindnr=FALSE,axiscex=0.75)
		LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",borderlwd=1,bordercol="white",dolabelcol=FALSE,popnames=mysambar$populations,poporder=mysambar$poporder,addindname=FALSE,order_on_longitude=FALSE,shortpop_nrchars=12,heightfactor=LEAheightfactor,addindnr=FALSE,axiscex=0.75)
		#
		# optionally order by longitude:
		if(("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
			{
			if(any(is.na(inds$longitude))|any(is.na(inds$latitude)))
				{
				cat("No missing values allowed in longitude and latitude column.",sep="\n")
				cat("SambaR will not order LEA structure plots by longitude.",sep="\n")
				}else{
				if(!silent){cat("LEAstructureplot by longitude",sep="\n")}
				runLEA(mindemes=Kmin,maxdemes=Kmax,order_on_longitude=TRUE)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=FALSE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)	
				LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,addindname=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
				if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
				if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",addindnr=FALSE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
				}
			}
		if(any(as.vector(inds$pop)!=as.vector(inds$pop2))&LEAperpop)
			{
			cat("Running LEA per population.",sep="\n")
			for (my_pop in mysambar$populations)
				{
				cat(my_pop,sep="\n")
				nrinds	<- nrow(inds[inds$pop==my_pop&inds$filter,])
				if(nrinds<3)
					{
					cat("Less than 3 individuals. Skipping LEA admixture plot.",sep="\n")
					}else{
					runLEA(mindemes=Kmin,maxdemes=6,popnames=mysambar$populations,order_on_longitude=FALSE,focuspop=my_pop)
					indspop		<- inds[inds$pop==my_pop&inds$filter,]
					mysubpops	<- unique(as.vector(indspop$pop2))
					mysubpops	<- mysubpops[order(mysubpops)]
					LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=FALSE,poporder=pop_order,shortpop=short_pop,colourvector=colour_vector,focuspop=my_pop,popnames=mysubpops,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
					}
				}
			}
		}
	# reset working directory to default:
	setwd(mysambar$inputdatadir)
	cat("STRUCTURE ANALYSES FINISHED.",sep="\n")
	if(!do_dapc)
		{
		cat(" ",sep="\n")
		cat("WARNING: DAPC analyses have not been performed because the flag 'do_dapc' is set to FALSE (default setting).",sep="\n")	
		cat("If you want to run DAPC analyses, rerun the findstructure function with the flag do_dapc set to TRUE, i.e.: findstructure(do_dapc=TRUE).",sep="\n")
		cat("Alternatively, to run DAPC analyses by itself (without having to rerun all other analyses), execute the following two commands:",sep="\n")
		cat("genlight2genind()",sep="\n")
		cat("multi_adegenet_dapc(export='pdf',thresvector=c(20,50,80,95),max_clusters=6,add_ellipse=FALSE,legendadd=TRUE,poslegend='bottomright',cexlegend=2,symsize=2,rundc=FALSE,plot_heatmap=TRUE)",sep="\n")
		}
	}

# make input for correspondence analysis (I called it factorial correspondence analysis, but actually not sure whether it is factorial indeed)	
makeinputfca<-function(popnames=mysambar$populations,remove0=FALSE)
	{
	if(length(popnames)==1)
		{
		return(cat("Currently only 1 population defined. SambaR can not execute correspondence analysis (CA).",sep="\n"))
		}else{
		temp	<- snps[snps$filter,c(paste("maf",mysambar$populations,sep="_"))]
		nsites	<- snps$nonmissallelecount[snps$filter]
		for (j in c(1:nrow(temp)))
			{
			myrow			<- as.vector(temp[j,]*nsites[j])
			if(remove0)
				{
				myrow[myrow==0]	<- 1
				}
			temp[j,]		<- myrow
			}
		temp			<- round(temp)
		colnames(temp)	<- mysambar$populations
		mysambar$fca_input	<<- temp[complete.cases(temp), ]
		}
	}

makeinputfca_ind<-function(popnames=mysambar$populations,doall=FALSE,impute_persnp=TRUE)
	{
	if(impute_persnp)
		{
		if(is.null(mysambar$imputedmatrix_persnp))
			{
			sambarimpute(per_snp=TRUE)
			}
		if(doall)
			{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix_persnp[,snps$filter])
			}else{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix_persnp[inds$filter,snps$filter])
			}
		}else{
		if(is.null(mysambar$imputedmatrix))
			{
			sambarimpute(per_snp=FALSE)
			}
		if(doall)
			{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix[,snps$filter])
			}else{
			mysambar$fca_input_ind		<<- t(mysambar$imputedmatrix[inds$filter,snps$filter])
			}
		
		}
	}
	
# input dataset:
sambarimpute<-function(doall=FALSE,per_snp=TRUE,silent=TRUE,calc_he=TRUE,popnames=mysambar$populations,do_overwrite=FALSE)
	{
	# impute data (because no missing values allowed):
	mymatrix				<- as.matrix(mygenlight)
	# impute data (because no missing values allowed):
	if(!per_snp)
		{
		cat("Imputing data using using genotype information per sample...",sep="\n")
		do_analysis			<- ifelse(is.null(mysambar$imputedmatrix_persnp),TRUE,ifelse(do_overwrite,TRUE,FALSE))
		if(!do_analysis)
			{
			cat("Obtaining imputed dataset from mysambar$imputedmatrix_persnp.",sep="\n")
			mymatrix		<- mysambar$imputedmatrix_persnp
			}
		}else{
		cat("Imputing data using using genotype information per SNP...",sep="\n")
		do_analysis			<- ifelse(is.null(mysambar$imputedmatrix),TRUE,ifelse(do_overwrite,TRUE,FALSE))
		if(!do_analysis)
			{
			cat("Obtaining imputed dataset from mysambar$imputedmatrix.",sep="\n")
			mymatrix		<- mysambar$imputedmatrix
			}
		}
	#
	if(do_analysis)
		{
		for (i in c(1:nrow(inds)))
			{
			myind				<- as.vector(inds$name)[i]
			mypop				<- as.vector(as.character(inds$pop))[i]
			if(!silent){cat(i,sep="\n")}
			if(!silent){cat(myind,sep="\n")}
			if(!silent){cat(mypop,sep="\n")}
			#
			myrow				<- mymatrix[i,]
			myrow_data			<- myrow[!is.na(myrow)]
			myrow_na			<- myrow[is.na(myrow)]
			nmiss				<- length(myrow_na)
			#
			columnname			<- paste("maf",mypop,sep="_")
			if(per_snp&!(columnname%in%colnames(snps)))
				{
				return(cat("ERROR: column with population specific minor allele frequencies missing from snps dataframe. First run the snp_maf() function.",sep="\n"))
				}
			if(nmiss<nrow(snps))
				{
				if(per_snp)
					{
					mymafcolumn			<- as.vector(snps[,columnname])
					if(any(is.na(mymafcolumn)))
						{
						# 26-04-2021: Quick and dirty solution to avoid the error:
						# Error in apply(popmatrix, 2, function(z) { : dim(X) must have a positive length
						if(!silent){cat(paste("WARNING: no maf-estimate for one or more SNPs of population ",mypop,". Using instead maf estimate of meta population.",sep=""),sep="\n")}  
						mymafcolumn		<-ifelse(is.na(mymafcolumn),snps$maf,mymafcolumn)
						}
					AAthres				<- (1-mymafcolumn)*(1-mymafcolumn)
					aathres				<- 1-(mymafcolumn*mymafcolumn)
					randomvec			<- runif(length(mymafcolumn))
					randomgeno			<- ifelse(randomvec<=AAthres,0,ifelse(randomvec<=aathres,1,2)) 
					myrow_all			<- ifelse(is.na(myrow),randomgeno,myrow)  
					#myrow_all			<- ifelse(is.na(myrow),9,myrow)		# test to check if replacing NAs only
					}else{
					myrow_na[1:nmiss]	<- sample(as.vector(myrow[!is.na(myrow)]),nmiss,replace=TRUE)
					myrow_all			<- c(myrow_data,myrow_na)
					myrow_all			<- myrow_all[order(names(myrow_all))]
					}
				mymatrix[i,]			<- myrow_all
				}else{
				if(inds$filter[i]&doall)
					{
					return(cat(paste("ERROR: Sample ",myind, "contains missing data only. Set doall flag to FALSE.")),sep="\n")
					}
				}
			}
		}		
	if(per_snp)
		{
		mysambar$imputedmatrix_persnp	<<- mymatrix
		cat("Imputed data stored at mysambar$imputedmatrix_persnp.",sep="\n")
		}else{
		mysambar$imputedmatrix			<<- mymatrix
		cat("Imputed data stored at mysambar$imputedmatrix.",sep="\n")
		}
	#
	if(calc_he)
		{
		cat("Calculating snp-specific maf, mac and He-scores for imputed dataset...",sep="\n")
		ninds						<- nrow(inds[inds$filter,])
		inputgenlight				<- as.genlight(mymatrix)
		snps$imputed_minorcount		<<- as.vector(glSum(inputgenlight[inds$filter,]))
		snps$imputed_majorcount		<<- 2*ninds-snps$imputed_minorcount	
		snps$imputed_maf			<<- round(snps$imputed_minorcount/(2*ninds),3)
		#
		popmatrix 					<- mymatrix[inds$filter,]
		popmatrix[is.na(popmatrix)]	<- 3
		snps$imputed_Aa				<<- apply(popmatrix,2,function(z){(length(z[z==1]))})
		snps$imputed_hetero			<<- apply(popmatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
		#
		# Per population:
		for (i in (1:length(popnames)))
			{
			if(any(inds$filter&inds$pop==popnames[i]))
				{
				snps$maftemp 		<<- glMean(inputgenlight[inds$filter&inds$pop==popnames[i],])
				snps$maftemp[!is.finite(snps$maftemp)]	<<- NA 
				if(any(is.na(snps$maftemp)))
					{
					cat(paste("WARNING: No data for 1 or more snps in population:",popnames[i],sep=" "),sep="\n")
					}
				snps$mactemp		<<- as.vector(glSum(inputgenlight[inds$filter&inds$pop==popnames[i],]))
				#
				popmatrix					<- mymatrix[inds$filter&inds$pop==popnames[i],,drop=FALSE]
				popmatrix[is.na(popmatrix)]	<- 3		# because otherwise NA's are counted as 1.
				snps$Aatemp					<<- apply(popmatrix,2,function(z){length(which(z==1))})
				snps$heterotemp				<<- apply(popmatrix,2,function(z){(length(z[z==1])/length(z[z!=3]))})
				}else{
				cat(paste("No individuals retained in population:",popnames[i],sep=" "),sep="\n")
				snps$maftemp 		<<- NA
				snps$mactemp		<<- NA
				snps$Aatemp			<<- NA
				snps$heterotemp		<<- NA
				}
			names(snps)[names(snps) == "maftemp"] 	<<- paste("imputed_maf",popnames[i],sep = "_")
			names(snps)[names(snps) == "mactemp"] 	<<- paste("imputed_mac",popnames[i],sep = "_")
			names(snps)[names(snps) == "Aatemp"] 	<<- paste("imputed_Aa",popnames[i],sep = "_")
			names(snps)[names(snps) == "heterotemp"]<<- paste("imputed_hetero",popnames[i],sep = "_")
			}
		# if this function has been executed before, remove columns produced during previous execution:
		snps 						<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
		}
	}

run_ca<-function(mydf=mysambar$fca_input,perpop=TRUE,mymethod="dudi",doall=FALSE,popnames=mysambar$populations,doinstall=FALSE,dodc=TRUE)
	{
	if(perpop&length(popnames)<3)
		{
		return(cat("Currently less than 2 population defined. SambaR can not execute fca analysis when perpop is set is TRUE.",sep="\n"))
		}
	if(!(mymethod=="dudi"|mymethod=="factominer"))
		{
		return(cat("ERROR: mymethod should be 'dudi' or 'factominer'.",sep="\n"))
		}
	# correspondence analysis is principal components analysis for categorical data (rather than for numerical data?)
	# mymethod can be be 'factominer' (FactoMineR package) or 'dudi' (ade4 package).
	# Other options for correspondence analysis, at present not incorporated, would be:
	# library(ca)
	# res.ca <- ca(housetasks)
	# library(MASS)
	# res.ca <- corresp(housetasks, nf = 3)
	# No matter which method, factominer is used for plotting.
 	#
	if(doinstall)
		{
		install.packages("FactoMineR")
		install.packages("factoextra")
		library("FactoMineR")
		library("factoextra")
		}
	npops	<- length(popnames)
	if(is.null(mydf))
		{
		return(cat("Error: provide a dataframe with minor allele counts per population to mydf flag.",sep="\n"))
		}
	if(!perpop)
		{
		if(doall)
			{
			ninds	<- nrow(inds)
			}else{
			ninds	<- nrow(inds[inds$filter,])
			}
		if(ncol(mydf)!=ninds)
			{
			return(cat("ERROR: number of columns in input file does not correspond with expected number of individuals.",sep="\n"))
			}
		}else{
		if(ncol(mydf)!=npops)
			{
			return(cat("ERROR: number of columns in input file does not correspond with expected number of populations.",sep="\n"))
			}
		}
	# mydf	<- unique(mydf)							# remove duplicates rows
	if(mymethod=="factominer")
		{
		# sambarfunction_findstructure:
		##### FINDSTRUCTURE #####
		# sambarfunction_findstructure:
		### correspondence analyses:
		# sambarfunction_findstructure:
		mysambar$res.ca 	<<- CA(mydf,ncp=5,graph=FALSE)
		# this gives sometimes the error: Error in eigen(crossprod(X, X), symmetric = TRUE) : infinite or missing values in 'x'
		}
	if(mymethod=="dudi")
		{
		#sambarfunction_findstructure:
		mysambar$res.ca 	<<- dudi.coa(mydf,scannf=FALSE,nf=5)		
		}
	#
	if(mymethod=="factominer")
		{
		mysambar$ca_eig.val <<- as.data.frame(get_eigenvalue(mysambar$res.ca))
		mysambar$ca_coord	<<- mysambar$res.ca$col$coord
		mysambar$ca_perc1	<<- round(res.ca$eig[1,2],1)
		mysambar$ca_perc2	<<- round(res.ca$eig[2,2],1)
		}
	if(mymethod=="dudi")
		{
		mysambar$ca_out 	<<- get_ca_col(mysambar$res.ca)
		mysambar$ca_coord	<<- mysambar$ca_out$coord
		mysambar$ca_eig.val <<- get_eigenvalue(mysambar$res.ca)
		mysambar$ca_perc1	<<- round(mysambar$ca_eig.val$variance.percent[1],1)
		mysambar$ca_perc2	<<- round(mysambar$ca_eig.val$variance.percent[2],1)
		}
	mytablename	<- "CA.ind.axis1vs2.dc_score.txt"
	if(dodc)
		{
		calc_dc(popnames=mysambar$populations,pscores=mysambar$ca_coord,axis_1=1,axis_2=2,tablename=mytablename)
		}
	}

plot_ca<-function(do_scree=FALSE,export=NULL,doall=FALSE,perpop=TRUE,popnames=mysambar$populations,dolabels=FALSE,addlegend=TRUE,symboltype=16,symbolsize=2.5,legendpos="topleft",legendcex=1.5,resetgraphics=TRUE)
	{
	npops	<- length(popnames)
	# screeplot:
	if(do_scree)
		{
		if(!is.null(export))
			{
			if(perpop)
				{
				if(export=="eps"){postscript("CA.pop.screeplot.eps",family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf("CA.pop.screeplot.pdf",family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png("CA.pop.screeplot.png",family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile("CA.pop.screeplot.wmf",family=mysambar$myfont,width=10,height=10)}
				}else{
				if(export=="eps"){postscript("CA.ind.screeplot.eps",family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf("CA.ind.screeplot.pdf",family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png("CA.ind.screeplot.png",family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile("CA.ind.screeplot.wmf",family=mysambar$myfont,width=10,height=10)}
				}
			}
		barplot(mysambar$ca_eig.val$variance.percent,ylab="Percentage explained variance",names.arg=c(1:nrow(eig.val)))
		if(!is.null(export)){dev.off()}
		}
	#
	# ordination plot:
	if(resetgraphics){graphics.off()}
	if(!is.null(export))
		{
		mylegend	<- ifelse(addlegend,ifelse(perpop,"pop.withlegend","ind.withlegend"),ifelse(perpop,"pop.nolegend",ifelse(dolabels,"ind.nolegend.labels","ind.nolegend")))
		if(export=="eps"){postscript(paste("CA",mylegend,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("CA",mylegend,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("CA",mylegend,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("CA",mylegend,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,5,2,2),cex.lab=2.5,cex.axis=2.5)
	plot(mysambar$ca_coord[,1],mysambar$ca_coord[,2],col="white",cex=symbolsize,pch=16,xlab=paste("Dim 1 (",mysambar$ca_perc1," %)",sep=""),ylab=paste("Dim 2 (",mysambar$ca_perc2," %)",sep=""))
	abline(h=0,col="grey")
	abline(v=0,col="grey")
	if(perpop)
		{
		mycolours	<- mysambar$mycolours
		}else{
		if(doall)
			{
			mycolours	<- inds$popcol
			}else{
			mycolours	<- inds$popcol[inds$filter]
			}
		}
	if(dolabels)
		{
		if(doall)
			{
			mynumbers	<- inds$nr
			}else{
			mynumbers	<- inds$nr[inds$filter]
			}
		text(x=mysambar$ca_coord[,1],y=mysambar$ca_coord[,2],mynumbers,col=mycolours,cex=0.5)
		}else{
		points(mysambar$ca_coord[,1],mysambar$ca_coord[,2],col=mycolours,cex=symbolsize,pch=16)
		}
	if(addlegend==TRUE&npops>1)
		{
		if(length(symboltype)>1)
			{
			legend(legendpos,legend=popnames,fill=mysambar$mycolours,pch=symboltype,bty="n",cex=legendcex)
			}else{
			legend(legendpos,legend=popnames,fill=mysambar$mycolours,bty="n",cex=legendcex)
			}
		}
	if(!is.null(export)){dev.off()}
	}
	
hwe<-function(popnames=mysambar$populations,indselection=inds$filter,mycolours=mysambar$mycolours,export=NULL,addlabels=TRUE,silent=TRUE)
	{
	popnames		<- as.vector(popnames)
	npops			<- length(popnames)
	### For metapop:
	snps$Hexp_meta	<<- 2*snps$maf*(1-snps$maf)
	snps$F_meta		<<- (snps$Hexp_meta-snps$hetero)/snps$Hexp_meta
	# alternatively:
	# snps$F_meta	<<- (snps$expAa-snps$Aa)/snps$expAa
	snps$HWEchi2	<<- ((snps$expAA-snps$AA)^2/(snps$expAA+1))+((snps$Aa-snps$expAa)^2/(snps$expAa+1))+((snps$aa-snps$expaa)^2/(snps$expaa+1))
	# Degrees of freedom (df) = N_genotypes - N_alleles. For biallelic snps: 3-2=1.
	# This is the reason: once we decided on a value for p, everything else was decided for us. Whatever p was, q had to be 1-p, and p2, 2pq, and q2 were set as well. 
	# So, to make columns for p-values and for significance (TRUE or FALSE), we can type:
	snps$HWEp		<<- round(pchisq(snps$HWEchi2,df=1,lower.tail=FALSE),6)
	snps$HWE		<<- snps$HWEchi2 < (qchisq(.95,df=1))
	# He deficit or excess?
	snps$Hdeficit	<<- ifelse(snps$expAa-snps$Aa>0,TRUE,FALSE) 
	# I noticed that deficit is often caused by high maf. Maybe to correct for it:
	# snps$Hdeficit <<- ifelse(snps$HWE=="TRUE"&snps$maf<0.45,snps$Hdeficit,NA)
	### Plot:
	graphics.off()
	ntiles			<- npops+1
	if(!is.null(export))
		{
		mywidth1	<- ntiles*6+1
		mywidth2	<- ntiles*400+200
		if(export=="eps"){postscript("HWE.eps",family=mysambar$myfont,width=mywidth1,height=10)}
		if(export=="pdf"){pdf("HWE.pdf",family=mysambar$myfont,width=mywidth1,height=10)}
		if(export=="png"){png("HWE.png",family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile("HWE.wmf",family=mysambar$myfont,width=mywidth1,height=10)}
		}
	par(mfrow=c(1,ntiles),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	hist(snps$HWEchi2[snps$filter],breaks=seq(0,max(snps$HWEchi2[snps$filter]+10,0.5)),xlim=c(0,20),ylim=c(0,nrow(snps[snps$filter,])),main="",xlab="",ylab="Number of loci")
	mtext("Metapop",side=3,line=-2,cex=2)
	abline(v=qchisq(.95,df=1),lty=2)
	mtext("Locus specific HWE chi squared scores",side=1,line=-1.5,cex=2,outer=TRUE)
	mtext("HWE test scores",side=3,line=-3.5,cex=2.5,outer=TRUE)
	# For individuals populations:
	### For individual pops:
	for (i in (1:length(popnames)))
		{
		if(!silent){cat(popnames[i],sep="\n")}
		# Expected genotypes per population:
		# misscount			<- glNA(mygenlight[indselection&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		# npopind				<- nrow(inds[indselection&inds$pop==popnames[i],])
		# nonmisscount 		<- 2*npopind-misscount
		# snps$nonmisstemp	<<- nonmisscount
		# Observed genotypes per population:
		# mymatrix 			<- as.matrix(mygenlight[indselection&inds$pop==popnames[i],])
		# mymatrix[is.na(mymatrix)]	<- 3
		# obsAA				<- apply(mymatrix,2,function(z){length(z[z==0])})
		# obsAa				<- apply(mymatrix,2,function(z){length(z[z==1])})
		# obsaa				<- apply(mymatrix,2,function(z){length(z[z==2])})
		# expAA				<- round((1-mymaf)*(1-mymaf)*nonmisscount/2)
		# expAa				<- round(2*mymaf*(1-mymaf)*nonmisscount/2)
		# expaa				<- round(mymaf*mymaf*nonmisscount/2)
		# 16-03-2021: masked 14 lines above
		obsAA				<- snps[,paste("AA",popnames[i],sep="_")]		# 16-03-2021
		obsAa				<- snps[,paste("Aa",popnames[i],sep="_")]		# 16-03-2021
		obsaa				<- snps[,paste("aa",popnames[i],sep="_")]		# 16-03-2021
		# misscount			<- snps[,paste("miss",popnames[i],sep="_")]		# 16-03-2021
		nonmisscount		<- snps[,paste("n",popnames[i],sep="_")]		# 16-03-2021
		mymaf				<- snps[,paste("maf",popnames[i],sep="_")]
		expAA				<- round((1-mymaf)*(1-mymaf)*nonmisscount)		# 16-03-2021
		expAa				<- round(2*mymaf*(1-mymaf)*nonmisscount)		# 16-03-2021
		expaa				<- round(mymaf*mymaf*nonmisscount)				# 16-03-2021
		# Do the HWE-test:
		snps$Ftemp			<<- (expAa-obsAa)/expAa
		snps$HWEchi2temp	<<- ((expAA-obsAA)^2/(expAA+1))+((obsAa-expAa)^2/(expAa+1))+((obsaa-expaa)^2/(expaa+1))
		snps$HWEptemp		<<- round(pchisq(snps$HWEchi2temp,df=1,lower.tail=FALSE),6)
		snps$HWEtemp		<<- snps$HWEchi2temp < (qchisq(.95,df=1))
		snps$Hdeficittemp	<<- ifelse(expAa-obsAa>0,TRUE,FALSE) 
		snps$expAatemp		<<- expAa
		#snps$obsAatemp		<<- obsAa		# 16-03-2021: masked
		# Plot:
		hist(snps$HWEchi2temp[snps$filter],breaks=seq(0,max(snps$HWEchi2temp[snps$filter],na.rm=TRUE)+10,0.5),xlim=c(0,20),ylim=c(0,nrow(snps[snps$filter,])),main="",xlab="",ylab="",col=mycolours[i])
		mtext(popnames[i],side=3,line=-2,cex=2)
		abline(v=qchisq(.95,df=1),lty=2)
		# Rename:
		# names(snps)[names(snps) == "nonmisstemp"]	<<- paste("n",popnames[i],sep = "_")
		# names(snps)[names(snps) == "obsAatemp"]	<<- paste("Aa",popnames[i],sep = "_")
		# 16-03-2021: masked two lines above
		names(snps)[names(snps) == "expAatemp"]		<<- paste("expAa",popnames[i],sep = "_")
		names(snps)[names(snps) == "Ftemp"] 		<<- paste("F",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEchi2temp"] 	<<- paste("HWEchi2",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEptemp"] 		<<- paste("HWEp",popnames[i],sep = "_")
		names(snps)[names(snps) == "HWEtemp"] 		<<- paste("HWE",popnames[i],sep = "_")
		names(snps)[names(snps) == "Hdeficittemp"]	<<- paste("Hdeficit",popnames[i],sep = "_")
		} 
	if(!is.null(export)){dev.off()}
	# results per population:
	nsnps		<- nrow(snps[snps$filter,])
	results		<- matrix(, nrow = (length(popnames)+1), ncol = 4)
	colnames(results)<- c("Equilibrium","Disequilibrium","He_deficit","He_surplus")
	rownames(results)<- c("metapop",as.vector(popnames))
	results[1,1]	<- nrow(snps[snps$HWE==TRUE&snps$filter,])/nsnps*100
	results[1,2]	<- nrow(snps[snps$HWE==FALSE&snps$filter,])/nsnps*100
	results[1,3]	<- nrow(snps[snps$HWE==FALSE&snps$filter&snps$Hdeficit==TRUE,])/nsnps*100
	results[1,4]	<- nrow(snps[snps$HWE==FALSE&snps$filter&snps$Hdeficit==FALSE,])/nsnps*100
	for (i in (1:length(popnames)))
		{
		myHWE		<- snps[,paste("HWE",popnames[i],sep="_")]
		myHdeficit	<- snps[,paste("Hdeficit",popnames[i],sep="_")]
		results[i+1,1]	<- nrow(snps[myHWE==TRUE&snps$filter,])/nsnps*100
		results[i+1,2]	<- nrow(snps[myHWE==FALSE&snps$filter,])/nsnps*100
		results[i+1,3]	<- nrow(snps[myHWE==FALSE&snps$filter&myHdeficit==TRUE,])/nsnps*100
		results[i+1,4]	<- nrow(snps[myHWE==FALSE&snps$filter&myHdeficit==FALSE,])/nsnps*100
		}
	mysambar$hwetable	<<- round(results,2)
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)] 
	}   	

wahlundplot<-function(export=NULL,popnames=mysambar$poporder,addlabels=TRUE,silent=TRUE,plotname="Wahlund_effect",addylabel=TRUE)
	{
	if(!silent){cat("Plotting locus-specific HWE score...",sep="\n")}
	fdf				<- snps[snps$filter,c("morgan","F_meta","HWE")]
	colnames(fdf)	<- c("pop","F","HWE")
	fdf$pop			<- "0_meta"
	npops			<- length(popnames)+1
	if(!silent){cat("Per population...",sep="\n")}
	for (j in c(1:(npops-1)))
		{
		mypop			<- popnames[j]
		if(!silent){cat(mypop,sep="\n")}
		fdfpop			<- snps[snps$filter,c("morgan",paste("F",mypop,sep="_"),paste("HWE",mypop,sep="_"))]
		colnames(fdfpop)<- c("pop","F","HWE")
		fdfpop$pop		<- paste(j,mypop,sep="_")
		fdf				<- as.data.frame(rbind(fdf,fdfpop))
		}
	fdf				<- fdf[!is.na(fdf$HWE)&is.finite(fdf$F),]
	fdfout			<- fdf[!fdf$HWE,]
	retainedpops	<- unique(fdf$pop)
	retainedpops	<- sapply(strsplit(retainedpops, "_"),"[",2)
	popbool			<- popnames%in%retainedpops
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=npops*mywidth2+200,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=npops*mywidth+2,height=6)}
		}
	par(oma=c(5,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
	boxplot(fdf$F~fdf$pop,border="white",col="white",las=2,xlab="",ylab="",cex.axis=1.5,pch=16,outline=TRUE,ylim=c(-1,1),names=c("metapop",popnames[popbool]))
	boxplot(fdf$F~fdf$pop,border=c("black",mysambar$colorder[popbool]),xlab="",ylab="",xaxt='n',yaxt='n',col="grey90",add=TRUE,outline=FALSE)
	if(length(as.vector(unique(fdfout$pop)))<(npops+1))
		{
		mypch	<- 1
		mycex	<- 0.25
		stripchart(F~pop,data=fdf,vertical=TRUE,method="jitter",pch=mypch,cex=mycex,xlab="",ylab="",col=c("black",mysambar$colorder[popbool]),bg="bisque",add=TRUE) 
		}else{
		# if possible show only loci significantly out of HWE
		mypch	<- 16
		mycex	<- 0.5
		stripchart(F~pop,data=fdfout,vertical=TRUE,method="jitter",pch=mypch,cex=mycex,xlab="",ylab="",col=c("black",mysambar$colorder[popbool]),bg="bisque",add=TRUE) 
		}
	if(addylabel)
		{	
		mtext(side=2,"F per SNP",line=3.25,cex=2,outer=TRUE,las=0)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

wahlundplot_old<-function(mysteps=0.05,export=NULL,popnames=mysambar$populations,addlabels=TRUE,silent=TRUE)
	{
	fislist			<- list()
	fislist2		<- list()
	ndatalist		<- list()
	npops			<- length(popnames)
	# for populations:
	for (j in c(1:npops))
		{
		mypop		<- popnames[j]
		if(!silent){cat(mypop,sep="\n")}
		myfis		<- snps[,paste("F",mypop,sep="_")]
		mymaf		<- snps[,paste("maf",mypop,sep="_")]
		myselection	<- is.finite(myfis)&snps$filter2
		if(any(myselection))
			{
			mybreaks	<- seq(0,1,mysteps)
			myhalf		<- mysteps/2
			mylabels	<- seq(myhalf,1-myhalf,mysteps)
			mafbins		<- cut(mymaf[myselection],mybreaks)
			# boxplot(myfis[myselection]~mafbins)
			fisperbin	<- aggregate(myfis[myselection],by=list(mafbins),FUN=mean) 
			nperbin		<- aggregate(myfis[myselection],by=list(mafbins),FUN=length)
			nbins		<- nrow(fisperbin)
			mylabels2	<- mylabels[1:nbins]
			fislist[[j]]	<- cbind(mylabels2,fisperbin$x) 
			fislist2[[j]]	<- fisperbin$x
			ndatalist[[j]]	<- nperbin$x
			}else{
			emptybins		<- seq(0,0.5,mysteps)
			zerodata		<- rep(0,length(emptybins))
			fislist[[j]]	<- cbind(emptybins,zerodata)
			fislist2[[j]]	<- zerodata
			ndatalist[[j]]	<- zerodata
			}
		}
	# for metapop:
	myfis		<- snps$F_meta
	mymaf		<- snps$maf
	myselection	<- is.finite(myfis)&snps$filter2
	mybreaks	<- seq(0,1,mysteps)
	myhalf		<- mysteps/2
	mylabels	<- seq(myhalf,1-myhalf,mysteps)
	mafbins		<- cut(mymaf[myselection],mybreaks)
	fisperbin	<- aggregate(myfis[myselection], by=list(mafbins),FUN=mean) 
	nperbin		<- aggregate(myfis[myselection], by=list(mafbins),FUN=length)
	nbins		<- nrow(fisperbin)
	mylabels2	<- mylabels[1:nbins]
	fislist[[npops+1]]	<- cbind(mylabels2,fisperbin$x) 
	ndatalist[[npops+1]]<- nperbin$x
	fislist2[[npops+1]]	<- fisperbin$x
	# define limit:
	myylim	<- c(-0.05,max(unlist(fislist2)))
	if(myylim[2]<=0)
		{
		myylim	<- c(min(unlist(fislist2)),0.03)
		}
	# plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Wahlund.eps",family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf("Wahlund.pdf",family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png("Wahlund.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("Wahlund.wmf",family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)	
	for (j in c(1:(npops+1)))
		{	
		if(j==4)
			{
			mycol		<- "black"
			myfis		<- fislist[[npops+1]]
			ndata		<- ndatalist[[npops+1]]
			}else{
			mycol		<- mysambar$mycolours[j]
			myfis		<- fislist[[j]]
			ndata		<- ndatalist[[j]]
			}
		if(j==1)
			{
			plot(myfis[ndata>100,],xlab="Locus specific maf",ylab="Locus specific Fis",xlim=c(0,1),ylim=myylim,col=mycol,type='b',lwd=3,pch=16)
			}else{
			points(myfis[ndata>100,],col=mycol,lwd=3,type='b',pch=16)
			}
		}
	abline(h=0,lty=2,lwd=1.5)
	if(addlabels)
		{
		mtext("He deficit",side=4,at=0.005,adj=0,line=0.5,cex=2)
		mtext("He excess",side=4,at=-0.005,adj=1,line=0.5,cex=2)
		}
	legend("topright",legend=c("metapop",popnames),fill=c("black",mysambar$mycolours),cex=2,bty="n")
	if(!is.null(export)){dev.off()}
	fislist<<-fislist
	}	

# Depends on StAMPP. Requires SambaR function 'do_heatmap'. 
ind_neimatrix<-function(export=NULL,doplot=FALSE,show_values=FALSE,textcex=1,textround=2)
		{
		# First create indstemp file with all samples clustered together per population:
		mymatrixtemp		<- as.matrix(mygenlight)
		mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		# 22-03-2022: remove reordering at this step (included now in plotindmatrix function):
		# indstemp			<- inds[order(inds$pop),]
		# pop(mygenlighttemp)	<- as.factor(indstemp$pop)
		# if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		#	{
		#	return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		#	}
		# neimatrix 						<- stamppNeisD(mygenlighttemp[indstemp$filter,snps$filter],pop=FALSE)
		# sambarfunction_findstructure:
		neimatrix 							<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=FALSE)
		neimatrix[!is.finite(neimatrix)]	<- NA
		colnames(neimatrix)					<- rownames(neimatrix)
		mysambar$indneimatrix				<<- neimatrix
		if(doplot)
			{
			do_heatmap(export_type=export,nbins=5,mymatrix=mysambar$indneimatrix,my_inds=inds,my_snps=snps,my_col="orange",exportname="Neimatrix.ind",addlab=TRUE,mytitle="Nei's genetic distance",showvalues=show_values,note_cex=textcex,note_round=textround)		
			do_heatmap(export_type=export,nbins=5,mymatrix=mysambar$indneimatrix,my_inds=inds,my_snps=snps,my_col="orange",exportname="Neimatrix.ind.withlegend",addlab=FALSE,mytitle="Nei's genetic distance",showvalues=show_values,note_cex=textcex,note_round=textround)
			}
		}

# 02-01-2023: still being used?
mat2df<-function(mymat=mysambar$indneimatrix)
	{
	myinds	<- rownames(mymat)
	ninds	<- length(myinds)
	neidf	<<- data.frame("name1"=rep(myinds,each=ninds),"name2"=rep(myinds,times=ninds),"dxy"=as.vector(mymat))
	}

# Function to convert a dataframe with pairwise sample scores into a 2D matrix, and optionally create heatmap using plotindmatrix function.
df2mat<-function(mydf=inds2,myinds=inds$nr,indnames=inds$name,nr_bins=6,mypops=inds$pop,myscore=NULL,doheatmap=FALSE,twosided=FALSE,above_diagonal=TRUE,exportprefix="Rawdistance_matrix.ind",plot_title="Uncorrected genetic distance (%)")
	{
	if(is.null(mydf))
		{
		return(cat("ERROR: specify an existing input dataframe.",sep="\n"))
		}
	if(is.null(myscore))
		{
		return(cat("ERROR: specify a column within the dataframe.",sep="\n"))
		}
	if(!myscore%in%colnames(mydf))
		{
		return(cat("ERROR: specified column does not occur within the specified dataframe.",sep="\n"))
		}	
	#
	ninds	<- length(myinds)
	if(twosided)
		{
		cat("Flag twosided is set to TRUE. Expects all sample pairs are listed twice in input dataframe (i.e., ind1-ind2 and ind2-ind1).",sep="\n")
		npairs	<- ninds*ninds
		if(nrow(mydf)!=npairs)
			{
			mydf	<<- mydf
			npairs	<<- npairs
			myinds	<<- myinds
			return(cat(paste("ERROR: Number of pairwise comparisons in input dataframe (",nrow(mydf),") does not correspond with expected number, based on specified individuals at myinds flag (",ninds,").",sep=""),sep="\n")) 
			}
		cat("Converting sample pair dataframe column to matrix...",sep="\n")
		mydf		<- mydf[order(mydf$name1,mydf$name2),]
		myscorevec	<- mydf[,myscore,drop=TRUE]	
		mymatrix	<- matrix(myscorevec,nrow=ninds,ncol=ninds,byrow=TRUE)
		if(above_diagonal)
			{
			cat("Storing data above diagonal.")
			mymatrix[lower.tri(mymatrix)]	<- NA
			}else{
			cat("Storing on both sides of diagonal.",sep="\n")
			}
		}else{
		mydf1	<- mydf[mydf$name1==mydf$name2,]
		mydf2	<- mydf[mydf$name1!=mydf$name2,]
		if(nrow(mydf1)>0)
			{
			cat("Input dataframe contains within-individual comparisons.",sep="\n")
			}
		npairs	<- (ninds*(ninds-1))/2
		if(nrow(mydf2)!=npairs)
		#if(nrow(mydf2)!=ninds&nrow(mydf1)>0)
			{
			return(cat(paste("ERROR: Number of pairwise comparisons in input dataframe (",nrow(mydf2),") does not correspond with expected number (n*(n-1))/2, with n = ",ninds,".",sep=""),sep="\n")) 
			}
		cat("Reordering data frames...",sep="\n")
		mydf1	<- mydf1[order(mydf1$name1),]
		mydf2	<- mydf2[order(mydf2$name1,mydf2$name2),]
		#
		cat("Converting sample pair dataframe column to matrix...",sep="\n")
		m2					<- matrix(NA,nrow=ninds,ncol=ninds)
		colnames(m2)		<- myinds
		rownames(m2)		<- myinds
		m2[lower.tri(m2)]	<- mydf2[,myscore,drop=TRUE]
		if(above_diagonal)
			{
			cat("Storing data above diagonal.")
			mymatrix		<- t(m2)
			}else{
			cat("Storing data below diagonal. Can be transformed into a dist object using the function 'as.dist()'.",sep="\n")
			mymatrix		<- m2
			}
		if(nrow(mydf1)>0)
			{
			cat("Adding within-individual scores to diagonal...",sep="\n")
			diag(mymatrix)	<- mydf1[,myscore,drop=TRUE]
			}else{
			cat("No within-individu scores detected.",sep="\n")
			}
		}
	rownames(mymatrix)	<-  indnames
	colnames(mymatrix)	<-	indnames
	#
	if(doheatmap)
		{
		# expects as input a MATRIX of ALL individuals (both retained and filtered out), in alphabetical order of sample names (similar as in inds dataframe).
		cat("Running plotindmatrix function...",sep="\n")
		mymatrix2					<- mymatrix
		mymatrix2[diag(mymatrix2)]	<- NA
		plotindmatrix(ind_matrix=mymatrix2,do_filter=TRUE,export_name=paste(exportprefix,"nr",sep="."),plottitle=plot_title,n_bins=nr_bins,export="pdf",bincol1="orange",bincol2="white",midbincol=NULL,,silent=TRUE,add_lab=TRUE,print_name=FALSE)
		plotindmatrix(ind_matrix=mymatrix2,do_filter=TRUE,export_name=paste(exportprefix,"name",sep="."),plottitle=plot_title,n_bins=nr_bins,export="pdf",bincol1="orange",bincol2="white",midbincol=NULL,,silent=TRUE,add_lab=TRUE,print_name=TRUE)
		cat("Distance matrices have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	return(mymatrix)
	}

# expects as input a MATRIX, with number of columns and rows equalling number of RETAINED individuals, in alphabetical order of sample names (similar as in inds dataframe).
# for example: mysambar$indneimatrix (generated with ind_neimatrix function) and mysambar$pimatrix (generated with calcpi and subsequently pidf2matrix function)  
plotindmatrix<-function(n_bins=5,do_filter=TRUE,show_values=FALSE,noteround=2,notecex=1,export=NULL,alphabet_order=FALSE,my_Breaks=NULL,bincol1="orange",bincol2="white",midbincol=NULL,add_lab=FALSE,legendcex=2,ind_matrix=mysambar$indneimatrix,export_name="Neimatrix.ind",plottitle=NULL,title_cex=2,title_line=1,silent=TRUE,print_name=FALSE,editordervec=NULL)
		{
		if(is.null(ind_matrix)){return(cat("ERROR: Please specify an existing matrix using the 'ind_matrix'-flag. In case you specified 'mysambar$indneimatrix', did you run the ind_neimatrix function?",sep="\n"))}
		if(is.null(export_name)){return(cat("ERROR: Please specify the name of the plot using the 'plotname'-flag.",sep="\n"))}
		ind_matrix	<- as.matrix(ind_matrix)
		if(do_filter)
			{
			if(length(inds$filter)!=nrow(ind_matrix))
				{
				if(length(inds$filter[inds$filter])==nrow(ind_matrix))
					{
					cat("WARNING: number of columns/rows of matrix specified to ind_matrix flag corresponds to number of retained individuals. Only plotting retained individuals.",sep="\n")
					}else{
					return(cat(paste("ERROR: number of columns/rows of matrix specified to ind_matrix flag (",nrow(ind_matrix),"), does not correspond with either total or retained number of individuals in inds dataframe.",sep=""),sep="\n"))
					}
				}else{
				cat("WARNING: the flag 'do_filter' is set to TRUE. Only plotting retained individuals.",sep="\n") 
				ind_matrix	<- ind_matrix[inds$filter,inds$filter]	# 02-01-2023
				inds		<- inds[inds$filter,]					# 02-01-2023
				}
			}
		# First reorder inds dataframe according to population:
		if(alphabet_order)
			{
			cat("Plotting samples in alphabetical order (because flag alphabet_order is set to TRUE).",sep="\n")
			indstemp			<- inds[order(inds$pop),]
			inputmat			<- ind_matrix[order(inds$pop),]	
			}else{
			cat("WARNING: attempting to reorder input matrix based on order defined at inds$poporder.",sep="\n")
			indstemp2			<- droplevels(inds[inds$filter,])
			indstemp2$filterorder<- c(1:nrow(indstemp2))
			indstemp			<- indstemp2[order(indstemp2$poporder),]
			belowdiag			<- ind_matrix[lower.tri(ind_matrix,diag=FALSE)]
			if(all(is.na(belowdiag)))
				{
				cat("WARNING: inputmatrix does not contain below diagonal values, needed for reordering. Mirroring above diagonal values to below diagonal values...",sep="\n")
				tmat			<- t(ind_matrix)
				ind_matrix[lower.tri(ind_matrix,diag=FALSE)]	<- tmat[lower.tri(tmat,diag=FALSE)]
				}
			inputmat			<- ind_matrix[indstemp$filterorder,indstemp$filterorder]
			}
		mysambar$indordermat	<<- inputmat 
		if(!is.null(editordervec))
			{
			cat("WARNING: reordering using user-specified vector to editordervec flag.")
			inputmat	<- inputmat[editordervec,editordervec]
			}
		export_name	<- paste(export_name,paste(n_bins,"bins",sep=""),sep=".")
		if(!silent){cat("Running do_heatmap function...",sep="\n")}
		do_heatmap(export_type=export,showvalues=show_values,note_round=noteround,note_cex=notecex,nbins=n_bins,mymatrix=inputmat,my_inds=indstemp,my_snps=snps,addlab=add_lab,legcex=legendcex,myBreaks=my_Breaks,my_col=bincol1,my_col2=bincol2,my_midcol=midbincol,exportname=export_name,mytitle=plottitle,titlecex=title_cex,titleline=title_line,printname=print_name)							 
		}

# expects as input a VECTOR for all pairwise comparisons between ALL individuals
plot_indmatrix<-function(export=NULL,indsfilter=TRUE,inputvalues=NULL,popnames=mysambar$populations,n_bins=5,mybreaks=NULL,legpos_x=0.1,legpos_y=0.45,leg_cex=2.5,matcol="orange",plotprefix="indmatrix",miss_labels=FALSE,currentdir=TRUE,plottitle="",silent=TRUE,perpop=FALSE,sub_title=NULL,make_global=FALSE)
	{
	# This function expects as input a vector with values for all pairwise comparisons between ALL individuals in the order 1-2,1-3,1-4,2-3,2-4,3-4 as example for a dataset of 4 individuals.
	# So: a vector with values for pairwise comparisons between retained individuals will lead to errors.
	if(is.null(inputvalues))
		{
		return(cat("ERROR: provide an input vector to inputvalues argument. Default is NULL.",sep="\n"))
		}
	# metapop:
	indstemp				<- inds
	nind					<- nrow(indstemp)
	npairwise				<- (nind*(nind-1))/2 
	if(length(inputvalues)!=npairwise)
		{
		cat(paste("ERROR: expected a vector of length ",npairwise,".",sep=""),sep="\n")
		return(cat(paste("Observed length of inputvalues vector is ",length(inputvalues),".",sep=""),sep="\n"))
		}
	myindmatrix 			<- matrix(NA,nrow=nind,ncol=nind)
	tempmatrix				<- myindmatrix
	tempmatrix[lower.tri(tempmatrix)]		<- round(inputvalues,3)
	myindmatrix								<- t(tempmatrix) 
	mynames2				<- as.character(inds$nr)							
	colnames(myindmatrix)	<- mynames2
	rownames(myindmatrix)	<- mynames2
	mysambar$ind_matrix		<<- myindmatrix 
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(myindmatrix,na.rm=TRUE),1)
	if(max(myindmatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(myindmatrix,na.rm=TRUE),1)
		}
	if(is.null(mybreaks))
		{
		binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
		mybreaks	<- seq(mymin,mymax,binsize)
		}
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	inds_all			<- inds_reordered
	inds_all$filter		<- TRUE
	indmatrix_3			<- myindmatrix[order(indstemp$pop),order(indstemp$pop)]
	indmatrix_4			<- t(indmatrix_3)
	indmatrix_3[is.na(indmatrix_3)&upper.tri(indmatrix_3)] <- indmatrix_4[!is.na(indmatrix_4)&upper.tri(indmatrix_4)]
	indmatrix_3[lower.tri(indmatrix_3)]	<- NA
	myindmatrix_reordered<- indmatrix_3
	#
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=myindmatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.no_axis",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex,subtitle=sub_title)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=myindmatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.indnr",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)		
	if(miss_labels)
		{
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=myindmatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,misslabels=TRUE,exportname=paste(plotprefix,"metapop.miss",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
		}
	if(indsfilter)
		{
		# filtered:
		indstemp		<- inds[inds$filter,]
		inds_all		<- indstemp[order(indstemp$pop),]						
		indfiltermat	<- myindmatrix[inds$filter,inds$filter]	
		indmatrix_3		<- indfiltermat[order(indstemp$pop),order(indstemp$pop)]
		indmatrix_4		<- t(indmatrix_3)
		indmatrix_3[is.na(indmatrix_3)&upper.tri(indmatrix_3)] <- indmatrix_4[!is.na(indmatrix_4)&upper.tri(indmatrix_4)]
		indmatrix_3[lower.tri(indmatrix_3)]	<- NA
		indfiltermat	<- indmatrix_3
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=indfiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.filter.no_axis",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=indfiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.filter.indr",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
		if(miss_labels)
			{
			do_heatmap(export_type=export,nbins=n_bins,mymatrix=indfiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,misslabels=TRUE,exportname=paste(plotprefix,"metapop.filter.miss",sep="."),mytitle=plottitle,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
			}
		#
		# for each population:
		if(perpop)
			{
			if(!silent){cat("Generating matrices for each population separately...",sep="\n")}
			for (mypop in popnames)
				{
				if(!silent){cat(mypop,sep="\n")}
				popfilter		<- inds$filter&inds$pop==mypop
				npopind			<- length(popfilter[popfilter])
				if(npopind<2)
					{
					if(!silent){cat("Less than 2 retained individuals. Omitting matrix.",sep="\n")}
					}else{
					popmatrix		<- myindmatrix[popfilter,popfilter]
					indspop			<- inds[popfilter,]
					do_heatmap(export_type=export,nbins=n_bins,mymatrix=popmatrix,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
					do_heatmap(export_type=export,nbins=n_bins,mymatrix=popmatrix,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,mypop,"indnr",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
					if(miss_labels)
						{
						do_heatmap(export_type=export,nbins=n_bins,mymatrix=popmatrix,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,misslabels=TRUE,exportname=paste(plotprefix,mypop,"miss",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y,legcex=leg_cex)
						}
					}
				}
			}
		}
	if(!is.null(export)&!silent)
		{
		cat("Matrix heatmaps have been exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(!silent)	
		{
		cat("Note that the position and size of the legend can be editted with the 'legpos_x', 'legpos_y' and 'leg_cex' arguments. The number of bins can be editted with the 'n_bins' argument.",sep="\n")
		cat("The colour tone of the matrix can be editted with the argument 'matcol'. Default is 'orange'.",sep="\n")
		}
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}


# phylogenetic tree
# requires the package 'Ape'
# Still need to find out how to assign the right colour codes to the tips
# Tree does not reflect population structure accurately, so decided not to use it. 
apetree<-function(mymatrix=mysambar$indneimatrix,my_inds=inds)
	{
	colnames(mymatrix)	<- my_inds$pop[my_inds$filter]
	colnames(mymatrix)	<- my_inds$pop[my_inds$filter]
	mytree				<- nj(mymatrix)
	plot(mytree,edge.color=my_inds$popcol[my_inds$filter],cex=0.5)
	}		

# 28-03-2022: which method or distance performs best?
# depends on getindtree 
comparetrees<-function(do_analysis=FALSE,export=NULL,subtitle=NULL,do_parsimony=TRUE,do_likelihood=TRUE,pathlength_domean=FALSE)
	{
	if(do_analysis)
		{
		#mydistances<- c('bitwise.dist','euclidean','ASD','pi','nei.dist','edwards.dist','reynolds.dist')
		mydistances	<- c('bitwise.dist','euclidean','ASD','pi','nei.dist','edwards.dist','reynolds.dist')
		mymethods	<- c('upgma','BME','OLS','NJ','bionj','ward.D','ward.D2')
		#mymethods	<- c('upgma','NJ','bionj')
		#mydistances	<- c('bitwise.dist','pi')
		ndistances	<- length(mydistances)
		nmethods	<- length(mymethods)
		#
		pmatrix_dist		<<- matrix(NA,nrow=ndistances,ncol=nmethods)
		colnames(pmatrix_dist)	<<- mymethods
		rownames(pmatrix_dist)	<<- mydistances
		pmatrix_scaled		<<- pmatrix_dist			# unscaled parsimony score of distance-based tree
		pmatrix_mp			<<- pmatrix_dist			# parsimony score of maximum parsimony tree based on NNI and SSR algorithms
		lmatrix_dist		<<- pmatrix_dist
		lmatrix_mp			<<- pmatrix_dist
		dmatrix_dist		<<- pmatrix_dist
		#
		for(distancenr in c(1:ndistances))
			{
			for(methodnr in c(1:nmethods))
				{
				mysambar$mytree_parsimony_scaled	<<- NA
				mysambar$mytree_parsimony			<<- NA
				mysambar$mytree_loglik				<<- NA
				mysambar$mytree						<<- NULL
				mysambar$mytree_distmat				<<- NULL
				#
				cat(paste("Distance: ",distancenr,"; Method: ",methodnr,".",sep=""),sep="\n")
				my_distance		<- mydistances[distancenr]
				my_method		<- mymethods[methodnr]
				cat(my_distance,sep="\n")
				cat(my_method,sep="\n")
				if(my_distance=="edwards.dist"|my_distance=="reynolds.dist")
					{
					getindtree(export=NULL,do_analysis=TRUE,mymethod=my_method,mydistance=my_distance,silent=FALSE,nbootstrap=1)
					}else{
					getindtree(export=NULL,do_analysis=TRUE,mymethod=my_method,mydistance=my_distance,silent=FALSE)
					}
				#
				pmatrix_scaled[distancenr,methodnr]	<<- mysambar$mytree_parsimony_scaled
				pmatrix_dist[distancenr,methodnr]	<<- mysambar$mytree_parsimony
				lmatrix_dist[distancenr,methodnr]	<<- mysambar$mytree_loglik
				#
				if(!is.null(mysambar$mytree)&!is.null(mysambar$mytree_distmat))
					{
					cat("Calculating difference between path length and genetic distance...",sep="\n")
					pathlength(mytree=mysambar$mytree,exporttype="pdf",plot_name=paste("Pathlengths",my_distance,my_method,sep="."),distancemat=mysambar$mytree_distmat,domean=pathlength_domean)
					dmatrix_dist[distancenr,methodnr]<<- mysambar$mytree_diffscore
					}
				if(!is.null(mysambar$mytree))
					{
					if(do_parsimony)
						{
						cat("Searching maximum parsimony tree using NNI and SPR algorithms...",sep="\n")
						myphydat						<- phyDat(data=mysambar$mydnabin,type="DNA",levels=NULL,return.index=TRUE)
						mytree_optim 					<- phangorn::optim.parsimony(tree=mysambar$mytree,data=myphydat)
						pmatrix_mp[distancenr,methodnr]	<<- phangorn::parsimony(tree=mytree_optim,data=myphydat,method="fitch")
						}
					if(do_likelihood)
						{
						cat("Calculating likelihood of MP tree...",sep="\n")
						# Error in phangorn::pml(tree = mytree_optim, data = myphydat) : tree must have edge weights
						myfit							<- phangorn::pml(tree=mytree_optim,data=myphydat)
						lmatrix_mp[distancenr,methodnr]<<- logLik(myfit)[1]
						}
					}			
				}
			}
		if(do_parsimony)
			{
			cat("Searching maximum parsimony tree using ratchet algorithm...",sep="\n")
			# No input tree required as start point:
			mytree_pratchet <- phangorn::pratchet(data=myphydat)
			ratchetscore	<- phangorn::parsimony(tree=mytree_pratchet,data=myphydat,method="fitch")
			cat(ratchetscore,sep="\n")
			}
		#
		mysambar$parsimonymatrix_dist	<<- pmatrix_dist
		mysambar$parsimonymatrix_mp		<<- pmatrix_mp
		mysambar$loglikmatrix_dist		<<- lmatrix_dist
		#mysambar$loglikmatrix_mp		<<- lmatrix_mp
		mysambar$dmatrix_dist			<<- dmatrix_dist
		cat("Finished generating trees. Log-likelihood values and parsimony scores stored in matrices 'lmatrix_dist', 'pmatrix_mp' and 'pmatrix_dist'.",sep="\n") 
		#
		write.table(pmatrix_dist,"Trees_parsimony_scores_distancetrees.txt",sep="\t",quote=FALSE,row.names=TRUE,col.names=TRUE)
		write.table(pmatrix_mp,"Trees_parsimony_scores_MPtrees.txt",sep="\t",quote=FALSE,row.names=TRUE,col.names=TRUE)
		write.table(lmatrix_dist,"Trees_likelihood_scores_distancetrees.txt",sep="\t",quote=FALSE,row.names=TRUE,col.names=TRUE)
		#write.table(lmatrix_mp,"Trees_likelihood_scores_MPtrees.txt",sep="\t",quote=FALSE,row.names=TRUE,col.names=TRUE)
		cat("Tables with parsimony scores written to directory:",sep="\t")
		cat(getwd(),sep="\n")
		}
	#
	for(j in c(1:3))
		{
		if(j==2)
			{
			if(do_parsimony)
				{
				mymatrix2		<- mysambar$parsimonymatrix_dist			# used for cellnote
				mymatrix		<- mysambar$parsimonymatrix_dist			# used for colour coding
				exportname		<- "Trees_parsimony_scores_distancetrees"
				plottitle		<- "Parsimony score"
				mycolfunc 		<- colorRampPalette(c("orange","white"))
				cat("Creating heatmaps with parsimony scores...",sep="\n")
				}else{
				return(cat("Not plotting parsimony scores because flag do_parsimony is set to FALSE.",sep="\n"))
				}
			}
		if(j==3)
			{
			if(do_likelihood)
				{
				mymatrix2		<- round(mysambar$loglikmatrix_dist)
				mymatrix		<- round(mysambar$loglikmatrix_dist)
				#mymatrix[2,]	<- NA			
				#mymatrix[6,]	<- NA
				#mymatrix[7,]	<- NA
				exportname		<- "Trees_likelihood_scores_distancetrees"
				plottitle		<- "Log-likelihood"
				mycolfunc 		<- colorRampPalette(c("white","orange"))
				cat("Creating heatmaps with likelihood scores...",sep="\n")
				}else{
				return(cat("Not plotting likelihood scores because flag do_likelihood is set to FALSE.",sep="\n"))
				}
			}
		if(j==1)
			{
			mymatrix2		<- round(mysambar$dmatrix_dist)
			mymatrix		<- round(mysambar$dmatrix_dist)
			exportname		<- "Trees_diff_scores_distancetrees"
			plottitle		<- "|(pathlength-distance)/pathlength|"
			mycolfunc 		<- colorRampPalette(c("orange","white"))
			cat("Creating heatmaps showing difference between path lengths and actual distances...",sep="\n")
			}
		if(all(is.na(mymatrix2)))
			{
			return(cat("ERROR: no non-NA values in input matrix.",sep="\n"))
			}
		mymin			<- min(mymatrix,na.rm=TRUE)
		mymax			<- max(mymatrix,na.rm=TRUE)
		myBreaks		<- seq(mymin,mymax,10)
		myColours		<- c(mycolfunc(length(myBreaks)-1))		
		if(!is.null(export))
			{
			mywidth		<- 10
			mywidth2	<- 720
			if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
			if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
			if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
			}
		heatmap.2(mymatrix2,cellnote=mymatrix2,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
		notecol="black",notecex=1.5,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
		ylab="",xlab="",srtRow=45,srtCol=45,key=FALSE,margins=c(8,8))
		mtext(plottitle, side = 3, line = 1.5, cex = 3)
		if(!is.null(subtitle)){mtext(subtitle, side = 3, line = -0.5, cex = 2)}
		mtext("clustering method", side = 1, cex = 2, line = 3.5)
		mtext("distance measure", side = 4, cex = 2, line = 0.5)
		if(!is.null(export)){dev.off()}
		}
	}

# 30-03-2022: depends on getindtree function
mptree<-function(mpsearch="NNI",starttree=NULL,starttree_distance=NULL,starttree_method=NULL)
	{
	if(!(mpsearch=="NNI"|mpsearch=="ratchet"))
		{
		return(cat("ERROR: mpsearch-flag accepts: 'NNI' or 'ratchet'.",sep="\n"))
		}
	# convert genlight to DNAbin:
	if(is.null(mysambar$mydnabin))
		{
		cat("DNAbin object not found. Generating...",sep="\n")
		genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
		}else{
		if(dim(mysambar$mydnabin)[1]!=nrow(inds[inds$filter,])|dim(mysambar$mydnabin)[2]!=nrow(snps[snps$filter,]))
			{
			cat("Dimensions of DNAbin object stored at mysambar$mydnabin do not correspond with number of retained individuals and/or number of retained snps. Overwriting...",sep="\n")
			genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
			}else{
			cat("WARNING: using existing DNAbin object stored at mysambar$mydnabin.",sep="\n")
			}
		}
	myphydat<-phyDat(data=mysambar$mydnabin,type="DNA",levels=NULL,return.index=TRUE)
	if(mpsearch=="NNI")
		{
		# find maximum parsimony tree using nearest-neighbor interchange (NNI) and subtree pruning and regrafting (SPR):
		cat("Searching maximum parsimony tree using NNI and SPR algorithms...",sep="\n")
		if(is.null(starttree))
			{
			return(cat("ERROR: define to the starttree flag an input tree as startpoint for the heuristic search.",sep="\n"))
			}
		if(is.null(starttree_distance))
			{
			return(cat("ERROR: define to the starttree_distance flag the distance measure used to generate the input tree.",sep="\n"))
			}
		if(is.null(starttree_method))
			{
			return(cat("ERROR: define to the starttree_method flag the clustering method used to generate the input tree.",sep="\n"))
			}
		mytree_optim <- phangorn::optim.parsimony(tree=starttree,data=myphydat)
		getindtree(export="pdf",plotname="Tree_MaximumParsimony_NNI_SPR",mydistance=starttree_distance,mymethod=starttree_method,do_analysis=FALSE,inputtree=mytree_optim,mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,calc_likelihood=FALSE)
		# likelihood score can not be calculated. Results in: Error in phangorn::pml(tree = mytree, data = myphydat) : tree must have edge weights
		}
	if(mpsearch=="ratchet")
		{
		# find maximum parsimony tree using parsimony ratchet algorithm:
		# no input tree needed
		cat("Searching maximum parsimony tree using ratchet algorithm...",sep="\n")
		mytree_pratchet <- phangorn::pratchet(data=myphydat)
		# the getindtree function 
		getindtree(export="pdf",plotname="Tree_MaximumParsimony_ratchet",fullplotname=FALSE,mydistance="pi",mymethod="NJ",do_analysis=FALSE,inputtree=mytree_pratchet,mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=0.8,calc_likelihood=FALSE)
		# likelihood score can not be calculated. Results in: Error in phangorn::pml(tree = mytree, data = myphydat) : tree must have edge weights
		}
	}				

# 30-03-2022: depends on getindtree function
mltree<-function(starttree=NULL,starttree_distance=NULL,starttree_method=NULL,dobootstrap=FALSE,mutationmodel="JC")
	{
	if(is.null(starttree))
		{
		return(cat("ERROR: define to the starttree flag an input tree as startpoint for the heuristic search.",sep="\n"))
		}
	if(is.null(starttree_distance))
		{
		return(cat("ERROR: define to the starttree_distance flag the distance measure used to generate the input tree.",sep="\n"))
		}
	if(is.null(starttree_method))
		{
		return(cat("ERROR: define to the starttree_method flag the clustering method used to generate the input tree.",sep="\n"))
		}
	# convert genlight to DNAbin:
	if(is.null(mysambar$mydnabin))
		{
		cat("DNAbin object not found. Generating...",sep="\n")
		genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
		}else{
		if(dim(mysambar$mydnabin)[1]!=nrow(inds[inds$filter,])|dim(mysambar$mydnabin)[2]!=nrow(snps[snps$filter,]))
			{
			cat("Dimensions of DNAbin object stored at mysambar$mydnabin do not corresponds with number of retained individuals are not number of retained snps. Overwriting...",sep="\n")
			}else{
			cat("WARNING: using existing DNAbin object stored at mysambar$mydnabin.",sep="\n")
			}
		}
	cat("Calculating likelihood of input tree...",sep="\n")
	myphydat		<- phyDat(data=mysambar$mydnabin,type="DNA",levels=NULL,return.index=TRUE)
	mytreefit 		<- phangorn::pml(tree=pi_ward2_tree,data=myphydat)
	# find maximum likelihood tree (computationally heavy): 
	cat("Searching maximum likelihood tree...",sep="\n")
	mytreefitJC 	<- phangorn::optim.pml(mytreefit,model=mutationmodel,rearrangement="stochastic")
	getindtree(export="pdf",plotname="Tree_MaximumLikelihood",mydistance=starttree_distance,mymethod=starttree_method,do_analysis=FALSE,inputtree=mytreefitJC$tree,mytype="unrooted",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=3,addnodelabels=TRUE,maxnodelabel=0.8)
	#
	if(dobootstrap)
		{
		# create list with bootstrapped trees (relatively fast compared to optim.pml):
		multi_core	<- ifelse(mysambar$os=="Windows",FALSE,TRUE)		# multicore not supported on Windows.
		bs 			<- phangorn::bootstrap.pml(mytreefitJC,bs=100,optNni=TRUE,multicore=multi_core,control=pml.control(trace=0))
		plotBS(midpoint(mytreefitJC$tree),bs,p=50,type="p")
		# Not sure yet how to include bootstrap values. bs is a list of trees. How to get the information how many times roots are supported? 
		}
	}

# 05-10-2022: under construction
plotconsensusnetwork<-function(treelist=genometreelist,distmat=NULL)
	{
	class(treelist) <- "multiPhylo"
	cnet 			<- consensusNet(treelist,0.3)
	plot(cnet)
	#
	# add edge weights: 
	cnet 			<- nnls.networx(cnet,distmat)
	par("mar" = rep(1, 4))
	plot(cnet, show.edge.label=TRUE)
	}

# 28-08-2023:
popnetwork<-function(mydistmat=mymat,popnames=mysambar$poporder,popcolors=mysambar$colorder,do_analysis=TRUE,plotname="Phylonetwork_neighbornet_pop",mylwd=0.25,doexport=FALSE,mynetwork=NULL,edgecolors=TRUE,tipcolor="black",silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1.5,addlegend=FALSE,legendpos="bottomright",legendcex=1.25,shortenfactor=1,showlength=TRUE,docompare=FALSE)
	{
	# Bryant, D. & Moulton, V. (2004) Neighbor-Net: An Agglomerative Method for the Construction of Phylogenetic Networks. Molecular Biology and Evolution, 2004, 21, 255-265
	#
	if(do_analysis)
		{
		if(any(class(mydistmat)=="dist"))
			{
			cat("Specified input matrix is of class 'dist'.",sep="\n")
			distmat			<- mydistmat
			}else{
			cat("Converting to class 'dist'.",sep="\n")
			distmat			<- as.dist(t(mydistmat))
			}
		if(any(!colnames(as.matrix(distmat))%in%popnames))
			{
			return(cat("ERROR: not all populations in input distance matrix are present in vector specified to popnames flag.",sep="\n"))
			}
		if(any(!popnames%in%colnames(as.matrix(distmat))))
			{
			return(cat("ERROR: not all populations specified to popnames flag are present in distance matrix.",sep="\n"))
			}
		cat("Running neighbornet analyses. This may take a while...",sep="\n") 
		mysambar$phylonetwork<<- phangorn::neighborNet(distmat)
		cat("Neighbour network stored at mysambar$phylonetwork.",sep="\n")
		mynetwork			<- mysambar$phylonetwork
		}
	# plot.networx from phangorn package
	# By default, labels are horizontal. In other words, the option 'lab4ut="axial"' is not available.
	# Therefore, I decided to add the labels afterwards
	# However, in order to have enough space for the labels (otherwise they are cut-off), we still add the labels (but 'invisibly': in white, against a white background)
	# The downside is that some lines are interrupted by the white tip labels.
	# A better solution would be to set the margins, but igraph overrules mar settings
	#
	npops		<- length(popnames)
	popordervec	<- vector()
	for(i in c(1:npops))
		{
		popordervec[i]	<- which(popnames%in%mynetwork$tip.label[i])
		}
	popnames2	<- popnames[popordervec]
	popcolors2	<- popcolors[popordervec]
	#
	# phangorn::plot.networx
	myplot		<- plot(mynetwork,type="equal angle",edge.width=mylwd,show.tip.label=TRUE,use.edge.length=showlength,edge.color="black",cex=labelcex,tip.color=mybg)
	# OPTIONALLY, TO ZOOM IN ON RETICULATION, SHORTEN EXTERNAL BRANCHES:
	if(shortenfactor<1)
		{
		cat("WARNING: shortening external branches!",sep="\n")
		myplot$.plot$vertices[1:npops,1]	<- myplot$.plot$vertices[1:npops,1]*shortenfactor
		myplot$.plot$vertices[1:npops,2]	<- myplot$.plot$vertices[1:npops,2]*shortenfactor
		}
	if(doexport){pdf(paste(plotname,paste("labelcex",labelcex,sep=""),paste("zoom",shortenfactor,sep=""),"pdf",sep="."),width=12,height=12)}
	par(bg=mybg)
	plot(myplot,type="equal angle",edge.width=mylwd,show.tip.label=TRUE,use.edge.length=TRUE,edge.color="black",cex=labelcex,tip.color=mybg)
	if(dolabels)
		{
		myplot2	<- myplot$.plot
		xvalues	<- myplot2$vertices[1:npops,1]
		yvalues	<- myplot2$vertices[1:npops,2]
		myradius<- atan(yvalues/xvalues)
		mydegree<- myradius*(180/pi)
		myadj	<- ifelse(xvalues>0,ifelse(yvalues>0,c(0,0),c(0,0)),ifelse(yvalues>0,c(1,1),c(1,1)))
		#invert labels:
		#myadj	<- ifelse(xvalues<0,ifelse(yvalues<0,c(0,0),c(0,0)),ifelse(yvalues<0,c(1,1),c(1,1)))
		for(k in c(1:npops))
			{
			text(xvalues[k],yvalues[k],popnames2[k],pch=16,col=popcolors2[k],cex=labelcex,srt=mydegree[k],adj=myadj[k])
			}
		}
	if(addlegend){legend(legendpos,legend=popnames,fill=popcolors,border=popcolors,bty="n",cex=legendcex)}
	if(doexport)
		{
		dev.off()
		cat("Phylonetwork has been exported to directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(docompare)
		{
		# 24-02-2024: not working yet
		# attempt to show corresponding edges in tree and network	
		# tip labels of network are not in alphabetical order
		# whereas tip labels of tree are
		# does this explain why edge labels are not corresponding?	
		# mytree	<- upgma(mydistmat)
		mytree		<- nj(mydistmat)
		# create a vector of labels for the network corresponding to edges in the tree
		edge.lab <- createLabel(mynetwork,mytree,mytree$edge[,2],"edge")
		# find edges that are in the network but not in the tree
		edge.col 					<- rep("black", nrow(mynetwork$edge))
		edge.col[is.na(edge.lab) ] 	<- "red"
		# instead of above two commands, this also works:
		# edge.col <- createLabel(mynetwork,mytree,"black",nomatch="red")
		#
		# plot trees and network alongside each other showing corresponding edges: 
		#mycex		<- 0.3
		mycex		<- 0.5
		pdf("Phylonetwork_vs_tree.pdf",width=10,height=5)
		par(mfrow=c(1,2),mar=c(1,1,1,1),oma=c(1,1,1,1))
		plot(mytree,type="unrooted")	# rotate.tree=180
		edgelabels(frame="n",col="blue",cex=mycex)
		nodelabels(frame="n",col="green",cex=mycex)
		tiplabels(frame="n",col="green")
		plot(mynetwork,show.edge.label=TRUE,"2D",show.node.label=TRUE,edge.color=edge.col,col.node.label="green",cex.node.label=mycex,col.edge.label="blue",cex.edge.label=mycex,edge.width=0.1)
		dev.off()
		}
	
	}

# 05-10-2022:
neighbournetwork<-function(mydistmat=mymat,do_analysis=TRUE,plotname="Phylonetwork_neighbornet",mylwd=0.5,doexport=FALSE,mynetwork=NULL,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1,addlegend=TRUE,legendpos="bottomright",legendcex=1.25)
	{
	# Bryant, D. & Moulton, V. (2004) Neighbor-Net: An Agglomerative Method for the Construction of Phylogenetic Networks. Molecular Biology and Evolution, 2004, 21, 255-265
	#
	if(do_analysis)
		{
		if(any(class(mydistmat)=="dist"))
			{
			cat("Specified input matrix is of class 'dist'.",sep="\n")
			distmat			<- mydistmat
			}else{
			cat("Converting to class 'dist'.",sep="\n")
			distmat			<- as.dist(t(mydistmat))
			}
		cat("Running neighbornet analyses. This may take a while...",sep="\n") 
		mysambar$phylonetwork<<- phangorn::neighborNet(distmat)
		cat("Neighbour network stored at mysambar$phylonetwork.",sep="\n")
		mynetwork			<- mysambar$phylonetwork
		}else{
		if(is.null(mynetwork))
			{
			return(cat("ERROR: specify a phylonetwork object to the mynetwork flag, or alternatively set the do_analysis flag to true and specify an input matrix to the mydistmat flag.",sep="\n"))
			}
		cat("WARNING: because flag 'do_analysis' is set to FALSE, using input network specified to mynetwork flag.",sep="\n")
		if(any(!mynetwork$tip.label%in%inds$name[inds$filter]))
			{
			return(cat("ERROR: one or more tiplabels in input network not present in inds$name[inds$filter].",sep="\n"))
			}
		}
	if(!any(class(mynetwork)=="networx"))
		{
		return(cat("ERROR: object specified to the mynetwork flag needs to be of class 'networx'.",sep="\n"))
		}
	ninds					<- length(mynetwork$tip.label)
	#mycolors2 				<- rep("black",Nedge(mynetwork))
	mycolors2				<- rep("black",nrow(mynetwork$edge))	# 25-10-2023
	if(edgecolors)
		{
		if(!silent){cat("Defining edge colours...",sep="\n")}
		indordervec			<- vector()
		for(i in c(1:ninds))
			{
			indordervec[i]	<- which(inds$name%in%mynetwork$tip.label[i])
			}
		my_colours			<- inds$popcol[indordervec]
		my_indlabels		<- inds$name[indordervec]
		tipindex			<- which(mynetwork$edge[,2]%in%c(1:ninds))
		indorder			<- mynetwork$edge[tipindex,2]
		my_colours2			<- my_colours[indorder]
		mycolors2[tipindex]	<- my_colours2
		}
	plotname	<- ifelse(addlegend,paste(plotname,"withlegend",sep="_"),plotname)
	plotname	<- ifelse(mybg=="white",plotname,paste(plotname,mybg,sep="_"))
	if(doexport){pdf(paste(plotname,labelcex,"pdf",sep="."),width=12,height=12)}
	par(bg=mybg)
	# plot.networx from phangorn package
	# By default, labels are horizontal
	# Therefore, I decided to add the labels afterwards
	# However, in order to have enough space for the labels (otherwise they are cut-off), we still add the labels (but 'invisibly': in white, against a white background)
	# The downside is that some lines are interrupted by the white tip labels.
	# A better solution would be to set the margins, but igraph overrules mar settings
	myplot	<- plot(mynetwork,type="equal angle",edge.width=mylwd,show.tip.label=TRUE,use.edge.length=TRUE,edge.color=mycolors2,cex=labelcex,tip.color=mybg)
	if(dolabels)
		{
		myplot2	<- myplot$.plot
		xvalues	<- myplot2$vertices[1:ninds,1]
		yvalues	<- myplot2$vertices[1:ninds,2]
		myradius<- atan(yvalues/xvalues)
		mydegree<- myradius*(180/pi)
		myadj	<- ifelse(xvalues>0,ifelse(yvalues>0,c(0,0),c(0,0)),ifelse(yvalues>0,c(1,1),c(1,1)))
		for(k in c(1:ninds))
			{
			text(xvalues[k],yvalues[k],my_indlabels[k],pch=16,col=my_colours[k],cex=labelcex,srt=mydegree[k],adj=myadj[k])
			}
		}
	if(addlegend){legend(legendpos,legend=mysambar$poporder,fill=mysambar$colorder,border=mysambar$colorder,bty="n",cex=legendcex)}
	if(doexport)
		{
		dev.off()
		cat("Phylonetwork has been exported to directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}



popprtree<-function(export=NULL,do_analysis=TRUE,mymethod="upgma",mydistance="bitwise.dist",legendpos=NULL,legendcex=1.5,makelinear=FALSE,mutrate=NULL,genomeprop=1,interval_col="lightblue",interval_lwd=3,myrect=NULL,rectcol=NULL,recttext=NULL,mytype="phylogram",printnodes=FALSE,nodedf=NULL,addscale=TRUE,mybg="white",heightfac=0.15,nbootstrap=0,axiscex=2,mycolours=NULL,genofilter=FALSE,plotname="Tree_DistanceBased",fullplotname=TRUE,plottitle=NULL,titlecex=3,myxlim=NULL,titleline=-11,labelcex=1,nodelabelcex=1,myadj=0,myfont=3,mylwd=1,labelangle="horizontal",tiplabels=TRUE,addnodelabels=TRUE,marknode=FALSE,marklabelcex=0.75,edgecolors=TRUE,maxnodelabel=80,nodelabelcol="grey50",showpop=FALSE,tree_angle=0,mydirection="rightwards",nshorten=0,silent=TRUE,calc_parsimony=TRUE,calc_likelihood=TRUE,dopathlength=FALSE,pathlengthbreaks=NULL,inputdistmat=NULL,inputtree=mysambar$mytree,inputnewickfile=NULL,inputnexusfile=NULL,drop_ind=NULL,ann_df=NULL,ann_legend=TRUE,ann_legendpos="bottomleft",use_ggtree=FALSE,do_append=FALSE)
	{
	return(cat("ERROR: from SambaR version 1.09 onwards, the 'popprtree' function has been renamed to 'getindtree' function.",sep="\n"))
	}

# 20-01-2023 (Sambar_v1.09.txt onwards): renamed from popprtree to getindtree
getindtree<-function(export=NULL,do_analysis=TRUE,mymethod="upgma",mydistance="bitwise.dist",legendpos=NULL,legendcex=1.5,makelinear=FALSE,addranges=TRUE,mutrate=NULL,errorrate=NULL,genomeprop=1,interval_col="lightblue",interval_lwd=3,myrect=NULL,rectcol=NULL,recttext=NULL,mytype="phylogram",printnodes=FALSE,nodedf=NULL,addscale=TRUE,addaxis=TRUE,mybg="white",heightfac=0.15,nbootstrap=0,axiscex=2,mycolours=NULL,genofilter=FALSE,plotname="Tree_DistanceBased",fullplotname=TRUE,plottitle=NULL,titlecex=3,myxlim=NULL,titleline=-11,labelcex=1,nodelabelcex=1,myadj=0,myfont=3,mylwd=1,labelangle="axial",tiplabels=TRUE,tipdots=FALSE,dotcex=3,dotpch=21,addnodelabels=TRUE,marknode=FALSE,marklabelcex=0.75,edgecolors=TRUE,maxnodelabel=80,nodelabelcol="grey50",showpop=FALSE,tree_angle=0,mydirection="rightwards",nshorten=0,silent=TRUE,calc_parsimony=FALSE,calc_likelihood=FALSE,dopathlength=FALSE,pathlength_domean=FALSE,matrixlabels=FALSE,pathlengthbreaks=NULL,inputdistmat=NULL,inputtree=mysambar$mytree,inputnewickfile=NULL,inputnexusfile=NULL,drop_ind=NULL,ann_df=NULL,ann_legend=TRUE,ann_legendpos="bottomleft",use_ggtree=FALSE,do_append=FALSE,rotatevec=NULL,myylabel="Genetic distance")
	{
	# type can be: "phylogram" (default), "cladogram", "fan", "unrooted", "radial"
	# distance can be 'bitwise.dist' (default, which is Hamming's distance), 'euclidean', 'allele sharing distance', 'pi', 'nei.dist', 'rogers.dist', 'edwards.dist', 'reynolds.dist'
	#
	# ASD			= allele sharing distance, calculated by SambaR's calcpi function
	# pi			= raw sequence dissimilarity, calculated by SambaR's calcpi function
	# bitwise.dist 	= Hamming's distance
	# euclidean		= sqrt(sum((p1-p2)^2))
	# nei.dist		= Nei's genetic distance
	# reynolds.dist = Reynolds, Weir and Cockerham's genetic distance
	# edwards.dist 	= Cavalli-Sforza and Edwards measure
	#
	# mymethod can be be either: 
	# ape and poppr: 			'NJ', 'bionj', 'upgma', 'BME' (balanced minimum evolution), 'OLS' (ordinary least squares), 'ratchet', 'NNI' (the latter two maximum parsimony)
	# hclust (stats package):	'ward.D', 'ward.D2', 'complete', 'single', 'mcquitty', 'average', 'median', or 'centroid'
	#
	# Based on a limited comparison, I found for hclust method options:
	# excellent results: 	"ward.D", "ward.D2" 
	# moderate results:		"complete", "average" (= UPGMA), "mcquitty" (= WPGMA) 
	# poor results:			"single", "median" (= WPGMC), "centroid" (= UPGMC)
	#
	### ALL REQUIRED PACKAGES PRESENT? ####
	if(!"poppr" %in% rownames(installed.packages()))
		{
		return(cat("ERROR: package 'poppr' not installed. Functions of these package are needed to create phylogenetic trees.",sep="\n"))
		}else{
		if("poppr" %in% (.packages()) == FALSE)
			{
			cat("Loading package 'poppr'...",sep="\n")
			library("poppr")
			}
		}
	if(!"ape" %in% rownames(installed.packages()))
		{
		return(cat("ERROR: package 'ape' not installed. Functions of these package are needed to create phylogenetic trees.",sep="\n"))
		}else{
		if("ape" %in% (.packages()) == FALSE)
			{
			cat("Loading package 'ape'...",sep="\n")
			library("ape")
			}
		}
	if(!"phangorn" %in% rownames(installed.packages()))
		{
		return(cat("ERROR: package 'phangorn' not installed. Functions of these package are needed to create phylogenetic trees.",sep="\n"))
		}else{
		if("phangorn" %in% (.packages()) == FALSE)
			{
			cat("Loading package 'phangorn'...",sep="\n")
			library("phangorn")
			}
		}
	if(!"stats" %in% rownames(installed.packages()))
		{
		return(cat("ERROR: package 'stats' not installed. Functions of these package are needed to create phylogenetic trees.",sep="\n"))
		}else{
		if("stats" %in% (.packages()) == FALSE)
			{
			cat("Loading package 'stats'...",sep="\n")
			library("stats")
			}
		}
	#
	### SPECIFIED METHOD AND DISTANCE SUPPORTED? ###
	if(do_analysis)
		{
		if(is.null(mymethod))
			{
			return(cat("ERROR: please specify clustering method to 'mymethod' flag.",sep="\n"))
			}
		if(!(mymethod=="BME"|mymethod=="OLS"|mymethod=="upgma"|mymethod=="NJ"|mymethod=="bionj"|mymethod=="ward.D"|mymethod=="ward.D2"|mymethod=="complete"|mymethod=="single"|mymethod=="mcquitty"|mymethod=="average"|mymethod=="median"|mymethod=="centroid"))
			{
			return(cat("ERROR: mymethod has to be either 'upgma', 'NJ', 'bionj', 'OLS', 'BME', 'ward.D', 'ward.D2', 'complete', 'single', 'mcquitty', 'average', 'median', or 'centroid'.",sep="\n"))
			}
		if(is.null(mydistance))
			{
			return(cat("ERROR: please specify clustering method to 'mymethod' flag.",sep="\n"))
			}
		# distance measure can be pi, hamming (bitwise.dist) nei, rogers, edwards or reynolds: 
		if(!(mydistance=="ASD"|mydistance=="pi"|mydistance=="bitwise.dist"|mydistance=="euclidean"|mydistance=="nei.dist"|mydistance=="rogers.dist"|mydistance=="edwards.dist"|mydistance=="reynolds.dist"))
			{
			return(cat("ERROR: mydistance has to be either 'ASD', 'pi', 'bitwise.dist', 'euclidean', 'nei.dist', 'rogers.dist', 'edwards.dist' or 'reynolds.dist'.",sep="\n"))
			}
		}
	#
	### CHECK SAMPLE FILTER SETTINGS ###
	if(!"allgeno"%in%colnames(inds))
		{
		return(cat("ERROR: columns 'inds$allgeno' missing.",sep="\n"))
		}
	if(!"allgeno2"%in%colnames(inds))
		{
		return(cat("ERROR: columns 'inds$allgeno2' missing.",sep="\n"))
		}
	if(genofilter)
		{
		cat("Not including individuals which do not possess al three genotypes (0, 1, 2).",sep="/n") 
		# We use an additional filter 'inds$allgeno'.
		# To prevent the error:
		# Error in (function (x, percent = TRUE, mat = FALSE, missing_match = TRUE,  : min(ploidy(x)) == max(ploidy(x)) is not TRUE
		# as a reminder, inds$allgeno and inds$allgeno2 are defined as follows:
		# inds$allgeno		<- inds$n0_pop>0&inds$n1_pop>0&inds$n2_pop>0
		# inds$allgeno2		<- inds$n0_pop>0&inds$n2_pop>0
		# allgeno2 is used to enable the use of haploid data or haplodiploid data (such as MT-DNA and sex chromosomal data).
		# However, in case allgeno2 returns the ploidy error, one could also try if the allgeno filter prevents the error
		myindsfilter		<- inds$filter&inds$allgeno2
		}else{
		cat("Using all individuals, also the ones which do not possess al three genotypes (0, 1, 2).",sep="\n")
		cat("If you run into an error stating 'min(ploidy(x)) == max(ploidy(x)) is not TRUE', try rerunning the getindtree function which the flag genofilter set to TRUE.",sep="\n") 
		myindsfilter	<- inds$filter
		}
	if(nrow(inds[inds$allgeno,])<3)
		{
		if(nrow(inds[inds$allgeno2,])<3)
			{
			cat("WARNING: Less than 3 individuals which have all 3 genotypes (0,1,2) or even only both homozygous (0,2) genotypes. This could lead to errors, but continuing anyway and hoping for the best.",sep="\n")
			}else{
			cat("WARNING: Less than 3 individuals which have all 3 genotypes (0,1,2), but 3 or more individuals do have both homozygous (0,2) genotypes. Why are heterozygous individuals absent? Continuing anyway.",sep="\n")
			}
		}
	if(!is.null(ann_df))
		{
		if(any(!c("name","clade","col")%in%colnames(ann_df)))
			{
			return(cat("ERROR: the annotation dataframe specified to the ann_df flag should contain the columns 'name','clade' and 'col'.",sep="\n"))
			}
		if(nrow(ann_df)!=nrow(inds[inds$filter,]))
			{
			return(cat("ERROR: number of rows of annotation dataframe does not correspond with number of retained individuals (as specified by inds$filter column).",sep="\n"))
			}
		}
	if(nshorten>0)
		{
		if(!is.null(ann_df))
			{
			return(cat("ERROR: currently not possible to add annotation when branch lengths are shortened. Please set the nshorten flag to zero or the ann_df flag to NULL",sep="\n"))
			}
		if(!is.null(myrect))
			{
			return(cat("ERROR: currently not possible to add rectangles when branch lengths are shortened. Please set the nshorten flag to zero or the myrect flag to NULL",sep="\n"))
			}
		}
	#
	### INPUT GENLIGHT OR GENIND? ###
	if(do_analysis)
		{
		if(mydistance=="bitwise.dist"|mydistance=="euclidean"|mydistance=="pi"|mydistance=="ASD")
			{
			my_gl		<- mygenlight[myindsfilter,snps$filter]
			}else{
			# other distances require genind object rather than genlight object
			if(is.null(mysambar$genind))
				{
				genlight2genind(input=mygenlight,add2sambar=TRUE)
				}else{
				if(length(pop(mysambar$genind))!=length(inds$name[inds$filter]))
					{
					cat("WARNING: number of individuals in mysambar$genind object does not correspond with number of retained individuals in inds dataframe. Creating new genind object...",sep="\n") 
					genlight2genind(input=mygenlight,add2sambar=TRUE)
					}else{
					cat("Using available genind object at mysambar$genind.",sep="\n")
					}
				}
			my_gl	<- mysambar$genind
			}
		}else{
		my_gl		<- mygenlight[myindsfilter,snps$filter]
		}
	#
	### DEFINE POPULATION (COLOURS) ###
	my_colours	<- inds$popcol[myindsfilter]
	if(!is.null(mycolours))
		{
		cat("Using colours specified to mycolours flag.",sep="\n")
		my_colours		<- mycolours
		}
	# if only one node per population:
	# mypopcolours	<- vector()
	# for(k in c(1:length(mytree$tip.label))){mypopcolours[k]<-mysambar$mycolours2[which(mysambar$populations2==mytree$tip.label[k])]}
	# Note: can be done only for heterozygous individuals. So if running for X chromosome or MT, males will be excluded. 
	#
	# defined populations:
	mypops		<- pop(my_gl)
	mypops		<- mypops
	ninds		<- length(mypops)
	#
	### START ACTUAL ANALYSIS ###
	if(do_analysis)
		{
		mysambar$mytree				<<- NULL
		mysambar$mytree_distmat		<<- NULL
		mysambar$mytree_diffscore	<<- NULL
		#
		if(nbootstrap==0)
			{
			### NO BOOTSTRAPPING ###
			### CREATE DISTANCE MATRIX ####
			if(!is.null(inputdistmat))
				{
				cat("Creating distance-based tree from distance matrix specified to the inputdistmat flag.",sep="\n")
				mydistmat				<- inputdistmat
				mysambar$mytree_distmat	<<- inputdistmat
				}else{
				if(mydistance=="pi"|mydistance=="ASD")
					{
					# pimatrix and ASD matrix are generated with SambaR's functions calcpi and pidf2matrix
					if(is.null(mysambar$pidf_metalist[[1]]))
						{
						cat("Pairwise distances list not present. Generating now...",sep="\n")
						# sambarfunction_findstructure
						calcpi(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE)
						}else{
						pidf		<- mysambar$pidf_metalist[[1]]
						obspairs	<- nrow(pidf[pidf$ind1!=pidf$ind2,])
						nind		<- nrow(inds[inds$filter,])
						exppairs	<- (nind*(nind-1))/2
						if(obspairs!=exppairs)
							{
							cat("Number of sample pairs in mysambar$pidf_metalist[[1]] does not correspond with expected number. Recalculating pairwise distances...",sep="\n")
							calcpi(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE)
							}
						}
					}
				if(mydistance=="pi")
					{
					cat("Creating distance-based tree from sequence dissimilarity matrix...",sep="\n")
					#sambarfunction_findstructure
					mysambar$pimatrix	<<- pidf2matrix(pidf=mysambar$pidf_metalist[[1]],myinds=as.character(inds$name[inds$filter]))
					mydistmat			<- mysambar$pimatrix
					}
				if(mydistance=="ASD")
					{
					cat("Creating distance-based tree from allele sharing distance (ASD) matrix...",sep="\n")
					#sambarfunction_findstructure
					#mysambar$asdmatrix	<<- pidf2matrix(pidf=mysambar$pidf_metalist[[1]],myinds=as.character(inds$name[inds$filter]),do_asd=TRUE)
					mysambar$asdmatrix	<<- pidf2matrix(pidf=mysambar$pidf_metalist[[1]],myinds=inds$nr[inds$filter],do_asd=TRUE)
					mydistmat			<- mysambar$asdmatrix
					}
				if(mydistance=="bitwise.dist")
					{
					mydistmat	<- poppr::bitwise.dist(my_gl,euclidean=FALSE)
					# alternatively:
					# mydistmat	<- phangorn::dist.hamming(myphydat)
					}
				if(mydistance=="euclidean")
					{
					mydistmat	<- poppr::bitwise.dist(my_gl,euclidean=TRUE)
					# note: very low likelihood scores for euclidean based trees.
					# This bias could be caused by the unit of euclidean distance (internal branches with values above 1, whereas tip branches have values below 1).
					}
				if(mydistance=="nei.dist")
					{
					#mydistmat	<- poppr::nei.dist(my_gl)
					if(!is.null(mysambar$indneimatrix))
						{
						if(nrow(mysambar$indneimatrix)==nrow(inds[myindsfilter,]))
							{
							cat("WARNING: using Nei D scores present at mysambar$indneimatrix.",sep="\n") 
							mydistmat	<- mysambar$indneimatrix
							}else{
							cat("Generating Nei D scores using Stampp...",sep="\n")
							mydistmat	<- stamppNeisD(mygenlight[myindsfilter,snps$filter],pop=FALSE)
							}
						}else{
						cat("Generating Nei D scores using Stampp...",sep="\n")
						mydistmat		<- stamppNeisD(mygenlight[myindsfilter,snps$filter],pop=FALSE)
						}
					mydistmat[!is.finite(mydistmat)]	<- NA
					colnames(mydistmat)					<- rownames(mydistmat)
					mysambar$indneimatrix				<<- mydistmat
					}
				if(mydistance=="rogers.dist")
					{
					# returns NA in case of missing data, but why does this problem not arise when using aboot function?  
					return(cat("ERROR: to use rogers.dist, specify to the nbootstrap flag a value above 0.",sep="\n"))  
					# mydistmat	<- poppr::rogers.dist(my_gl)
					}
				if(mydistance=="edwards.dist")
					{
					# returns NA in case of missing data, but why does this problem not arise when using aboot function?  
					return(cat("ERROR: to use edwards.dist, specify to the nbootstrap flag a value above 0.",sep="\n")) 
					# mydistmat	<- poppr::edwards.dist(my_gl)
					}
				if(mydistance=="reynolds.dist")
					{
					# returns NA in case of missing data, but why does this problem not arise when using aboot function?  
					return(cat("ERROR: to use reynolds.dist, specify to the nbootstrap flag a value above 0.",sep="\n")) 
					# mydistmat	<- poppr::reynolds.dist(my_gl)
					}
				mysambar$mytree_distmat		<<- mydistmat
				if(any(is.na(mydistmat)))
					{
					return(cat("ERROR: Phylogeny can not be generated due to missing data in pairwise distance matrix.",sep="\n"))
					}
				}
			### GENERATE PHYLOGENY ###
			cat("Generating phylogeny without calculating bootstrap support...",sep="\n")
			if(mymethod=="ward.D"|mymethod=="ward.D2"|mymethod=="complete"|mymethod=="single"|mymethod=="mcquitty"|mymethod=="average"|mymethod=="median"|mymethod=="centroid")
				{
				cat("Using hclust function of stats package...",sep="\n")
				hc 				<- stats::hclust(as.dist(mydistmat),method=mymethod)	
				mytree			<- ape::as.phylo(hc)
				}
			if(mymethod=="BME")
				{
				mytree			<- ape::fastme.bal(mydistmat,nni=TRUE,spr=TRUE)
				}
			if(mymethod=="OLS")
				{
				mytree			<- ape::fastme.ols(mydistmat,nni=TRUE)
				}
			if(mymethod=="NJ")
				{
				cat("Using NJ algorithm...",sep="\n")
				mytree 			<- ape::nj(mydistmat)
				}
			if(mymethod=="bionj")
				{
				if(max(mydistmat)>100)
					{
					if(max(mydistmat)>1000)
						{
						# To avoid error: Error in ape::bionj(mydistmat) : at least one distance was greater than 10
						cat("WARNING: because bionj function does not accept distance matrices which contains values above 100, dividing all values by 100.",sep="\n")
						mydistmat					<- mydistmat/100
						}else{
						# To avoid error: Error in ape::bionj(mydistmat) : at least one distance was greater than 10
						cat("WARNING: because bionj function does not accept distance matrices which contains values above 100, dividing all values by 10.",sep="\n")
						mydistmat					<- mydistmat/10
						}
					mysambar$mytree_distmat		<<- mydistmat
					}
				mytree 			<- ape::bionj(mydistmat)
				}
			if(mymethod=="upgma")
				{
				cat("Using upgma algorithm...",sep="\n")
				mytree 			<- phangorn::upgma(mydistmat)
				}
			}else{
			#### WITH BOOTSTRAPPING ####
			if(mydistance=="pi"|mydistance=="ASD")
				{
				return(cat("ERROR: currently SambaR does not yet offer the possibility to calculate bootstrap support when mydistance is set to 'pi' to 'ASD'. Either set nbootstrap to zero or use a different distance estimate.",sep="\n"))
				}
			if(mymethod=="ward.D"|mymethod=="ward.D2"|mymethod=="complete"|mymethod=="single"|mymethod=="mcquitty"|mymethod=="average"|mymethod=="median"|mymethod=="centroid")
				{
				return(cat("ERROR: currently SambaR does not yet offer the possibility to calculate bootstrap support for hclust phylogenies.",sep="\n"))
				#mytreefunction <- function(x) as.phylo(hclust(as.dist(poppr::bitwise.dist(x)),method=mymethod) 	
				}
			if(mymethod=="BME")
				{
				return(cat("ERROR: currently SambaR does not yet offer the possibility to calculate bootstrap support for BME phylogenies.",sep="\n"))
				#mytreefunction	<- function(x) ape::fastme.bal(poppr::bitwise.dist(x),nni=TRUE,spr=TRUE)
				}
			if(mymethod=="OLS")
				{
				return(cat("ERROR: currently SambaR does not yet offer the possibility to calculate bootstrap support for OLS phylogenies.",sep="\n"))
				#mytreefunction	<- function(x) ape::fastme.ols(poppr::bitwise.dist(x),nni=TRUE)
				}
			#if(mymethod=="NJ")
			#	{
			#	cat("Using NJ algorithm...",sep="\n")
			#	mytreefunction	<- function(x) ape::nj(poppr::bitwise.dist(x))
			#	}
			if(mymethod=="bionj")
				{
				return(cat("ERROR: currently SambaR does not yet offer the possibility to calculate bootstrap support for bionj phylogenies.",sep="\n"))
				mytreefunction	<- function(x) ape::bionj(poppr::bitwise.dist(x))
				}
			#if(mymethod=="upgma")
			#	{
			#	cat("Using upgma algorithm...",sep="\n")
			#	mytreefunction	<- function(x) phangorn::upgma(poppr::bitwise.dist(x))
			#	}
			cat("Generating phylogeny including bootstrap support using the aboot function of the poppr package...",sep="\n")
			mytree 			<- poppr::aboot(my_gl,tree=mymethod,distance=mydistance,sample=100,showtree=F,cutoff=50,quiet=F)
			#mytree 		<- poppr::aboot(my_gl,tree=mytreefunction,distance=mydistance,sample=100,showtree=F,cutoff=50,quiet=F)
			}
		mysambar$mytree	<<- mytree
		cat("Phylo object stored at mysambar$mytree.",sep="\n")
		}else{
		cat("The flag 'do_analysis' is set to FALSE. Plotting tree stored specified to inputtree flag (default: mysambar$mytree).",sep="\n")
		if(is.null(inputtree)&is.null(inputnewickfile)&is.null(inputnexusfile))
			{
			return(cat("ERROR: inputtree, inputnewickfile and inputnexusfile are all NULL.",sep="\n"))
			}
		if(!is.null(inputtree))
			{
			cat("Using tree specified to inputtree flag.",sep="\n")
			mytree				<- inputtree
			mysambar$inputtree	<<- mytree
			}
		if(!is.null(inputnewickfile))
			{
			cat("Importing tree in newick format...",sep="\n")
			if(!file.exists(inputnewickfile))
				{
				cat(paste("ERROR: Specified tree file (",inputnewickfile,") not found in directory:",sep=""),sep="\n")
				return(cat(getwd(),sep="\n"))
				}
			mytree				<- ape::read.tree(inputnewickfile)
			mysambar$inputtree	<<- mytree		
			}
		if(!is.null(inputnexusfile))
			{
			cat("Importing tree in nexus format...",sep="\n")
			if(!file.exists(inputnexusfile))
				{
				cat("ERROR: Specified tree file not found in directory:",sep="\n")
				return(cat(getwd(),sep="\n"))
				}
			mytree				<- ape::read.nexus(inputnexusfile)
			mysambar$inputtree	<<- mytree
			}
		}
	# to observe structure of tree object:
	# str(mysambar$mytree)
	if(!is.null(drop_ind))
		{
		if(length(drop_ind)>0)
			{
			cat("Dropping individual(s):...",sep="\n")
			for(k in c(1:length(drop_ind)))
				{
				cat(drop_ind[k],sep="\n")
				if(!drop_ind[k]%in%inds$name)
					{
					return(cat(paste("Sample ",drop_ind[k],", which is specified to drop_ind flag, not present in inds object.",sep=""),sep="\n"))
					}
				mytree		<- drop.tip(phy=mytree,tip=drop_ind[k])
				}
			}
		}
	if(length(mytree$tip.label)!=length(inds$name[inds$filter]))
		{
		mytree				<<- mytree
		return(cat("ERROR: number of labels in tree (mytree$tip.label) does not correspond with number of retained individuals (inds$name[inds$filter]) in inds dataframe. Try using the drop_ind flag or resetting inds$filter.",sep="\n"))
		}
	if(any(!(as.character(mytree$tip.label)%in%as.character(inds$name[inds$filter]))))
		{
		mytree				<<- mytree
		return(cat("ERROR: one or more labels in tree (mytree$tip.label) do not correspond with names of retained individuals in inds dataframe (inds$name[inds$filter]).",sep="\n"))
		}
	#
	if(!is.null(rotatevec))
		{
		# rotatevec should be a vector with node numbers
		cat("Rotating node(s). If you receive an error after this line, please set the flag rotatevec to NULL, or provide other node number(s).",sep="\n")  
		mytree		<- ape::rotate(mytree,rotatevec)
		}
	#
	if(any(!(as.character(mytree$tip.label)==as.character(inds$name[inds$filter]))))
		{
		cat("WARNING: order of labels in tree (mytree$tip.label) does not correspond with order of retained individuals in inds dataframe (inds$name[inds$filter]). Reordering my_colours vector accordingly...",sep="\n")
		namevec				<- as.character(inds$name[inds$filter])
		namevec2			<- as.character(mytree$tip.label)
		ordervec			<- vector()
		for(j in c(1:length(namevec)))
			{
			ordervec[j]		<- which(namevec==namevec2[j])
			}
		my_colours			<- my_colours[ordervec]
		if(!is.null(ann_df))
			{
			ann_df			<- ann_df[ordervec,]
			if(any(ann_df$name!=namevec2))
				{
				return(cat("ERROR: names in ann_df and tree$tip.label do not correspond.",sep="\n"))
				}
			ann_colours		<- ann_df$col
			}
		}
	#mycolors2 				<- rep("black",Nedge(mytree))	
	mycolors2 				<- rep("black",nrow(mytree$edge))
	if(edgecolors)
		{
		if(!silent){cat("Defining edge colours...",sep="\n")}
		tipindex				<- which(mytree$edge[,2]%in%c(1:ninds))
		indorder				<- mytree$edge[tipindex,2]
		mycolors2[tipindex]		<- my_colours[indorder]
		}
	#colorstemp		<<- mycolors2
	if(showpop)
		{
		# 16-07-2021: to plot one pop name per population rather than all sample names
		# 16-07-2021: Because plot.phylo function does not accepted duplicated sample names nor NA-values, I use this workaround:
		# not perfect, but comes close
		if(!silent){cat("Editing edge labels (because flag showpop is set to TRUE)...",sep="\n")}
		coldf			<- data.frame("pop"=mypops,"popcol"=my_colours)
		coldf$nr		<- c(1:nrow(coldf))
		coldf$bool		<- !duplicated(coldf$pop,fromLast=TRUE)
		coldf$pop2		<- ifelse(coldf$bool,as.character(coldf$pop),paste(coldf$pop,coldf$nr,sep="_"))
		coldf$popcol2	<- ifelse(coldf$bool,as.character(coldf$popcol),"white")
		mytree$tip.label<- coldf$pop2
		my_colours		<- coldf$popcol2
		}
	#
	#if(!is.null(mysambar$mytree)&!is.null(mysambar$mytree_distmat)&dopathlength)
	if(!is.null(mytree)&!is.null(mysambar$mytree_distmat)&dopathlength)
		{
		cat("Calculating pathlength and optionally (if distance matrix is present) difference between path length and genetic distance...",sep="\n")
		cat("This may take a while depending on the number of samples...",sep="\n")
		cat("If you receive an error after this line, or if the calculation takes too long, set the flag do_pathlength to FALSE.",sep="\n") 
		pathlength(mytree=mytree,exporttype="pdf",plot_name=paste("Pathlengths",mymethod,sep="."),distancemat=as.matrix(mydistmat),heatmapbreaks=pathlengthbreaks,addlabels=matrixlabels,domean=pathlength_domean)
		}else{
		cat("Not calculating path lengths.",sep="\n")
		}
	if(calc_parsimony)
		{
		cat("Calculating parsimony score of the tree. If this calculation takes too long, rerun the getindtree with the flag 'calc_parsimony' set to FALSE.",sep="\n")
		# convert genlight to DNAbin:
		if(is.null(mysambar$mydnabin))
			{
			cat("DNAbin object not found. Generating...",sep="\n")
			genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
			}else{
			if(dim(mysambar$mydnabin)[1]!=nrow(inds[inds$filter,])|dim(mysambar$mydnabin)[2]!=nrow(snps[snps$filter,]))
				{
				cat("Dimensions of DNAbin object stored at mysambar$mydnabin do not correspond with number of retained individuals and/or number of retained snps. Overwriting...",sep="\n")
				genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
				}else{
				if(any(labels(mysambar$mydnabin)!=inds$name[inds$filter]))
					{
					cat("WARNING: Sample labels of DNAbin object stored at mysambar$mydnabin do not correspond with inds$name. Overwriting...",sep="\n")
					genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
					}else{
					cat("WARNING: using existing DNAbin object stored at mysambar$mydnabin.",sep="\n")
					}
				}
			}
		
		# calculate parsimony score:
		cat("Obtaining parsimony score...",sep="\n")
		myphydat							<- phangorn::phyDat(data=mysambar$mydnabin,type="DNA",levels=NULL,return.index=TRUE)
		myparsimony							<- phangorn::parsimony(tree=mytree,data=myphydat,method="fitch")
		parsimony_persite					<- myparsimony/(nrow(snps[snps$filter,]))
		parsimony_persite_perind			<- parsimony_persite/(nrow(inds[inds$filter,]))
		mysambar$mytree_parsimony			<<- myparsimony
		mysambar$mytree_parsimony_scaled	<<- parsimony_persite_perind
		}
	if(calc_likelihood)
		{
		cat("Calculating likelihood of the tree. If this calculation takes too long, rerun the getindtree with the flag 'calc_likelihood' set to FALSE.",sep="\n")
		if(is.null(mysambar$mydnabin))
			{
			cat("DNAbin object not found. Generating...",sep="\n")
			genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
			}else{
			if(dim(mysambar$mydnabin)[1]!=nrow(inds[inds$filter,])|dim(mysambar$mydnabin)[2]!=nrow(snps[snps$filter,]))
				{
				cat("Dimensions of DNAbin object stored at mysambar$mydnabin do not correspond with number of retained individuals and/or number of retained snps. Overwriting...",sep="\n")
				genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
				}else{
				cat("WARNING: using existing DNAbin object stored at mysambar$mydnabin.",sep="\n")
				}
			}
		# calculate loglikelihood score:
		cat("Obtaining likelihood score...",sep="\n")
		myfit		<- phangorn::pml(tree=mytree,data=myphydat)
		myloglik	<- logLik(myfit)[1]
		mysambar$mytree_loglik	<<- myloglik
		}
	#
	if(makelinear)
		{
		# linearize using mean path lengths method: 
		myplottree 	<- chronoMPL(mytree)
		# or, alternatively, use likelihood approach with calibration points: 
		# model can be 'correlated', 'discrete' or 'relaxed' (first two options result in better likelihood scores)
		# mycalibration <- makeChronosCalib(mytree,node="root",age.max=1)
		# chronos(mytree,lambda=1,model="correlated",quiet=FALSE,calibration=mycalibration,control=chronos.control())
		if(!is.null(mutrate))
			{
			cat("WARNING: rought attempt to convert raw genetic distance estimates into time estimates.",sep="\n") 
			if(is.null(genomeprop))
				{
				return(cat("ERROR: please indicate to the 'genomeprop'-flag the proportion of variable sites, used by the tree-building software (which often kicks out non-variable sites). If all sites were used, set to 1.",sep="\n"))  
				}
			if(genomeprop>1|genomeprop<=0)
				{
				# Note: genomeprop should be set below 1 when treebuilding has been performed on a subset consisting of polymorphic sites (i.e., not including monomorphic sites)
				# The proportion is: nr_polymorphic_sites/nr_total_sites
				return(cat("ERROR: genomeprop needs to be equal or smaller than 1, and bigger than 0.",sep="\n"))  
				}
			if(is.null(errorrate))
				{
				corr_factor	<- 1
				}else{
				corr_factor	<- 1-errorrate
				}
			myplottree[[2]] <- (corr_factor*myplottree[[2]]*genomeprop)/mutrate
			}
		}else{
		myplottree		<- mytree
		}
	mysambar$plottree	<<- myplottree
	#
	# plot:
	mydistance	<- ifelse(mydistance=="bitwise.dist","Hammingdist",mydistance)
	mydistance	<- ifelse(mydistance=="nei.dist","Neidist",mydistance)
	mydistance	<- ifelse(mydistance=="edwards.dist","Edwardsdist",mydistance)
	labelstr	<- ifelse(tiplabels,"tiplabels",ifelse(tipdots,"tipdots","notiplabels"))
	labelstr2	<- ifelse(addnodelabels,ifelse(marknode,"nodemarked","nodelabels"),"nonodelabels")
	colorstr	<- ifelse(edgecolors,"colortips","blacktips")
	if(fullplotname)
		{
		plotname2	<- paste(plotname,mydistance,mymethod,mytype,labelstr,labelstr2,colorstr,sep=".")
		}else{
		plotname2	<- paste(plotname,mytype,labelstr,labelstr2,colorstr,sep=".")
		}
	plotname2		<- ifelse(makelinear,paste(plotname2,"linearized",sep="."),plotname2)
	plotname2		<- ifelse(mybg=="white",plotname2,paste(plotname2,mybg,sep="."))
	plotname2		<- ifelse(is.null(mutrate),plotname2,paste(plotname2,paste("u",formatC(mutrate,format="e",digits=1),sep=""),sep="_"))
	#cat(plotname,sep="\n")
	if(!is.null(export))
		{
		myheight	<- ifelse(mytype=="phylogram",ninds*heightfac+2,14)
		myheight2	<- ifelse(mytype=="phylogram",ninds*heightfac*100+20,14)
		if(export=="eps"){postscript(paste(plotname2,"eps",sep="."),width=14,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname2,"pdf",sep="."),width=14,height=myheight)}
		if(export=="png"){png(paste(plotname2,"png",sep="."),width=720,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname2,"wmf",sep="."),width=14,height=myheight)}
		}
	par(cex.axis=axiscex,bg=mybg)
	if(!silent){cat("Running plot.phylo function of the ape package...",sep="\n")}
	#
	if(!use_ggtree)
		{
		if(nshorten==0)
			{
			ape::plot.phylo(myplottree,x.lim=myxlim,cex=labelcex,font=myfont,adj=0,show.tip.label=tiplabels,tip.color=my_colours,type=mytype,lab4ut=labelangle,edge.width=mylwd,node.pos=1,edge.color=mycolors2,rotate.tree=tree_angle,direction=mydirection)
			}else{
			cat(paste("Plotting tree with ",nshorten," shortened branches...",sep=""),sep="\n")
			ape::plotBreakLongEdges(myplottree,n=nshorten,cex=labelcex,font=myfont,adj=0,show.tip.label=tiplabels,tip.color=my_colours,type=mytype,lab4ut=labelangle,edge.width=mylwd,node.pos=1,edge.color=mycolors2,rotate.tree=tree_angle,direction=mydirection)
			}
		}else{
		# UNDER CONSTRUCTION:
		ggtree(mysambar$plottree,layout="unrooted")
		}
	if(tipdots)
		{
		if(dotpch>20)
			{
			tiplabels(pch=dotpch,col="grey40",bg=my_colours,cex=dotcex)
			}else{
			tiplabels(pch=dotpch,col=my_colours,cex=dotcex)
			}
		#for(k in c(1:length(dotindex)))
		#	{
		#	tiplabels(tip=dotindex[k],pch=21,col=dotcolors[k],bg=dotcolors[k],cex=dotcex)
		#	}
		}
	#myxaxis	<-axis(1,col=mybg,col.axis=mybg,by=1)
	if(!is.null(myrect))
		{
		if(!is.rooted(mysambar$plottree))
			{
			dev.off()
			return(cat("ERROR: to draw rectangles at the correct position, the tree needs to be rooted. Please add an outgroup or set myrect to FALSE.",sep="\n")) 
			}
		nrect	<- length(myrect)
		if(nrect%%2!=0)
			{
			return(cat("ERROR: myrect should be a vector with 2 values per rectangle; e.g.: c(18000,30000,120000,126000).",sep="\n"))
			}
		myrootage		<- max(myplottree[[2]])
		if(is.null(rectcol))
			{
			rectcol	<- rep("grey60",nrect)
			}else{
			if(length(rectcol)<(nrect/2))
				{
				return(cat("ERROR: incorrect number of rectangle colours.",sep="\n"))
				}
			}
		for(k in c(1:(nrect/2)))
			{
			rect(xleft=myrootage-myrect[k*2-1],ybottom=-4,xright=myrootage-myrect[k*2],ytop=ninds+1,border=adjustcolor(rectcol[k],alpha.f=0.5),col=adjustcolor(rectcol[k],alpha.f=0.5))
			if(!is.null(recttext))
				{
				#mysqrt	<- ifelse(nchar(recttext[k])>4,0,90)
				#myadj	<- ifelse(nchar(recttext[k])>4,1,0)
				mysqrt	<- ifelse(nchar(recttext[k])>4,0,0)
				myadj	<- ifelse(nchar(recttext[k])>4,1,1)
				text(x=myrootage-mean(c(myrect[k*2-1],myrect[k*2])),y=ninds+1.5,recttext[k],cex=1.25,srt=mysqrt,adj=myadj)
				}
			}
		}
	if(!is.null(myplottree$node.label)&addnodelabels)
		{
		# this are node labels (e.g. support values), not tip labels (e.g. sample names, stored at myplottree$label)
		if(!silent){cat("Adding node labels...",sep="\n")}
		if(!is.null(maxnodelabel))
			{
			if(any(grepl("/",myplottree$node.label,fixed = TRUE)))
				{
				cat("Assuming node labels are generated with IQtree. Selecting support values after separator...",sep="\n") 
				myplottree$node.label		<- as.numeric(sub(".*/","",myplottree$node.label))
				}
			if(is.numeric(myplottree$node.label))
				{
				if(maxnodelabel<=1)
					{
					myplottree$node.label	<- ifelse(myplottree$node.label>=maxnodelabel,NA,round(myplottree$node.label,1))
					}else{
					myplottree$node.label	<- ifelse(myplottree$node.label>=maxnodelabel,NA,myplottree$node.label)
					}
				}
			}
		if(marknode)
			{
			myplottree$node.label	<- ifelse(myplottree$node.label<=maxnodelabel,"#",myplottree$node.label)
			nodelabels(myplottree$node.label,frame="n",cex=marklabelcex,xpd=TRUE,col="red")
			}else{
			nodelabels(myplottree$node.label,adj=c(1.3,-0.5),frame="n",cex=nodelabelcex,font=3,xpd=TRUE,col=nodelabelcol)
			}
		}
	#nodelabels(myplottree$node.label,adj=c(1.3,-0.5),frame="n",cex=1,font=3,xpd=TRUE)
	if(!is.null(legendpos)){legend(legendpos,legend=mysambar$poporder,fill=mysambar$colorder,border=mysambar$colorder,bty="n",cex=legendcex)}
	if(makelinear)
		{
		if(mytype=="phylogram")
			{
			if(!is.null(mutrate)&is.null(myrect))
				{
				mtext(side=3,paste("mutation rate = ",formatC(mutrate,format="e",digits=1)," per site per year",sep=""),line=-1)
				}
			cat("Adding x-axis...",sep="\n")
			if(addaxis){axisPhylo(side=1,backward=TRUE)}
			# add p-values of molecular clock test per branch:
			# mypvalues	<- round(attr(myplottree,"Pval"),3)
			# nodelabels(mypvalues,frame="n",cex=0.75,xpd=TRUE,col="red")
			#
			if(addranges)
				{
				# add standard-errors of the node ages
				cat("Adding standard deviation bars...",sep="\n")
				mystderr	<- round(attr(myplottree, "stderr"), 3)
				# nodelabels(mystderr,frame="n",cex=0.75,xpd=TRUE,col="red") 
				# POSITION OF TIPS AND NODES IN PLOTS ALONG X AND Y-AXIS:
				xvalues		<- node.depth.edgelength(myplottree)
				yvalues		<- node.height(myplottree)
				# SELECT NODES ONLY:
				ntips		<- length(myplottree$tip.label)
				xvalues		<- xvalues[(ntips+1):length(xvalues)]
				yvalues		<- yvalues[(ntips+1):length(yvalues)]
				nnodes		<- length(xvalues)
				myrgb		<- as.vector(col2rgb(col=interval_col,alpha = FALSE))
				mytranscol 	<- rgb(myrgb[1],myrgb[2],myrgb[3],max=255,alpha=125)
				for(k in c(1:nnodes))
					{
					mysd	<- mystderr[k]
					segments(x0=xvalues[k]-mysd*xvalues[k],y0=yvalues[k],x1=xvalues[k]+mysd*xvalues[k],y1=yvalues[k],col=mytranscol,lwd=interval_lwd)
					}
				}
			}else{
			cat("Not a phylogram. Not adding x-axis.",sep="\n")
			}
		}else{
		if(addaxis){axis(side=1,cex=2)}
		}
	if(addscale)
		{
		myylabel	<- ifelse(!is.null(mutrate)&makelinear,"TMRCA (ya)",myylabel)
		mtext(myylabel,side=1,line=3,cex=2.5)
		}
	if(!is.null(ann_df))
		{
		if(mytype!="phylogram")
			{
			cat("Annotation requires phylogram structure.",sep="\n")
			}else{
			if(!is.rooted(mysambar$plottree))
				{
				dev.off()
				return(cat("ERROR: to draw annotation at the correct position, the tree needs to be rooted. Please add an outgroup or set myrect to FALSE.",sep="\n")) 
				}
			cat("Adding annotation...",sep="\n")
			if("adephylo" %in% rownames(installed.packages()) == FALSE) {install.packages("adephylo")}
			if("adephylo" %in% (.packages()) == FALSE){library(adephylo)}
			myrootage		<- max(myplottree[[2]])
			x 				<- c(rep(myrootage/100,nrow(inds)))
			names(x) 		<- inds$name[inds$filter]
			if(length(ann_colours)!=length(myplottree$tip.label))
				{
				dev.off()
				return(cat("ERROR: Number of tip labels does not correspond with length of ann_colours vector.",sep="\n"))
				}
			phydataplot(x,myplottree,offset=myrootage*0.2,border=NA,col=ann_colours)
			#
			# add legend:
			if(ann_legend)
				{
				myclades	<- unique(ann_df$clade)
				myclades	<- myclades[order(myclades)]
				mycladecols	<- vector()
				mycladepchs	<- vector()
				addannpch	<- "pch"%in%colnames(ann_df)
				for(k in c(1:length(myclades)))
					{
					mynr			<- which(ann_df$clade==myclades[k])[1]
					mycladecols[k]	<- ann_df$col[mynr]
					if(addannpch)
						{
						mycladepchs[k]	<- ann_df$pch[mynr]
						}else{
						mycladepchs[k]	<- 22
						}
					}
				if(addannpch)
					{
					legend(ann_legendpos,legend=myclades,fill=mycladecols,bty='n',cex=1.5,border=mycladecols,pch=)
					}else{
					legend(ann_legendpos,legend=myclades,fill=mycladecols,bty='n',cex=1.5,border=mycladecols)
					}
				}
			}
		}
	if(printnodes)
		{
		nodelabels(frame="none",bg="white",cex=0.1,col="grey50")
		}
	if(!is.null(nodedf))
		{
		cat("Adding node labels...",sep="\n")
		if(any(!c("text","node")%in%colnames(nodedf)))
			{
			return(cat("ERROR: nodedf should contain column names 'text' and 'node'.",sep="\n"))
			}
		nodelabels(text=nodedf$text,node=nodedf$node,frame="n",cex=1.5,xpd=TRUE,col="red")
		}
	if(!is.null(plottitle)){mtext(plottitle,side=3,line=titleline,cex=titlecex)}
	if(!dopathlength)
		{
		if(calc_parsimony&calc_likelihood)
			{
			if(silent){cat("Adding tree scores...",sep="\n")}
			mytext	<- paste("parsimony score per site: ",round(parsimony_persite,3),"; -log(likelihood): ",round(myloglik),sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		if(calc_parsimony&!calc_likelihood)
			{
			if(silent){cat("Adding tree scores...",sep="\n")}
			mytext	<- paste("parsimony score per site: ",round(parsimony_persite,3),sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		if(!calc_parsimony&calc_likelihood)
			{
			if(silent){cat("Adding tree scores...",sep="\n")}
			mytext	<- paste("-log(likelihood): ",round(myloglik),sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		}else{
		tree_error	<- round(mean(abs(mysambar$mytree_diffmat),na.rm=TRUE),4)
		if(calc_parsimony&calc_likelihood)
			{
			if(silent){cat("Adding tree scores...",sep="\n")}
			mytext	<- paste("parsimony score per site: ",round(parsimony_persite,3),"; -log(likelihood): ",round(myloglik),";\n|(pathlength - genetic distance)/pathlength|: ",tree_error,sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		if(calc_parsimony&!calc_likelihood)
			{
			if(silent){cat("Adding tree scores...",sep="\n")}
			mytext	<- paste("parsimony score per site: ",round(parsimony_persite,3),";\n|(pathlength - genetic distance)/pathlength|: ",tree_error,sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		if(!calc_parsimony&calc_likelihood)
			{
			if(silent){cat("Adding tree scores...",sep="\n")}
			mytext	<- paste("-log(likelihood): ",round(myloglik),";\n|(pathlength - genetic distance)/pathlength|: ",tree_error,sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		if(!calc_parsimony&!calc_likelihood&dopathlength)
			{
			mytext	<- paste("|(pathlength - genetic distance)/pathlength|: ",tree_error,sep="")
			mtext(mytext,side=3,cex=labelcex)
			}
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Phylogenetic plot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	#
	# export txt files:
	if(!is.null(export))
		{
		if(fullplotname)
			{
			filename	<- paste(plotname,mydistance,mymethod,"numbers",sep=".")
			}else{
			filename	<- plotname
			}
		# export in Nexus format:
		write.nexus(mytree,file=paste(filename,"numbers.nexus.txt",sep="."),translate=TRUE)
		#write.nexus(mytree,file=paste(filename,"labels.nexus.txt",sep="."),translate=TRUE)
		#
		# export in newick format:
		if(do_append)
			{
			cat("Adding Newick-format tree to file 'mytrees.labels.newick.txt'.",sep="\n") 
			write.tree(mytree,file=paste("mytrees.labels.newick.txt",sep="."),append=TRUE,digits=0,tree.names=FALSE)
			}else{
			write.tree(mytree,file=paste(filename,"labels.newick.txt",sep="."),append=FALSE,digits=0,tree.names=FALSE)
			}
		# without branch lengths:
		# mytree[[2]]<-NULL
		# write.tree(mytree,file=paste(filename,"labels.newick.nobranchlengths.txt",sep="."),append=FALSE,digits=0,tree.names=FALSE)
		}
	}

# 23-08-2022: function to plot dependency of TMRCA on mutation rate
# depends on getindtree:
runlineartree<-function(input_tree=myrootedtree,mutrates=seq(0.5,2.0,0.1),genome_prop=1,do_analysis=FALSE,mycolours=c("black","grey20","grey40","grey60","grey80"),mynodes=c(127,128,129,147,149),mynodelabels=c("B","C","D","E","A"),export=NULL,plotname="TMRCA_vs_u",plottitle=NULL,mycex=2.5,axiscex=2,labcex=2.5,maincex=2.5,xline=3.5,yline=4,legendpos="topright",legendcex=1.75,error_rate=NULL)
	{
	if(do_analysis)
		{
		if(is.null(input_tree))
			{
			return(cat("ERROR: Specify a rooted phylo object to the input_tree flag.",sep="\n"))
			}
		mutrates2	<- mutrates*10^-9
		ulist		<- list()
		for(k in c(1:length(mutrates2)))
			{
			getindtree(do_analysis=FALSE,mydistance="euclidean",mymethod="bionj",makelinear=TRUE,genomeprop=genome_prop,mutrate=mutrates2[k],errorrate=error_rate,inputtree=input_tree,mytype="phylogram",labelangle="axial",export="pdf",dopathlength=FALSE,fullplotname=FALSE,calc_parsimony=FALSE,calc_likelihood=FALSE,heightfac=0.1,labelcex=0.75)
			utree			<- mysambar$plottree 
			xvalues			<- node.depth.edgelength(utree)
			ulist[[k]]		<- abs(xvalues-xvalues[1])
			}
		ulist				<<- ulist
		mysambar$tmrcadf	<<- data.frame(do.call(cbind,ulist))
		}else{
		if(is.null(mysambar$tmrcadf))
			{
			return(cat("ERROR: mysambar$tmrcadf not found. Perhaps set the flag do_analysis to TRUE?",sep="\n"))
			}
		}
	cat("Subselecting nodes...",sep="\n")
	mydf			<- mysambar$tmrcadf
	mydf2			<- mydf[mynodes,]
	rownames(mydf2)	<- mynodelabels
	mydf2			<- mydf2[order(mynodelabels),]
	#
	cat("Plotting...",sep="\n")
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,7.5,3,0.25),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex)	
	mymin		<- min(mydf2)
	mymax		<- max(mydf2)
	plot(mutrates,unlist(mydf2[1,]),log="xy",ylim=c(mymin,mymax),type="b",pch=16,ylab="",xlab="",yaxt="n",col=mycolours[1])
	ylabels	<- c(100000,200000,500000,1000000,seq(2000000,10000000,2000000))
	axis(side=2,at=ylabels,label=ylabels/1000000,las=2)
	for(k in c(2:nrow(mydf2)))
		{
		lines(mutrates,unlist(mydf2[k,]),type="b",pch=16,col=mycolours[k])
		}
	legend(legendpos,legend=mynodelabels[order(mynodelabels)],fill=mycolours,bty="n",cex=legendcex)
	mtext(side=1,line=xline,"Mutation rate /site /year (10^-9)",cex=labcex)
	mtext(side=2,line=yline,"TMRCA (Mya)",cex=labcex)
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}


# extract subtree, specified by the number of the node at the base of the clade to be extracted
# In case you do not not know the number of the branch:
# Node numbers can be visualized by added to a tree plot, by running the command: nodelabels(frame="none",bg="white",cex=0.25,col="grey50")
# function 'Subtree' from Martin R. Smith from Durham University
# First option is extract.clade: extract.clade(phy=mytree,node=307) from ape package
getsubtree<-function(tree,node) 
	{
	if(is.null(treeOrder <- attr(tree, 'order')) || treeOrder != 'preorder') 
		{
		stop("Tree must be in preorder")
		}
	tipLabel 	<- tree[["tip.label"]]
	nTip 		<- length(tipLabel)
	if(node<=nTip) 
		{
		return(SingleTaxonTree(tipLabel[node]))
		}
	if(node==nTip+1L) 
		{
		return(tree)
		}
	edge <- tree[["edge"]]
	parent <- edge[, 1]
	child <- edge[, 2]
	subtreeParentEdge <- match(node, child)
	keepEdge <- DescendantEdges(subtreeParentEdge, parent, child)
	keepEdge[subtreeParentEdge] <- FALSE
	edge <- edge[keepEdge, ]
	edge1 <- edge[, 1]
	edge2 <- edge[, 2]
	#
	isTip <- edge2 <= nTip
	tips  <- edge2[isTip]
	new.nTip <- length(tips)
	name <- character(new.nTip)
	# method='radix' typically a few % faster than 'auto'
	tipOrder <- order(tips, method = 'radix')
	name[tipOrder] <- tipLabel[tips]
	edge2[isTip] <- tipOrder
	#  
	## renumber nodes:
	nodeAdjust <- new.nTip + 1 - node
	edge2[!isTip] <- edge2[!isTip] + nodeAdjust
	edge[, 1] <- edge1 + nodeAdjust
	edge[, 2] <- edge2
	#
	# Return:
	structure(list(tip.label = name,Nnode = dim(edge)[1] - new.nTip + 1L,edge = edge), class = 'phylo', order = 'preorder')
	}

# 26-07-2022: core module of pathlength function
# depends on function nodepath of package 'ape' 
calcpathlength<-function(mytree=mytree)
	{
	myinds				<- mytree$tip.label			
	ninds				<- length(myinds)
	mymatrix			<- matrix(NA,nrow=ninds,ncol=ninds)
	colnames(mymatrix)	<- myinds
	rownames(mymatrix)	<- myinds
	for(i in c(1:ninds))
		{
		for(j in c(1:ninds))
			{
			mypath		<- nodepath(mytree,from=i,to=j)
			myindices	<- vector()
			for(k in c(1:length(mypath)))
				{
				node2		<- mypath[k]
				node1		<- mypath[k-1]
				myindex		<- which((mytree$edge[,1]==node1&mytree$edge[,2]==node2)|(mytree$edge[,1]==node2&mytree$edge[,2]==node1))
				myindices	<- c(myindices,myindex)
				}
			mymatrix[i,j]	<- sum(mytree$edge.length[myindices])
			}
		}
	return(mymatrix)
	}

# 31-03-2022: extract from phylo object path lengths for sample pairs 
# depends on function nodepath of package 'ape' 
# 09-02-2023: equivalent to cophenetic.phylo function of ape? (also has an option to calculate distances between internal nodes)
pathlength<-function(mytree=mysambar$mytree,exporttype=NULL,plot_name="Pathlengths",distancemat=NULL,do_silent=TRUE,plotpathlength=FALSE,heatmapbreaks=NULL,addlabels=FALSE,domean=FALSE)
	{
	myinds		<- inds$name[inds$filter]				
	mycolours	<- inds$popcol[inds$filter]
	ninds		<- length(myinds)
	if(is.null(mytree))
		{
		return(cat("ERROR: specified tree does not exist.",sep="\n"))
		}
	if(length(mytree$tip.label)!=ninds)
		{
		return(cat("ERROR: number of labels in tree (mytree$tip.label) does not correspond with number of retained individuals (inds$name[inds$filter]) in inds dataframe.",sep="\n"))
		}
	if(any(!(as.character(mytree$tip.label)%in%as.character(myinds))))
		{
		return(cat("WARNING: one or more labels in tree (mytree$tip.label) do not correspond with names of retained individuals in inds dataframe (inds$name[inds$filter]).",sep="\n"))
		}
	if(any(!(as.character(mytree$tip.label)==as.character(myinds))))
		{
		cat("WARNING: order of labels in tree (mytree$tip.label) does not correspond with order of retained individuals in inds dataframe (inds$name[inds$filter]). Reordering individual names accordingly...",sep="\n")
		namevec			<- as.character(myinds)
		namevec2		<- as.character(mytree$tip.label)
		ordervec		<- vector()
		for(j in c(1:length(namevec)))
			{
			ordervec[j]	<- which(namevec==namevec2[j])
			}
		mycolours		<- mycolours[ordervec]
		myinds			<- myinds[ordervec]
		}
	# calculate path lengths between tips:
	if(nrow(mytree$edge)!=length(mytree$edge.length))
		{
		return(cat("ERROR: number of edges (nrow(mytree$edge)) does not correspond with number of edge lengths (mytree$edge.length).",sep="\n"))
		}
	#
	mymatrix			<- matrix(NA,nrow=ninds,ncol=ninds)
	colnames(mymatrix)	<- myinds
	rownames(mymatrix)	<- myinds
	for(i in c(1:ninds))
		{
		for(j in c(1:ninds))
			{
			mypath		<- nodepath(mytree,from=i,to=j)
			myindices	<- vector()
			for(k in c(1:length(mypath)))
				{
				node2		<- mypath[k]
				node1		<- mypath[k-1]
				myindex		<- which((mytree$edge[,1]==node1&mytree$edge[,2]==node2)|(mytree$edge[,1]==node2&mytree$edge[,2]==node1))
				myindices	<- c(myindices,myindex)
				}
			mymatrix[i,j]	<- sum(mytree$edge.length[myindices])
			}
		}
	if(any(myinds!=inds$name[inds$filter]))
		{
		ordervec		<- vector()
		for(k in c(1:ninds))
			{
			ordervec[k]		<- which(as.character(myinds)==as.character(inds$name[inds$filter][k]))
			}
		mymatrix	<- mymatrix[ordervec,ordervec]	# this one-liner only works if below-diagonal values equal above-diagonal values	
		}
	mysambar$mytree_pathlength	<<- mymatrix
	mymatrix2					<- mymatrix
	diag(mymatrix2)				<- NA		# not interested in diagonal values
	if(plotpathlength)
		{
		# by default set to FALSE, because actual path lengths are not of interest.
		# Of interest is the difference between path length and genetic distance
		plotindmatrix(n_bins=6,export=exporttype,add_lab=addlabels,ind_matrix=mymatrix2,export_name=plot_name,plottitle="Path length",silent=do_silent)
		}
	#
	if(!is.null(distancemat))
		{
		distancemat		<- as.matrix(distancemat)
		cat("Calculating and plotting difference between distance and path length...",sep="\n")
		if(is.null(dim(mymatrix)))
			{
			return(cat("ERROR: expected a matrix, but encountered object with less than 2 dimensions.",sep="\n"))
			}
		if(nrow(distancemat)!=nrow(mymatrix))
			{
			return(cat("ERROR: matrices do not correspond.",sep="\n"))
			}
		if(ncol(distancemat)!=ncol(mymatrix))
			{
			return(cat("ERROR: matrices do not correspond.",sep="\n"))
			}
		distancemat					<- as.matrix(distancemat)
		#ratiomat					<- mymatrix/distancemat					# as.matrix needed in case distancemat is a dist object
		#ratiomat[!is.finite(ratiomat)]	<- NA								# division by 0 leads to infinite diagonal values
		#plotindmatrix(n_bins=6,export=exporttype,add_lab=FALSE,ind_matrix=ratiomat,export_name=paste(plot_name,"diff",sep="."),plottitle="pathlength / distance",silent=do_silent)
		diffmat						<- (mymatrix-distancemat)/mymatrix
		diffmat[!is.finite(diffmat)]<- NA
		absdiffmat					<- abs(mymatrix-distancemat)/mymatrix
		absdiffmat[!is.finite(absdiffmat)]<- NA
		#
		if(domean)
			{
			# 27-11-2023: 
			# In X-chromosomal data, a lot of noise between individuals, because relatively few crossing-over points (leaving room for stochasticity).
			# By taking the mean, we artificially reduce the noise in the residual plot.
			cat("WARNING: calculating and plotting mean residual error values per population pair...",sep="\n")
			popvec	<- inds$pop[inds$filter]
			for(mypop1 in mysambar$populations)
				{
				for(mypop2 in mysambar$populations)
					{
					diffmat[popvec==mypop1,popvec==mypop2]	<- mean(diffmat[popvec==mypop1,popvec==mypop2],na.rm=TRUE)
					}
				}
			}
		# plotindmatrix(n_bins=6,export=exporttype,add_lab=FALSE,ind_matrix=absdiffmat,export_name=paste(plot_name,"absdiff",sep="."),plottitle="|(pathlength-distance)/pathlength"|,silent=do_silent)
		#
		# mybreaks	<- c(-0.3,-0.07,-0.05,-0.03,-0.01,0.01,0.03,0.05,0.07,0.3)
		mymax		<- max(abs(diffmat),na.rm=TRUE)	
		ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
		mymax		<- ceiling_dec(mymax)
		if(is.null(heatmapbreaks))
			{
			cat("Defining breaks from data...",sep="\n")
			if(mymax>0.1)
				{
				mybreaks	<- c(-mymax,-0.06,-0.04,-0.02,0.02,0.04,0.06,mymax)
				mybreaks2	<- c(-mymax,-0.07,-0.05,-0.03,-0.01,0.01,0.03,0.05,0.07,mymax)
				}else{
				mybreaks	<- c(-0.1,-0.06,-0.04,-0.02,0.02,0.04,0.06,0.1)
				mybreaks2	<- c(-mymax,-0.07,-0.05,-0.03,-0.01,0.01,0.03,0.05,0.07,mymax)
				}
			plotindmatrix(n_bins=length(mybreaks)-1,export=exporttype,add_lab=addlabels,ind_matrix=diffmat,my_Breaks=mybreaks,bincol1="blue",bincol2="red",midbincol="grey80",legendcex=2,export_name=paste(plot_name,"diff",sep="."),plottitle="(pathlength-distance)/pathlength",silent=do_silent)
			plotindmatrix(n_bins=length(mybreaks2)-1,export=exporttype,add_lab=addlabels,ind_matrix=diffmat,my_Breaks=mybreaks2,bincol1="blue",bincol2="red",midbincol="grey80",legendcex=1.75,export_name=paste(plot_name,"diff",sep="."),plottitle="(pathlength-distance)/pathlength",silent=do_silent)
			}else{
			cat("Using predefined breaks...",sep="\n")
			mybreaks		<- heatmapbreaks
			mybreakstemp	<<- heatmapbreaks
			plotindmatrix(n_bins=length(mybreaks)-1,export=exporttype,add_lab=addlabels,ind_matrix=diffmat,my_Breaks=mybreaks,bincol1="blue",bincol2="red",midbincol="grey80",legendcex=2,export_name=paste(plot_name,"diff",sep="."),plottitle="(pathlength-distance)/pathlength",silent=do_silent)
			}
		#
		distvec						<- distancemat[lower.tri(distancemat)]
		pathvec						<- mymatrix[lower.tri(mymatrix)]
		mybool						<- pathvec!=0
		mysambar$mytree_diffmat		<<- diffmat			
		mysambar$mytree_diffscore	<<- sum(abs(pathvec[mybool]-distvec[mybool])/pathvec[mybool],na.rm=TRUE)
		}else{
		cat("No distance matrix specified/found. Not calculating difference between distance and path length.",sep="\n")
		}
	}

comparemat<-function(mat1=NULL,mat2=NULL,plot_name="Matrix_diff_SNPvsMISAT",do_silent=TRUE,exporttype=NULL,binsize=0.05,plot_title="(mat1-mat2)/mat1")
	{
	mat1		<- as.matrix(mat1)
	mat2		<- as.matrix(mat2)
	diag(mat1)	<- NA
	diag(mat2)	<- NA
	diffmat		<- (mat2-mat1)/mat2
	mymax		<- max(abs(diffmat),na.rm=TRUE)
	mymin		<- min(abs(diffmat),na.rm=TRUE)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	mymax		<- ceiling_dec(mymax)
	mymin		<- floor_dec(mymin)
	#if(mymax>0.1)
	#	{
	#	mybreaks	<- c(-mymax,-0.06,-0.04,-0.02,0.02,0.04,0.06,mymax)
	#	}else{
	#	mybreaks	<- c(-0.1,-0.06,-0.04,-0.02,0.02,0.04,0.06,0.1)
	#	}
	mybreaks	<- seq(mymin,mymax,binsize)
	plotindmatrix(n_bins=length(mybreaks)-1,export=exporttype,add_lab=FALSE,ind_matrix=diffmat,my_Breaks=mybreaks,bincol1="darkorange",bincol2="grey80",legendcex=2,export_name=plot_name,plottitle=plot_title,silent=do_silent)
	}

pathlength_scatterplot<-function(export=NULL,yline=4.75,addlegend=TRUE,focuspop=NULL,excludepop=NULL,plotname="Pathlengths_vs_GeneticDistance",plottitle=NULL,symbolsize=1.5,legendcex=1,legendpos="topleft",plotrange=NULL)
	{
	if(is.null(mysambar$mytree_distmat))
		{
		return(cat("ERROR: mysambar$mytree_distmat not found.",sep="\n"))
		}
	if(is.null(mysambar$mytree_distmat))
		{
		return(cat("ERROR: mysambar$mytree_pathlength not found.",sep="\n"))
		}
	# genetic distance:
	mydistmat		<- as.matrix(mysambar$mytree_distmat)
	distdf			<- as.data.frame(as.table(mydistmat))
	colnames(distdf)<- c("sample1","sample2","dist")
	distdf			<- distdf[!is.na(distdf$dist),]
	distdf$ind1		<- ifelse(as.character(distdf$sample1)<as.character(distdf$sample2),as.character(distdf$sample1),as.character(distdf$sample2))
	distdf$ind2		<- ifelse(as.character(distdf$sample1)<as.character(distdf$sample2),as.character(distdf$sample2),as.character(distdf$sample1))
	distdf			<- distdf[order(distdf$ind1,distdf$ind2),]
	distdf			<- distdf[,c("ind1","ind2","dist")]
	distdf			<- distdf[!duplicated(distdf),]
	#
	# distance in tree:
	mypathmat		<-as.matrix(mysambar$mytree_pathlength)
	pathdf			<-as.data.frame(as.table(mypathmat))
	colnames(pathdf)<- c("sample1","sample2","path")
	pathdf			<- pathdf[!is.na(pathdf$path),]	 
	pathdf$ind1		<- ifelse(as.character(pathdf$sample1)<as.character(pathdf$sample2),as.character(pathdf$sample1),as.character(pathdf$sample2))
	pathdf$ind2		<- ifelse(as.character(pathdf$sample1)<as.character(pathdf$sample2),as.character(pathdf$sample2),as.character(pathdf$sample1))
	pathdf			<- pathdf[order(pathdf$ind1,pathdf$ind2),]
	pathdf			<- pathdf[,c("ind1","ind2","path")]
	pathdf			<- pathdf[!duplicated(pathdf),]
	#
	# combine:
	if(nrow(pathdf)!=nrow(distdf))
		{
		return(cat("ERROR: different numbers of rows in pathdf and distdf.",sep="\n"))
		}
	distdf$path		<- pathdf$path
	#
	# add population info:
	popdf			<- inds[,c("name","pop","popcol")]
	colnames(popdf)	<- c("ind1","pop1","col1")
	mydf			<- merge(distdf,popdf,by="ind1")
	colnames(popdf)	<- c("ind2","pop2","col2")
	mydf			<- merge(mydf,popdf,by="ind2")
	mydf$popcol1	<- ifelse(as.character(mydf$col1)<as.character(mydf$col2),as.character(mydf$col1),as.character(mydf$col2))
	mydf$popcol2	<- ifelse(as.character(mydf$col1)<as.character(mydf$col2),as.character(mydf$col2),as.character(mydf$col1))
	# calculate difference:
	mydf$absdiff	<- abs((mydf$path-mydf$dist)/mydf$path)
	mydf$diff		<- (mydf$path-mydf$dist)/mydf$path
	mydf$absdiff[!is.finite(mydf$absdiff)]	<- NA
	mydf$diff[!is.finite(mydf$diff)]		<- NA
	# optionally make subselection:
	mysambar$mytree_diffdf	<<- mydf 
	if(!is.null(focuspop))
		{
		for(mypop in focuspop)
			{
			mydf		<- mydf[mydf$pop1==mypop|mydf$pop2==mypop,]
			}
		mydf		<- mydf[mydf$pop1!=mydf$pop2,]	
		}
	mydf	<<- mydf
	if(!is.null(excludepop))
		{
		for(mypop in excludepop)
			{
			mydf		<- mydf[mydf$pop1!=mypop&mydf$pop2!=mypop,]
			}
		mydf		<- mydf[mydf$pop1!=mydf$pop2,]
		}
	# remove within individual comparison:
	mydf			<- mydf[mydf$ind1!=mydf$ind2,]
	mysambar$pathlengthdf	<<- mydf
	#
	xmax			<- max(mydf$path)
	xmin			<- min(mydf$path)
	ymax			<- max(mydf$dist)
	ymin			<- min(mydf$dist)
	if(is.null(plotrange))
		{
		axismin		<- min(c(xmin,ymin))
		axismax		<- max(c(xmax,ymax))
		}else{
		axismin		<- plotrange[1]
		axismax		<- plotrange[2]
		}
	if(!is.null(export))
		{
		legendlabel	<- ifelse(addlegend,"withlegend","NOlegend")
		rangelabel	<- ifelse(is.null(plotrange),"fullrange",paste(plotrange[1],"-",plotrange[2],sep=""))
		poplabel	<- ifelse(is.null(focuspop),"allpops",focuspop)
		if(export=="eps"){postscript(paste(plotname,poplabel,rangelabel,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,poplabel,rangelabel,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,poplabel,rangelabel,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,poplabel,rangelabel,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,7,2.5,1),cex.axis=1.75,cex.lab=2.5,cex.main=3)
	plot(mydf$path,mydf$dist,pch=21,lwd=2,col=as.character(mydf$popcol1),bg=as.character(mydf$popcol2),xlim=c(axismin,axismax),ylim=c(axismin,axismax),cex=symbolsize,xlab="Tree path length",ylab="",las=1)
	lines(c(-100,100),c(-100,100),col="grey60")
	mtext(side=2,line=yline,"Genetic distance",cex=3)
	if(addlegend)
		{
		legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,cex=2.5,line=0.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 30-08-2022:
phylonetwork<-function(use_dnabin=TRUE,njnetwork=FALSE,doplot=FALSE,mythres=0.3)
	{
	set.seed(1)
	if(use_dnabin)
		{
		if(is.null(mysambar$mydnabin))
			{
			cat("DNAbin object not found. Generating...",sep="\n")
			genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
			}else{
			if(dim(mysambar$mydnabin)[1]!=nrow(inds[inds$filter,])|dim(mysambar$mydnabin)[2]!=nrow(snps[snps$filter,]))
				{
				cat("Dimensions of DNAbin object stored at mysambar$mydnabin do not correspond with number of retained individuals and/or number of retained snps. Overwriting...",sep="\n")
				genlight2DNAbin(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,quiet=FALSE) 
				}else{
				cat("WARNING: using existing DNAbin object stored at mysambar$mydnabin.",sep="\n")
				}
			}
		myphydat	<- phyDat(data=mysambar$mydnabin,type="DNA",levels=NULL,return.index=TRUE)
		mytree 		<- nj(dist.hamming(myphydat))
		bs 			<- bootstrap.phyDat(myphydat,FUN=function(x)nj(dist.hamming(x)),bs=100)
		mytree 		<- plotBS(mytree,bs,"unrooted")
		}else{
		mytree		<- bitwise.dist(mygenlight[inds$filter,snps$filter])
		bs			<- poppr::aboot(mygenlight[inds$filter,snps$filter],tree="NJ",distance="bitwise.dist",sample=10,showtree=F,cutoff=50,quiet=F)
		mytree 		<- plotBS(mytree,bs,"unrooted")
		# results in: Error: $ operator is invalid for atomic vectors
		}
	if(njnetwork)
		{
		# exhaustive:
		#neighbor network (2D-version of NJ algorithm)
		distmat 	<- dist.hamming(myphydat)
		nnet 		<- neighborNet(distmat)
		plot(nnet,"2D")
		}else{
		# consensus network:
		cnet <- consensusNet(bs,mythres)
		plot(cnet, show.edge.label=TRUE)
		}
	if(doplot)
		{
		# further instructions can be found in online tutorial of K. Schiep, Intertwining Trees and Networks
		# Show edges with occur in tree as well as network:
		edge.lab <- createLabel(nnet,mytree,mytree$edge[,2],"edge")
		edgelabels(mytree$edge[,2],col="blue",frame="none",cex=.7)
		#
		# find edges that are in the network but not in the tree (indicated in red)
		#edge.col 					<- rep("black",nrow(nnet$edge))
		#edge.col[is.na(edge.lab)] 	<- "red"
		edge.col 	<- createLabel(nnet,mytree,"black",nomatch="red")
		x 			<- plot(nnet,edge.label=edge.lab,show.edge.label=T,"2D",edge.color=edge.col,col.edge.label="blue",cex=.7)
		}
	}

# 18-02-20: The function 'calc_dc' calculates what I call the the dc-score, the 'distinct clustering'-score.
# I developed this measure to enhance objective interpretation of coordination analyses (such as PCA, PCOA and CA).
# It is not uncommon to read that PCA-analyses 'clearly' reveal distinct clusters.
# The dc-score quantifies to what extent clusters overlap based on first 2 axes of PCA plot.
# The measure is very intuitive: it is the ratio between 'mean distance of samples from population mean' and the 'mean distance between populations'.
# If the dc-score is close to 0, populations cluster away from each other, and for each population sample dots are laying atop of each other.
# If the dc-score is equal or greater than 1, populations overlap.   
# The input to the function should be a matrix with sample loadings on pc-axes, for example created with the function ape_pcoa.
# Note: the dc-score does not consider consider explained variance by each ordination axis. 
calc_dc<-function(popnames=mysambar$populations,pscores=NULL,tablename=NULL,make_global=FALSE,axis_1=1,axis_2=2)
	{
	if(is.null(pscores))
		{
		return(cat("ERROR: provide matrix or dataframe with p-scores to pscore flag.",sep="\n"))
		}
	mypops			<- inds$pop[inds$filter]
	npops			<- length(popnames)
	if(npops==1)
		{
		return(cat("Only 1 population defined. Omitting calculation of dc-score.",sep="\n"))
		}
	nsamples		<- length(mypops)
	n_pcs			<- ncol(pscores)
	meanp			<- matrix(NA,nrow=n_pcs,ncol=npops)
	colnames(meanp)	<- popnames
	devp			<- matrix(NA,nrow=n_pcs,ncol=nsamples)
	meandev			<- matrix(NA,nrow=n_pcs,ncol=npops)
	colnames(meandev)<- popnames
	#
	for (pcol in c(1:n_pcs))
		{
		myp			<-	pscores[,pcol]
		# calculate mean p-scores per population:
		for (k in c(1:npops))
			{
			my_pop			<- popnames[k]
			meanp[pcol,k]	<- mean(myp[mypops==my_pop])
			}
		# calculate deviation from mean p-score per sample:
		for (m in c(1:nsamples))
			{
			my_pop		<- mypops[m]
			popnr		<- which(popnames==my_pop)
			devp[pcol,m]<- abs(myp[m]-meanp[pcol,popnr])  
			}
		# calculate mean deviation for each population:
		for (k in c(1:npops))
			{
			my_pop			<- popnames[k]
			mydev			<- devp[pcol,]			
			meandev[pcol,k]	<- mean(mydev[mypops==my_pop])
			}
		}
	if(make_global)
		{
		meanp		<<- meanp
		devp		<<- devp
		meandev		<<- meandev
		}
	#
	# calculate distance between populations for two axes:
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	pdist			<- vector()
	for (k in c(1:ncombi))
		{
		my_pop1		<- combitable[1,k]
		my_pop2		<- combitable[2,k]
		pvec1		<- meanp[c(axis_1,axis_2),which(popnames==my_pop1)] 
		pvec2		<- meanp[c(axis_1,axis_2),which(popnames==my_pop2)]
		dist1		<- abs(pvec2[1]-pvec1[1])
		dist2		<- abs(pvec2[2]-pvec1[2])
		pdist[k]	<- round(sqrt(dist1^2+dist2^2),4)
		}
	# calculate the mean distance between samples and population meanspacing
	sampledist		<- round(sqrt(devp[axis_1,]^2+devp[axis_2,]^2),4)
	sampledistmean	<- vector()
	for (k in c(1:npops))
		{
		my_pop			<- popnames[k]
		sampledistmean[k]<- mean(sampledist[mypops==my_pop])
		}
	#
	# lastly, calculate the ratio between 'sample deviation from population mean' and 'mean differentiation between populations':
	# 'distinct cluster'-score:
	dcscore		<- data.frame("pop1"=combitable[1,],"pop2"=combitable[2,],"popdist"=pdist)		
	for (k in c(1:ncombi))
		{
		my_pop1				<- as.character(dcscore$pop1[k])
		my_pop2				<- as.character(dcscore$pop2[k])
		dcscore$within1[k]	<- round(sampledistmean[which(popnames==my_pop1)],4)
		dcscore$within2[k]	<- round(sampledistmean[which(popnames==my_pop2)],4)
		dcscore$n_pop1[k]	<- length(which(mypops==my_pop1)) 
		dcscore$n_pop2[k]	<- length(which(mypops==my_pop2))
		}
	dcscore$dc1				<- round(dcscore$within1/dcscore$popdist,4) 
	dcscore$dc2				<- round(dcscore$within2/dcscore$popdist,4)
	#
	# mean dc-score:
	dcscore$meandc			<- round(mean(c(dcscore$dc1,dcscore$dc2)),4)
	dcscore$weigted_meandc	<- round(sum(dcscore$dc1*dcscore$n_pop1+dcscore$dc2*dcscore$n_pop2)/(sum(dcscore$n_pop1)+sum(dcscore$n_pop2)),4)	
	mysambar$dcscore		<<- dcscore 
	if(!is.null(tablename))
		{
		#cat(paste("Writing file '",tablename,"'. If you receive the error 'Error in file(file, ifelse(append,'a','w')): cannot open the connection', is the file perhaps open in a file viewer?",sep=""),sep="\n")
		#cat("Else, run the findstructure function with the flag do_dc set to FALSE.",sep="\n")
		write.table(dcscore,tablename,row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		}
	}

dcplot<-function(exporttype=NULL,mycex=6)
	{
	z		<- data.frame("p1"=as.numeric(as.character(c("-0.02","0.02","0.03","0.02","-0.03","-0.01"))),"p2"=as.numeric(as.character(c("-0.03","-0.03","0.03","0.02","0.03","0.01"))),"mean_p1"=as.numeric(as.character(c("0","0","0.025","0.025","-0.02","-0.02"))),"mean_p2"=as.numeric(as.character(c("-0.03","-0.03","0.025","0.025","0.02","0.02"))))
	z$col	<- c("blue","blue","darkred","darkred","darkgreen","darkgreen")
	if(!is.null(exporttype))
		{
		mywid		<- 27.5
		myhei		<- 9.5
		mywid2		<- 2000
		myhei2		<- 720
		plotname	<- "dcscore_example"
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(6,4,3,1),cex.axis=3.75)
	plot(z$p1,z$p2,xlim=c(-0.035,0.035),ylim=c(-0.035,0.035),col=z$col,xlab="",cex=mycex,ylab="",xaxt='n',pch=16)
	legend("right",legend=c("popA","popB","popC"),cex=4,bty='n',fill=c("blue","darkred","darkgreen"))
	mtext("1. ordination analysis",cex=2.5,side=3,line=0.5)
	axis(side=1,mgp=c(0,2.5,0))
	#
	plot(z$p1,z$p2,xlim=c(-0.035,0.035),ylim=c(-0.035,0.035),col=z$col,xlab="",cex=mycex,ylab="",xaxt='n',pch=16)
	points(z$mean_p1,z$mean_p2,pch=1,col=z$col,cex=mycex)
	legend("right",legend=c("popA","popB","popC"),cex=4,bty='n',fill=c("blue","darkred","darkgreen"))
	mtext("2. mean loadings per population",cex=2.5,side=3,line=0.5)
	axis(side=1,mgp=c(0,2.5,0))
	#
	plot(z$p1,z$p2,xlim=c(-0.035,0.035),ylim=c(-0.035,0.035),col=z$col,xlab="",cex=mycex,ylab="",xaxt='n',pch=16)
	points(z$mean_p1,z$mean_p2,pch=1,col=z$col,cex=mycex)
	legend("right",legend=c("popA","popB","popC"),cex=4,bty='n',fill=c("blue","darkred","darkgreen"))
	mtext("3. distances between (mean) loadings",cex=2.5,side=3,line=0.5)
	axis(side=1,mgp=c(0,2.5,0))
	arrows(x0=z$p1,y0=z$p2,x1=z$mean_p1,y1=z$mean_p2,col=z$col,length=0.25)
	arrows(x1=z$p1,y1=z$p2,x0=z$mean_p1,y0=z$mean_p2,col=z$col,length=0.25)
	#
	arrows(x0=z$mean_p1[1],y0=z$mean_p2[1],x1=z$mean_p1[3],y1=z$mean_p2[3],length=0.25)
	arrows(x0=z$mean_p1[3],y0=z$mean_p2[3],x1=z$mean_p1[1],y1=z$mean_p2[1],length=0.25)
	arrows(x0=z$mean_p1[1],y0=z$mean_p2[1],x1=z$mean_p1[5],y1=z$mean_p2[5],length=0.25)
	arrows(x0=z$mean_p1[5],y0=z$mean_p2[5],x1=z$mean_p1[1],y1=z$mean_p2[1],length=0.25)
	arrows(x0=z$mean_p1[3],y0=z$mean_p2[3],x1=z$mean_p1[5],y1=z$mean_p2[5],length=0.25)
	arrows(x0=z$mean_p1[5],y0=z$mean_p2[5],x1=z$mean_p1[3],y1=z$mean_p2[3],length=0.25)
	mtext("axis1",side=1,line=3.5,cex=3,outer=TRUE)
	mtext("axis2",side=2,line=0.5,cex=3,outer=TRUE)
	if(!is.null(exporttype)){dev.off()}
	}

plotloadings<-function(exporttype=NULL,naxes=10,varthres=NULL,myloadings=mysambar$p$vectors,myperc=mysambar$pcoaperc,myxlim=NULL,plotname="Ordination_loadings")
	{
	# or: p$values$Relative_eig
	if(is.null(myloadings))
		{
		return(cat("ERROR: provide a matrix with loadings to the myloadings flag.",sep="\n"))	
		}
	if(nrow(myloadings)!=nrow(inds[inds$filter,]))
		{
		return(cat("ERROR: number of rows of loadings matrix does not correspond to number of retained individuals. Not plotting loadings.",sep="\n"))
		}
	if(is.null(myperc))
		{
		if(is.null(naxes))
			{
			return(cat("ERROR: no input specified to myperc flag and also not to naxes flag. How many axes should be displayed?.",sep="\n"))		
			}else{
			cat("WARNING: selecting number of axes as specified to naxes flag.",sep="\n") 
			}
		}else{	
		if(is.null(varthres))
			{
			cat("WARNING: selecting number of axes as specified to naxes flag, because varthres is set to NULL.",sep="\n") 
			}else{
			cat(paste("Selecting axes with a minimum of explained variance above ",varthres,".",sep=""),sep="\n")		
			#mybool	<- p$values$Relative_eig>varthres
			mybool	<- myperc>varthres
			naxes	<- length(mybool[mybool])
			}
		}
	#cat(paste(naxes," selected.",sep=""),sep="\n")
	if(length(naxes)==0)
		{
		return(cat("ERROR: Zero axes selected.",sep="\n"))
		}
	if(ncol(myloadings)<naxes)
		{
		cat("WARNING: less columns in myloadings matrix than specified to naxes flag (default is 10). Adjusting...",sep="\n")
		naxes	<- ncol(myloadings)	
		}
	popnames	<- mysambar$populations
	popcolours	<- mysambar$mycolours
	npops		<- length(popnames)
	#
	mymat			<- myloadings[,c(1:naxes),drop=FALSE]
	rownames(mymat)	<- inds$name[inds$filter]
	colnames(mymat)	<- c(1:naxes) 
	mydf			<- data.frame("p"=as.vector(mymat),"name"=rep(rownames(mymat),ncol(mymat)),"axis"=rep(colnames(mymat),each=nrow(mymat)))
	indstemp		<- inds[inds$filter,c("name","pop")]
	mydf			<- merge(mydf,indstemp,by="name")
	mydf$axisorder	<- factor(mydf$axis,levels=rev(c(1:naxes)))
	#
	if(is.null(myxlim))
		{
		myxlim	<- c(min(mymat,na.rm=TRUE),max(mymat,na.rm=TRUE))	
		}
	if(!is.null(plotname))
		{
		plotname	<- paste(plotname,"stripchart",sep="_")
		}else{
		plotname	<- "Ordination_loadings_stripchart"
		}
	if(!is.null(exporttype))
		{
		myheight	<- naxes*0.75+2
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=myheight)}
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=myheight)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=myheight)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=myheight)}
		par(mar=c(2.5,5,1.5,6.5),cex.axis=2,cex.lab=3,cex.main=3)
		}
	stripchart(p~axisorder,data=mydf,vertical=FALSE,col="white",method="jitter",jitter=0.425,pch=16,cex=1,bg=inds$popcol[inds$filter],ylab="",xlab="",las=1,xlim=myxlim)
	mtext(side=2,"Axis",line=3,cex=2.5)
	if(!is.null(myperc))
		{
		myperc	<- paste(round(myperc*100,1),"%",sep="")
		myperc	<- myperc[1:naxes]
		axis(side=4,at=seq(1,naxes,1),label=rev(myperc),cex=0.25,las=1)
		}
	for(j in c(1:npops))
		{
		mypop	<- popnames[j]
		mycol	<- popcolours[j]
		stripchart(p~axisorder,data=mydf[mydf$pop==mypop,],vertical=FALSE,col=mycol,method="jitter",jitter=0.425,pch=16,cex=1.25,bg=mycol,add=TRUE,ylab="")
		}
	if(!is.null(exporttype)){dev.off()}
	}

ape_pcoa_pop<-function(popnames=mysambar$populations,exporttype="pdf",my_method="hamming",silent=TRUE)
	{
	if(length(popnames)>1)
		{
		for (my_pop in popnames)
			{
			if(!silent){cat(my_pop,sep="\n")}
			npopind	<- nrow(inds[inds$pop==my_pop&inds$filter,])
			if(npopind<3)
				{
				if(!silent){cat("Less than 3 retained individuals. Omitting population specific pcoa plot.",sep="\n")}
				}else{
				ape_pcoa(indselection=inds$filter&inds$pop==my_pop,method=my_method,printname=inds$name,export=exporttype,label_size=1,labels=TRUE,addlegend=FALSE,exportname=my_pop,dodc=FALSE)
				if(any(as.vector(inds$pop2)!=as.vector(inds$pop)))
					{
					ape_pcoa(indselection=inds$filter&inds$pop==my_pop,use_symboltype2=TRUE,symbolsize=3,method=my_method,printname=inds$name,export=exporttype,labels=FALSE,addlegend=TRUE,exportname=my_pop,dodc=FALSE)
					}else{
					ape_pcoa(indselection=inds$filter&inds$pop==my_pop,use_symboltype2=FALSE,symbolsize=3,method=my_method,printname=inds$name,export=exporttype,labels=TRUE,addlegend=TRUE,exportname=my_pop,dodc=FALSE)
					}
				}
			}
		cat("Population specific pcoa plots have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}else{
		cat("Currently only 1 population defined. Omitting population specific pcoa plots.",sep="\n")
		}
	}

# PCoA: Principal Coordinates Analysis (NOTE: this is different from principal component analysis or PCA). Depends on StAMPP (Nei's genetic distance) and Ape (pcoa):
# ape_pcoa(method="hamming",symbolkey="sex",legendpos="topleft")
ape_pcoa<-function(pscores=NULL,inputdistmat=NULL,method="nei",axis1=1,axis2=2,doplot=TRUE,mybg="white",axiscol="black",dodc=TRUE,do_mirror=c(FALSE,FALSE),indselection=inds$filter,snpselection=snps$filter,colourcode=inds$popcol,popcolours=mysambar$mycolours,labcex=3,axiscex=2,axisdistance=NULL,labeldistance=3.75,ylabeldistance=3.75,export=NULL,exportname=NULL,popnames=mysambar$populations,mypch=16,symbolkey=NULL,use_symboltype2=FALSE,mar1=5,mar2=6.5,mar3=3.5,mar4=1,symbolsize=2.5,addlegend=TRUE,legendpos="bottomright",legendcex=2,mylegend=mysambar$poporder,mylegendcol=mysambar$colorder,mylegendtitle=NULL,side4label=NULL,addtitle=NULL,title_cex=NULL,titledistance=1,labels=FALSE,label_size=0.75,printname=NULL,printpop2=FALSE,missvector=NULL,resetgraphics=TRUE,silent=TRUE,makeglobal=FALSE,return_object=FALSE,addellipse=FALSE,ellipselevel=0.5,addbox=TRUE,boxlwd=1,shuffle_par=NULL,addxy=FALSE,use_current_dir=FALSE)
	{
	# method can be "nei" (Nei's genetic distance D), "hamming" (Hamming's genetic distance), "euclidean", "pi", "reynolds", or "edwards", although the latter two produces NA and are therefore not useful.
	# Note: snpselection and indselection can not be applied when running method 'pi'. You should use calcpi() function to recalculate pi on different snp dataset.
	# Note: symbol size will be 0.75 for labels (irrespective of settings), to avoid overlap. 
	# Note: legend will not be displayed when only one population is defined, irrespective of settings.
	#
	# How to interpret the eigenvalues (from GUSTA ME website):
	# "As with other ordination techniques such as PCA and CA, PCoA produces a set of uncorrelated (orthogonal) axes to summarise the variability in the data set. 
	# Each axis has an eigenvalue whose magnitude indicates the amount of variation captured in that axis. 
	# The proportion of a given eigenvalue to the sum of all eigenvalues reveals the relative 'importance' of each axis. 
	# A successful PCoA will generate a few (2-3) axes with relatively large eigenvalues, capturing above 50% of the variation in the input data, with all other axes having small eigenvalues."
	#
	if(!(method=="nei"|method=="hamming"|method=="pi"|method=="euclidean"|method=="reynolds"|method=="edwards"))
		{
		return(cat("ERROR: method has to be either 'nei', 'hamming', 'pi', 'euclidean', 'reynolds' or 'edwards'.",sep="\n"))
		}
	if(!is.null(symbolkey))
		{
		if(any(symbolkey%in%colnames(inds)))
			{
			symbolkeyvec	<- inds[,symbolkey]
			}else{
			return(cat("ERROR: Symbolkey not present as column name in inds dataframe.",sep="\n"))
			}
		if(length(unique(symbolkeyvec[indselection]))>13)
			{
			return(cat("ERROR: Symbolkey contains more than 13 levels. Currently not supported by SambaR.",sep="\n"))
			}
		}
	npops			<- length(popnames)
	#
	if(is.null(pscores))
		{
		if(!is.null(inputdistmat))
			{
			cat("Using distance matrix specified to inputdistmat flag.",sep="\n")
			cat(paste("Number of individuals: ",ncol(as.matrix(inputdistmat)),".",sep=""),sep="\n")
			distmat	<- inputdistmat
			if(any(is.na(distmat)))
				{
				mysambar$pcoa_error	<<- TRUE
				return(cat("ERROR: Pcoa plot can not be generated due to missing data in input distance matrix.",sep="\n"))
				}else{
				mysambar$pcoamatrix	<<- inputdistmat
				mysambar$pcoa_error	<<- FALSE
				}
			if(any(is.infinite(distmat)))
				{
				return(cat("ERROR: Pcoa plot can not be generated due to infinite values in input distance matrix.",sep="\n"))
				}
			# sambarfunction_findstructure:
			p 				<- ape::pcoa(distmat, correction="none", rn=NULL)
			if(makeglobal)
				{
				mymatrix	<<- distmat
				p			<<- p
				}
			}else{
			if(!silent){cat("Calculating genetic distance matrix, and subsequently carrying out pcoa analyses...",sep="\n")}
			if(method=="nei")
				{
				if(!silent){cat("Generating distance matrix based on Nei's D...",sep="\n")}
				# sambarfunction_findstructure:
				neimatrix 		<- StAMPP::stamppNeisD(mygenlight[indselection,snpselection],pop=FALSE)
				if(!silent){neimatrix	<<- neimatrix}
				if(any(is.na(neimatrix)))
					{
					mysambar$pcoa_error	<<- TRUE
					return(cat("ERROR: Pcoa plot can not be generated due to missing data in neimatrix.",sep="\n"))
					}else{
					mysambar$pcoamatrix	<<- neimatrix
					mysambar$pcoa_error	<<- FALSE
					}
				if(any(is.infinite(neimatrix)))
					{
					return(cat("ERROR: Pcoa plot can not be generated due to infinite values in neimatrix.",sep="\n"))
					}
				# sambarfunction_findstructure:
				p 				<- ape::pcoa(neimatrix, correction="none", rn=NULL)
				if(makeglobal)
					{
					mymatrix	<<- neimatrix
					p			<<- p
					}
				}
			if(method=="hamming")
				{
				ploidy(mygenlight)<-2
				if(!silent){cat("Generating distance matrix based on Hammings genetic distance...",sep="\n")}
				# sambarfunction_findstructure:
				hammingmatrix	<- poppr::bitwise.dist(mygenlight[indselection,snpselection],mat=TRUE,euclidean=FALSE)
				if(any(is.na(hammingmatrix)))
					{
					mysambar$pcoa_error	<<- TRUE
					return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
					}else{
					mysambar$pcoamatrix	<<- hammingmatrix
					mysambar$pcoa_error	<<- FALSE
					}
				# sambarfunction_findstructure:
				p 				<- ape::pcoa(hammingmatrix, correction="none", rn=NULL)
				if(makeglobal)
					{
					mymatrix	<<- hammingmatrix
					p			<<- p
					}
				}
			if(method=="euclidean")
				{
				eucmatrix		<- poppr::bitwise.dist(mygenlight[indselection,snpselection],mat=TRUE,euclidean=TRUE)
				if(any(is.na(eucmatrix)))
					{
					mysambar$pcoa_error	<<- TRUE
					return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
					}else{
					mysambar$pcoamatrix	<<- eucmatrix
					mysambar$pcoa_error	<<- FALSE
					}
				# sambarfunction_findstructure:
				p 				<- ape::pcoa(eucmatrix, correction="none", rn=NULL)
				if(makeglobal)
					{
					mymatrix	<<- eucmatrix
					p			<<- p
					}
				}
			if(method=="pi")
				{
				# pimatrix is generated with calcpi
				if(is.null(mysambar$pidf_metalist[[1]]))
					{
					cat("Pairwise distances list not present. Generating now...",sep="\n")
					#sambarfunction_findstructure
					calcpi(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE)
					}else{
					pidf		<- mysambar$pidf_metalist[[1]]
					obspairs	<- nrow(pidf[pidf$ind1!=pidf$ind2,])
					nind		<- nrow(inds[inds$filter,])
					exppairs	<- (nind*(nind-1))/2
					if(obspairs!=exppairs)
						{
						cat("Number of sample pairs in mysambar$pidf_metalist[[1]] does not correspond with expected number. Recalculating pairwise distances...",sep="\n")
						calcpi(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE)
						}
					}
				#sambarfunction_findstructure
				pidf			<- mysambar$pidf_metalist[[1]]
				if(!silent){cat("Converting from dataframe to matrix...",sep="\n")}
				#sambarfunction_findstructure
				pimatrix		<- pidf2matrix(pidf=mysambar$pidf_metalist[[1]],myinds=inds$nr[inds$filter])
				if(any(is.na(pimatrix)))
					{
					mysambar$pcoa_error	<<- TRUE
					return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
					}else{
					mysambar$pcoamatrix	<<- pimatrix
					mysambar$pcoa_error	<<- FALSE
					}
				if(!silent){cat("Executing pcoa analyses...",sep="\n")}
				# sambarfunction_findstructure:
				if(!silent){pimatrix	<<- pimatrix}
				p 				<- ape::pcoa(pimatrix, correction="none", rn=NULL)	
				if(makeglobal)
					{
					mymatrix	<<- pimatrix
					p			<<- p
					}
				# 15-11-2019: untraceable error when running the function above: Error in array(STATS, dims[perm]) : 'dims' cannot be of length 0
				# 26-01-2020: another untraceable error when running the function above: 
				# Error in data.frame(eig[1:k], rel.eig, rel.eig.cor, bs, cum.eig.cor, cum.bs) : 
				# arguments imply differing number of rows: 90, 92
				# In addition: Warning message:
				# In sqrt(eig[1:k2]) : NaNs produced
				}
			if(method=="edwards")
				{
				# 21-03-2022: not useful, because produces NA-values.
				if(is.null(mysambar$genind))
					{
					genlight2genind(input=mygenlight,add2sambar=TRUE)
					}else{
					if(length(pop(mysambar$genind))!=length(inds$name[inds$filter]))
						{
						cat("WARNING: number of individuals in mysambar$genind object does not correspond with number of retained individuals in inds dataframe. Creating new genind object...",sep="\n") 
						genlight2genind(input=mygenlight,add2sambar=TRUE)
						}else{
						cat("Using available genind object at mysambar$genind.",sep="\n")
						}
					}
				mymatrix		<- poppr::edwards.dist(mysambar$genind)
				if(any(is.na(mymatrix)))
					{
					mysambar$pcoa_error	<<- TRUE
					return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
					}else{
					mysambar$pcoamatrix	<<- mymatrix
					mysambar$pcoa_error	<<- FALSE
					}
				# sambarfunction_findstructure:
				p 				<- ape::pcoa(mymatrix, correction="none", rn=NULL)
				if(makeglobal)
					{
					mymatrix	<<- mymatrix
					p			<<- p
					}
				}
			if(method=="reynolds")
				{
				# 21-03-2022: not useful, because produces NA-values. 
				if(is.null(mysambar$genind))
					{
					genlight2genind(input=mygenlight,add2sambar=TRUE)
					}else{
					if(length(pop(mysambar$genind))!=length(inds$name[inds$filter]))
						{
						cat("WARNING: number of individuals in mysambar$genind object does not correspond with number of retained individuals in inds dataframe. Creating new genind object...",sep="\n") 
						genlight2genind(input=mygenlight,add2sambar=TRUE)
						}else{
						cat("Using available genind object at mysambar$genind.",sep="\n")
						}
					}
				mymatrix		<- poppr::reynolds.dist(mysambar$genind)
				if(any(is.na(mymatrix)))
					{
					mysambar$pcoa_error	<<- TRUE
					return(cat("Pcoa plot can not be generated due to missing data.",sep="\n"))
					}else{
					mysambar$pcoamatrix	<<- mymatrix
					mysambar$pcoa_error	<<- FALSE
					}
				# sambarfunction_findstructure:
				p 				<- ape::pcoa(mymatrix, correction="none", rn=NULL)
				if(makeglobal)
					{
					mymatrix	<<- mymatrix
					p			<<- p
					}
				}
			}
		}else{
		cat("Plotting p-scores provided to pscores flag...",sep="\n")
		p	<- pscores
		} 	
	mysambar$myp		<<- p
	#
	if(doplot)
		{
		myp1	<- p$vectors[,axis1]
		myp2	<- p$vectors[,axis2]
		if(!is.null(shuffle_par))
			{
			myp1	<- myp1+shuffle_par*runif(length(myp1))
			myp2	<- myp2+shuffle_par*runif(length(myp2))
			}
		if(do_mirror[1])
			{
			cat("Mirror image of axis1.",sep="\n")
			myp1	<- -myp1
			}
		if(do_mirror[2])
			{
			cat("Mirror image of axis2.",sep="\n")
			myp2	<- -myp2
			}	
		if(!silent){cat("Finished pcoa analyses. Plotting...",sep="\n")}
		if(!is.null(export))
			{
			if(resetgraphics){graphics.off()}
			if(!use_current_dir){setwd(mysambar$structuredir)}
			my_symbol	<- ifelse(labels,ifelse(is.null(missvector),"labels","missingness"),ifelse(is.null(symbolkey),ifelse(use_symboltype2,"symboltype2","dots"),symbolkey))
			if(is.null(exportname))
				{
				myplotname	<- paste("pcoa",method,paste("PC",axis1,"vs",axis2,sep=""),my_symbol,sep=".")
				}else{
				myplotname	<- paste("pcoa",exportname,method,paste("PC",axis1,"vs",axis2,sep=""),my_symbol,sep=".")
				}
			myplotname		<- ifelse(mybg=="white",myplotname,paste(myplotname,mybg,sep="."))
			if(export=="eps"){postscript(paste(myplotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf(paste(myplotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png(paste(myplotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(myplotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
			}
		# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
		par(mar=c(mar1,mar2,mar3,mar4),cex.axis=axiscex,cex.main=3.5,bg=mybg,col=axiscol,col.axis=axiscol,col.lab=axiscol,col.main=axiscol)
		#plot(myp1,myp2,xlab=paste("PC",axis1," (",round(p$values$Relative_eig[axis1]*100,1),"%)",sep=""),ylab=paste("PC",axis2," (",round(p$values$Relative_eig[axis2]*100,1),"%)",sep=""),col="white",frame=FALSE)
		if(is.null(axisdistance))
			{
			plot(myp1,myp2,xlab="",ylab="",col=mybg,frame=FALSE)
			}else{
			if(axisdistance>=0)
				{
				plot(myp1,myp2,xlab="",ylab="",col=mybg,frame=FALSE,xaxt='n')
				axis(side=1,mgp=c(0,axisdistance,0),cex=axiscex)
				}else{
				plot(myp1,myp2,xlab="",ylab="",col=mybg,frame=FALSE,xaxt='n',yaxt='n')
				box(which="plot")
				}
			}
		if(addellipse)
			{
			cat("Adding ellipse. If you receive an error after this line, set the flag addellipse to FALSE.",sep="\n")
			if("car"%in%(.packages()) == FALSE) {library(car)}
			car::dataEllipse(x=myp1,y=myp2,add=TRUE,groups=as.factor(inds$pop[indselection]),col=popcolours,levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
			}
		if("Rel_corr_eig"%in%colnames(p$values))
			{
			cat("Using 'Rel_corr_eig'...",sep="\n")
			myxlab	<- paste("PC",axis1," (",round(p$values$Rel_corr_eig[axis1]*100,1),"%)",sep="")
			myylab	<- paste("PC",axis2," (",round(p$values$Rel_corr_eig[axis2]*100,1),"%)",sep="")	
			mysambar$pcoaperc	<<- p$values$Rel_corr_eig
			}else{
			cat("Using 'Relative_eig'...",sep="\n")
			myxlab	<- paste("PC",axis1," (",round(p$values$Relative_eig[axis1]*100,1),"%)",sep="")
			myylab	<- paste("PC",axis2," (",round(p$values$Relative_eig[axis2]*100,1),"%)",sep="")
			mysambar$pcoaperc	<<- p$values$Relative_eig
			}
		mtext(myxlab,side=1,line=labeldistance,cex=labcex,col=axiscol)
		mtext(myylab,side=2,line=ylabeldistance,cex=labcex,col=axiscol)
		if(!is.null(side4label))
			{
			mtext(side4label,side=4,line=1,cex=labcex,col=axiscol,font=2)
			}
		if(addxy)
			{
			abline(h=0,col="grey95")
			abline(v=0,col="grey95")
			}
		if(labels)
			{
			if(!is.null(missvector))
				{
				text(myp1,myp2,round(missvector[indselection],4),col=colourcode[indselection],cex=label_size)
				}else{
				if(!is.null(printname))
					{
					text(myp1,myp2,printname[indselection],col=colourcode[indselection],cex=label_size)
					}else{
					text(myp1,myp2,inds$nr[indselection],col=colourcode[indselection],cex=0.75)
					}
				}
			}else{
			if(use_symboltype2)
				{
				#points(myp1,myp2,col=colourcode[indselection],bg=colourcode[indselection],pch=as.vector(inds$symboltype2[indselection]),cex=symbolsize)
				points(myp1,myp2,col="grey50",bg=colourcode[indselection],pch=as.vector(inds$symboltype2[indselection]),cex=symbolsize)
				}else{
				if(is.null(symbolkey))
					{
					if(mypch==21)	
						{
						points(myp1,myp2,col="grey50",bg=colourcode[indselection],pch=mypch,cex=symbolsize)
						}else{
						points(myp1,myp2,col=colourcode[indselection],pch=mypch,cex=symbolsize)
						}
					}else{
					symbolvector	<- c(16,17,18,20,15,0,1,2,6,3,4,5,8)
					mypch			<<- symbolvector[as.factor(symbolkeyvec)]
					points(myp1,myp2,col=colourcode[indselection],pch=mypch[indselection],cex=symbolsize)
					}
				}
			}
		if(!is.null(mylegend)&!is.null(mylegendcol)&addlegend)
			{
			legend(legendpos,mylegend,fill=mylegendcol,bty="n",border=mylegendcol,cex=legendcex,title=mylegendtitle,text.col=axiscol)
			}
		if(addlegend==TRUE&npops>1&is.null(mylegend))
			{
			mypopcols	<- popcolours[1:npops]
			if(!is.null(symbolkey))
				{
				symbolvector	<- c(16,17,18,20,15,0,1,2,6,3,4,5,8)
				mypch			<<- symbolvector[as.factor(symbolkeyvec)]
				legendpch		<- unique(mypch[!is.na(mypch)])
				legendkey		<- unique(symbolkeyvec[!is.na(symbolkeyvec)])
				legend(legendpos,legend=legendkey,pch=legendpch,bty="n",cex=legendcex)
				}else{
				if(use_symboltype2)
					{
					#legendpch		<- unique(as.vector(inds$symboltype2[indselection]))
					#legendkey		<- unique(as.vector(inds$pop2[indselection]))
					#legendpch		<- legendpch[order(legendkey)]
					#legendkey		<- legendkey[order(legendkey)]
					#pop_col		<- unique(as.vector(inds$popcol[indselection]))
					#legend(legendpos,legend=legendkey,pch=legendpch,bty="n",cex=legendcex,col=pop_col)
					legend(legendpos,popnames,fill=mypopcols,bty="n",cex=legendcex,border=mypopcols)
					}else{
					legend(legendpos,popnames,fill=mypopcols,bty="n",cex=legendcex,border=mypopcols)
					}
				}
			}
		if(!is.null(addtitle))
			{
			if(is.null(title_cex))
				{
				#cat("No titlecex.",sep="\n")
				title(main=addtitle,line=titledistance,col.main=axiscol)
				}else{
				#cat("Title cex specified.")
				title(main=addtitle,line=titledistance,cex.main=title_cex,col.main=axiscol)
				#mtext(addtitle,side=3,line=titledistance,cex=title_cex)
				}
			}
		if(addbox)
			{
			box(which="plot",col=axiscol,lwd=boxlwd)
			}
		if(!is.null(export))
			{
			dev.off()
			if(!is.null(symbolkey))
				{
				path1<- paste(getwd())
				cat(paste("PCoA-plot has been written to: ", paste(path1,(paste("pcoa",method,my_symbol,sep=".")),sep="/"), sep =""),sep="\n")
				}
			}
		}
	if(dodc)
		{
		# calculate 'distinct clustering' score
		if(!is.null(export))
			{
			if(npops>1)
				{
				calc_dc(popnames=mysambar$populations,pscores=p$vectors,axis_1=axis1,axis_2=axis2,tablename=paste(myplotname,paste("axis",axis1,"vs",axis2,sep=""),"dc_score.txt",sep="."))
				}
			}
		}
	if(return_object)
		{
		return(p)
		}
	}

# 04-09-2024:
# compare distances in pcoa to distances in underlying distance matrix:
# renamed, previously called pcoadistances
pcoastress<-function(mymethod="pi",ndim=NULL,distmat=mysambar$pcoamatrix,yline=NULL,doexport=TRUE,plottitle=NULL,doplot=TRUE,onlybetween=TRUE)
	{
	if(!is.null(distmat))
		{
		cat("Using distance matrix provided to distmat flag.",sep="\n")
		if(is.null(mysambar$myp))
			{
			return(cat("ERROR: loadings not found at mysambar$myp.",sep="\n"))
			}
		}else{
		ape_pcoa(method=mymethod)
		dev.off()
		distmat			<- mysambar$pcoamatrix	
		}
	if(mymethod=="pi"){diag(distmat)<-0}
	loadingdf		<- mysambar$myp$vectors			# loadings of pcoa-axes
	#
	ninds			<- ncol(distmat)
	popcolmat1		<- matrix(rep(inds$popcol,times=ninds),ncol=ninds,nrow=ninds)
	popcolmat2		<- matrix(rep(inds$popcol,each=ninds),ncol=ninds,nrow=ninds)
	mypops			<- inds$pop[inds$filter]
	if(length(mypops)!=ninds){return(cat("ERROR: length of population vector does not correspond with dimensions of distance matrix.",sep="\n"))}
	#
	ndim			<- ifelse(is.null(ndim),ncol(loadingdf),ndim)
	errorvec		<<- vector()
	for(k in c(1:ndim))
		{
		loadingmat	<<- as.matrix(dist(loadingdf[,c(1:k)]))				# euclidean distances of loadings
		diffmat		<<- (distmat-loadingmat)/distmat
		if(onlybetween)
			{
			for(i in c(1:ninds))
				{
				for(j in c(1:ninds))
					{
					diffmat[i,j]	<<- ifelse(mypops[i]==mypops[j],0,diffmat[i,j])
					}
				}
			}
		if(doplot)
			{
			plot(distmat[upper.tri(distmat)],loadingmat[upper.tri(loadingmat)],pch=21,cex=1,ylim=c(0,max(distmat)),xlim=c(0,max(distmat)),col=popcolmat1[upper.tri(popcolmat1)],bg=popcolmat2[upper.tri(popcolmat2)],xlab="True distance",ylab="PCoA distance",las=1)
			lines(c(0,max(distmat)),c(0,max(distmat)),col="red",lty=2)
			}
		errorvec[k]	<<- mean(abs(diffmat[upper.tri(diffmat)]))
		}
	if(ndim==ncol(loadingdf))
		{
		if(doexport){pdf(paste("Pcoa_stress",ndim,"pdf",sep="."),height=4,width=4)}
		plot(errorvec,xlab="# PCoA axes",ylab="",ylim=c(0,1),pch=16,cex=1,cex.lab=1.5,las=0,cex.axis=1.25)
		abline(h=yline,lty=2,lwd=2,col="red")
		mtext(side=2,"PCOA residual error",line=2.5,cex=1.5)
		if(!is.null(plottitle)){mtext(plottitle,side=3,line=0.5,cex=1.75)}
		if(doexport){dev.off()}
		}
	}

poppcoa<-function(pscores=NULL,popmat=mysambar$popneimatrix,method="nei",mypopnames=mysambar$populations,mypopcols=mysambar$mycolours,axis1=1,axis2=2,doplot=TRUE,mybg="white",axiscol="black",do_mirror=c(FALSE,FALSE),popselection=TRUE,labcex=3,axiscex=2,axisdistance=NULL,labeldistance=3.75,ylabeldistance=3.75,export=NULL,exportname=NULL,popnames=mysambar$populations,mar1=5,mar2=6.5,mar3=3.5,mar4=1,symbolsize=3.5,addlegend=TRUE,legendpos="bottomright",legendcex=1.5,side4label=NULL,addtitle=NULL,title_cex=NULL,titledistance=1,labels=FALSE,label_size=0.75,printname=NULL,resetgraphics=TRUE,silent=TRUE,makeglobal=FALSE,return_object=FALSE,addbox=TRUE,boxlwd=1,shuffle_par=NULL,addxy=FALSE,use_current_dir=TRUE)
	{
	if(is.null(popmat))
		{
		return(cat("ERROR: specify a pairwise population matrix to the popmat flag.",sep="\n"))
		}
	p <- ape::pcoa(popmat,correction="none",rn=NULL)
	if(ncol(p$vectors)<max(axis1,axis2))
		{
		cat("PCoA-axis does not exist. Aborting...",sep="\n") 
		}else{
		if(doplot)
			{
			myp1	<- p$vectors[,axis1]
			myp2	<- p$vectors[,axis2]
			if(!is.null(shuffle_par))
				{
				myp1	<- myp1+shuffle_par*runif(length(myp1))
				myp2	<- myp2+shuffle_par*runif(length(myp2))
				}
			if(do_mirror[1])
				{
				cat("Mirror image of axis1.",sep="\n")
				myp1	<- -myp1
				}
			if(do_mirror[2])
				{
				cat("Mirror image of axis2.",sep="\n")
				myp2	<- -myp2
				}	
			if(!silent){cat("Finished pcoa analyses. Plotting...",sep="\n")}
			if(!is.null(export))
				{
				if(resetgraphics){graphics.off()}
				if(!use_current_dir){setwd(mysambar$structuredir)}
				if(is.null(exportname))
					{
					myplotname	<- paste("pcoa_population",method,paste("PC",axis1,"vs",axis2,sep=""),sep=".")
					}else{
					myplotname	<- paste("pcoa:population",exportname,method,paste("PC",axis1,"vs",axis2,sep=""),sep=".")
					}
				myplotname		<- ifelse(mybg=="white",myplotname,paste(myplotname,mybg,sep="."))
				if(export=="eps"){postscript(paste(myplotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf(paste(myplotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png(paste(myplotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(myplotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
				}
			# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
			par(mar=c(mar1,mar2,mar3,mar4),cex.axis=axiscex,cex.main=3.5,bg=mybg,col=axiscol,col.axis=axiscol,col.lab=axiscol,col.main=axiscol)
			if(is.null(axisdistance))
				{
				plot(myp1,myp2,xlab="",ylab="",col=mybg,frame=FALSE)
				}else{
				if(axisdistance>=0)
					{
					plot(myp1,myp2,xlab="",ylab="",col=mybg,frame=FALSE,xaxt='n')
					axis(side=1,mgp=c(0,axisdistance,0),cex=axiscex)
					}else{
					plot(myp1,myp2,xlab="",ylab="",col=mybg,frame=FALSE,xaxt='n',yaxt='n')
					box(which="plot")
					}
				}
			if("Rel_corr_eig"%in%colnames(p$values))
				{
				cat("Using 'Rel_corr_eig'...",sep="\n")
				myxlab	<- paste("PC",axis1," (",round(p$values$Rel_corr_eig[axis1]*100,1),"%)",sep="")
				myylab	<- paste("PC",axis2," (",round(p$values$Rel_corr_eig[axis2]*100,1),"%)",sep="")	
				mysambar$pcoaperc	<<- p$values$Rel_corr_eig
				}else{
				cat("Using 'Relative_eig'...",sep="\n")
				myxlab	<- paste("PC",axis1," (",round(p$values$Relative_eig[axis1]*100,1),"%)",sep="")
				myylab	<- paste("PC",axis2," (",round(p$values$Relative_eig[axis2]*100,1),"%)",sep="")
				mysambar$pcoaperc	<<- p$values$Relative_eig
				}
			mtext(myxlab,side=1,line=labeldistance,cex=labcex,col=axiscol)
			mtext(myylab,side=2,line=ylabeldistance,cex=labcex,col=axiscol)
			if(!is.null(side4label))
				{
				mtext(side4label,side=4,line=1,cex=labcex,col=axiscol,font=2)
				}
			if(addxy)
				{
				abline(h=0,col="grey95")
				abline(v=0,col="grey95")
				}
			if(labels)
				{
				text(myp1,myp2,mypopnames,col=mypopcols,cex=label_size)
				}else{
				points(myp1,myp2,col="grey50",bg=mypopcols,cex=symbolsize,pch=21)
				}
			if(!is.null(addtitle))
				{
				if(is.null(title_cex))
					{
					title(main=addtitle,line=titledistance,col.main=axiscol)
					}else{
					title(main=addtitle,line=titledistance,cex.main=title_cex,col.main=axiscol)
					}
				}
			if(addlegend)
				{
				legend(legendpos,mysambar$poporder,fill=mysambar$colorder,cex=legendcex,bty='n')
				}
			if(addbox)
				{
				box(which="plot",col=axiscol,lwd=boxlwd)
				}
			if(!is.null(export))
				{
				dev.off()
				}
			}
		}
	}

# This function is to create pcoa plots with different small subsets.
# The function is different from 'multiplot_pcoa' (see below)
plotmulti_pcoa<-function(export=NULL,mymethod="nei",nloci=c(500,375,250,125),randomsubset=TRUE,do_legend=TRUE,poslegend="bottomright",cex_legend=4,silent=TRUE,size_symbol=4,no_fixed=TRUE,no_miss=TRUE,dodc=TRUE)
	{
	if(!silent&randomsubset){cat("Creating PCoA plots using subsets of randomly selected SNPs...",sep="\n")}
	if(!silent&!randomsubset){cat("Creating PCoA plots using subsets of SNPs with highest standard deviation of minor allele frequencies...",sep="\n")}
	setwd(mysambar$structuredir)
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	nsnps		<- nrow(snps[snps$filter,])
	if(any(nloci>nsnps))
		{
		return(cat(paste("ERROR: Number of retained SNPs (",nsnps,") is below specified subset size.",sep=""),sep="\n")) 
		}
	mynumbers	<- c(1:nrow(snps))
	if(!randomsubset)
		{
		if(!"sd_popmaf"%in%colnames(snps))
			{
			return(cat("ERROR: SambaR couldn't find column called 'sd_popmaf' in snps dataframe. Rerun the filterdata function, or set the flag randomsubset to TRUE.",sep="\n"))
			}
		if(length(mysambar$populations)==1)
			{
			return(cat("Currently 1 population defined. Impossible to selection loci with highest variation in MAF among populations. Omitting 'multi_pcoa.highest_sd_maf' plot.",sep="\n"))
			}
		if(!silent){cat("Setting filter...",sep="\n")}
		popmafs 				<- snps[,grep("maf_",colnames(snps))]
		mafmin					<- apply(popmafs,1,min)
		nodatavec				<- !is.na(rowSums(popmafs))
		mysd					<- snps$sd_popmaf
		if(no_fixed)
			{
			fixedfilter			<- mafmin>0
			}else{
			fixedfilter			<- rep(TRUE,nrow(snps))
			}
		if(no_miss)
			{
			missfilter			<- nodatavec
			}else{
			missfilter			<- rep(TRUE,nrow(snps))
			}
		myfilter			<- snps$filter&fixedfilter&missfilter&is.finite(mysd)&!is.na(mysd)
		if(!silent){cat("Applying filter...",sep="\n")}
		mysd					<- mysd[myfilter]
		snpsfiltered			<- snps[myfilter,]
		snpstemp				<- snpsfiltered[order(-mysd),]
		if(length(mysd)<max(nloci))
			{
			return(cat("Low number of retained SNPs with minor allele present in all populations. Omitting 'multi_pcoa.highest_sd_maf' plot.",sep="\n")) 
			}
		}
	myselectionlist	<- list()
	if(!is.null(export))
		{
		mylabel		<- ifelse(randomsubset,paste(mymethod,"randomsubset",sep="."),paste(mymethod,"highest_sd_maf",sep="."))
		mylabel2	<- paste(max(nloci),"snps",sep="")
		mylabel3	<- ifelse(randomsubset,"with_fixed",ifelse(no_fixed,"no_fixed","with_fixed"))
		mylabel4	<- ifelse(randomsubset,"with_miss",ifelse(no_miss,"no_miss","with_miss"))
		legendlabel	<- ifelse(do_legend,"withlegend","nolegend")
		if(export=="pdf"){pdf(paste("multi_pcoa",mylabel,mylabel2,mylabel3,mylabel4,legendlabel,"pdf",sep="."),height=18,width=18)}
		}
	par(mfrow=c(2,2))
	for(n_subset in nloci)
		{
		if(!silent){cat(n_subset,sep="\n")}
		if(randomsubset)
			{
			mydraw		<- sample(mynumbers[snps$filter],n_subset)
			myselection	<- mynumbers%in%mydraw
			}else{
			snpsubset	<- head(snpstemp,n_subset)
			thres		<- min(snpsubset$sd_popmaf,na.rm=TRUE)
			myselection	<- snps$sd_popmaf>=thres&myfilter
			myselection	<<- myselection
			# add to SNPs dataframe:
			myselectionlist[[n_subset]]	<- myselection
			snps$mafSDtop				<<- myselection
			names(snps)[which(names(snps)=="mafSDtop")]	<<- paste("mafSDtop",n_subset,sep="")
			snps 						<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
			}
		# create plot:
		add_legend		<- ifelse(n_subset==nloci[1],ifelse(do_legend,TRUE,FALSE),FALSE)
		ape_pcoa(snpselection=myselection,method=mymethod,resetgraphics=FALSE,addlegend=add_legend,legendpos=poslegend,makeglobal=TRUE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
		mtext(paste(n_subset," snps",sep=""),cex=3)
		if(!mysambar$pcoa_error&dodc)
			{
			#cat("Calculating dc_scores...",sep="\n")
			calc_dc(popnames=mysambar$populations,pscores=p$vectors,axis_1=1,axis_2=2,tablename=NULL)
			if(length(mysambar$populations)>1)
				{
				mtext(text=paste("dc = ",round(mysambar$dcscore$meandc[1],2),sep=""),side=3,cex=2.75,line=-2.5)
				}
			}
		}
	if(!is.null(export)){dev.off()}
	#
	if(mymethod=="hamming"&!randomsubset)
		{
		setwd(mysambar$inputfilesdir)
		for(n_subset in nloci)
			{
			plot_name	<- paste("metapop.highest_popmafsd",paste(n_subset,"SNPS",sep=""),mymethod,mylabel3,mylabel4,"number",sep=".")
			genlight2ped(snpsfilter=myselection,indsfilter=inds$filter,exportname=plot_name,quiet=TRUE) 		
			plot_name	<- paste("metapop.highest_popmafsd",paste(n_subset,"SNPS",sep=""),mymethod,mylabel3,mylabel4,"letter",sep=".")
			genlight2ped(snpsfilter=myselection,indsfilter=inds$filter,exportname=plot_name,quiet=TRUE,genonumber=FALSE) 
			}
		setwd(mysambar$structuredir)
		}
	}

# This script is to create pcoa plots with different filter settings.
# The function is different from 'plotmulti_pcoa' (see above)
multiplot_pcoa<-function(exporttype=NULL,mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=FALSE,poslegend="center",cex_legend=4,size_symbol=4,maxmiss=0.01)
	{
	my_plist	<- list()
	mypnames	<- vector()
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(dolabels)
			{
			plotname	<- ifelse(print_miss,paste("pcoa_multi",mymethod,"proportion.missingdata",sep="."),paste("pcoa_multi",mymethod,"label",sep="."))
			}else{
			plotname	<- paste("pcoa_multi",mymethod,sep=".")
			}
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(4,4,3,1),cex.axis=3.75)
	nsnps		<- nrow(snps[snps$filter,])
	mynumbers	<- c(1:nrow(snps))
	# no filter:
	if(print_miss)
		{
		indsmissingness(max_miss=maxmiss)	# calculate inds$miss3
		miss_vector1	<- inds$miss
		miss_vector2	<- inds$miss2
		miss_vector3	<- inds$miss3
		}else{
		miss_vector1	<- NULL
		miss_vector2	<- NULL
		miss_vector3	<- NULL
		}
	# all snps:
	p_apepcoa			<- ape_pcoa(return_object=TRUE,snpselection=rep(TRUE,nsnps),labcex=2.75,labels=dolabels,missvector=miss_vector1,axiscex=3,axisdistance=2,labeldistance=5.5,method=mymethod,resetgraphics=FALSE,addlegend=dolegend,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	my_plist[[1]]		<- p_apepcoa
	mymax				<- round(max(snps$miss,na.rm=TRUE),2)
	nretained			<- nrow(snps) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mypnames[1]			<- paste("miss",mymax,sep="")
	# current filter settings:
	p_apepcoa			<- ape_pcoa(return_object=TRUE,snpselection=snps$filter,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector2,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	my_plist[[2]]		<- p_apepcoa
	mymax				<- round(max(snps$miss[snps$filter],na.rm=TRUE),2)
	nretained			<- nrow(snps[snps$filter,]) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mypnames[2]			<- paste("miss",mymax,sep="")
	# 
	p_apepcoa			<- ape_pcoa(return_object=TRUE,snpselection=snps$miss<=maxmiss,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector3,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	my_plist[[3]]		<- p_apepcoa
	nretained			<- nrow(snps[snps$miss<=maxmiss,])
	mtext(paste(nretained," SNPs, max ", maxmiss, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mypnames[3]			<- paste("miss",maxmiss,sep="")
	if(!is.null(exporttype)){dev.off()}
	mysambar$plist		<<- my_plist
	mysambar$pnames		<<- mypnames
	}

# This script is to create combined pcoa plots for different axis combinations
# The function is different from 'plotmulti_pcoa' (see above)
multiplot_pcoa_axes<-function(exporttype=NULL,my_legend=NULL,my_legendcol=NULL,exportname=NULL,mymethod="hamming",cex_lab=2.75,dolabels=FALSE,print_miss=FALSE,print_name=NULL,dolegend=TRUE,poslegend="bottom",cex_legend=3,size_symbol=4,size_label=2.5,maxmiss=0.01,myaxes=c(1,2,1,3,2,3),mirroraxis=c(rep(FALSE,6)),use_symbol2=FALSE)
	{
	setwd(mysambar$structuredir)
	#my_plist	<<- list()
	#mypnames	<<- vector()
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(is.null(exportname))
			{
			exportname		<- "pcoa_multi_axes"
			}else{
			exportname		<- paste(exportname,"pcoa_multi_axes",sep=".")
			}
		if(dolabels)
			{
			plotname	<- ifelse(print_miss,paste(exportname,mymethod,"proportion.missingdata",sep="."),paste(exportname,mymethod,"label",sep="."))
			}else{
			plotname	<- paste(exportname,mymethod,sep=".")
			}
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(4,4,3,1),cex.axis=3.75)
	boolmirror1	<- mirroraxis[1:2]
	boolmirror2 <- mirroraxis[3:4]
	boolmirror3 <- mirroraxis[5:6]
	if(!print_miss)
		{
		mymissvector	<- NULL
		}else{
		mymissvector	<- inds$miss
		}
	if(is.null(my_legend)&is.null(my_legendcol))
		{
		ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[1],axis2=myaxes[2],do_mirror=boolmirror1,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,addlegend=dolegend,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
		}else{
		ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[1],axis2=myaxes[2],do_mirror=boolmirror1,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,mylegend=my_legend,mylegendcol=my_legendcol,addlegend=FALSE,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
		}
	mtext("PC1 vs PC2",side=3,cex=2.75,line=0.5)
	ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[3],axis2=myaxes[4],do_mirror=boolmirror2,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	mtext("PC1 vs PC3",side=3,cex=2.75,line=0.5)
	ape_pcoa(snpselection=snps$filter,method=mymethod,labcex=cex_lab,labels=dolabels,label_size=size_label,missvector=mymissvector,printname=print_name,axis1=myaxes[5],axis2=myaxes[6],do_mirror=boolmirror3,axiscex=3,axisdistance=2,labeldistance=5.5,use_symboltype2=use_symbol2,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	mtext("PC2 vs PC3",side=3,cex=2.75,line=0.5)
	if(!is.null(exporttype)){dev.off()}
	}

# This script is to create pcoa plots with all individuals, and as many SNPs as possible.
# The function is different from 'plotmulti_pcoa' (see above)
pcoa_allinds<-function(exporttype=NULL,mymethod="hamming",dolabels=FALSE,print_miss=FALSE,dolegend=FALSE,poslegend="center",cex_legend=4,size_symbol=4)
	{
	if(mymethod=="pi")
		{
		return(cat("ERROR: can not make SNP subsets with method 'pi'. Choose 'nei' or 'hamming'.",sep="\n"))
		}
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(dolabels)
			{
			plotname	<- ifelse(print_miss,paste("pcoa_multi_allinds",mymethod,"missingdata",sep="."),paste("pcoa_multi_allinds",mymethod,"label",sep="."))
			}else{
			plotname	<- paste("pcoa_multi_allinds",mymethod,sep=".")
			}
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(4,4,3,1),cex.axis=3.75)
	nr_inds		<- nrow(inds)
	nsnps		<- nrow(snps[snps$filter,])
	mynumbers	<- c(1:nrow(snps))
	# no filter:
	if(print_miss)
		{
		miss_vector1	<- inds$miss
		miss_vector2	<- inds$miss2
		}else{
		miss_vector1	<- NULL
		miss_vector2	<- NULL
		miss_vector3	<- NULL
		}
	#
	# all snps:
	my_selection		<- rep(TRUE,nrow(snps))
	ape_pcoa(indselection=rep(TRUE,nr_inds),snpselection=my_selection,labcex=2.75,labels=dolabels,missvector=miss_vector1,axiscex=3,axisdistance=2,labeldistance=5.5,method=mymethod,resetgraphics=FALSE,addlegend=dolegend,legendpos=poslegend,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	nretained			<- nrow(snps) 
	mtext(paste("all ",nretained," SNPs",sep=""),side=3,cex=2.75,line=0.5)
	#
	# current filter settings:
	ape_pcoa(indselection=rep(TRUE,nr_inds),snpselection=snps$filter,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector2,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	nretained			<- nrow(snps[snps$filter,]) 
	mtext(paste("retained ",nretained," SNPs",sep=""),side=3,cex=2.75,line=0.5)
	#
	# ~1000 SNPs with least missing data:
	if(nrow(snps[snps$hefilter,])>1000)
		{
		snpprop		<- 1000/nrow(snps[snps$hefilter,])
		}else{
		snpprop		<- 1
		}
	mythres		<- quantile(snps$miss2[snps$hefilter],snpprop)
	my_selection<- snps$miss2<=mythres&snps$hefilter
	#
	if(print_miss)
		{
		mat 		<- as.matrix(mygenlight[,my_selection])
		nNA 		<- apply(mat,1,function(x) length(x[is.na(x)])) # number of NA per individual
		miss_vector3<- nNA / ncol(mat) # fraction of SNPs with missing data per individual
		}
	nretained			<- length(my_selection[my_selection])		
	ape_pcoa(indselection=rep(TRUE,nr_inds),snpselection=my_selection,method=mymethod,labcex=2.75,labels=dolabels,missvector=miss_vector3,axiscex=3,axisdistance=2,labeldistance=5.5,resetgraphics=FALSE,addlegend=FALSE,symbolsize=size_symbol,legendcex=cex_legend,dodc=FALSE)
	mtext(paste(nretained," highest quality SNPs",sep=""),side=3,cex=2.75,line=0.5)
	if(!is.null(exporttype)){dev.off()}
	}

plotmiss_vs_p<-function(mymethod="hamming",exporttype="pdf")
	{
	for(j in c(1:3))
		{
		if(!is.null(exporttype))
			{
			mywid		<- 27.5
			myhei		<- 9.5
			mywid2		<- 2000
			myhei2		<- 720
			mydataset	<- ifelse(j==1,mysambar$pnames[1],ifelse(j==2,mysambar$pnames[2],mysambar$pnames[3])) 
			plotname	<- paste("pcoa",mymethod,"miss_pcscore",mydataset,sep=".")
			if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}	
			if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywid2,height=myhei2)}
			if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywid,height=myhei)}
			}
		par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(6,4,3,1),cex.axis=3.75)
		xx	<- inds$miss[inds$filter]
		plot(xx,mysambar$plist[[j]]$vectors[,1],col=inds$popcol[inds$filter],xlab="",ylab="",pch=16,cex=4,xaxt='n')
		mtext("PC 1",cex=2.5,side=3,line=0.5)
		axis(side=1,mgp=c(0,2.5,0))
		plot(xx,mysambar$plist[[j]]$vectors[,2],col=inds$popcol[inds$filter],xlab="",ylab="",pch=16,cex=4,xaxt='n')
		mtext("PC 2",cex=2.5,side=3,line=0.5)
		axis(side=1,mgp=c(0,2.5,0))
		plot(xx,mysambar$plist[[j]]$vectors[,3],col=inds$popcol[inds$filter],xlab="",ylab="",pch=16,cex=4,xaxt='n')
		mtext("PC 3",cex=2.5,side=3,line=0.5)
		axis(side=1,mgp=c(0,2.5,0))
		mtext("Proportion missing data",side=1,line=4,cex=3,outer=TRUE)
		mtext("PC score",side=2,line=0.5,cex=3,outer=TRUE)
		if(!is.null(exporttype)){dev.off()}
		}
	}

# Depends on package SNPRelate
# Note, if you didn't close the genofile before calling it again, you will get this ERROR: ERROR in file(filename, "wb") : cannot open the connection
# In addition: Warning message: # In file(filename, "wb") : cannot open file 'my.gds': Permission denied
multisnprelate_pca<-function(dolabels=FALSE,exporttype=NULL,dolegend=TRUE,poslegend="right",cex_legend=3.5,size_symbol=2.75,maxmiss=0.01)
	{
	if(!is.null(exporttype))
		{
		mywid	<- 27.5
		myhei	<- 9.5
		mywid2	<- 2000
		myhei2	<- 720
		if(dolabels)
			{
			if(exporttype=="eps"){postscript("pca.snprelate_multi.labels.eps",family=mysambar$myfont,width=mywid,height=myhei)}	# 10.5 instead of 10 because otherwise some labels are missing
			if(exporttype=="pdf"){pdf("pca.snprelate_multi.labels.pdf",family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="png"){png("pca.snprelate_multi.labels.png",family=mysambar$myfont,width=mywid2,height=myhei2)}
			if(exporttype=="wmf"){win.metafile("pca.snprelate_multi.labels.wmf",family=mysambar$myfont,width=mywid,height=myhei)}
			}else{
			if(exporttype=="eps"){postscript("pca.snprelate_multi.eps",family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="pdf"){pdf("pca.snprelate_multi.pdf",family=mysambar$myfont,width=mywid,height=myhei)}
			if(exporttype=="png"){png("pca.snprelate_multi.png",family=mysambar$myfont,width=mywid2,height=myhei)}
			if(exporttype=="wmf"){win.metafile("pca.snprelate_multi.wmf",family=mysambar$myfont,width=mywid,height=myhei)}
			}
		}
	par(mfrow=c(1,3),mar=c(2,4,2,0.5),oma=c(6,4,3,1),cex.axis=3.75)
	# no filter:
	snprelate_pca(export=NULL,resetgraphics=FALSE,addaxislabel=FALSE,snpsfilter=rep(TRUE,nrow(snps)),addlegend=dolegend,labels=dolabels,legendpos=poslegend,legendcex=cex_legend,symbolsize=size_symbol,dodc=FALSE)	
	mymax			<- round(max(snps$miss,na.rm=TRUE),2)
	nretained		<- nrow(snps) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	# current filter settings:
	snprelate_pca(export=NULL,resetgraphics=FALSE,addaxislabel=FALSE,snpsfilter=snps$filter,addlegend=FALSE,labels=dolabels,legendpos=poslegend,legendcex=cex_legend,symbolsize=size_symbol,dodc=FALSE)	
	mymax			<- round(max(snps$miss[snps$filter],na.rm=TRUE),2)
	nretained		<- nrow(snps[snps$miss<=mymax,]) 
	mtext(paste(nretained," SNPs, max ", mymax, " missing",sep=""),side=3,cex=2.75,line=0.5)
	# strict filter (max %1 missing data): 
	snprelate_pca(export=NULL,resetgraphics=FALSE,addaxislabel=FALSE,snpsfilter=(snps$miss<=0.01),addlegend=FALSE,labels=dolabels,legendpos=poslegend,legendcex=cex_legend,symbolsize=size_symbol,dodc=FALSE)	
	nretained		<- nrow(snps[snps$miss<=maxmiss,])
	mtext(paste(nretained," SNPs, max ", maxmiss, " missing",sep=""),side=3,cex=2.75,line=0.5)
	mtext("Eigenvector 1",side=1,line=4,cex=3,outer=TRUE)
	mtext("Eigenvector 2",side=2,line=0.5,cex=3,outer=TRUE)
	if(!is.null(exporttype)){dev.off()}
	}

# 02-12-2024: LEA pca
plottracywidom<-function(do_export=TRUE,runanalysis=TRUE,doplot=TRUE,plottitle=NULL)
	{
	if(runanalysis)
		{
		if(!"LEAinput.ped"%in%list.files())
			{
			return(cat("ERROR: input file 'LEAinput.ped' not found. First run runLEA function().",sep="\n"))
			}
		mypca	<- LEA::pca("LEAinput.ped",center=TRUE,scale=FALSE)
		tracy.widom(mypca)
		# Here you might receive the error:
		# Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec,  :  line 103 did not have 6 elements
		# This error, due to a hashtag in the file 'LEAinput.tracywidom' is not a fatal error.
		# We can read and plot the output ourselves.
		}
	if(doplot)
		{
		if(do_export){pdf("TracyWidom.pdf")}
		y	<-read.table("LEAinput.pca/LEAinput.tracywidom",header=TRUE,comment.char="")
		y	<- y[c(1:(nrow(y)-1)),]
		par(mar=c(4,4.5,3,5),cex.axis=1.5)	
		plot(y$N,y$percentage,type="b",col="black",lwd=2,xlab="",ylab="")
		par(new=TRUE)
		plot(y$N,y$pvalues,yaxt='n',ylab="",xaxt='n',xlab="",type='b',lwd=2,col="red")
		axis(side=4,col="red")
		mtext("Explained variance (%)",side=2,line=2.5,cex=2)
		mtext("PCA axis",side=1,line=2.5,cex=2)
		mtext("Tracy Widom p-value",side=4,cex=2,line=3.5,col="red")
		if(!is.null(plottitle)){mtext(side=3,plottitle,cex=2,line=0.5)}
		if(do_export)
			{
			dev.off()
			cat("Plot has been exported to directory: ",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	}

snprelate_pca<-function(chrom=FALSE,resetgraphics=TRUE,axis1=1,axis2=2,do_mirror=c(FALSE,FALSE),indsfilter=inds$filter,snpsfilter=snps$filter,export=NULL,exportname=NULL,plottitle=NULL,symbolsize=4,labels=FALSE,printname=NULL,addaxislabel=TRUE,mylegend=mysambar$poporder,mylegendcol=mysambar$colorder,mylegendtitle=NULL,addlegend=TRUE,legendpos="right",popnames=mysambar$poporder,popcolours=mysambar$colorder,symboltype=16,legendcex=2.25,dodc=TRUE)
	{
	mymatrix	<- as.matrix(mygenlight[indsfilter,snpsfilter])
	mypops		<- as.factor(inds$pop[indsfilter]) 
	mypopcolours<- inds$popcol[indsfilter]
	if(chrom)
		{
		# sambarfunction_findstructure:
		### PCA analyses (SNPrelate):
		# sambarfunction_findstructure:
		snpgdsCreateGeno("my.gds",snpfirstdim=FALSE,genmat=mymatrix,sample.id=inds$name[indsfilter],snp.id=snps$name[snpsfilter],snp.chromosome=snps$chr[snpsfilter],snp.position = snps$position[snpsfilter])
		}else{
		snpgdsCreateGeno("my.gds",snpfirstdim=FALSE,genmat=mymatrix,sample.id=inds$name[indsfilter],snp.id=snps$name[snpsfilter],snp.chromosome=rep(1,length(snps$name[snpsfilter])),snp.position = snps$position[snpsfilter])
		}
	# sambarfunction_findstructure:
	genofile 	<- snpgdsOpen("my.gds")
	# sambarfunction_findstructure:
	pca 		<- snpgdsPCA(genofile)
	# sambarfunction_findstructure:
	sample.id 	<- read.gdsn(index.gdsn(genofile, "sample.id"))
	npops		<- length(popnames)
	pcadata 	<- data.frame(sample.id = pca$sample.id,pop=factor(mypops)[match(pca$sample.id,sample.id)],EV1 = pca$eigenvect[,axis1],EV2 = pca$eigenvect[,axis2],stringsAsFactors = FALSE)
	pcadata$col	<- mypopcolours
	# sambarfunction_findstructure:
	snpgdsClose(genofile)
	if(resetgraphics)
		{
		graphics.off()
		if(!is.null(export))
			{
			exportname		<- ifelse(is.null(exportname),"pca.snprelate",paste("pca.snprelate",exportname,sep="."))
			exportname		<- paste(exportname,paste(axis1,"vs",axis2,sep=""),sep=".")
			if(labels)
				{
				exportname	<- ifelse(is.null(printname),paste(exportname,"sample_nrs",sep="."),paste(exportname,"labels",sep="."))
				if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}	# 10.5 instead of 10 because otherwise some labels are missing
				if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				}else{
				if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=10.5,height=10.5)}
				}
			}
		par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
		}
	# 28-09-2021: replaced following line:
	# mycols	<- mysambar$mycolours[1:npops]
	mycols		<- popcolours
	# First create outline of the plot. The argument 'col="white"' hides the datapoints, so we can edit them in the next commands. 
	myp1		<- pcadata$EV1
	myp2		<- pcadata$EV2
	if(do_mirror[1])
		{
		cat("Mirror image of axis1.",sep="\n")
		myp1	<- -myp1
		}
	if(do_mirror[2])
		{
		cat("Mirror image of axis2.",sep="\n")
		myp2	<- -myp2
		}
	if(addaxislabel)
		{
		plot(myp1,myp2,pch=16,col="white",xlab="",ylab="",cex=symbolsize)
		#mtext("eigenvector 1",side=1,line=3.5,cex=3.5)
		#mtext("eigenvector 2",side=2,line=3.5,cex=3.5)
		mtext(paste("Dim ",axis1," (",round(100*pca$varprop[axis1],1)," %)",sep=""),side=1,line=3.5,cex=3.5)
		mtext(paste("Dim ",axis2," (",round(100*pca$varprop[axis2],1)," %)",sep=""),side=2,line=3.5,cex=3.5)
		}else{
		plot(pcadata$EV1,pcadata$EV2,pch=16,col="white",xlab="",ylab="",cex=symbolsize,xaxt='n')
		axis(side=1,mgp=c(0,2.5,0))
		}
	if(labels)
		{
		if(is.null(printname))
			{
			text(myp1,myp2,inds$nr[inds$filter],pch=16,col=pcadata$col,cex=0.75)
			}else{
			text(myp1,myp2,printname[inds$filter],pch=16,col=pcadata$col,cex=0.75)
			}
		}else{
		if(length(symboltype)>1)
			{
			mysymbols	<<- vector()
			for (j in c(1:npops))
				{
				nrsamples	<- length(inds$name[inds$pop==popnames[j]&indsfilter])
				symboltemp	<- rep(symboltype[j],nrsamples)
				mysymbols	<- c(mysymbols,symboltemp)		
				}
			rm(symboltemp)
			points(myp1,myp2,col=pcadata$col,pch=mysymbols,cex=symbolsize)
			}else{
			points(myp1,myp2,col=pcadata$col,pch=16,cex=symbolsize)
			}
		}
	if(!is.null(mylegend)&!is.null(mylegendcol))
		{
		legend(legendpos,mylegend,fill=mylegendcol,bty="n",border=mylegendcol,cex=legendcex,title=mylegendtitle)
		}
	if(addlegend==TRUE&npops>1&is.null(mylegend))
		{
		if(length(symboltype)>1)
			{
			legend(legendpos,legend=popnames,fill=mycols,border=mycols,pch=symboltype,bty="n",cex=legendcex)
			}else{
			legend(legendpos,legend=popnames,fill=mycols,border=mycols,bty="n",cex=legendcex)
			}
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,line=0.5,cex=3.5)
		}
	if(!is.null(export)){dev.off()}	
	mypcascores	<- cbind(pcadata$EV1,pcadata$EV2)
	mytablename	<- paste(exportname,"dc_score.txt",sep=".")
	if(dodc)
		{
		calc_dc(popnames=mysambar$populations,pscores=mypcascores,axis_1=1,axis_2=2,tablename=mytablename)
		}
	}

bothMDS<-function(exporttype=NULL,rundc=TRUE)
	{
	if(!is.null(exporttype))
		{
		if(exporttype=="eps"){postscript("MDS.metric_vs_nonmetric.eps",family=mysambar$myfont,width=20,height=10)}
		if(exporttype=="pdf"){pdf("MDS.metric_vs_nonmetric.pdf",family=mysambar$myfont,width=20,height=10)}
		if(exporttype=="png"){png("MDS.metric_vs_nonmetric.png",family=mysambar$myfont,width=1440,height=720)}
		if(exporttype=="wmf"){win.metafile("MDS.metric_vs_nonmetric.wmf",family=mysambar$myfont,width=20,height=10)}
		}
	par(mfrow=c(1,2))
	doMDS(export=NULL,nonmetric=FALSE,labels=TRUE,addlegend=TRUE,addtitle=TRUE,dodc=rundc)	# export should be NULL
	doMDS(export=NULL,nonmetric=TRUE,labels=TRUE,addlegend=FALSE,addtitle=TRUE,dodc=rundc) 	# export should be NULL
	if(!is.null(exporttype)){dev.off()}
	}
	
doMDS<-function(export=NULL,ndim=2,nonmetric=FALSE,labels=FALSE,addlegend=TRUE,legendpos="right",popnames=mysambar$populations,symboltype=16,symbolsize=2,addtitle=FALSE,legendcex=2,dodc=TRUE)
	{
	mydata	<- as.matrix(mygenlight)[inds$filter,snps$filter]
	mylabels<- inds$nr[inds$filter]
	npops	<- length(popnames)
	mycols	<- inds$popcol[inds$filter]
	mypopcols<- mysambar$mycolours[1:npops]
	# calculation:
	d 		<- dist(mydata) 						# euclidean distances between the rows
	mymin	<- min(d,na.rm=TRUE)
	if(mymin<=0)
		{
		cat("Zero or negative distance in distance matrix, meaning some individuals have identical genotype scores. Skipping MDS plot.",sep="\n")
		}else{
		if(nonmetric)
			{
			#sambarfunction_findstructure:
			### Multi-dimensional scaling (MDS) analyses:
			#sambarfunction_findstructure:
			myfit 	<- isoMDS(d,k=ndim)
			x 		<- myfit$points[,1]
			y 		<- myfit$points[,2]
			}else{
			#sambarfunction_findstructure:
			myfit 	<- cmdscale(d,eig=FALSE,k=ndim) 	
			x 		<- myfit[,1]
			y 		<- myfit[,2]
			}
		# plot:
		mdstype	<- ifelse(nonmetric,"MDS.nonmetric","MDS.metric")
		if(!is.null(export))
			{
			if(labels)
				{
				if(export=="eps"){postscript((paste(mdstype,"labels.eps",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf((paste(mdstype,"labels.pdf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png((paste(mdstype,"labels.png",sep=".")),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile((paste(mdstype,"labels.wmf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				}else{
				if(export=="eps"){postscript((paste(mdstype,"eps",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf((paste(mdstype,"pdf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png((paste(mdstype,"png",sep=".")),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile((paste(mdstype,"wmf",sep=".")),family=mysambar$myfont,width=10,height=10)}
				}
			}	
		#par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=3.5)
		par(mar=c(5,6,3,1),cex.axis=2)
		plot(x,y,xlab="",ylab="",main="",type="n",las=1)
		mtext("Coordinate 1",side=1,line=3.5,cex=3)
		mtext("Coordinate 2",side=2,line=3.5,cex=3)
		if(labels)
			{
			text(x,y,labels=mylabels,cex=.75,col=mycols)
			}else{
			points(x,y,cex=symbolsize,col=mycols,pch=symboltype)
			}	
		if(addtitle)
			{
			mytitle	<- ifelse(nonmetric,"Non-metric MDS","Metric MDS")
			mtext(mytitle,side=3,line=0.5,cex=3)
			}
		if(addlegend&npops>1)
			{
			if(length(symboltype)>1)
				{
				legend(legendpos,legend=popnames,fill=mypopcols,pch=symboltype,bty="n",cex=legendcex)
				}else{
				legend(legendpos,legend=popnames,fill=mypopcols,bty="n",cex=legendcex)
				}
			}
		if(!is.null(export)){dev.off()}
		mds_scores	<- cbind(x,y)	
		mytablename	<- paste(mdstype,"axis1vs2.dc_score.txt",sep=".")
		if(dodc)
			{
			calc_dc(popnames=mysambar$populations,pscores=mds_scores,axis_1=1,axis_2=2,tablename=mytablename)
			}
		}
	}
	
# DAPC (and PCA) with Adegenet
genlight2genind<-function(input=mygenlight,add2sambar=TRUE)
	{
	# When trying to run dapc analysis with genlight, I got an ERROR stating that on a Windows computer mc.cores is not possible.
	# I decided to work around this problem by converting genlight object to genind object. 
	# 27-01-2020: for big datasets (e.g 350,000 SNPs for 90 individuals) genind conversion is not feasible.
	# 27-01-2020: the error I got before I don't get now, so it seems that conversion is not necessary anyway.
	#
	# The conversion does take time, so first check whether it is needed or whether you already did it:
	if(add2sambar)
		{
		if(!is.null(mysambar$genind))
			{
			n_inds	<- dim(mysambar$genind$tab)[1]
			n_snps	<- (dim(mysambar$genind$tab)[2])/2
			if((n_inds==nrow(inds[inds$filter,]))&(n_snps==nrow(snps[snps$filter,])))
				{
				return(cat("Genind object already stored in mysambar$genind. No conversion needed.",sep="\n"))	
				}
			}
		}
	cat("Converting genlight object to genind object...",sep="\n")
	cat("This might take a while.",sep="\n")
	#
	# First line is in case the user (you) changed inds$popcol column and populations vector but forgot to change genlight$pop correspondingly:
	if(add2sambar)
		{
		mygenlight@pop	<- as.factor(inds$pop)
		x.mat 			<- as.matrix(input[inds$filter,snps$filter]) # input is a genlight object
		}else{
		x.mat			<- as.matrix(input)
		}
	x.mat[x.mat == 0] 	<- "1/1" # homozygote reference
	x.mat[x.mat == 1] 	<- "1/2" # heterozygote
	x.mat[x.mat == 2] 	<- "2/2" # homozygote alternate
	mycolnames			<- colnames(x.mat)
	mycolnames			<- gsub(":","_",mycolnames)			# 09-07-19: to avoid ERROR: ERROR in .local(.Object, ...) : more than one '.' in column names; please name column as [LOCUS].[ALLELE]
	mycolnames			<- gsub("\\.","_",mycolnames)		# 09-07-19: to avoid ERROR: ERROR in .local(.Object, ...) : more than one '.' in column names; please name column as [LOCUS].[ALLELE]
	colnames(x.mat)		<- mycolnames
	#x.mat				<<- x.mat
	mygenind 	  		<- df2genind(x.mat,sep="/",ploidy = 2)
	if(add2sambar)
		{
		pop(mygenind)	  	<- as.vector(mygenlight@pop[inds$filter])
		mysambar$genind		<<- mygenind
		cat("Conversion finished. Genind object is stored at mysambar$genind.",sep="\n")
		}else{
		mygenind		<<- mygenind
		cat("Conversion finished. Genind object is stored at mygenind.",sep="\n")
		}
	}

# 19-02-2024: 
adegenet_pca<-function(nraxes=20)
	{
	mypca	<- glPca(mygenlight[inds$filter,snps$filter],scannf=FALSE,nf=nraxes)
	scatter(mypca)
	#
	# PCA plot:
	plot(mypca$scores[,1],mypca$scores[,2],pch=16,col=inds$popcol[inds$filter])
	}

# dudi.pca does not accept missing data (ERROR: na entries in table) so impute data first
# 13-02-2020: I tried to plot(pca1$co$Comp1,pca1$co$Comp2,col=col), but results 
# therefore, I don't use the following function:
# 19-02-2024: this function used to be called: 'adegenet_pca'	
ade4_pca<-function(export=NULL,nfactor=10)
	{
	setwd(mysambar$structuredir)
	if(is.null(mysambar$imputedmatrix))
		{
		sambarimpute()
		}
	mygeno			<- as.data.frame(t(mysambar$imputedmatrix[inds$filter,snps$filter]))		# it seems I have to transpose to give eigenvalues for samples rather than for snps	
	nind			<- nrow(inds[inds$filter,])
	nloc			<- nrow(snps[snps$filter,])
	mypops			<- inds$pop[inds$filter]
	mypoplabels		<- as.vector(unique(mypops))
	col				<- as.vector(unique(inds$popcol[inds$filter]))
	pca1 			<- dudi.pca(mygeno,cent=FALSE,scale=FALSE,scannf=FALSE,nf=10)
	# plot(pca1$co$Comp1,pca1$co$Comp2,col=col)		# unfortunately output doesn't seem to make sense
	#
	# PCA eigenvalues (can also be inset in graph):
	if(!is.null(export)){pdf(paste("adegenet.pca.eigenvalues",nloc,"loci",nind,"samples.pca.pdf",sep="."),width=6,height=6)}
	barplot(pca1$eig[1:50],main="PCA eigenvalues", col=heat.colors(50))
	if(!is.null(export)){dev.off()}
	#
	# PCA plot:
	if(!is.null(export)){pdf(paste("adegenet.pca",nloc,"loci",nind,"samples.pca.pdf",sep="."),width=12,height=12)}
	par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
	s.class(pca1$li, pop(mygeno),xax=1,yax=2,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-2"))
	s.class(pca1$li, pop(mygeno),xax=1,yax=3,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-3"))
	s.class(pca1$li, pop(mygeno),xax=2,yax=3,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 2-3"))
	s.class(pca1$li, pop(mygeno),xax=1,yax=4,col=transp(col,.6), axesell=FALSE, cstar=0, cpoint=1.5, grid=FALSE, clabel=2.5)
	title(paste("PC axes: 1-4"))
	if(!is.null(export)){dev.off()}
	# unused:
	# s.label(pca1$li,xax=1,yax=2)														# to plot sample labels
	# add.scatter.eig(pca1$eig[1:20],nf=nfactor,xax=1,yax=2, posi = "bottomright")		# to add inset of PCA eigenvalues
	}

overlapdapc<-function(popnames=mysambar$populations,observedmat=NULL)
	{
	# if mysambar$dapcoverlaplist does not correspond with current mysambar$populations, the following error:  
	# Error in dimnames(x) <- dn : length of 'dimnames' [1] not equal to array extent
	#
	if(is.null(observedmat))
		{
		return(cat("ERROR: Provide input to observedmat flag.",sep="\n"))
		}
	mymatrix			<- observedmat
	npops				<- length(popnames)
	rownames(mymatrix)	<- popnames
	colnames(mymatrix)	<- paste("cluster",c(1:npops))
	# reorder matrix:
	mymatlist	<- list()
	myperms		<- permutations(n=npops,r=npops)	# depends on gtools
	nperms		<- nrow(myperms)
	diagsum		<- rep(NA,nperms)
	for(j in c(1:nperms))
		{
		myperm		<- myperms[j,]
		myoptions	<- c(1:npops)
		taken		<- 0
		myorder		<- rep(NA,npops)
		for (k in myperm)
			{
			myrow		<- mymatrix[k,]
			myoptions	<- myoptions[!myoptions==taken]
			myremrow	<- myrow[myoptions]
			myhigh		<- max(myremrow)
			taken		<- which(myrow==myhigh)[1] 
			myorder[k]	<- taken
			}
		mynewmat		<- mymatrix[,myorder]
		diagsum[j]		<- sum(diag(mynewmat))
		mymatlist[[j]]	<- mynewmat
		}
	mywinner	<- which(diagsum==max(diagsum))[1]
	bestmat		<- mymatlist[[mywinner]]
	#
	# observed vector:
	myobs		<- c(diag(bestmat),bestmat[upper.tri(bestmat)],bestmat[lower.tri(bestmat)])
	# expected vector:
	npopinds	<- as.vector(table(inds$pop[inds$filter]))
	myexp		<- c(npopinds,rep(0,npops*(npops-1)))
	# now calculate deviation:
	mytable		<- cbind(myobs,myexp)
	mytable		<- mytable[rowSums(mytable)!=0,]
	options(warn=-1)
	mychiout	<- chisq.test(mytable)
	options(warn=0)
	mychi		<- mychiout[[1]]
	mydf		<- mychiout[[2]]
	myp			<- mychiout[[3]]
	mychidf		<- data.frame("chi2"=mychi,"df"=mydf,"pvalue"=myp)  
	write.table(mychidf,"dapc.inferred.vs.expected.chisquared-score.txt",row.names=FALSE,col.names=TRUE,quote=FALSE)
	cat("File 'dapc.inferred.vs.expected.chisquared-score.txt' with chi-squared value written to directory:",sep="\n")
	cat(getwd(),sep="\n")
	}
	
# 09-01-2018: are the following lines regarding the dapc function still true?
#If the length of your populations vector is one (so all individuals are assigned to the same population), the dapc plot will be created interactively, which means that at a certain point you are prompted to input numbers on the screen. Because the plot is generated two times (different formats), and because you get 4 questions per plot, this will be a bit repetitive. 
#The prompts are (and rough guidelines to what the input should be):
#Choose the number PCs to retain (>= 1): 			1/3*nind
#Choose the number of clusters (>=2: 				your a priori guess
#Choose the number PCs to retain (>=1): 			1/3*nind
#Choose the number discriminant functions to retain (>=1):	 3
#If you have your samples assigned to more than one population, this will be done automatically for you, so you won’t be prompted.  

multi_adegenet_dapc<-function(export=NULL,xvalonly=FALSE,nrep=50,thresvector=c(20,50,80,95),max_clusters=6,legendadd=TRUE,poslegend="right",cexlegend=2.5,symsize=2,silent=FALSE,rundc=TRUE,plot_heatmap=TRUE,add_ellipse=FALSE,ellipse_level=0.5)
	{
	# Note: adding ellipse causes warning:
	# In chol.default(shape, pivot = TRUE) : the matrix is either rank-deficient or indefinite
	npops	<- length(mysambar$populations)
	if(!xvalonly)
		{
		# for explained variance based analysis:
		for(mythres in thresvector)
			{
			setwd(mysambar$structuredir)
			dapcfolder	<- paste("dapc_explainedvariance",mythres,sep="")
			if(file.exists(dapcfolder))
				{
				setwd(file.path(mysambar$structuredir,dapcfolder))
				}else{
				dir.create(file.path(mysambar$structuredir,dapcfolder))
				setwd(file.path(mysambar$structuredir,dapcfolder))
				}
			cat(paste("Starting DAPC analyses with number of PC's based on an explained variance of ",mythres,"%.",sep=""),sep="\n")
			adegenet_dapc(maxclusters=max_clusters,export="pdf",addellipse=add_ellipse,ellipselevel=ellipse_level,min_explainedvariance=mythres,use_genind=FALSE,addlegend=legendadd,legendpos=poslegend,legendcex=cexlegend,symbolsize=symsize,use_current_dir=TRUE,dodc=rundc,plotheatmap=plot_heatmap)
			if(length(mysambar$dapcoverlaplist)>=(npops-1)&npops!=1&plot_heatmap)
				{
				cat("Calculating correspondence between inferred and expected clusters. If you receive an error after this line, rerun the findstructure function with the flag 'dapc_heatmap' set to FALSE.",sep="\n")
				# calculate chi-squared value for overlap between inferred and expected clusters:
				overlapdapc(observedmat=mysambar$dapcoverlaplist[[npops-1]])
				}
			setwd(mysambar$structuredir)
			}
		# for a score based analysis:
		setwd(mysambar$structuredir)
		dapcfolder	<- paste("dapc_ascore")
		if(file.exists(dapcfolder))
			{
			setwd(file.path(mysambar$structuredir,dapcfolder,sep=""))
			}else{
			dir.create(file.path(mysambar$structuredir,dapcfolder))
			setwd(file.path(mysambar$structuredir,dapcfolder))
			}
		cat("Starting DAPC analyses with number of PC's based on an the a-score.",sep="\n")
		adegenet_dapc(maxclusters=max_clusters,export="pdf",addellipse=add_ellipse,ellipselevel=ellipse_level,use_genind=FALSE,addlegend=legendadd,legendpos=poslegend,legendcex=cexlegend,symbolsize=symsize,use_current_dir=TRUE,dodc=rundc,plotheatmap=plot_heatmap)
		if(length(mysambar$dapcoverlaplist)>=(npops-1)&npops!=1&plot_heatmap)
			{
			cat("Calculating correspondence between inferred and expected clusters. If you receive an error after this line, rerun the findstructure function with the flag 'dapc_heatmap' set to FALSE.",sep="\n")
			# calculate chi-squared value for overlap between inferred and expected clusters:
			overlapdapc(observedmat=mysambar$dapcoverlaplist[[npops-1]])
			}
		setwd(mysambar$structuredir)
		}
	# To prevent overfitting, we want to know the maximum number of principal components to retain.
	# Above we use the a-score or the arbitrary threshold 80% explained variance.
	# Another way to investigate the number of PC's to retain is to use the function xvalDapc().
	# This function calculates the proportion of succesful outcome prediction 
	# I have no clue what is predicted, and when it is successful.
	# The important point is however that you should select the number of PCs at which the curves starts to plateau.
	# First impute data, because the function uses dadi.pca, and dadi.pca does not accept NA values.
	n_snps	<- nrow(snps[snps$filter,])
	if(!file.exists("dapc_xval.cross.validation.20.pdf"))
		{
		if(n_snps>25000)
			{
			cat("The dataset contains more than 50K SNPs. Skipping xvalDapc() function in order to save time.",sep="\n")
			cat("To execute this function, run: 'runxval(nrep=20)'. With big datasets, high number of repetitions will cause long calculation times.",sep="\n")
			}else{
			if(npops>1)
				{
				cat("Running the function xvalDapc() to determine minimum number of principal components to retain.",sep="\n")
				runxval(nrep=50)
				}else{
				cat("Currently only 1 population defined. Skipping the function xvalDapc().",sep="\n")
				}
			}
		}else{
		cat("File called 'dapc_xval.cross.validation.20.pdf' already present. Skipping the function xvalDapc().",sep="\n")
		}
	setwd(mysambar$structuredir)
	}
	
runxval<-function(nrep=20,exporttype="pdf")
	{
	setwd(mysambar$structuredir)
	if(is.null(mysambar$imputedmatrix))
		{
		sambarimpute()
		}
	for (mymax in c(20,100))
		{
		xval	<- xvalDapc(mysambar$imputedmatrix[inds$filter,snps$filter],grp=as.factor(inds$pop[inds$filter]),n.pca.max=mymax,n.rep=nrep,xval.plot=FALSE)
		if(!is.null(exporttype))
			{
			plotname	<- paste("dapc_xval.cross.validation",mymax,sep=".")
			if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=6,height=6)}
			if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=6,height=6)}
			if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=6,height=6)}
			}
		par(mar=c(4,6,0.5,0.5))
		boxplot(xval[[1]]$success~xval[[1]]$n.pca,col="orange",las=2,xlab="",ylab="",cex.axis=1.5,pch=16)
		#points(rep(seq(mymax/10,mymax-mymax/10,mymax/10),each=nrep)/2,xval[[1]]$success,col="grey50",cex=1,pch=16)	# overlaying points, not insightful
		mtext(side=2,"Proportion successful predictions",line=4.25,cex=2)
		mtext(side=1,"Number of PCs",line=3,cex=2)
		if(!is.null(exporttype)){dev.off()}
		}
	}

adegenet_dapc<-function(export=NULL,use_genind=FALSE,min_explainedvariance=NULL,sumstatsplot=TRUE,maxclusters=5,transparent=0.6,symbolsize=2,addlegend=TRUE,legendpos="right",legendcex=2.5,use_current_dir=FALSE,silent=TRUE,dodc=TRUE,plotheatmap=TRUE,addellipse=FALSE,ellipselevel=0.5)
	{	
	# if min_explainedvariance is not NULL, this function will use min_explainedvariance threshold (any value between 0 and 100) to define number of PC's to incorporate
	# otherwise, the function will use the a-score to define the number of PC's. 
	#
	if(is.null(mysambar$genind)&use_genind)
		{
		return(cat("ERROR: No genind object stored at mysambar$genind. Did you run the genlight2genind()-function?",sep="\n"))
		}
	if(!use_current_dir){setwd(mysambar$structuredir)}
	# First create indstemp file with all samples clustered together per population:
	if(!silent){cat("Selecting and ordering samples...",sep="\n")}
	if(use_genind)
		{
		mygeno		<- mysambar$genind
		}else{
		# sambarfunction_findstructure:
		### DAPC analyses:
		# sambarfunction_findstructure:
		mygeno		<- mygenlight[inds$filter,snps$filter]
		}
	mymatrixtemp	<- as.matrix(mygeno)
	mypopnames		<- inds$pop[inds$filter]
	# sambarfunction_findstructure:
	mymatrixtemp	<- mymatrixtemp[order(mypopnames),]
	# sambarfunction_findstructure:
	mygeno			<- as.genind(mymatrixtemp)
	if(is.null(mygeno@all.names))
		{
		# This is to avoid the error:
		# invalid length in all.names: Error in validObject(x) : invalid class "genind" object: FALSE
		cat("WARNING: all.names missing from genind object. Adding now...",sep="\n")
		mygeno@loc.fac		<- as.factor(snps$name[snps$filter])
		mygeno@loc.n.all	<- rep(2,nrow(snps[snps$filter,]))
		mygeno@all.names	<- as.list(snps$name[snps$filter])
		}else{
		if(length(mygeno@all.names)!=nrow(snps[snps$filter,]))
			{
			cat("WARNING: all.names vector in genind object does not have expected length. Replacing...",sep="\n")
			mygeno@loc.fac		<- as.factor(snps$name[snps$filter])
			mygeno@loc.n.all	<- rep(2,nrow(snps[snps$filter,]))
			mygeno@all.names	<- as.list(snps$name[snps$filter])
			}
		}
	indstemp		<- inds[order(inds$pop),]
	pop(mygeno)		<- as.factor(indstemp$pop[inds$filter])
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name[indstemp$filter])))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Defining population colours..",sep="\n")}
	# Now start analysis:	
	nind			<- nrow(indstemp[indstemp$filter,])
	nloc			<- nrow(snps[snps$filter,])
	mypops			<- indstemp$pop[indstemp$filter]
	mypoplabels		<- as.vector(unique(mypops))
	mycols			<- as.vector(unique(indstemp$popcol[indstemp$filter]))	# used for barplot
	mycols			<- mycols[order(mypoplabels)]							# how to double check if colours are assigned to clusters correctly?
	npops			<- length(mypoplabels)
	if(npops==1)
		{
		cat("At present only 1 population defined.",sep="\n")
		cat("To run without ERRORs, DAPC needs at least 2 populations as input.",sep="\n")		# ERROR message: ERROR in svd(X, nu = 0L) : infinite or missing values in 'x'
		cat("Therefore, Sambar randomly assigned the samples to 2 populations.",sep="\n")
		myhalf			<- floor(nind/2)
		myrandomlabels	<- c(rep("random_pop1",myhalf),rep("random_pop2",(nind-myhalf)))
		pop(mygeno)		<- myrandomlabels
		mypopulations	<- c("random_pop1","random_pop2")
		npops			<- 2
		}else{
		mypopulations	<- mysambar$populations
		}
	if(sumstatsplot)
		{
		## create plot with dapc summary statistics:
		graphics.off()
		if(!is.null(export))
			{
			if(!silent){cat("Opening device...",sep="\n")}
			if(export=="eps"){postscript("dapc.summarystatistics.eps",family=mysambar$myfont,width=19,height=7)}
			if(export=="pdf"){pdf("dapc.summarystatistics.pdf",family=mysambar$myfont,width=19,height=7)}
			if(export=="png"){png("dapc.summarystatistics.png",family=mysambar$myfont,width=1300,height=500)}
			if(export=="wmf"){win.metafile("dapc.summarystatistics.wmf",family=mysambar$myfont,width=19,height=7)}
			# wmf only works if solid = 1 (Otherwise ERROR about blank input)
			}
		par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
		#
		## plot pca eigenvalues:
		if(!silent){cat("Starting DAPC analyses...",sep="\n")}
		dapc.out 		<- dapc(mygeno,n.pca=100,n.da=100)	# we set n.pca and n.da for now really high so pc's cover 100 of explained variance (and for nda no choice is made yet(?))
		if(!silent){cat("Selecting number of PCs to retain...",sep="\n")}
		mypcaeigen 		<- dapc.out$pca.eig
		mypcaeigensum 	<- 100*cumsum(mypcaeigen)/sum(mypcaeigen)
		mytotalpca		<- length(mypcaeigensum)
		# Retaining too many components with respect to the number of individuals can lead to over-fitting and unstability in the membership probabilities returned by the method 
		# The bottomline is therefore retaining a few PCs without sacrificing too much information.
		# Different ways to determine optimal number:
		# mynpca		<- which(mypcaeigensum>80)[1]			# when 80% explained?
		# mynpca		<- which((diff(mypcaeigensum)<0.5))[1]	# alternative method: when added explained variance below a certain threshold (e.g 0.5%)? 
		# accepted way is using built-in function of dapc, which calculates a so called a score, and outputs a plot at the same time:
		# 30-06-2022: added option n.sim=100 (default n.sim=10) following recommendations of a SambaR user
		my_ascore 		<- optim.a.score(dapc.out,n.sim=100)			
		if(is.null(min_explainedvariance))
			{
			mynpca		<- my_ascore$best
			cat(paste("Based on the a-score statistic,",mynpca,"is the optimal number of PCs. DAPC-analyses will be executed using this value.",sep=" "),sep="\n")
			}else{
			mynpca		<- which(mypcaeigensum>min_explainedvariance)[1]
			cat(paste("Number of PCs to retain given the prespecified amount of explained variance is: ",mynpca,". DAPC-analyses will be executed using this value.",sep=""),sep="\n")
			}
		cat(paste("Number of PC's included in analysis: ",mynpca,sep=""),sep="\n") 
		plot(mypcaeigensum,col=rep(c("orange","grey20"),c(mynpca,1000)),ylim=c(0,100),xlim=c(0,mytotalpca),main="Variance explained by PCA", xlab="PCA axis", ylab="Cumulated variance (%)",cex=1, pch=20, type="h", lwd=2)
		legend("topleft",legend=c("Not retained","Retained"),fill=c("grey20","orange"),bty='n',cex=1.5)
		#
		## create bic plot:
		# I set max.n.clust to 10, unless datasets contain no more than 10 (sub)populations, or less individuals): 
		mymaxcluster	<- 10
		mymaxcluster	<- ifelse(npops>10,npops,mymaxcluster)
		mymaxcluster	<- ifelse(nind<10,nind-1,mymaxcluster)
		mygrp 			<- find.clusters(mygeno,max.n.clust=mymaxcluster,n.pca=mynpca,choose.n.clust=FALSE)	
		#
		# When I try to run the following function:
		# xvalDapc(as.matrix(mygeno),mygrp,n.pca.max=nrow(mygeno),n.da=20,n.pca=mynpca,n.rep=30,xval.plot=TRUE)
		# I get the error:
		# Error in order(y) : unimplemented type 'list' in 'orderVector1'
		# Or:
		# xval<-xvalDapc(mygeno,grp=as.factor(inds$pop[inds$filter]),n.pca.max=100,n.rep=3)
		# Error in dudi.pca(x, nf = n.pca.max, scannf = FALSE, center = center,  :  na entries in table
		#
		#
		plot(mygrp$Kstat,main="Bic value",xlab="Number of clusters",ylab="BIC",type='b',col="grey20")
		if(!is.null(export)){dev.off()}
		#
		# plot reassignment of samples:
		# this plot is difficult to assign population colours, because I am not sure whether clusters defined by dapc are the same as population clusters
		# graphics.off()
		# if(!is.null(export))
		#	{
		#	if(export=="eps"){postscript("dapc.barplot.eps",family=mysambar$myfont,width=13,height=7)}
		#	if(export=="pdf"){pdf("dapc.barplot.pdf",family=mysambar$myfont,width=13,height=7)}
		#	if(export=="png"){png("dapc.barplot.png",family=mysambar$myfont,width=720,height=500)}
		#	if(export=="wmf"){win.metafile("dapc.barplot.wmf",family=mysambar$myfont,width=13,height=7)}
		#	# wmf only works if solid = 1 (Otherwise ERROR about blank input)
		#	}
		# if(npops==1)
		#	{
		#	tempcols<-mysambar$mycolours[1:2]
		#	}else{
		#	tempcols=mycols1
		#	}
		# par(mar=c(4.5,15,1,2.5),cex.axis=2,cex.lab=2.5,cex.main=2.5)
		# sumtemp <- summary(dapc(mygeno, n.da=20, n.pca=mynpca))$assign.per.pop*100
		# barplot(sumtemp, xlab="% of reassignment to actual cluster",horiz=TRUE,las=1,col=tempcols,xlim=c(0,100))
		# if(!is.null(export)){dev.off()}
		#
		# not sure what this plot is doing:
		# barplot(dapc.out$eig,main="Discriminant analysis eigenvalues",ylab="F-statistic",xlab="Linear Discriminants",col="orange",names.arg=c(1:length(dapc.out$eig)))
		#
		}
	myclusters	<- c(2:maxclusters)
	cat("Running DAPC analyses for various number of expected clusters (K).",sep="\n")
	cat("Observe the screeplot in the 'dapc.summarystatistics'-plot to find the optimal K value (lowest point or flattening of decline).",sep="\n")
	myoverlap		<- list()
	dapcqmatrixlist	<- list()
	dapcld_poplist	<- list()
	dapcld_inflist	<- list()
	# scatter plots for different number of clusters:
	for (i in myclusters)
		{
		cat(paste("K =",i,sep=" "),sep="\n")
		#
		# sambarfunction_findstructure:
		mygrp 	<- find.clusters(mygeno,max.n.clust=20,n.pca=mynpca,n.clust=i)
		# From the adegenet manual: For small number of clusters (less than tens), all DA eigenvalues can be saved. 
		# I set n.da to upper limit of 20, but only 'ncluster - 1' are saved when running dapc function   
		#
		for (myindex in c(1:2))
			{
			# we are going to create scatter plots both a priori information (clusters inferred by find.clusters function) and without a priori information.
			showinferred	<- ifelse(myindex==1,TRUE,FALSE)
			if(!showinferred)
				{
				# Without grp$grp dapc will use a priori defined population assignment as input.
				# 13-02-2020: I include the option within grp$grp now, so users can compare the output.
				#dapc.out 			<- dapc(mygeno,pop=NULL,n.pca=mynpca,n.da=20)		# 09-06-2022: if pop=NULL, defaults to pop=mygeno@pop
				dapc.out 			<- dapc(mygeno,pop=mygeno@pop,n.pca=mynpca,n.da=20)
				#datatype			<- "WITH_prior_popinfo"		# renamed for clarity on 09-06-2022
				datatype			<- "PRIOR_POPINFO"
				dapcld_poplist[[i-1]]<- as.data.frame(dapc.out$ind.coord)			
				}else{
				# sambarfunction_findstructure:
				dapc.out 			<- dapc(mygeno,pop=mygrp$grp,n.pca=mynpca,n.da=20)	 
				#datatype			<- "WITHOUT_prior_popinfo"	# renamed for clarity on 09-06-2022
				datatype			<- "INFERRED_CLUSTERS"
				dapcld_inflist[[i-1]]<- as.data.frame(dapc.out$ind.coord)
				}
			mydapc					<- as.data.frame(dapc.out$ind.coord)
			mysambar$mydapc			<<- mydapc
			#
			# matrix with population membership probabilities:
			myqmatrix				<- round(dapc.out$posterior,3)
			myqmatrix				<- myqmatrix[order(rownames(myqmatrix)),]
			if(showinferred)
				{
				dapcqmatrixlist[[i-1]]	<- myqmatrix
				mytable					<- as.matrix(table(pop(mygeno),mygrp$grp))	
				colnames(mytable)		<- paste("cluster",levels(mygrp$grp),sep="_")
				myoverlap[[i-1]]		<- mytable
				}
			mysambar$dapcoverlaplist	<<- myoverlap
			#
			# Scatter plots:
			graphics.off()
			# to add DAPC eigenvalues: scree.da=TRUE; to add PCA eigenvalues: scree.pca=TRUE
			# as mentioned above, number of discriminant functions is nclusters (i) - 1.
			# if i = 2, there is only one option: xax = 1 and yax = 1.
			# if i = 3, there are 3 options: xax = 1 and yax=1; xax = 1 and yax = 2, xax = 2 and yax = 2. However, we are only interested in the second option.
			# if i = 4 or more, this are the options we are interested in: xax = 1 and yax = 2, xax = 1 and yax = 3, xax = 2 and yax = 3.
			# so:
			#				
			# if (i == 2)
			#	{
			#	if(!is.null(export))
			#		{
			#		if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc.eps",sep="."),height=6,width=6)}
			#		if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc.pdf",sep="."),height=6,width=6)}
			#		if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc.png",sep="."),height=720,width=720)}
			#		if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc.wmf",sep="."),height=6,width=6)}
			#		}
			#	add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
			#	scatter(dapc.out, grp=mypops, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=transparent,cex.lab=2.5,clabel=2.5,label=NULL,legend=add_leg)
			#	if(!is.null(export)){dev.off()}
			#	}
			#
			if (i == 3)
				{
				for(myrun in c(1:4))
					{
					if(!is.null(export))
						{
						mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
						if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"eps",sep="."),height=10,width=10)}
						if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=10,width=10)}
						if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"png",sep="."),height=720,width=720)}
						if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=10,width=10)}
						}
					par(cex.axis=2,cex.lab=2.5,cex.main=2.5)
					#scatter(dapc.out, grp=mypops, col=mycols, xax=1, yax=2, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=transparent,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
					if(myrun<3)
						{
						plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
						if(addellipse)
							{
							#cat("Adding ellipse. If you receive an error after this line, set the flag addellipse to FALSE.",sep="\n")
							if("car"%in%(.packages()) == FALSE) {library(car)}
							car::dataEllipse(x=mydapc$LD1,y=mydapc$LD2,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
							}
						}else{
						plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
						text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
						}
					abline(v=0,col="grey")
					abline(h=0,col="grey")
					if(myrun%%2!=0)
						{
						add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
						if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
						}
					mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
					if(!is.null(export)){dev.off()}
					}
				}
			# 13-02-2020: It is a mystery to me why it is possible to run plot(mydapc$LD1,mydapc$LD2) even if npca=1 (meaning that the column mydapc$L2 is absent).
			# it results in samples clustered together in discs shaped agglomerations.
			#if(mynpca<4)	# 20-02-2020: because I experienced that mynpca can be 4 or higher, and only one column in mydapc.
			if (ncol(mydapc)<3)
				{
				cat("Number of retained PC's is below 4. Skipping dapc plot's for K=4 and higher.",sep="\n")
				}else{
				if (i == 4)
					{
					for(myrun in c(1:4))
						{
						if(!is.null(export))
							{
							mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
							if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"eps",sep="."),height=12,width=12)}
							if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=12,width=12)}
							if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"png",sep="."),height=1200,width=1200)}
							if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=12,width=12)}
							}
						#par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						par(mfrow=c(2,2),mar=c(1,2,2,1),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=2, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							if(addellipse)
								{
								#cat("Adding ellipse. If you receive an error after this line, set the flag addellips to FALSE.",sep="\n")
								if("car"%in%(.packages()) == FALSE) {library(car)}
								car::dataEllipse(x=mydapc$LD1,y=mydapc$LD2,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
								}
							}else{
							plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=4)
							text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						if(myrun%%2!=0)
							{
							add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
							if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=3)}
							}
						mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(!"LD3"%in%colnames(mydapc))
							{
							cat("WARNING: no column 'LD3' in mydapc dataframe. Not plotting LD1 vs LD3 or LD2 vs LD3.",sep="\n")
							}else{
							if(myrun<3)
								{
								plot(mydapc$LD1,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								if(addellipse)
									{
									#cat("Adding ellipse. If you receive an error after this line, set the flag addellipse to FALSE.",sep="\n")
									if("car"%in%(.packages()) == FALSE) {library(car)}
									car::dataEllipse(x=mydapc$LD1,y=mydapc$LD3,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
									}
								}else{
								plot(mydapc$LD1,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								text(mydapc$LD1,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
								}
							abline(v=0,col="grey")
							abline(h=0,col="grey")
							mtext("DAs: 1 vs 3",side=3,line=0,cex=2.5)
							#scatter(dapc.out, grp=mypops, xax=2, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
							if(myrun<3)
								{
								plot(mydapc$LD2,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								if(addellipse)
									{
									#cat("Adding ellipse. If you receive an error after this line, set the flag addellipse to FALSE.",sep="\n")
									if("car"%in%(.packages()) == FALSE) {library(car)}
									car::dataEllipse(x=mydapc$LD2,y=mydapc$LD3,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
									}
								}else{
								plot(mydapc$LD2,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								text(mydapc$LD2,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
								}
							abline(v=0,col="grey")
							abline(h=0,col="grey")
							mtext("DAs: 2 vs 3",side=3,line=0,cex=2.5)
							}
						if(!is.null(export)){dev.off()}
						}
					}
				#
				if (i > 4)
					{
					for(myrun in c(1:4))
						{
						if(!is.null(export))
							{
							mysymbol	<- ifelse(myrun<3,ifelse(myrun==1,"dots.withlegend","dots.nolegend"),ifelse(myrun==3,"labels.withlegend","labels.nolegend"))
							if(export=="eps"){postscript(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"eps",sep="."),height=12,width=12)}
							if(export=="pdf"){pdf(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=12,width=12)}
							if(export=="png"){png(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"png",sep="."),height=1200,width=1200)}
							if(export=="wmf"){win.metafile(paste("dapc.K",i,mynpca,"scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=12,width=12)}
							}
						#par(mfrow=c(2,2),mar=c(5,6,5,2),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						par(mfrow=c(2,2),mar=c(1,2,2,1),cex.axis=2,cex.lab=2.5,cex.main=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=2, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(myrun<3)
							{
							plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							if(addellipse)
								{
								#cat("Adding ellipse. If you receive an error after this line, set the flag addellips to FALSE.",sep="\n")
								if("car"%in%(.packages()) == FALSE) {library(car)}
								car::dataEllipse(x=mydapc$LD1,y=mydapc$LD2,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
								}
							}else{
							plot(mydapc$LD1,mydapc$LD2,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
							text(mydapc$LD1,mydapc$LD2,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
							}
						abline(v=0,col="grey")
						abline(h=0,col="grey")
						if(myrun%%2!=0)
							{
							add_leg	<- ifelse(length(mysambar$populations)==1,FALSE,addlegend)
							if(add_leg){legend(legendpos,legend=mypopulations,fill=mysambar$mycolours[1:npops],bty='n',cex=3)}
							}
						mtext("DAs: 1 vs 2",side=3,line=0,cex=2.5)
						#scatter(dapc.out, grp=mypops, xax=1, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
						if(!"LD3"%in%colnames(mydapc))
							{
							cat("WARNING: no column 'LD3' in mydapc dataframe. Not plotting LD1 vs LD3 or LD2 vs LD3.",sep="\n")
							}else{
							if(myrun<3)
								{
								plot(mydapc$LD1,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								if(addellipse)
									{
									#cat("Adding ellipse. If you receive an error after this line, set the flag addellips to FALSE.",sep="\n")
									if("car"%in%(.packages()) == FALSE) {library(car)}
									car::dataEllipse(x=mydapc$LD1,y=mydapc$LD3,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
									}
								}else{
								plot(mydapc$LD1,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								text(mydapc$LD1,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
								}
							abline(v=0,col="grey")
							abline(h=0,col="grey")
							mtext("DAs: 1 vs 3",side=3,line=0,cex=2.5)
							#scatter(dapc.out, grp=mypops, xax=2, yax=3, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
							if(myrun<3)
								{
								plot(mydapc$LD2,mydapc$LD3,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								if(addellipse)
									{
									#cat("Adding ellipse. If you receive an error after this line, set the flag addellips to FALSE.",sep="\n")
									if("car"%in%(.packages()) == FALSE) {library(car)}
									car::dataEllipse(x=mydapc$LD2,y=mydapc$LD3,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
									}
								}else{
								plot(mydapc$LD2,mydapc$LD3,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								text(mydapc$LD2,mydapc$LD3,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
								}
							abline(v=0,col="grey")
							abline(h=0,col="grey")
							mtext("DAs: 2 vs 3",side=3,line=0,cex=2.5)
							}
						#
						if(!"LD4"%in%colnames(mydapc))
							{
							cat("WARNING: no column 'LD4' in mydapc dataframe. Not plotting LD1 vs LD4.",sep="\n")
							}else{
							#scatter(dapc.out, grp=mypops, xax=1, yax=4, col=mycols, scree.da=TRUE, posi.da="bottomright",scree.pca=TRUE,posi.pca="bottomleft",cell=3, cex=1, bg="white", cstar=0,solid=0.6,cex.lab=2.5,clabel=2.5,label=NULL,legend=addlegend)
							if(myrun<3)
								{
								plot(mydapc$LD1,mydapc$LD4,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								if(addellipse)
									{
									#cat("Adding ellipse. If you receive an error after this line, set the flag addellips to FALSE.",sep="\n")
									if("car"%in%(.packages()) == FALSE) {library(car)}
									car::dataEllipse(x=mydapc$LD1,y=mydapc$LD4,add=TRUE,groups=as.factor(indstemp$pop[indstemp$filter]),col=mysambar$mycolours[1:npops],levels=ellipselevel,grid=FALSE,lwd=2,group.labels=NULL,center.pch=NULL,plot.points=FALSE,xlab="",ylab="")	
									}
								}else{
								plot(mydapc$LD1,mydapc$LD4,col="white",pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
								text(mydapc$LD1,mydapc$LD4,indstemp$nr[inds$filter],col=indstemp$popcol[indstemp$filter],cex=0.25)
								}
							abline(v=0,col="grey")
							abline(h=0,col="grey")
							mtext("DAs: 1 vs 4",side=3,line=0,cex=2.5)
							}
						if(!is.null(export)){dev.off()}
						}
					}
				}
			if(ncol(mydapc)>1&dodc)
				{
				mytablename	<- paste("dapc.K",i,mynpca,"scatter.dapc",datatype,"axis1vs2.dc_score.txt",sep=".")
				calc_dc(popnames=mysambar$populations,pscores=mydapc,axis_1=1,axis_2=2,tablename=mytablename)
				}
			}
		}
	#
	names(dapcqmatrixlist)		<- paste("K",myclusters,sep="")
	mysambar$dapcqmatrixlist	<<- dapcqmatrixlist
	#mysambar$dapcld_poplist	<<- dapcld_poplist
	#mysambar$dapcld_inflist	<<- dapcld_inflist
	#
	# lastly, create heatmaps showing overlap between dapc inferred clusters and your a priori defined populations:
	if(plotheatmap)
		{
		cat("Plotting correspondence between expected and inferred clusters...",sep="\n")
		cat("If you receive an error after this line, rerun the findstructure function with the flag 'dapc_heatmap' set to FALSE.",sep="\n") 
		dapc_heatmap(export_type=export,myoverlap=mysambar$dapcoverlaplist)
		}else{
		cat("Not plotting correspondence between expected and inferred clusters because the flag 'plotheatmap' is set to FALSE.",sep="\n")
		}
	}

dapc_heatmap<-function(export_type=NULL,myoverlap=mysambar$dapcoverlaplist)
	{
	graphics.off()
	ntables			<- length(myoverlap)
	mymax			<- max(unlist(myoverlap))
	mymin			<- min(unlist(myoverlap))
	mycolfunc 		<- colorRampPalette(c("white","orange"))
	myBreaks		<- seq(mymin,mymax,(mymax/10))
	myColours		<- c(mycolfunc(length(myBreaks)-1))		
	gl 				<- lapply(1:length(myoverlap), function(i){
	mymatrix		<- data.matrix(myoverlap[[i]])
	heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
	notecol="black",notecex=2.5,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
	ylab="",xlab="",srtRow=45,srtCol=45,key=FALSE,margins=c(8,8))
	grid.echo()
	grid.grab()})
	graphics.off()
	if(!is.null(export_type))
		{
		myheight	<- ceiling(ntables/2)*6.5
		mywidth		<- ifelse(ntables==1,7.5,15)
		myheight2	<- ceiling(ntables/2)*650
		mywidth2	<- ifelse(ntables==1,750,1500)
		if(export_type=="eps"){postscript("dapc.inferred.vs.expectedclusters.eps",height=myheight,width=mywidth)}
		if(export_type=="pdf"){pdf("dapc.inferred.vs.expectedclusters.pdf",height=myheight,width=mywidth,onefile=FALSE)}
		if(export_type=="png"){png("dapc.inferred.vs.expectedclusters.png",height=myheight2,width=mywidth2)}
		if(export_type=="wmf"){win.metafile("dapc.inferred.vs.expectedclusters.wmf",height=myheight,width=mywidth)}
		}	
	grid.newpage()
	grid.arrange(grobs=gl,ncol=2,clip=TRUE)	
	if(!is.null(export_type)){dev.off()}
	}

# 02-05-2020: to create stand alone plot
dapc_scatter<-function(addlegend=TRUE,export=NULL,symbolsize=2,legendpos="topright",legendcex=2.5,popnames=mysambar$populations,titlesize=2.5)
	{
	# first run adegenet_dapc (with desired settings) to create dapc output (mydapc matrix).
	# First create indstemp file with all samples clustered together per population:
	if(is.null(mysambar$mydapc))
		{
		cat("ERROR: could not find object 'mydapc'.",sep="\n") 	
		}else{
		cat("Plotting DAPC output...",sep="\n")
		mydapc		<- mysambar$mydapc
		}
	npops			<- length(popnames)
	mygeno			<- mygenlight[inds$filter,snps$filter]
	mymatrixtemp	<- as.matrix(mygeno)
	mypopnames		<- inds$pop[inds$filter]
	mymatrixtemp	<- mymatrixtemp[order(mypopnames),]
	mygeno			<- as.genind(mymatrixtemp)
	indstemp		<- inds[order(inds$pop),]
	pop(mygeno)		<- as.factor(indstemp$pop[inds$filter])
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste("scatter.dapc",datatype,mysymbol,"eps",sep="."),height=10,width=10)}
		if(export=="pdf"){pdf(paste("scatter.dapc",datatype,mysymbol,"pdf",sep="."),height=10,width=10)}
		if(export=="png"){png(paste("scatter.dapc",datatype,mysymbol,"png",sep="."),height=720,width=720)}
		if(export=="wmf"){win.metafile(paste("scatter.dapc",datatype,mysymbol,"wmf",sep="."),height=10,width=10)}
		}
	par(cex.axis=2,cex.lab=2.5,cex.main=2.5)
	plot(mydapc$LD1,mydapc$LD2,col=indstemp$popcol[indstemp$filter],pch=16,xaxt='n',yaxt='n',xlab="",ylab="",cex=symbolsize)
	abline(v=0,col="grey")
	abline(h=0,col="grey")
	if(addlegend){legend(legendpos,legend=popnames,fill=mysambar$mycolours[1:npops],bty='n',cex=legendcex)}
	mtext("DAs: 1 vs 2",side=3,line=0,cex=titlesize)
	if(!is.null(export)){dev.off()}
	}

haplonetworks<-function(nplots=3,do_silent=TRUE,show_mut=2,do_randomsubset=TRUE,noderatio=0.1,do_overwrite=TRUE,legend_cex=1.5,legend_pos="topleft",nrloci=1000,bin_factor=NULL,export_name="Genotype_network",alt_threshold=0)
	{
	if("raster" %in% (.packages()) == TRUE)
		{
		return(cat("ERROR: can not generate network if package 'raster' is loaded, because it masks a function of the package spDep. Please load a new R session and run the getpackages() function with within mypackageslist.txt the column value of the row 'raster' set to FALSE (default).",sep="\n"))  
		}
	# To prevent error:
	# Error in h(simpleError(msg, call)) : 
	# error in evaluating the argument 'data' in selecting a method for function 'with': unable to find an inherited method for function 'raster' for signature '"integer"'
	if(is.null(mysambar$mydnabin)|do_overwrite)
		{
		genlight2DNAbin(export=TRUE,input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="filtereddata.diploid.fa") 
		}
	for(plotnr in c(1:nplots))
		{
		if(!do_silent){cat(plotnr,sep="\n")}
		binlabel	<- ifelse(is.null(bin_factor),"nobinning",paste("binwidth",bin_factor,sep=""))
		haplonetwork(silent=do_silent,export=TRUE,showmut=show_mut,exportname=paste(export_name,binlabel,plotnr,sep="_"),legendcex=legend_cex,randomsubset=do_randomsubset,myratio=noderatio,nloci=nrloci,legendpos=legend_pos,binfactor=bin_factor,altthreshold=alt_threshold)
		}
	}

# 30-03-2022: previously called makenetwork
haplonetwork<-function(myinput=mysambar$mydnabin,showmut=2,nloci=1000,randomsubset=FALSE,popnames=mysambar$populations,legendpos="topleft",legendcex=1.5,myratio=0.1,export=FALSE,exportname="Genotype_network",silent=TRUE,binfactor=NULL,altthreshold=0)
	{
	# too many loci results in overlapping circles.
	# 1000 randomly sampled loci with a ratio of 0.1 works best 
	# or: 2000 loci with a ratio of 0.05
	#
	# 20-05-2021: not clear to me what causes this error:
	# Error in integrate(L_jm, 0, 1, j = i, m = M) : non-finite function value
	#
	if("raster" %in% (.packages()) == TRUE)
		{
		return(cat("ERROR: can not generate network if package 'raster' is loaded, because it masks a function of the package spDep. Please load a new R session and run the getpackages() function with within mypackageslist.txt the column value of the row 'raster' set to FALSE (default).",sep="\n"))  
		}
	if(is.null(myinput))
		{
		return(cat("ERROR: specified input file does not exist. Did you run the genlight2DNAbin() function?",sep="\n"))
		}
	if(length(altthreshold)==1)
		{
		if(altthreshold!=0)
			{
			return(cat("ERROR: altthreshold should be either 0 or contain two elements: c(minimum,maximum).",sep="\n"))
			}
		}
	# define pops and colours:
	indstemp	<- droplevels(inds[inds$filter,])
	myorder		<- order(indstemp$pop)
	indstemp	<- indstemp[myorder,]
	mypops		<- indstemp$pop
	#
	mypops2		<- popnames[order(popnames)]
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	# mycolours	<- mycolours[order(popnames)]
	#
	# select data:
	if(!silent){cat("Selecting data...",sep="\n")}
	bigdataset	<- ncol(myinput)>nloci
	if(bigdataset)
		{
		if(randomsubset)
			{
			cat(paste("Using random subset of ",nloci," SNPs...",sep=""),sep="\n")
			myinput		<- myinput[myorder,sample(c(1:ncol(myinput)),nloci,replace=FALSE)]
			}else{
			cat(paste("Using ",nloci," SNPs with highest deviation in population minor allele frequencies...",sep=""),sep="\n")
			snpstemp	<- snps[snps$filter,]
			sdthres		<- head(tail(sort(snpstemp$sd_popmaf),nloci),1)
			myinput		<- myinput[myorder,snpstemp$sd_popmaf>=sdthres]
			}
		}else{
		cat("Using all SNPs...",sep="\n")
		myinput		<- myinput[myorder,]
		}
	ndata		<- ncol(myinput)
	#
	# create network: 
	cat("Creating network...",sep="\n")
	cat("This make take a while...",sep="\n")
	e 			<- dist.dna(myinput)
	if(!silent){cat("pegas::haplotype...",sep="\n")}
	h 			<- pegas::haplotype(myinput)
	h 			<<- sort(h, what = "label")
	if(!silent){cat("pegas::haploNet...",sep="\n")}
	net 		<- pegas::haploNet(h)
	if(!is.null(binfactor))
		{
		cat("Binning number of substitutions as defined by binfactor flag.",sep="\n")
		net[,3]		<- ceiling(net[,3]/binfactor)
		altthreshold<- ceiling(altthreshold/binfactor)
		}
	#
	if(!silent){cat("Indexing...",sep="\n")}
	ind.hap		<- with(stack(setNames(attr(h,"index"),rownames(h))),table(hap=ind,pop=mypops[values]))
	#
	# without legend:
	cat("Plot without legend...",sep="\n")
	datatype	<- ifelse(randomsubset,"randomsubset","highest_sdmaf")
	exportname	<- paste(exportname,datatype,sep="_")
	if(export){pdf(paste(exportname,ndata,"snps.pdf",sep="."))}
	plot(net,show.mutation=showmut,bg=mycolours,size=attr(net,"freq"),scale.ratio=myratio,pie=ind.hap,label=FALSE,fast = FALSE,threshold=altthreshold)
	dev.off()
	# with legend:
	cat("Plot with legend...",sep="\n")
	exportname	<- paste(exportname,"legend",sep=".")
	if(export){pdf(paste(exportname,ndata,"snps.pdf",sep="."))}
	plot(net,show.mutation=showmut,bg=mycolours,size=attr(net,"freq"),scale.ratio=myratio,pie=ind.hap,label=FALSE,fast = FALSE,threshold=altthreshold)
	legend(legendpos,mypops2,col=mycolours,pch=19,ncol=1,bty='n',cex=legendcex)
	if(export){dev.off()}
	}	

# Bayesian population assignment probabilities:
assign2pop<-function(popnames=mysambar$populations,mindata=200,n_subset=NULL,silent=TRUE,top_popmafsd=TRUE,docount=FALSE,slowmethod=FALSE)
	{
	# I developed this method myself, but it turns out to be roughly similar to methods described in:
	# Peatkau et al, 1995, Microsatellite analysis of population structure in Canadian polar bears; 
	# Cornuet JM, Piry S, Luikart G, Estoup A, Solignac M, 1999. New methods employing multilocus genotypes to select or exclude populations as origins of individuals;
	# Baudouin & Cornuet, 2004, Analytical Bayesian Approach for Assigning Individuals to Populations
	# The last paper uses a Dirichlet distribution. Different?
	# 
	# The software Structure is also based on Bayes Rule likelihood of population assignment given a sample's genotype. 
	# It is however more complex (it derives population division itself, rather than using a predefined set of populations:
	# Pritchard et al, 2000, Inference of population structure using multilocus genotype data;
	#
	# The question is:
	# among populations of a reference set, which of these populations is most likely to be the origin of a particular individual?
	if(is.null(n_subset))
		{
		fileConn	<- file("popassign.bayesian.explained.txt")
		writeLines(c("The 'popassign.bayesian'-plots depict the probability that a certain individual belongs to a predefined populations given it's observed genotype and given the minor allele frequencies of the predefined populations.",
		"This can be denoted as Pr(hypothesis|observation) or in short Pr(H|O).",
		"The hypothesis H is the population assignment and the observation O is the genotype score. The genotype score is either 0 (homozygous major), 1 (heterozygous), or 2 (homozygous minor).",
		"To calculate these probabilities SambaR use the following Bayesian formula:",
		"Pr(H|O) 	= (Pr(O|H)*Pr(H))/Pr(O)",
		"in which:",
		"Pr(H) 		= 1/npops # flat prior distribution",
		"Pr(O|H) 	= probability of observed genotypes given the population minor allele frequencies",
		"Pr(O)		= sum of product of Pr(H) and Pr(O|H) for all populations",
		"Because the prior distribution is flat, the formula can be simplified to:",
		"Pr(H1|O) 	= Pr(O|H1)/(Pr(O|H1)+Pr(O|H2)+ ... + Pr(O|Hn))	# in which n denotes number of populations",
		"For example: say we have two bottles, one (A) with 10 red and 90 white balls, and the other (B) with 1 red and 99 red balls.",
		"A ball is drawn from either bottle (you don't know which), and it happens to be red. From which bottle is the ball drawn?",
		"Pr(A|red) = Pr(red|A)/(Pr(red|A)+Pr(red|B)) = 0.1/(0.1+0.01) = 0.91",
		"Pr(B|red) = Pr(red|B)/(Pr(red|A)+Pr(red|B)) = 0.01/(0.1+0.01) = 0.09",
		"Similarly, we are going to calculate the probabilities that a sample has been drawn from any of our populations:",
		"Pr(popA|genotype) = Pr(genotype|popA)/(Pr(genotype|popA)+Pr(genotype|popB))",
		"Pr(popB|genotype) = Pr(genotype|popB)/(Pr(genotype|popA)+Pr(genotype|popB))", 
		"For example, say we have 2 populations, and for a particular locus one population (A) has a minor allele frequency (MAF) of 10 percent, and the other a MAF of 1 percent.",
		"What is the probability that an individual which is homozygous for both major alleles (i.e. genotype 0) belongs to either popA or popB?",
		"Pr(popA|0) = Pr(0|popA)/(Pr(0|popA)+Pr(0|popB)) = (0.9*0.9)/(0.9*0.9+0.99*0.99) = 0.45", 
		"Pr(popB|0) = Pr(0|popB)/(Pr(0|popA)+Pr(0|popB)) = (0.99*0.99)/(0.9*0.9+0.99*0.99) = 0.55",
		"This example only shows one locus. When having multiple loci, we calculate the probabilities Pr(geno|popA) and Pr(geno|popB) by multiplying each locus specific probability (assuming they are independent):",
		"Pr(geno|popA) = Pr(locus_1|popA)*Pr(locus_2|popA)*...*Pr(locus_k|popA)							# in which k denotes total number of loci",
		"Pr(geno|popB) = Pr(locus_1|popB)*Pr(locus_2|popB)*...*Pr(locus_k|popB)							# in which k denotes total number of loci",
		"In the script this is (roughly) written as: Pr_geno[j] <- (j-1)*Pr_geno[j-1]*Pr_locus[j]		# in which j denotes each jth locus",
		"Excluded from the calculation are all snps for which one of either alleles are not represented in all populations. Those loci would make the probability converge to 0 or 1, and hence they are omitted.", 
		"To avoid circularity, population allele frequencies are based on sample sets excluding the sample of interest.", 
		"",
		"If you use this Bayesian population assignment probability test for publication, please cite SambaR.", 
		"Similar methods have previously been published by:",
		"Peatkau et al, 1995, Microsatellite analysis of population structure in Canadian polar bears", 
		"Baudouin & Cornuet, 2004, Analytical Bayesian Approach for Assigning Individuals to Populations",
		""),fileConn)
		close(fileConn)
		}
	#
	popmafs 				<- snps[,grep("maf_",colnames(snps))]
	# 28-05-2021: included next lines to removed imputed_maf columns, which otherwise cause an error:
	imputecolumns			<- grep("imputed_maf_",colnames(popmafs))
	if(length(imputecolumns)>0)
		{
		popmafs					<- popmafs[,-imputecolumns]
		}
	#
	mafmin					<- apply(popmafs,1,min)
	colnames(popmafs)		<- popnames
	nodatavec				<- !is.na(rowSums(popmafs))
	mysd					<- snps$sd_popmaf
	myfilter				<- (snps$filter)&(mafmin>0)&(nodatavec)&is.finite(mysd)&!is.na(mysd)
	mysd					<- mysd[myfilter]
	mymafs					<- popmafs[myfilter,]
	# mymafs[is.na(mymafs)]	<- 0.0000001		# 09-07-19: quick and dirty solution for ERROR: ERROR in if (any(mymafs[j, ] == 0) | any(mymafs[j, ] == 1)) { : missing value where TRUE/FALSE needed
	# 18-02-2020: this can massively influence the results, I suppose, so this is NOT a good solution!!! I solved it by filtering out any rows with NA.
	ndata		<- nrow(mymafs)
	ndataperpop	<- vector()
	for(j in c(1:ncol(popmafs)))
		{
		mycolumn		<- popmafs[snps$filter,j]
		ndataperpop[j]	<- length(mycolumn[mycolumn>0&(!is.na(mycolumn))])
		}
	ndatadf		<- data.frame("population"=popnames,"nsnps_minorallele_present"=ndataperpop)
	if(ndata<mindata&is.null(n_subset))
		{
		cat("WARNING: a relatively low number of SNPs has the minor allele present in all populations. As a result, the power of the Bayesian assignment test might be low.",sep="\n")
		write.table(ndatadf,"popassign.bayesian.WARNING.data_per_population.txt",col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")
		fileConn	<- file("popassign.bayesian.WARNING.txt")
		writeLines(c("WARNING: with the current filter settings, a relatively low number of SNPs has the minor allele present in all populations. As a result, the power of the Bayesian assignment test might be low.",
		"Observe the 'popassign.bayesian.data_per_population.txt' to see which populations you might consider to merge or remove in order to up this number and improve the power.",
		""),fileConn)
		close(fileConn)
		}
	mysambar$ndata_popassign		<<- ndata
	if(ndata<2)
		{
		return(cat("Less than 2 SNPs retained. Aborting assign2pop().",sep="\n"))
		}
	nsnps				<- nrow(snps[myfilter,])
	ninds				<- nrow(inds)
	npops				<- length(popnames)
	popassigncol		<- rep(NA,npops)
	for (k in c(1:npops))
		{
		if(!(paste("maf",popnames[k],sep="_")) %in% colnames(snps))
			{
			return(cat("Missing column with maf values. Execute 'maffunction()' followed by 'correctmaf()' and then try running 'assign2pop()' again",sep="\n"))
			} 
		popassigncol[k]	<- inds$popcol[inds$pop==popnames[k]][1]
		}
	mysambar$popassigncol	<<- popassigncol
	#
	if(!is.null(n_subset))
		{
		nsnps			<- n_subset
		if(top_popmafsd)
			{
			mymafs		<- mymafs[order(-mysd),] 
			mymafs		<- head(mymafs,n_subset)
			}else{
			myselection	<- sample(nrow(mymafs),n_subset)
			mymafs		<- mymafs[myselection, ]
			}
		}
	# mymafs		<<- mymafs
	# create empty dataframes:
	myhomomaj	<- matrix(NA,ncol=ncol(mymafs),nrow=nrow(mymafs))
	myhetero	<- myhomomaj
	myhomomin	<- myhomomaj
	myprop		<- myhomomaj
	# start the calculation:
	myassign			<- matrix(NA,ninds,npops)
	myassignalt			<- matrix(NA,ninds,npops)	# new/temp
	for (i in c(1:nrow(inds)))
		{		
		if(!silent)
			{
			cat(i,sep="\n")
			cat(as.vector(inds$name[i]),sep="\n")
			}
		myprmat			<- matrix(NA,nsnps,npops)
		mycountmat		<- matrix(NA,nsnps,npops)		### new
		indgeno			<- as.matrix(mygenlight[i,myfilter])
		indpop			<- inds$pop[i]
		if(!is.null(n_subset))
			{
			if(top_popmafsd)
				{
				indgeno	<- as.vector(indgeno)
				indgeno	<- indgeno[order(-mysd)]
				indgeno	<- head(indgeno,n_subset)
				}else{
				indgeno	<- indgeno[,myselection]
				}
			}
		if(slowmethod)
			{
			# pr based on first locus:
			mygeno			<- indgeno[1]
			mypr			<- rep(NA,npops)
			for (k in c(1:npops))
				{
				mypr[k]		<- ifelse(mygeno==2,mymafs[1,k]*mymafs[1,k],ifelse(mygeno==1,2*mymafs[1,k]*(1-mymafs[1,k]),(1-mymafs[1,k])*(1-mymafs[1,k])))
				}
			if(any(is.na(mypr)))
				{
				mypr		<-rep(1/npops,npops)
				mycountmat[1,]	<- rep(NA,npops)
				}else{
				mycountmat[1,]	<- mypr==max(mypr)	
				}
			mypr			<- mypr/sum(mypr)	 
			myprmat[1,] 		<- mypr
			# 
			# now update probability with info from all loci:
			for (j in c(2:nsnps))
				{
				# cat(j,sep="\n")
				mygeno		<- indgeno[j]
				mynewpr		<- rep(NA,npops)
				if(is.na(mygeno))
					{
					myprmat[j,]	<- myprmat[j-1,]
					mycountmat[j,]	<- rep(NA,npops)	
					}else{
					for (k in c(1:npops))
						{
						mynewpr[k]<- ifelse(mygeno==2,mymafs[j,k]*mymafs[j,k],ifelse(mygeno==1,2*mymafs[j,k]*(1-mymafs[j,k]),(1-mymafs[j,k])*(1-mymafs[j,k])))
						}
					mycountmat[j,]	<- mynewpr==max(mynewpr)
					if(any(mymafs[j,]==0)|any(mymafs[j,]==1))
						{
						myprmat[j,]	<- myprmat[j-1,]				# I am excluding from the calculation all snps with at least one population without the minor alleles. Otherwise the probability converges immediately to 0 or 1.   
						}else{
						mynewpr		<- mynewpr/sum(mynewpr)
						for (k in c(1:npops))
							{
							mypr[k] <- (j-1)*mypr[k]*mynewpr[k]
							}
						mypr		<- mypr/sum(mypr)
						myprmat[j,]	<- mypr
						}
					}
				}	
			myassign[i,]		<- myprmat[j,]
			if(docount)
				{
				# alternative way:						
				for (k in c(1:npops))
					{
					mycount		<- mycountmat[,k]
					myassignalt[i,k]<- length(mycount[mycount==TRUE&!is.na(mycount)])
					}
				}
			}else{
			# 23-3-2020: fast method:
			#
			# 05-04-2020: correct population allele frequency estimate, to avoid circularity:
			indpopnr			<- which(popnames==indpop)
			mymafsnew			<- mymafs
			if(!inds$filter[i])
				{
				# if set to FALSE, individual is not included in analyses, so it's genotype has not been considered when calculating population allele frequency
				# no need to correct
				newindpopmafs				<- as.vector(mymafs[,indpopnr])
				mymafsnew[,indpopnr]		<- newindpopmafs
				indgeno2					<- as.vector(indgeno)
				indgeno2[is.na(indgeno2)]	<- 3	# because NA-values can be interpreted as 1	
				boolmaf0					<- newindpopmafs!=0
				}else{
				indpopsize			<- nrow(inds[inds$pop==indpop&inds$filter,])
				indpopmafs			<- as.vector(mymafs[,indpopnr])
				indpopmacs			<- round(indpopmafs*indpopsize*2)		# 07-05-2020: if I do not round, I get strange values for new mafs, like -0.00000000000000005551115 instead of 0 
				indgeno2			<- as.vector(indgeno)
				indgeno2[is.na(indgeno2)]	<- 3	# because NA-values can be interpreted as 1			
				if(length(indgeno2)!=length(indpopmacs))
					{
					return(cat("ERROR: length indgeno2 does not equal length indpopmacs. Please contact developer of SambaR.",sep="\n"))
					}
				newnralleles		<- 2*(indpopsize-1)
				newindpopmafs		<- ifelse(indgeno2==3,indpopmafs,ifelse(indgeno2==2,(indpopmacs-2)/newnralleles,ifelse(indgeno2==1,(indpopmacs-1)/newnralleles,indpopmacs/newnralleles)))
				boolmaf0			<- newindpopmafs!=0
				mymafsnew			<- mymafs
				mymafsnew[,indpopnr]<- newindpopmafs
				if(any(newindpopmafs[!is.na(newindpopmafs)]<0))
					{
					testmafs		<<- mymafs
					testmafs2		<<- mymafsnew
					return(cat("ERROR: corrected minor allele frequency below 0. Please contact developer of SambaR.",sep="\n"))
					}
				if(any(newindpopmafs[!is.na(newindpopmafs)]>1))
					{
					testmafs		<<- mymafs
					testmafs2		<<- mymafsnew
					return(cat("ERROR: corrected minor allele frequency above 1. Please contact developer of SambaR.",sep="\n"))
					}
				}
			#
			for (k in c(1:npops))
				{	
				myhomomaj[,k]	<- (1-mymafsnew[,k])*(1-mymafsnew[,k])
				myhetero[,k]	<- 2*mymafsnew[,k]*(1-mymafsnew[,k])
				myhomomin[,k]	<- mymafsnew[,k]*mymafsnew[,k]
				myprop[,k]		<- ifelse(indgeno2==3,NA,ifelse(indgeno2==2,as.vector(myhomomin[,k]),ifelse(indgeno2==1,as.vector(myhetero[,k]),as.vector(myhomomaj[,k]))))
				}
			if(i==10000)		# this can be used when encountering problems. 
				{
				testboolmaf		<<- boolmaf0
				testgeno		<<- indgeno2
				testmafs		<<- mymafs
				testmafs2		<<- mymafsnew
				testprop		<<- myprop
				}
			myhomomajdf			<- myhomomaj
			myheterodf			<- myhetero
			myhomomindf			<- myhomomin
			#
			# 05-04-2020: filter out SNPs in which corrected minor allele frequency equals 0:
			mypropdf			<- myprop
			mypropdf			<- mypropdf[boolmaf0&indgeno2!=3,]
			if(any(boolmaf0&indgeno2!=3))
				{
				if(length(indgeno2[boolmaf0&indgeno2!=3])==1)
					{
					if(!silent){cat(paste("WARNING: only 1 retained data point for sample: ",as.vector(inds$name[i]),".",sep=""),sep="\n")}
					myprop3df	<- myprop
					myprop3df[nrow(myprop3df),]	<- rep(1/npops,npops)
					}else{
					nr_sites			<- nrow(mypropdf)
					if(nr_sites<mindata)
						{
						if(!silent){cat(paste("WARNING: Number of retained data points below minimum value specified by the mindata flag for sample: ",as.vector(inds$name[i]),".",sep=""),sep="\n")}
						}
					myprop2df			<- mypropdf/(rowSums(mypropdf))
					myprop3df			<- matrix(NA,nrow=nrow(myprop2df),ncol=ncol(myprop2df))
					myprop3df[1,]		<- myprop2df[1,]
					#cat(nr_sites,sep="\n")
					for(j in (2:nr_sites))
						{
						mynewpr			<- myprop2df[j,]
						if(any(is.na(mynewpr)))
							{
							mynewpr		<- rep(1/npops,npops)
							}
						mypr			<- (j-1)*myprop3df[j-1,]*mynewpr
						mypr_prop		<- mypr/sum(mypr)
						if(any(!is.finite(mypr_prop)))
							{
							myprop3df[j,]	<- round(myprop3df[j-1,])
							}else{
							myprop3df[j,]	<- mypr_prop
							}
						}
					}
				}else{
				if(!silent){cat(paste("WARNING: no retained data points for sample: ",as.vector(inds$name[i]),".",sep=""),sep="\n")}
				myprop3df	<- myprop
				myprop3df[nrow(myprop3df),]	<- rep(1/npops,npops) 
				}
			if(!silent)
				{
				myprop3df2	<<- myprop3df
				}
			myassign[i,]	<- myprop3df[nrow(myprop3df),]
			}
		myassign[myassign<0.0001]	<- 0
		myassign[myassign>0.9999]	<- 1
		if(docount)
			{
			for (i in c(1:nrow(myassignalt)))
				{
				mysum			<- sum(myassignalt[i,])
				myassignalt[i,] <- myassignalt[i,]/mysum
				}
			}
		}
	if(is.null(n_subset))
		{
		cat("Adding data to inds dataframe.",sep="\n")
		for (k in c(1:npops))
			{
			inds$prtemp		<<- myassign[,k]
			names(inds)[names(inds) == "prtemp"] <<- paste("pr",popnames[k],sep = "")
			}
		inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
		}
	# needed for plotting:
	mysambar$myassign	<<- myassign
	mysambar$myassign2	<<- t(myassign)
	if(docount)
		{
		mysambar$myassign3	<<- t(myassignalt)
		}
	if(is.null(n_subset))
		{
		mysambar$fulldata_myassign	<<- myassign
		}
	}

# depends on 'assign2pop' and 'multiplotassign'
# The structure is like this:
# multi_assign2pop calls assign2pop for each number of SNPs and saves the scores in popassignlist
# multi_assign2pop subsequently calls multiplotassign for plotting
# so the function 'plotassign2pop' is not used. This function is used for plotting one set of SNPs only (rather than for multiple subsets of SNPs) 

multi_assign2pop<-function(nsnp_vector=NULL,exporttype=NULL,top_popmaf_sd=FALSE)
	{
	if(is.null(mysambar$fulldata_myassign))
		{
		return(cat("Can not find object 'mysambar$fulldata_myassign'. First (re)run 'assign2pop(n_subset=NULL)' and try again.",sep="\n"))
		}
	fulldata_myassign	<- mysambar$fulldata_myassign
	if(nrow(fulldata_myassign)!=nrow(inds))
		{
		return("Number of rows of 'fulldata_myassign' differs from number of rows of 'inds' dataframe. Firs (re)run 'assign2pop(n_subset=NULL)' and try again.",sep="\n")
		}
	popmafs 	<- snps[,grep("maf_",colnames(snps))]
	mafmin		<- apply(popmafs,1,min)
	nodatavec	<- !is.na(rowSums(popmafs))
	myfilter	<- (snps$filter)&(mafmin>0)&(nodatavec)
	nsnps		<- nrow(snps[myfilter,])
	if(nsnps<500)
		{
		return(cat("Retained dataset contains less than 500 SNPs which have minor allele present in all populations. Skipping multi_assign2pop plot.",sep="\n"))
		}
	if(nsnps>500)
		{	
		nsnpvector=c(50,100,200,350,500)
		}
	if(nsnps>1000)
		{
		nsnpvector=c(50,100,200,500,1000)
		}
	if(nsnps>2000)
		{
		nsnpvector=c(50,100,500,1000,2000)
		}
	if(nsnps>5000)
		{
		nsnpvector=c(50,100,500,1000,5000)
		}
	if(!is.null(nsnp_vector))
		{
		nsnpvector=nsnp_vector
		}
	mysambar$nsnpallvector	<<- c(nsnpvector,nsnps)
	mysambar$popassignlist	<<-list()
	for(myrun in c(1:length(mysambar$nsnpallvector)))
		{
		nsubset	<- mysambar$nsnpallvector[myrun] 
		cat(paste(nsubset,"SNPs",sep=" "),sep="\n")
		if(myrun==length(mysambar$nsnpallvector))
			{
			if(any(!(paste("pr",mysambar$populations,sep="")%in%colnames(inds))))
				{
				assign2pop(top_popmafsd=top_popmaf_sd)
				}else{
				mysambar$myassign	<- 	inds[,paste("pr",mysambar$populations,sep="")]
				}
			}else{
			assign2pop(popnames=mysambar$populations,n_subset=nsubset,top_popmafsd=top_popmaf_sd)
			}
		mysambar$popassignlist[[myrun]]	<<- mysambar$myassign
		}
	names(mysambar$popassignlist)	<<- paste("nsnps",c(nsnpvector,nsnps),sep="_")
	# plot:
	multiplotassign(export=exporttype,top_popmafsd=top_popmaf_sd)
	}

multiplotassign<-function(mymatrixlist=mysambar$popassignlist,export=NULL,shortpop=NULL,popnames=mysambar$populations,addindnr=TRUE,mycol=mysambar$popassigncol,top_popmafsd=FALSE)
	{
	nsamples			<- nrow(inds[inds$filter,])
	nsets				<- length(mymatrixlist)
	#
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp		<- as.matrix(mygenlight)
	mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
	indstemp			<- inds[order(inds$pop),]
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	#
	if(!is.null(export))
		{
		myheight1	<- nsets*1.25+1.5
		myheight2	<- nsets*125+150
		mywidth1	<- nsamples*0.1+1.5
		mywidth2	<- nsamples*80+200
		indlabel	<- ifelse(addindnr,"indnr","noxaxis")
		maxsnps		<- names(mymatrixlist)[length(mymatrixlist)-1]
		maxsnps		<- ifelse(top_popmafsd,paste(maxsnps,"highestmafsd",sep="."),maxsnps)
		if(export=="eps"){postscript(paste("popassign.bayesian.multi",maxsnps,indlabel,"eps",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="pdf"){pdf(paste("popassign.bayesian.multi",maxsnps,indlabel,"pdf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		if(export=="png"){png(paste("popassign.bayesian.multi",maxsnps,indlabel,"png",sep="."),"Structureplot.LEA.indnr.png",family=mysambar$myfont,width=560,height=myheight2)}
		if(export=="wmf"){win.metafile(paste("popassign.bayesian.multi",maxsnps,indlabel,"wmf",sep="."),family=mysambar$myfont,width=8,height=myheight1)}
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# get info needed for plot:
	mylocs			<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mypops		<- indstemp$pop[indstemp$filter]
		mylocs[i]	<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs2		<- mylocs
	#
	mysets		<- c(1:nsets)
	par(mfrow=c(nsets,1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	for(myset in mysets)
		{
		#cat(myset,sep="\n")	
		qmatrix		<- mymatrixlist[[myset]]
		qmatrix		<- qmatrix[order(inds$pop),]
		qmatrix		<- qmatrix[indstemp$filter,]
		if(myset==nsets&&addindnr)
			{
			mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,ifelse(nsamples>300,0.1,0.25),0.35),0.5)
			barplot(t(qmatrix),col=mycol,border=NA,space=0,xlab="",ylab="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			}else{
			xpos	<- barplot(t(qmatrix),col=mycol,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=2)}
			if(myset==1)
				{
				if(length(popnames)>3)
					{
					# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
					mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
					if(mylas==1)
						{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)
						}else{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)	# 14-07-2019: can't work out adjustment to the right
						}
					}else{
					if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)}
					}
				}
			}
		mtext(paste(mysambar$nsnpallvector[myset],"snps",sep=""),side=4,line=-0.75,cex=1.25)
		}
	mtext("Assignment probability",side=2,line=-1.5,outer=TRUE,cex=1.75)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=1.75)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=1.75)
		}
	if(!is.null(export)){dev.off()}
	}

plotassign2pop<-function(export=NULL,bayesian=TRUE,popnames=mysambar$populations,shortpop=NULL,addsamplenr=TRUE,myinset=-0.15,mycol=mysambar$popassigncol,linecol="white",mylwd=3.5)
	{
	# count number of datapoints used in analysis:
	popmafs <- snps[,grep("maf_",colnames(snps))]
	mafmin	<- apply(popmafs,1,min)
	ndata	<- length(mafmin[mafmin>0&snps$filter])
	#
	# First create indstemp file with all samples clustered together per population:
	indstemp			<- inds[order(inds$pop),]
	nsamples			<- length(indstemp$name2[indstemp$filter])
	if(addsamplenr)
		{
		mylabels			<- indstemp$nr[indstemp$filter]
		}else{
		mylabels			<- rep("",nsamples)
		}
	myassign2			<- mysambar$myassign2[,order(inds$pop)]
	if(!bayesian)
		{
		myassign3		<- mysambar$myassign3[,order(inds$pop)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# get info needed for plot:
	mylocs	<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mypops		<- indstemp$pop[indstemp$filter]
		mylocs[i]	<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	mylocs		<- mylocs+1		# can not subset xpos with value 0
	npops		<- length(popnames)
	#
	# Now we are ready to plot:
	if(!is.null(export))
		{
		mywidth		<- nsamples*0.25+8
		mywidth2	<- nsamples*25+800
		myheight	<- ifelse(nsamples<80,6.5,mywidth/4)
		myheight2	<- 650
		plotname	<- ifelse(addsamplenr,paste("popassign.bayesian.withsamplenr",paste(ndata,"snps",sep=""),sep="."),paste("popassign.bayesian",paste(ndata,"snps",sep=""),sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}	
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	par(mar=c(4.5,8,5.5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(bayesian)
		{
		# plot bayesian probability:
		mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,0.75,1),1.5)
		xpos		<- barplot(myassign2[,indstemp$filter],ylab="",col=mycol,space=0,border=NA,names.arg=mylabels,cex.names=mycex,las=2)
		mtext("Bayesian probability",cex=3.5,side=2,line=5)
		if(length(popnames)>3)
			{
			mylocs		<- xpos[mylocs]
			mylocs		<- mylocs-mylocs[which(mylocs==min(mylocs))]		# because xpos gives midpoint of bars.
			abline(v=mylocs,lwd=mylwd,col=linecol)
			mylas		<- ifelse(any(table(indstemp$pop[indstemp$filter])<3),3,1)
			if(mylas==1)
				{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=3.5,las=mylas)
				}else{
				mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=3.5,las=mylas)
				}
			}else{
			mylocs		<- xpos[mylocs]
			mylocs		<- mylocs-mylocs[which(mylocs==min(mylocs))]		# because xpos gives midpoint of bars.
			if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=3.5)}
			if(length(popnames>1)){abline(v=mylocs,lwd=mylwd,col=linecol)}
			}
		}else{
		# plot counts: how many times a locus most likely to be drawn from population k:
		#barplot(myassign3[,indstemp$filter],ylab="",col=mycol,border=NA,legend=popnames,args.legend=list(x="topright",bty = "n",inset=c(-0.07,0),cex=2.25),names.arg=mylabels,cex.names=1.5,las=2)
		barplot(myassign3[,indstemp$filter],ylab="",col=mycol,border=NA,names.arg=mylabels,cex.names=1.5,las=2)
		mtext("Bayesian probability",cex=3,side=2,line=5)
		}
	if(!is.null(export)){dev.off()}
	}

plotstructure<-function(qmatrixlist=NULL,colourvector=NULL,plotname="Structureplot",ylabel=NULL,export=NULL,shortpop=NULL,popnames=mysambar$populations,poporder=NULL,addindnr=TRUE,order_on_longitude=FALSE)
	{
	# poporder does not work yet
	# input is either:
	# - name of list with qmatrices to qmatrixlist flag
	# - or txt files with qmatrices in inputfilesdir (if qmatrixlist is set to NULL (default) 
	if(is.null(qmatrixlist))
		{
		setwd(mysambar$inputfilesdir)
		cat("Searching for file names ending on 'qmatrix.txt' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		filenames 	<- list.files(pattern = ".*.qmatrix.txt")
		if(length(filenames)==0)
			{
			return(cat("ERROR: the directory does not contain files ending on 'qmatrix.txt'.",sep="\n"))
			}
		filenames2	<- gsub(".qmatrix.txt","",filenames)
		filenames2	<- sub(".*K","",filenames2)
		filenames	<- filenames[order(as.numeric(filenames2),decreasing=F)]
		qmatrixlist <- lapply(filenames,function(x)read.table(x,header=FALSE)) 
		}
	nmatrices	<- length(qmatrixlist) 
	nsamples	<- nrow(qmatrixlist[[1]])
	maxdemes	<- ncol(qmatrixlist[[1]])
	npops		<- length(popnames)
	mydemes		<- vector()
	#
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		}
	#
	for(i in 1:nmatrices)
		{
		mydemes[i]	<- ncol(qmatrixlist[[i]])
		}
	if(nsamples==nrow(inds))
		{
		cat("Number of samples in input file equals total number of individuals in inds dataframe.",sep="\n")
		cat("Sambar will assume that samples in input file have the same names are in the same order (i.e. alphabetical) as in inds$name column.",sep="\n")
		dofilter	<- FALSE		
		mysamples	<- inds$name
		}else{
		if(nsamples==nrow(inds[inds$filter,]))
			{	
			cat("Number of samples in input file equals total number of retained individuals in inds dataframe.",sep="\n")
			cat("Sambar will assume that samples in input file have the same names are in the same order as in inds$name[inds$filter] column.",sep="\n")
			dofilter	<- TRUE
			mysamples	<- inds$name[inds$filter]
			}else{
			return(cat("ERROR: Number of samples in input file does not correspond with (retained or total) number of individuals in inds dataframe.",sep="\n"))
			}
		}
	nsamples		<- nrow(inds[inds$filter,])
	if(!is.null(export))
		{
		myheight1	<- nmatrices*1.25+1.5
		myheight2	<- nmatrices*125+150
		if(addindnr)
			{
			mywidth1	<- nsamples*0.15+1.5
			mywidth2	<- nsamples*20+200
			}else{
			mywidth1	<- 8
			mywidth2	<- 560
			}
		orderlabel	<- ifelse(order_on_longitude,"geo","alphabet")
		indlabel	<- ifelse(addindnr,"indnr","noxaxis")
		if(export=="eps"){postscript(paste(plotname,orderlabel,indlabel,"eps",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}	# width=8
		if(export=="pdf"){pdf(paste(plotname,orderlabel,indlabel,"pdf",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		if(export=="png"){png(paste(plotname,orderlabel,indlabel,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,orderlabel,indlabel,"wmf",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		}
	if(is.null(colourvector))
		{	
		colourvector	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	if(maxdemes>length(colourvector))
		{
		cat("ERROR: maxdemes exceeds number of colours.",sep="\n")
		return(cat("Redefine the flag maxdemes or the flag colourvector. If running the findstructure() function, redefine the flag K_max or the flag colour_vector.",sep="\n"))
		}else{
		colourvector	<- colourvector[1:length(colourvector)]
		}
	if(is.null(shortpop))
		{
		shortpop		<- substr(popnames,1,2)
		if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
			{
			shortpop	<- substr(popnames,1,3)
			}
		}
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp		<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		if(is.null(poporder))
			{
			mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
			indstemp			<- inds[order(inds$pop),]
			}else{
			mymatrixtemp		<- mymatrixtemp[order(inds$poporder),]
			indstemp			<- inds[order(inds$poporder),]
			popnames			<- popnames[my_order]
			shortpop			<- shortpop[my_order]
			}
		}else{
		if("longitude3"%in%colnames(inds))
			{
			cat("Ordering based on longitude3...",sep="\n")
			popcoorddf			<- inds[,c("pop","longitude3","latitude")]
			}else{
			cat("Ordering based on longitude...",sep="\n")
			popcoorddf			<- inds[,c("pop","longitude","latitude")]
			}
		names(popcoorddf)	<- c("pop","longitude","latitude")
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop			<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$poplat[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		shortpop			<- shortpop[order(poplong$x)]
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	mygenlighttemp		<- as.genlight(mymatrixtemp)
	pop(mygenlighttemp)	<- as.factor(indstemp$pop)
	nsamples			<- nrow(indstemp[indstemp$filter,])
	# get info needed for plot:
	mylocs				<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop			<- popnames[i]
		mypops			<- indstemp$pop[indstemp$filter]
		mylocs[i]		<- which(mypops==mypop)[1]-1
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit black line of first population (because not necessary)
	#
	qmatrixorderlist	<- list()
	par(mfrow=c(length(mydemes),1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
	for(k in c(1:nmatrices))
		{
		ndemes		<- mydemes[k] 
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		qmatrix 	<- qmatrixlist[[k]]
		if(dofilter)
			{
			filteredinds<- inds[inds$filter,]
			if(!order_on_longitude)
				{
				if(!is.null(poporder))
					{
					qmatrix		<- qmatrix[order(filteredinds$poporder),]
					}else{
					qmatrix		<- qmatrix[order(filteredinds$pop),]
					}
				}else{
				qmatrix		<- qmatrix[order(filteredinds$poplong),]
				}
			}else{
			if(!order_on_longitude)
				{
				if(!is.null(poporder))
					{
					qmatrix		<- qmatrix[order(inds$poporder),]
					}else{
					qmatrix		<- qmatrix[order(inds$pop),]
					}
				}else{
				qmatrix		<- qmatrix[order(inds$poplong),]
				}
			}
		qmatrixorderlist[[k]]	<- qmatrix
		mycolours	<- colourvector[1:ndemes]
		if(k==nmatrices&&addindnr)
			{
			#mycex		<- ifelse(maxdemes<4,0.5,0.75)
			# mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,0.25,0.35),0.5)	# 28-01-2020
			mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,ifelse(nsamples>300,0.1,0.25),0.35),0.5)
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=1,col="white")}
			}else{
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=1,col="white")}
			}
		if(k==1)
			{
			if(length(popnames)>3)
				{
				# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
				mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
				if(mylas==1)
					{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)
					}else{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5,las=mylas)	# 14-07-2019: can't work out adjustment to the right
					}
				}else{
				if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)}
				}
			}
		mtext(paste("K = ",ndemes,sep=""),side=4,line=-0.75,cex=1.5)
		}
	ylabel	<- ifelse(is.null(ylabel),"Ancestry coefficients",paste("Ancestry coefficients",ylabel,sep=" "))
	mtext(ylabel,side=2,line=-1.5,outer=TRUE,cex=1.75)
	if(addindnr)
		{
		mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=1.75)
		}else{
		mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=1.75)
		}
	#
	#names(qmatrixlist)		<- paste("K",mydemes,sep="_")
	#mysambar$qmatrixlist	<<- qmatrixlist
	names(qmatrixorderlist)	<- paste("K",mydemes,sep="_")
	mysambar$qmatrixorderlist<<- qmatrixorderlist
	#
	if(!is.null(export))
		{
		dev.off()
		cat("Structure plot exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}	
		
plotassign2pop_hetero<-function(popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	mycolours	<- mysambar$mycolours[1:npops]
	#pdf("popassign.bayesian.vshetero.pdf",width=5,height=npops*1.25)
	pdf("popassign.bayesian.vshetero.pdf")
	par(cex.axis=1.5,cex.lab=2,mar=c(5,5,1,1))
	#par(mfrow=c(npops,1),mar=c(2,3.5,0.5,0.5),oma=c(2,1,1,1))
	#mymax		<- max(inds$hetero,na.rm=TRUE)
	#mymax		<- max(inds$maf,na.rm=TRUE)
	#mymax		<- max(inds$maf_all,na.rm=TRUE)
	#mymax		<- max(inds$n0,na.rm=TRUE)
	#mymax		<- max(inds$n1,na.rm=TRUE)
	#mymax		<- max(inds$n2,na.rm=TRUE)
	for (j in c(1:npops))
		{
		mypop	<- popnames[j]
		mypr	<- inds[,paste("pr",mypop,sep="")]
		#plot(inds$hetero[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$maf[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$maf_all[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n0[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n1[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		#plot(inds$n2[inds$pop==mypop],mypr[inds$pop==mypop],col=mycolours[j],las=1,ylim=c(0,1.05),ylab="",xlab="",pch=16,xlim=c(0,mymax))
		firstn	<- inds$n1/inds$nsites2
		secondn	<- inds$n2/inds$nsites2
		myxlim	<- c(min(firstn,na.rm=TRUE),max(firstn,na.rm=TRUE))
		myylim	<- c(0,max(secondn,na.rm=TRUE))
		if(j==1)
			{
			plot(firstn[inds$pop==mypop],secondn[inds$pop==mypop],col=mycolours[j],pch=16,cex=2,xlim=myxlim,ylim=myylim,ylab="Proportion minor homozygous sites",xlab="Proportion heterozygous sites")
			points(firstn[inds$pop==mypop&mypr<1],secondn[inds$pop==mypop&mypr<1],pch=17,cex=3,col=mycolours[j])
			}else{
			points(firstn[inds$pop==mypop],secondn[inds$pop==mypop],col=mycolours[j],pch=16,cex=2)
			points(firstn[inds$pop==mypop&mypr<1],secondn[inds$pop==mypop&mypr<1],pch=17,cex=3,col=mycolours[j])
			}
		}
	#mtext("Heterozygosity",side=1,outer=TRUE,line=0.5)
	#mtext("Bayesian probability",side=2,outer=TRUE,line=-0.75)
	legend("topright",legend=c("Pr==1","Pr<1"),pch=c(16,17),cex=2,bty='n')
	dev.off()
	}	

runLEA<-function(mindemes=2,maxdemes=6,mydemes=NULL,popnames=mysambar$populations,order_on_longitude=FALSE,focuspop=NULL,poporder=NULL,dolong3=FALSE,myploidy=2)
	{
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		cat("Expected population names:",sep="\n")
		cat(popnames,sep=", ")
		cat("",sep="\n")
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		inds$poporder	<- NA
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			inds$poporder[inds$pop==my_pop]	<- k  
			}
		}
	#inds	<<- inds
	#
	# Export data:
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp			<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		if(is.null(poporder))
			{
			mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
			indstemp			<- inds[order(inds$pop),]
			}else{
			mymatrixtemp		<- mymatrixtemp[order(inds$poporder),]
			indstemp			<- inds[order(inds$poporder),]
			popnames			<- popnames[my_order]
			}
		}else{
		if(any(inds$longitude<120,na.rm=TRUE)&any(inds$longitude>120,na.rm=TRUE))
			{
			cat("WARNING: whilst running runLEA function, samples observed close to -180 and 180 degrees longitude. using inds$longitude2 column to order on longitude.",sep="\n")
			if(dolong3)
				{
				popcoorddf			<- inds[,c("pop","longitude3","latitude")]		
				}else{
				popcoorddf			<- inds[,c("pop","longitude2","latitude")]
				}
			colnames(popcoorddf)<- c("pop","longitude","latitude")
			}else{
			popcoorddf			<- inds[,c("pop","longitude","latitude")]
			}
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop			<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$latlong[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(!is.null(focuspop))
		{
		mymatrixtemp		<- mymatrixtemp[indstemp$pop==focuspop,]
		indstemp			<- indstemp[indstemp$pop==focuspop,]
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		pop(mygenlighttemp)	<- as.factor(indstemp$pop2)
		}else{
		mygenlighttemp		<- as.genlight(mymatrixtemp)
		pop(mygenlighttemp)	<- as.factor(indstemp$pop)
		}
	genlight2ped(exportname="LEAinput",input=mygenlighttemp,in_inds=indstemp,indsfilter=indstemp$filter)
	#
	### LEA admixture analyses:
	# sambarfunction_findstructure:
	LEA_input		<- LEA::ped2geno("LEAinput.ped","LEAinput.geno")
	obj.snmf		<- LEA::snmf("LEAinput.geno",K=mindemes:maxdemes,ploidy=myploidy,entropy=T,alpha=100,project="new")
	mysambar$lea_CE	<<- summary(obj.snmf)$crossEntropy[1,] 
	#
	# Creating LEA matrices:
	if(is.null(mydemes))
		{
		mydemes			<- c(mindemes:maxdemes)
		}
	totalnr			<- length(mydemes)
	leaqmatrixlist	<- vector(mode="list",length=length(totalnr))
	for(mynr in c(1:totalnr))
		{
		ndemes		<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		# sambarfunction_findstructure:
		obj.snmf	<- LEA::snmf("LEAinput.geno", K = ndemes, alpha = 100, project = "new")
		# sambarfunction_findstructure:
		qmatrix 	<- LEA::Q(obj.snmf, K = ndemes)
		leaqmatrixlist[[mynr]]		<- qmatrix
		#
		# 09-06-2023: export matrix as txt file:
		qmatrix2			<- qmatrix
		rownames(qmatrix2)	<- indstemp$name[inds$filter]
		leamatrixname		<- paste("Structureplot.LEAqmatrix_K",ndemes,sep="")
		leamatrixname		<- ifelse(is.null(focuspop),paste(leamatrixname,"txt",sep="."),paste(leamatrixname,focuspop,"txt",sep="."))
		write.table(qmatrix2,leamatrixname,sep="\t",quote=FALSE,row.names=TRUE,col.names=FALSE)
		}
	names(leaqmatrixlist)	<- paste("K",mydemes,sep="_")
	if(order_on_longitude)
		{
		mysambar$leaqmatrixlist_longitude	<<- leaqmatrixlist
		}else{
		mysambar$leaqmatrixlist				<<- leaqmatrixlist
		}
	#
	# to subsequently create pca:
	# mypc = pca("LEAinput.geno", scale = TRUE)
	# plot(mypc$projections,col=indstemp$popcol[indstemp$filter],pch=16)
	# remove.pcaProject("LEAinput.pcaProject")
	# sambarfunction_findstructure:
	remove.snmfProject("LEAinput.snmfProject")
	# if function above doesn't work, delete directory and files like this:
	# sambarfunction_findstructure:
	unlink("LEAinput.snmf", recursive=TRUE)
	cat("Files with qmatrices have been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}

# function to plot cross-entropy score (which can be used to determine optimal K):
LEAceplot<-function(export=NULL,mindemes=2,maxdemes=6,plottitle=NULL)
	{
	# function to plot LEA crossEntropy scores
	# the corssEntropy scores are by the runLEA function and stored as:
	# mysambar$lea_CE	<<- summary(obj.snmf)$crossEntropy[1,]
	# The plot could also be generated with the command: plot(obj.snmf,col="blue4",cex=1.4,pch = 19)
	if(is.null(mysambar$lea_CE))
		{
		return(cat("ERROR: mysambar$lea_CE does not exist. This is not normally generated by the runLEA function, which is invoked by the findstructure function.",sep="\n"))
		}
	ce			<- mysambar$lea_CE
	mydemes		<- seq(mindemes,maxdemes)
	if(length(ce)!=length(mydemes))
		{
		return(cat("ERROR: length of mysambar$lea_CE does not agree with expected length based on mindemes and maxdemes.",sep="\n"))
		}
	names(ce)	<- mydemes
	plottitle	<- ifelse(is.null(plottitle),"Cross-entropy criterion",plottitle)
	#
	graphics.off()
	if(!is.null(export))
		{
		plotname	<- paste("Structureplot.LEA.crossentropy",paste("K",mindemes,"-",maxdemes,sep=""),sep=".")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=12,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=12,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=1200,height=800)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=12,height=8)}
		}
	par(mar=c(5,6,5,2),cex.axis=1.5,cex.lab=2,cex.main=2.5)
	plot(mydemes,ce,type='b',xlab="Number of ancestral populations (K)",ylab="Minimal cross-entropy",pch=16,cex=2)
	mtext(side=3,line=0.5,plottitle,cex=2.25)
	if(!is.null(export)){dev.off()}
	}

# 18-03-2022: function to calculate cross-entropy multiple times (in order to evaluate stochasticy):
LEAce<-function(min_demes=2,max_demes=12,nruns=50,runanalysis=TRUE,plottitle=NULL,export=NULL,plotwidth=8,plotcol="orange",leapoporder=mysambar$poporder)
	{
	ndemes				<- max_demes-min_demes+1
	mydemes				<- seq(min_demes,max_demes)
	if(runanalysis)
		{
		cedf				<- data.frame("K"=rep(mydemes,times=nruns),"ce"=NA)
		for(myrun in c(1:nruns))
			{
			runLEA(mindemes=min_demes,maxdemes=max_demes,popnames=mysambar$populations,order_on_longitude=FALSE,focuspop=NULL,poporder=leapoporder,dolong3=FALSE,myploidy=2)
			cedf$ce[((myrun-1)*ndemes+1):(myrun*ndemes)]	<- as.vector(mysambar$lea_CE)
			}
		mysambar$cedf		<<- cedf
		}else{
		if(is.null(mysambar$cedf))
			{
			return(cat("ERROR: mysambar$cedf does not exist. Rerun the LEAce function with the flag runanalysis set to TRUE. E.g.: LEAce(runanalysis=TRUE).",sep="\n"))
			}
		}
	cedf		<- mysambar$cedf
	plottitle	<- ifelse(is.null(plottitle),"Cross-entropy criterion",plottitle)
	#
	# boxplot:
	if(!is.null(export))
		{
		plotname	<- paste("Structureplot.LEA.crossentropy",paste("K",min_demes,"-",max_demes,sep=""),paste("nruns",nruns,sep=""),sep=".")
		if(export=="eps"){postscript(paste(plotname,sep="."),width=plotwidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=plotwidth,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=plotwidth*100,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=plotwidth,height=8)}
		}
	par(mar=c(5,5,5,0.5),cex.axis=1.5,cex.lab=2,cex.main=2.5)
	boxplot(cedf$ce~cedf$K,border="grey50",col="grey90",pch=16,outline=FALSE,ylab="Minimal cross-entropy",xlab="Number of ancestral populations")
	stripchart(ce~K,data=cedf,vertical=TRUE,method="jitter",pch=16,cex=1,col=plotcol,bg="bisque",add=TRUE)
	mtext(side=3,line=0.5,plottitle,cex=2.25)
	if(!is.null(export)){dev.off()}
	#
	# table:
	write.table(cedf,paste(plotname,"txt",sep="."),sep="\t",quote=FALSE,col.names=TRUE,row.names=FALSE)
	cat("Table with cross-entropy scores exported to directory:",sep="\n")
	cat(getwd(),sep="\n")
	#
	# ANOVA tests: significant difference of cross-validation scores between different K?
	cat("Plotting p-values...",sep="\n")
	LEAce_pvalue(mydf=mysambar$cedf,doplot=TRUE)
	}

LEAce_pvalue<-function(mydf=mysambar$cedf,doplot=TRUE,myround=3)
	{
	Kvec			<- unique(mydf$K)
	pmat			<- matrix(NA,length(Kvec),length(Kvec))
	colnames(pmat)	<- paste("K",Kvec,sep="=")
	rownames(pmat)	<- paste("K",Kvec,sep="=")
	for(i in c(1:length(Kvec)))
		{
		myK1	<- Kvec[i]
		#cat(myK1,sep="\n")
		for(j in c(1:length(Kvec)))
			{
			myK2		<- Kvec[j]
			#cat(myK2,sep="\n")
			mydf2		<- mydf[mydf$K==myK1|mydf$K==myK2,]
			myanova 	<- aov(ce~K,data=mydf2)
			pmat[i,j]	<- round(summary(myanova)[[1]][["Pr(>F)"]][1],myround)
			}
		}
	if(doplot)
		{
		cat("Plotting p-values...",sep="\n")
		plotname	<- paste("Structureplot.LEA.crossentropy",paste("K",min(Kvec),"-",max(Kvec),sep=""),"pvalues",sep=".")
		pdf(paste(plotname,"pdf",sep="."))
		myBreaks	<- c(0,0.05,1)
		myColours	<- c("white","darkorange")
		pmat2		<- pmat
		pmat2[lower.tri(pmat2,diag = FALSE)]	<- NA
		pmat2		<- round(pmat2,4)
		heatmap.2(pmat2,cellnote=pmat2,notecex=1,notecol="black",lhei=c(0.5,4),lwid=c(0.5,4),Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",
		cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
		mtext(side=3,"ANOVA p-values",line=1,cex=1.75)
		dev.off()
		cat("Plot with ANOVA p-values exported to directory:",sep="\n")
		cat(getwd(),sep="\n")	
		}
	}

# Note: input to poporder should be the same as for runLEA, otherwise output does not make sense.
LEAstructureplot<-function(mymatrixlist=NULL,mindemes=2,maxdemes=6,mydemes=NULL,side4labels=NULL,ylabel=NULL,addylabel=TRUE,mybg="white",axiscol="black",borderlwd=0.5,bordercol="white",heightfactor=0.75,widthfactor=NULL,focuspop=NULL,colourvector=NULL,dolabelcol=FALSE,export=NULL,exportname=NULL,shortpop=NULL,popnames=mysambar$populations,poporder=NULL,addindnr=TRUE,addindname=FALSE,order_on_longitude=FALSE,dolong3=FALSE,silent=TRUE,axiscex=1.5,axis4cex=1.5,labelcex=1.75,yaxiscex=1.25,shortpop_nrchars=3,uppermargin=6)
	{
	if(is.null(shortpop))
		{
		if(!silent){cat("WARNING: no input vector provided to shortpop flag.",sep="\n")}
		}
	# poporder should be a vector with all population names.
	if(!is.null(poporder))
		{
		cat("Redefining order of populations as specified by poporder flag.",sep="\n") 
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(length(poporder)!=length(popnames))
			{
			return(cat("ERROR: vector input to poporder argument is not the same length as vector input to popnames argument.",sep="\n"))
			}
		if(any(!poporder%in%popnames))
			{
			return(cat("ERROR: One or more population names listed in poporder vector are not present in popnames argument.",sep="\n"))
			}
		if(any(!popnames%in%poporder))
			{
			return(cat("ERROR: One or more population names listed in popnames vector are not present in poporder argument.",sep="\n"))
			}
		npops			<- length(poporder)
		my_order		<- vector()
		for (k in c(1:npops))
			{
			my_pop			<- poporder[k]
			my_order[k]		<- which(popnames==my_pop)
			}
		}
	if(any(is.na(popnames)))
		{
		return(cat("ERROR: NA-value in popnames vector.",sep="\n"))
		}
	if(is.null(mymatrixlist))
		{
		if(order_on_longitude)
			{
			leaqmatrixlist	<- mysambar$leaqmatrixlist_longitude
			}else{
			leaqmatrixlist	<- mysambar$leaqmatrixlist
			}
		}else{
		leaqmatrixlist		<- mymatrixlist
		}
	if(is.null(mydemes))
		{
		nexpected		<- (maxdemes-mindemes+1)
		}else{
		nexpected		<- length(mydemes)
		}
	nobserved		<- length(leaqmatrixlist)
	if(nobserved!=nexpected)
		{
		return(cat(paste("ERROR: length of input qmatrix list (",nobserved,") does not equal expected length based on input to mindemes and maxdemes flags (",nexpected,").",sep=""),sep="\n"))
		}
	nsamples		<- nrow(inds[inds$filter,])
	#
	# First create indstemp file with all samples clustered together per population:
	mymatrixtemp			<- as.matrix(mygenlight)
	if(!order_on_longitude)
		{
		if(is.null(poporder))
			{
			#cat("Ordering based on poporder input...",sep="\n")
			mymatrixtemp		<- mymatrixtemp[order(inds$pop),]
			indstemp			<- inds[order(inds$pop),]
			}else{
			#cat("Not reordering.",sep="\n")
			inds$leaorder		<<- factor(inds$pop,levels=poporder)
			mymatrixtemp		<- mymatrixtemp[order(inds$leaorder),]
			indstemp			<- inds[order(inds$leaorder),]
			popnames			<- popnames[my_order]
			# 20-01-2023: lines below replaced with lines above
			#mymatrixtemp		<- mymatrixtemp[order(inds$poporder),]
			#indstemp			<- inds[order(inds$poporder),]
			#popnames			<- popnames[my_order]
			}
		}else{
		#cat("Ordering on longitude...",sep="\n")
		if(any(inds$longitude<120,na.rm=TRUE)&any(inds$longitude>120,na.rm=TRUE))
			{
			cat("WARNING: samples observed close to -180 and 180 degrees longitude. using inds$longitude2 column to order on longitude.",sep="\n")
			if(dolong3)
				{
				popcoorddf		<- inds[inds$filter,c("pop","longitude3","latitude")]		
				}else{
				popcoorddf		<- inds[inds$filter,c("pop","longitude2","latitude")]
				}
			colnames(popcoorddf)<- c("pop","longitude","latitude")
			}else{
			popcoorddf			<- inds[,c("pop","longitude","latitude")]
			}
		poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean, na.rm=TRUE)
		poplongtemp			<<- poplong
		inds$poplong		<<- NA
		inds$poplat			<<- NA
		for(j in c(1:nrow(poplong)))
			{
			mypop							<- poplong$Group.1[j]
			inds$poplong[inds$pop==mypop]	<<- poplong$x[j]
			inds$latlong[inds$pop==mypop]	<<- poplat$x[j]
			}
		mymatrixtemp		<- mymatrixtemp[order(inds$poplong),]
		indstemp			<- inds[order(inds$poplong),]
		popnames			<- popnames[order(poplong$x)]
		#shortpop			<- shortpop[order(poplong$x)]
		}
	if(any(is.na(popnames)))
		{
		return(cat("ERROR: after reordering, NA-value in popnames vector.",sep="\n"))
		}
	if(any(!row.names(mymatrixtemp)==as.vector(indstemp$name)))
		{
		return(cat("ERROR: after reordering (clustering per sample) rownames of mymatrixtemp do not correspond with indstemp$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(!is.null(focuspop))
		{
		mymatrixtemp		<- mymatrixtemp[indstemp$pop==focuspop,]
		indstemp			<- indstemp[indstemp$pop==focuspop,]
		myindpops			<- indstemp$pop2
		}else{
		myindpops			<- indstemp$pop		
		}
	#
	ndemes				<- maxdemes-mindemes
	if(!is.null(export))
		{
		if(!is.null(widthfactor))
			{
			widthfactor2	<- 100*widthfactor
			mywidth1		<- nsamples*widthfactor+1.5
			mywidth2		<- nsamples*widthfactor2+200
			}else{
			mywidth1		<- 8
			mywidth2		<- 800
			}
		heightfactor2	<- 100*heightfactor
		myheight1		<- (ndemes+1)*heightfactor+1.5
		myheight2		<- (ndemes+1)*heightfactor2+150
		orderlabel		<- ifelse(order_on_longitude,"geo","poporder")
		indlabel		<- ifelse(addindnr,ifelse(addindname,"indname","indnr"),"noxaxis")
		poplabel		<- ifelse(is.null(focuspop),"metapop",focuspop)
		exportname		<- ifelse(is.null(exportname),"Structureplot.LEA",paste(exportname,"structureplot.LEA",sep="."))
		collabel		<- ifelse(dolabelcol,"col","black")
		if(export=="eps"){postscript(paste(exportname,poplabel,orderlabel,indlabel,collabel,shortpop_nrchars,"eps",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		if(export=="pdf"){pdf(paste(exportname,poplabel,orderlabel,indlabel,collabel,shortpop_nrchars,"pdf",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		if(export=="png"){png(paste(exportname,poplabel,orderlabel,indlabel,collabel,shortpop_nrchars,"png",sep="."),"Structureplot.LEA.indnr.png",family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(exportname,poplabel,orderlabel,indlabel,collabel,shortpop_nrchars,"wmf",sep="."),family=mysambar$myfont,width=mywidth1,height=myheight1)}
		}
	if(is.null(colourvector))
		{
		colourvector	<- mysambar$mycolours
		}
	if(length(colourvector)<maxdemes)
		{
		sambarcolours	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		colourtemp		<- colourvector
		colourvector	<- c(colourtemp,sambarcolours[!sambarcolours%in%colourtemp])
		if(length(colourvector)<maxdemes){cat("WARNING: maxdemes exceeds number of colours.",sep="\n")} 
		}
	if(ndemes>length(colourvector))
		{
		cat("ERROR: maxdemes exceeds number of colours.",sep="\n")
		return(cat("Redefine the flag maxdemes or the flag colourvector. If running the findstructure() function, redefine the flag K_max or the flag colour_vector.",sep="\n"))
		}else{
		colourvector	<- colourvector[1:length(colourvector)]
		}
	if(is.null(shortpop))
		{
		# originally: only 2 characters, unless more needed to discriminate
		#shortpop		<- substr(popnames,1,2)
		#if(length(as.vector(unique(shortpop)))<length(shortpop))	# if two more populations with same first two letters
		#	{
		#	shortpop	<- substr(popnames,1,shortpop_nrchars)
		#	}
		shortpop	<- substr(popnames,1,shortpop_nrchars)
		}
	nsamples		<- nrow(indstemp[indstemp$filter,])
	# get info needed for plot:
	mylocs			<- vector()
	mypopcols		<- vector()
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		if(!silent){cat(mypop,sep="\n")}
		#mypops		<- indstemp$pop[indstemp$filter]
		mypops		<- myindpops[indstemp$filter]
		mylocs[i]	<- as.vector(which(mypops==mypop)[1]-1)
		if(length(which(mysambar$populations2==mypop))==0)
			{
			return(cat(paste("ERROR: population ",mypop," not present in mysambar$populations2.",sep=""),sep="\n"))
			}
		mypopcols[i]<- mysambar$mycolours2[which(mysambar$populations2==mypop)]
		}
	if(!dolabelcol)
		{
		mypopcols	<- rep("black",length(mypopcols))
		}
	mylocs2		<- mylocs		# I should come up here with a way to omit seperation line of first population (because not necessary)
	#mylocs2	<<- mylocs
	#
	if(is.null(mydemes))
		{
		mydemes	<- c(mindemes:maxdemes)
		}
	totalnr		<- length(mydemes)
	par(mfrow=c(length(mydemes),1),mar=c(0.5,5,0.5,0.5),oma=c(4,1,uppermargin,1),cex.axis=yaxiscex,cex.lab=2.5,cex.main=2.5,bg=mybg,col=axiscol,col.axis=axiscol,col.lab=axiscol,col.main=axiscol)
	#for(ndemes in mydemes)
	for(mynr in c(1:totalnr))
		{
		ndemes		<- mydemes[mynr]
		cat(paste("K = ",ndemes,sep=""), sep ="\n")	
		#qmatrix	<- leaqmatrixlist[[ndemes-1]]
		qmatrix		<- leaqmatrixlist[[mynr]]
		rownames(qmatrix)	<- NULL				# added on 17-08-2021 (if rownames are present, they appear in plot)
		mycolours	<- colourvector[1:ndemes]
		#if(ndemes==maxdemes&&addindnr)
		if(mynr==totalnr&&addindnr)
			{
			#mycex		<- ifelse(maxdemes<4,0.5,0.75)
			mycex		<- ifelse(nsamples>100,ifelse(nsamples>200,ifelse(nsamples>300,0.1,0.25),0.35),0.5)
			if(addindname)
				{
				barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$name[indstemp$filter],cex.names=mycex,las=2)
				}else{
				barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",names.arg=indstemp$nr[indstemp$filter],cex.names=mycex,las=2)
				}
			if(length(popnames>1)){abline(v=mylocs2,lwd=borderlwd,col=bordercol)}
			}else{
			barplot(t(qmatrix),col=mycolours,border=NA,space=0,xlab="",ylab ="",las=2)
			if(length(popnames>1)){abline(v=mylocs2,lwd=borderlwd,col=bordercol)}
			#if(ndemes==mindemes)
			if(mynr==1)
				{
				if(length(popnames)>3)
					{
					# las options: parallel to axis (0, default), horizontal (1), perpendicular (2), vertical (3).
					#mylas	<- ifelse(any(table(indstemp$pop[indstemp$filter])<6),3,1)
					mylas	<- ifelse(any(table(myindpops[indstemp$filter])<6),3,1)
					if(mylas==1)
						{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=axiscex,las=mylas,col=mypopcols)
						}else{
						mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=axiscex,las=mylas,col=mypopcols)	# 14-07-2019: can't work out adjustment to the right
						}
					}else{
					if(length(popnames>1)){mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=axiscex)}
					}
				}
			}
		if(is.null(side4labels))
			{
			mtext(paste("K = ",ndemes,sep=""),side=4,line=-0.75,cex=axis4cex)
			}else{
			mtext(side4labels[mynr],side=4,line=-0.75,cex=axis4cex)
			}
		}
	if(addylabel)
		{
		ylabel	<- ifelse(is.null(ylabel),"Ancestry coefficients",paste("Ancestry coefficients",ylabel,sep=" "))
		mtext(ylabel,side=2,line=-1.5,outer=TRUE,cex=labelcex)
		}
	if(!addindname)
		{
		if(addindnr)
			{
			mtext("Individuals",side=1,line=2.5,outer=TRUE,cex=labelcex)
			}else{
			mtext("Individuals",side=1,line=1.5,outer=TRUE,cex=labelcex)
			}
		}
	if(!is.null(export)){dev.off()}
	}

# End of population structure analyses 
###############################################################################################################








###############################################################################################################
# Geographic maps

# Function to create geographic maps:
createmaps<-function(K_max=6,radius_ratio=30,perc_vector=c(20,40,60,80,95),calcbic=TRUE,shapeprefix=NULL,my_bg="white",axis_col="black",dotess=TRUE,dolea=TRUE,dodapc=TRUE,domst=TRUE,domantel=TRUE,plot_per_pop=FALSE,marine_data=FALSE,adjust_ratio=1,symbolsize=3,colour_df=NULL,my_tree=NULL,distdf=NULL,thres_vec=NULL)
	{
	# 23-06-2022: still to be added: options to set background colour (mybg) and box colour of output plots 
	# radius_ratio is the ratio between radius of piechart and the range of either longitude or latitude (i.e. smallest of the two)
	# e.g.: 30 means 1/30th.
	if((!"latitude"%in%colnames(inds))|(!"longitude" %in% colnames(inds)))
		{
		cat("ERROR: Longitude and/or latitude column are absent in inds dataframe.",sep="\n")
		return(cat("Impossible to generate geographical maps.",sep="\n"))
		}
	if(any(is.na(inds$longitude[inds$filter]))|any(is.na(inds$latitude[inds$filter])))
		{
		cat("No missing values allowed in longitude and latitude column.",sep="\n")
		return(cat("SambaR will not create geographical maps. If wanted, you can use the addgeofile() function to update the inds$latitude and inds$longitude column.",sep="\n"))
		}
	if(!"longitude2"%in%colnames(inds))
		{
		# pacific or atlantic centred map?
		inds$longitude2			<<- ifelse(inds$longitude>=0,inds$longitude,abs(inds$longitude)+180)
		}
	if(!"longitude3"%in%colnames(inds))
		{
		# pacific or atlantic centred map?
		inds$longitude3			<<- ifelse(inds$longitude>=-15,inds$longitude,180+(180-abs(inds$longitude)))
		}
	if(!"geomapsdir" %in% (names(mysambar)))
		{
		geomapsdir				<- paste(mysambar$sambardir,"Maps",sep="/")
		nelements				<- length(mysambar)
		mysambar$geomapsdir		<<- geomapsdir
		}else{
		if(is.null(mysambar$geomapsdir))
			{
			geomapsdir			<- paste(mysambar$sambardir,"Maps",sep="/")
			nelements			<- length(mysambar)
			mysambar$geomapsdir	<<- geomapsdir
			}
		}
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	if(!file.exists(mysambar$geomapsdir)){dir.create(file.path(mysambar$geomapsdir))}
	cat("Setting directory to:",sep="\n")
	cat(mysambar$geomapsdir,sep="\n")
	setwd(mysambar$geomapsdir)
	#
	# SAMPLE LOCATIONS:
	cat("Plotting location of samples using R package Rworldmap...",sep="\n")
	plotlocations(export="pdf",addaxislabels=FALSE,adjustratio=adjust_ratio,mycex=symbolsize,mydeviation=NULL)
	plotlocations(export="pdf",addaxislabels=TRUE,adjustratio=adjust_ratio,mycex=1,mydeviation=1)
	cat("Plotting location of samples using R package maps...",sep="\n")
	#plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=symbolsize,dolabels=FALSE,showborders=FALSE)
	plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1,dolabels=TRUE,showborders=TRUE)
	plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=symbolsize,dolabels=FALSE,showborders=TRUE)
	#plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1.25,dolabels=TRUE,showborders=FALSE)
	#
	if(!is.null(shapeprefix))
		{
		# install and load additional packages:
		getshapepg()
		# load shape file:
		# Expects to find shape files in the inputdatadir.
		cat("Searching for input shape files in directory:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		for(mysuffix in c("cpg","dbf","prj","shp","shx"))
			{
			if(!file.exists(paste(mysambar$inputdatadir,paste(shapeprefix,mysuffix,sep="."),sep="/")))
				{
				return(cat(paste("ERROR: ",mysuffix,"-file not found.",sep=""),sep="\n"))
				}
			}
		cat("Loading shape file...",sep="\n")			
		getsingleshape(myprefix=shapeprefix,mydir=mysambar$inputdatadir)
		# correct coordinates to allow to recentre map:
		shiftranges(longthreshold=15)
		# create dataframes mygeocoord and mygeocols)
		plotlocations2(export="pdf",addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,my_pch=NULL,mycex=1,dolabels=TRUE,showborders=TRUE)
		# plot sample locations with current species range map:
		# note, you first need to have run the functions getsingle, shifranges and the SambaR function 'plotlocations2' (the latter in order to create mygeocoord and mygeocols needed for this function):
		mapsingleshape(plotratios=1.8,export="pdf",mybg=my_bg,boxcol=axis_col,myfilter=mydata$LEGEND!="Extinct",mycolours="grey60",transparency_level=0.5,mycoord=mysambar$geocoord,mycoordcol=mysambar$geocols,mycex=2,showborders=FALSE,mylegend=c("historic range","present range"),legendcex=1.25)
		}
	#
	# MAKE CLADES:
	if(calcbic)
		{
		cat("Calculating BIC-values per K...",sep="\n")
		run_find.clusters_bic(maxK=20,percvector=perc_vector,niter=1000)
		}
	cat("Plotting clusters delineated by find.clusters() function...",sep="\n")
	for(mypercvalue in perc_vector)
		{
		cat(paste("Explained percentage: ",mypercvalue,".",sep=""),sep="\n")
		run_find.clusters(mygeno=mygenlight,indsfilter=inds$filter,doexport=TRUE,maxK=20,myperc=mypercvalue,plotsize=10,niter=100,mycoord=NULL,myfactor=2,mycex=0.75,exportname="Myclusters",dolabels=FALSE)
		}
	if(!is.null(distdf)&!is.null(thres_vec))
		{
		# Alternative function to find.clusters. Uses cut-off distance values to delineate clusters.
		# Cut-off distance values needs to be determined:
		cat("Plotting clusters based on cut-off values...",sep="\n")
		runfindclusters(my_df=distdf,dropvec=NULL,thresvec=thres_vec,mypchs=c(21,25,22,24,23,8),mycolours=NULL,do_tmrca=TRUE)	
		# generate hierarchical cluster colours  using colour tones:
		# getcladecol(cladevec=inds$clade,subcladevec=inds$subclade,lightby=0.4,darkby=0.2)
		}
	# DENDROGRAM WITH HIGHLIGHTED CLADES:
	if(!is.null(colour_df)&is.null(my_tree))
		{
		cat("Highlighting clusters in dendrogram using ggtree...",sep="\n")
		plotcladetree(mytree=mysambar$mytree,colourdf=NULL,exportname="mytree")
		#
		# alternatively add annotation bars: 
		# anndf			<- inds[inds$filter,c("name","clade","cladecol")]
		# colnames(anndf)	<- c("name","clade","col")
		# getindtree(ann_df=anndf,plotname="Tree_clades",inputnewickfile="RAxML_bestTree.bootstrap100",makelinear=TRUE,genomeprop=0.00628067,drop_ind=dropvec,ann_legendpos="bottomleft",axiscex=1.5,mutrate=1.3*10^-9,myrect=c(18000,30000,95000,98000),rectcol=c("grey70","grey70"),export="pdf",do_analysis=FALSE,mytype="phylogram",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=1.5,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,fullplotname=FALSE,calc_parsimony=FALSE,calc_likelihood=FALSE)
		# getindtree(ann_df=anndf,plotname="Tree_clades",inputnewickfile="RAxML_bestTree.bootstrap100",makelinear=TRUE,genomeprop=0.00628067,drop_ind=dropvec,ann_legendpos="bottomleft",axiscex=1.5,mutrate=1.3*10^-9,myrect=c(18000,30000,95000,98000),rectcol=c("grey70","grey70"),export="pdf",do_analysis=FALSE,mytype="phylogram",labelangle="axial",labelcex=1.25,edgecolors=TRUE,tiplabels=TRUE,mylwd=1.5,addnodelabels=FALSE,maxnodelabel=100,nodelabelcex=1.5,showpop=FALSE,fullplotname=FALSE,calc_parsimony=FALSE,calc_likelihood=FALSE)
		}
	#
	# PIECHARTS LEA:		
	if(!is.null(mysambar$leaqmatrixlist)&dolea)
		{
		cat("Creating geographical maps with admixture piecharts using LEA output...",sep="\n")
		cat("If you receive an error shortly after this line, set the flag dolea to FALSE.",sep="\n")
		mymaxK	<- length(mysambar$leaqmatrixlist)+1
		if(mymaxK<K_max)
			{
			cat(paste("Warning: K_max is set to",K_max,"but currently data available for a maximum K of",mymaxK,sep=" "),sep="\n")
			cat("If desired, rerun the findstructure() function with a higher Kmax value.",sep="\n")
			cat(paste("Creating plots now for K = 2 to K =",mymaxK,sep=" "),sep="\n")
			maplea(maxdemes=mymaxK,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
			maplea(maxdemes=mymaxK,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
			}else{
			maplea(maxdemes=K_max,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
			maplea(maxdemes=K_max,radiusratio=radius_ratio,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
			}
		}else{
		cat("Could not find object called mysambar$leaqmatrixlist. Run the findstructure() function and try again.",sep="\n")
		}
	# PIECHARTS DAPC:
	if(!is.null(mysambar$dapcqmatrixlist)&dodapc)
		{
		cat("Creating geographical maps with admixture piecharts using DAPC output...",sep="\n")
		cat("If you receive an error shortly after this line, set the flag dodapc to FALSE.",sep="\n")
		mymaxK	<- length(mysambar$dapcqmatrixlist)+1
		if(mymaxK<K_max)
			{
			cat(paste("Warning: K_max is set to",K_max,"but currently data for available for a maximum K of",mymaxK,sep=" "),sep="\n")
			cat("If desired, rerun the findstructure() function with a higher Kmax value.",sep="\n")
			cat(paste("Creating plots now for K = 2 to K =",mymaxK,sep=" "),sep="\n")
			mapdapc(maxdemes=mymaxK,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
			mapdapc(maxdemes=mymaxK,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
			}else{
			mapdapc(maxdemes=K_max,exporttype="pdf",plotperpop=plot_per_pop,addlabels=TRUE)
			mapdapc(maxdemes=K_max,exporttype="pdf",plotperpop=plot_per_pop,addlabels=FALSE)
			}
		}else{
		cat("Object 'dapcqmatrixlist' not present in mysambar list. Run the findstructure() function and try again.",sep="\n")
		}
	# TESS:
	if(dotess)
		{
		cat("Creating Tessellation plots...",sep="\n")
		cat("If you receive an error shortly after this line, set the flag dotess to FALSE.",sep="\n")
		# map tess qmatrix:
		runtess3(export="pdf",myrepos='http://cran.us.r-project.org',maxK=K_max)
		maptess(use_lea=FALSE,mydemes=c(2:K_max),export="pdf",multiplot=FALSE,marine=marine_data)
		maptess(use_lea=FALSE,mydemes=c(2:5),export="pdf",multiplot=TRUE,marine=marine_data)
		# barplot tess:
		tesslist<-list()
		for(ndemes in c(2:(K_max)))	
			{
			tesslist[[ndemes-1]] 	<- qmatrix(tessout,K=ndemes)
			}
		plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=TRUE,order_on_longitude=FALSE)
		plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=TRUE,order_on_longitude=TRUE)
		plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=FALSE,order_on_longitude=FALSE)
		plotstructure(qmatrixlist=tesslist,export="pdf",plotname="TESS.structureplot",addindnr=FALSE,order_on_longitude=TRUE)
		}
	if(dolea)
		{
		# map LEA qmatrix
		cat("Creating Tessellation plots using LEA ancestry matrix as input...",sep="\n")
		cat("If you receive an error shortly after his line, rerun the  createmaps function with the flag 'dolea' set to FALSE.",sep="\n")
		maptess(use_lea=TRUE,mydemes=c(2:K_max),export="pdf",multiplot=FALSE,marine=marine_data)
		maptess(use_lea=TRUE,mydemes=c(2:5),export="pdf",multiplot=TRUE,marine=marine_data)
		}
	# MANTEL PLOTS:
	if(domantel)
		{
		if("d3"%in%colnames(inds2))
			{
			cat("If you receive an error shortly after this line, set the flag domantel to FALSE.",sep="\n")
			pops2scatter(legendcex=1,export="pdf")
			if(!"fst"%in%colnames(pops2))
				{
				hudsonfst()			
				}
			popfstmantel(logaxis="x",export="pdf")
			}else{
			cat("Mantel plots currently not included.",sep="\n")
			# 22-06-2022: still need to update pops2scatter and popfstmantel, to accept input scores other than generated by vcf_calcdist function.
			#cat("Creating mantel plot...",sep="\n")
			#multi_mantel_plot(popnames=mysambar$populations,doexport=TRUE)
			}
		}
	# NETWORK:
	# if(do_network)
	#	{	
	#	# 01-10-2019: not insightful, therefore by default not included
	#	cat("Generating genotype network...",sep="\n")	
	#	cat("If you receive whilst an error after this line, set the flag 'do_network' to FALSE.",sep="\n")
	#	if(nrow(snps[snps$filter,])>1000)	# if less than 1000 loci, no need to sample, and therefore no stochastic element, so no need to run analysis multiple times to see general behaviour
	#		{
	#		haplonetworks(nplots=5)
	#		}else{
	#		haplonetworks(nplots=1)
	#		}
	if(domst)
		{
		cat("Generating geographic maps with minimum spanning networks...",sep="\n")
		cat("If you receive an error shortly after this line, set the flag 'domst' to FALSE.",sep="\n")
		# minimum spanning network:
		if(is.null(mysambar$indneimatrix))
			{
			ind_neimatrix()
			}
		msntree(mymat=mysambar$indneimatrix,exporttype="pdf",exportprefix="NeiD")
		msntree(mymat=NULL,exporttype="pdf",my_distance="euclidean")
		msntree(mymat=NULL,exporttype="pdf",my_distance="pi")
		msntree(mymat=NULL,exporttype="pdf",my_distance="bitwise.dist")
		# very messy network:
		#if("d"%in%colnames(inds2))
		#	{
		#	rawdistancemat	<- df2mat(myscore="d",doheatmap=TRUE,twosided=FALSE)
		#	msnnetwork(mymat=rawdistancemat,exporttype="pdf",exportprefix="RawGeneticDistance")
		#	}
		}
	cat("Files have been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	setwd(mysambar$inputdatadir)
	}

msntree<-function(mymat=NULL,exporttype=NULL,exportprefix=NULL,my_distance="euclidean")
	{
	if(is.null(exportprefix))
		{
		if(my_distance=="euclidean"){exportprefix="EuclideanD"}
		if(my_distance=="pi"){exportprefix="AlleleSharingDistance"}
		if(my_distance=="bitwise.dist"){exportprefix="HammingDistance"}
		}
	if(is.null(mymat))
		{
		cat("Generating distance matrix...",sep="\n")
		getindtree(export=NULL,dopathlength=FALSE,do_analysis=TRUE,mytype="unrooted",mydistance=my_distance,mymethod="bionj",calc_parsimony=FALSE,calc_likelihood=FALSE)
		mymat	<- mysambar$mytree_distmat
		}
	if(is.null(mymat))
		{
		return(cat("ERROR: specify an existing matrix to the mymat flag, or else set flag to NULL.",sep="\n"))
		}
	if(is.matrix(mymat))
		{
		if(all(is.na(mymat[lower.tri(mymat)])))
			{
			cat("Transposing and converting matrix to a dist object...",sep="\n")
			tmat		<- t(mymat) 
			distmat 	<- dist(tmat)
			}else{
			cat("Converting matrix to a dist object...",sep="\n")
			distmat		<- dist(mymat)
			}
		}else{
		if(!class(mymat)=="dist")
			{
			return(cat("ERROR: object specified to mymatrix flag is not a matrix.",sep="\n"))
			}else{
			cat("Input matrix is a dist object.",sep="\n")
			distmat			<- mymat
			}
		}
	cat("Running minimum spanning tree analyses...",sep="\n")	
	#PC 	<- prcomp(distmat)
	M 		<- mst(distmat)
	distmat	<<- distmat
	M		<<- M
	plotlocations2(export=exporttype,msnmatrix=M,exportname=exportprefix)
	#
	# opar <- par(mfcol = c(2, 2))
	# plot(M,graph="nsca",show.mutation=0)
	# library(igraph)
	# gr4ph <-  graph.adjacency(mymst, mode = "undirected",weight=TRUE)
	}

# create map using Rworldmap
plotlocations<-function(export=NULL,dolabels=FALSE,mygeodf=NULL,mygeofile=NULL,adjustratio=1,addlegend=FALSE,exportname="sample_locations",mytitle=NULL,mytitle2=NULL,silent=TRUE,margin=0.1,addaxislabels=FALSE,my_pch=NULL,my_col=NULL,mycex=3,mydeviation=NULL)
	{
	# mygeodf should be a dataframe with at least the columns 'longitude' and 'latitude'
	# mygeofile should be a tab separated txt file with at least the columns 'longitude' and 'latitude'
	mycols			<- NULL
	if(is.null(mygeodf)&is.null(mygeofile))
		{
		cat("Flags 'mygeodf' and 'mygeofile' set to NULL (default). Assuming to find within inds dataframe columns called 'longitude' and 'latitude'.",sep="\n")
		if(!"longitude"%in%colnames(inds)|!"latitude"%in%colnames(inds))
			{
			return(cat("Columns 'longitude' and 'latitude' not present in inds dataframe.",sep="\n"))
			}
		coord		<- inds[inds$filter,c("longitude","latitude")]
		mycols		<- inds$popcol[inds$filter]
		}else{
		if(!is.null(mygeofile))
			{
			mygeo		<- read.table(mygeofile,header=TRUE,sep="\t")
			}else{
			mygeo		<- mygeodf
			}
		coord		<- mygeo[,c("longitude","latitude")]
		}
	if(is.null(my_col))
		{
		if(is.null(mycols))
			{
			mycols		<- rep("black",nrow(coord))
			}
		}else{
		mycols		<- as.character(my_col)
		}
	if(is.null(my_pch))
		{
		mypch		<- 19
		}else{
		mypch		<- my_pch
		}
	if(is.factor(coord$latitude))
		{
		coord$latitude	<-  as.numeric(sub(",",".",as.character(coord$latitude)))
		}
	if(is.factor(coord$longitude))
		{
		coord$longitude	<-  as.numeric(sub(",",".",as.character(coord$longitude)))
		}
	cat("Matrix with geographical coordinates has been stored under the name 'mysambar$geocoord'.",sep="\n")
	mysambar$geocoord		<<- coord
	mygeocoord				<<- coord	# still needed?
	if(!is.null(mydeviation))
		{
		if(is.null(mygeodf)&is.null(mygeofile))
			{
			indstemp	<- inds[inds$filter,]
			if(!"do_coordshuffle"%in%colnames(inds))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent from inds dataframe. Shuffling all data points.",sep="\n")
				indstemp$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}else{
			if(!"do_coordshuffle"%in%colnames(mygeo))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent in mygeo. Shuffling all data points.",sep="\n")
				mygeo$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}
		}
	if("rworldmap"%in%(.packages()) == FALSE){library(rworldmap)}
	newmap 		<- getMap(resolution = "low")
	myratio		<- (max(coord$longitude,na.rm=TRUE)-min(coord$longitude,na.rm=TRUE))/(max(coord$latitude,na.rm=TRUE)-min(coord$latitude,na.rm=TRUE))
	if(!is.null(export))
		{
		plotname		<- ifelse(addaxislabels,paste(exportname,"withaxes",sep="."),paste(exportname,"no_axes",sep="."))
		adjustlabel		<- paste("ratio",adjustratio,sep="")
		deviationlabel	<- ifelse(is.null(mydeviation),"exactlocation","withdeviation")
		if(myratio<1)
			{
			if(export=="pdf"){pdf(paste(plotname,adjustlabel,deviationlabel,"Rworldmap.pdf",sep="."),height=adjustratio*8/myratio,width=6)}
			}else{
			if(export=="pdf"){pdf(paste(plotname,adjustlabel,deviationlabel,"Rworldmap.pdf",sep="."),height=8,width=adjustratio*6*myratio)}
			}
		if(!silent){cat(paste("Writing pdf file called:", exportname,sep=" "),sep="\n")}
		}
	if(addaxislabels)
		{
		par(cex.axis=1.5,oma=c(1,2,0.5,0.5))
		plot(coord,xlab="",ylab="",type="n",las=1,col="white")
		}else{
		plot(coord,xlab="",ylab="",type="n",las=1,xaxt='n',yaxt='n',col="white")
		}
	plot(newmap,add=T,col="grey70",border="white")
	if(dolabels)
		{
		text(coord,indstemp$name,col=mycols,cex=mycex,pch=mypch)
		}else{
		points(coord,col=mycols,cex=mycex,pch=mypch)
		}
	box(col="grey70")
	if(addaxislabels)
		{
		mtext("Longitude",side=1,line=3,cex=2)
		mtext("Latitude",side=2,line=4,cex=2)
		}
	if(!is.null(mytitle)){mtext(mytitle,side=3,line=0,cex=1.5)}
	if(!is.null(mytitle2)){mtext(mytitle2,side=3,line=1.25,cex=1.5)}
	if(addlegend){legend("bottomleft",legend=c("NCBI","sequenced","new_samples_to_be_sequenced"),pch=c(16,15,17),bty='n',cex=3.5)}
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Closed pdf file.",sep="\n")}
		}
	}		

# depends on plotlocations2
plotfossils<-function(adjustlong=TRUE)
	{
	x			<- read.table("brownbearfossil_pbdb_data.tsv",skip=17,sep="\t",header=TRUE)
	y			<- x[,c("early_interval","max_ma","min_ma","lng","lat")]
	colnames(y)	<- c("early_interval","max_ma","min_ma","longitude","latitude")
	y$col		<- ifelse(y$min_ma==0&y$max_ma==0.0117,"darkgreen",ifelse(y$min_ma==0.0117&y$max_ma==0.126,"blue",ifelse(y$min_ma==0.126&y$max_ma==0.781,"darkred",NA)))
	y$bool		<- ifelse(y$min_ma==0&y$max_ma==0.0117,TRUE,ifelse(y$min_ma==0.0117&y$max_ma==0.126,TRUE,ifelse(y$min_ma==0.126&y$max_ma==0.781,TRUE,FALSE)))
	y$period	<- ifelse(y$min_ma==0&y$max_ma==0.0117,"0-11.7 Kya",ifelse(y$min_ma==0.0117&y$max_ma==0.126,"11.7-126 Kya",ifelse(y$min_ma==0.126&y$max_ma==0.781,"126-781 Kya",NA)))
	y$pch		<- ifelse(y$min_ma==0&y$max_ma==0.0117,1,ifelse(y$min_ma==0.0117&y$max_ma==0.126,2,ifelse(y$min_ma==0.126&y$max_ma==0.781,0,NA)))
	if(adjustlong)
		{
		y$longitude	<- ifelse(y$longitude>=-15,y$longitude,180+(180-abs(y$longitude)))
		}
	fossildf	<- y[y$bool,]
	fossilcoldf	<- data.frame("period"=c("0-11.7 Kya","11.7-126 Kya","126-781 Kya"),"col"=c("darkgreen","blue","darkred"),"pch"=c(1,2,0))
	#
	plotlocations2(export="pdf",longthreshold=15,legendtxt=fossilcoldf$period,legendcol=as.character(fossilcoldf$col),exportname="fossillocations",silent=TRUE,mygeodf=fossildf,my_col=fossildf$col[fossildf$bool])
	#
	}

# Create map using package Maps. Advantage compared to Rworldmap is that this function allows to centre the map around the Pacific ocean, if needed 
plotlocations2<-function(export=NULL,indsfilter=inds$filter,mycols=inds$popcol[inds$filter],longthreshold=15,xmargin=0.05,ymargin=0.15,mapcol="grey90",mybg="white",msnmatrix=NULL,msnlwd=1.5,addaxislabels=FALSE,mydeviation=NULL,exportname="samplelocations",silent=TRUE,mygeodf=NULL,mygeofile=NULL,my_col=NULL,shapelist=NULL,addshapecol="grey50",legendpos="topleft",legendtxt=NULL,legendcol=NULL,my_pch=21,legendcex=0.75,mycex=1,pchlwd=0.25,dolabels=FALSE,printname=FALSE,showborders=FALSE,textdf=NULL,textcex=1.25,boxcol="grey90",boxlwd=1,linesdf=NULL,legendpos2="topright",rangefilter=NULL,mybreaks=c(-0.01,0.05,0.1,0.15,0.2,0.25,1),distdf=NULL,plotbin=4)
	{
	if("maps" %in% rownames(installed.packages()) == FALSE) {install.packages("maps",repos='http://cran.us.r-project.org')}
	if("maps" %in% (.packages()) == FALSE)					{library(maps)}
	if(is.null(indsfilter))
		{
		return(cat("ERROR: indsfilter is NULL.",sep="\n"))
		}	
	if(length(indsfilter[indsfilter])<2)
		{
		return(cat("ERROR: according to indsfilter, less then 2 retained individuals.",sep="\n"))
		}
	if(is.null(mygeodf)&is.null(mygeofile))
		{
		cat("Flags 'mygeodf' and 'mygeofile' set to NULL (default). Assuming to find within inds dataframe columns called 'longitude' and 'latitude'.",sep="\n")
		if(!"longitude"%in%colnames(inds)|!"latitude"%in%colnames(inds))
			{
			return(cat("Columns 'longitude' and 'latitude' not present in inds dataframe.",sep="\n"))
			}
		if(any(inds$longitude<0,na.rm=TRUE)&"longitude3"%in%colnames(inds))
			{
			cat("Using inds$longitude3...",sep="\n")
			coord			<- inds[indsfilter,c("longitude3","latitude")]
			colnames(coord)	<- c("longitude","latitude")
			if(!is.null(rangefilter))
				{
				cat("Using range delimitation specified by rangefilter flag.",sep="\n")
				allcoord		<- inds[rangefilter,c("longitude3","latitude")]
				}
			}else{
			cat("WARNING: Column inds$longitude3 not present, or no value in inds$longitude below 0. Therefore using inds$longitude. The plot will be centred around the Atlantic Ocean.",sep="\n")
			coord		<- inds[indsfilter,c("longitude","latitude")]
			if(!is.null(rangefilter))
				{
				cat("Using range delimitation specified by rangefilter flag.",sep="\n")
				allcoord		<- inds[rangefilter,c("longitude","latitude")]
				}
			}
		}else{
		if(!is.null(mygeofile))
			{
			mygeo		<- read.table(mygeofile,header=TRUE,sep="\t")
			}else{
			mygeo		<- mygeodf
			}
		coord			<- mygeo[,c("longitude","latitude")]
		}
	if(is.null(my_col))
		{
		if(is.null(mycols))
			{
			mycols		<- rep("black",nrow(coord))
			}
		}else{
		mycols			<- as.character(my_col)
		}
	if(is.null(my_pch))
		{
		mypch		<- 19
		}else{
		mypch		<- my_pch
		}
	if(is.factor(coord$latitude))
		{
		cat("WARNING: converting latitude factor vector into numeric vector.",sep="\n") 
		coord$latitude		<-  as.numeric(sub(",",".",as.character(coord$latitude)))
		if(!is.null(rangefilter)){allcoord$latitude	<-  as.numeric(sub(",",".",as.character(allcoord$latitude)))}
		}
	if(is.factor(coord$longitude))
		{
		cat("WARNING: converting longitude factor vector into numeric vector.",sep="\n") 
		coord$longitude		<-  as.numeric(sub(",",".",as.character(coord$longitude)))
		if(!is.null(rangefilter)){allcoord$longitude	<-  as.numeric(sub(",",".",as.character(allcoord$longitude)))}
		}
	if(is.character(coord$latitude))
		{
		cat("WARNING: converting latitude character vector into numeric vector.",sep="\n") 
		coord$latitude		<-  as.numeric(sub(",",".",as.character(coord$latitude)))
		if(!is.null(rangefilter)){allcoord$latitude	<-  as.numeric(sub(",",".",as.character(allcoord$latitude)))}
		}
	if(is.character(coord$longitude))
		{
		cat("WARNING: converting longitude character vector into numeric vector.",sep="\n") 
		coord$longitude		<-  as.numeric(sub(",",".",as.character(coord$longitude)))
		if(!is.null(rangefilter)){allcoord$longitude	<-  as.numeric(sub(",",".",as.character(allcoord$longitude)))}
		}
	mygeocols			<<- mycols
	mysamplenrs			<- inds$nr[indsfilter]
	mysamplenames		<- inds$name[inds$filter]
	if(!is.null(mydeviation))
		{
		if(is.null(mygeodf)&is.null(mygeofile))
			{
			indstemp	<- inds[indsfilter,]
			if(!"do_coordshuffle"%in%colnames(inds))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent from inds dataframe. Shuffling all data points.",sep="\n")
				indstemp$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(indstemp$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}else{
			if(!"do_coordshuffle"%in%colnames(mygeo))
				{
				cat("WARNING: the flag docoord_shuffle is not NULL, but boolean column called 'do_coordshuffle' absent in mygeo. Shuffling all data points.",sep="\n")
				mygeo$do_coordshuffle	<- TRUE
				}
			for (j in c(1:nrow(coord)))
				{
				#cat(j,sep="\n")
				coord$longitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$longitude[j]+runif(1,-mydeviation,mydeviation),coord$longitude[j])
				coord$latitude[j] 	<- ifelse(mygeo$do_coordshuffle[j],coord$latitude[j]+runif(1,-mydeviation,mydeviation),coord$latitude[j])
				}
			}
		}else{
		cat("Flag 'mydeviation' is set to NULL. Not shuffling.",sep="\n")
		}
	#
	geocoord			<- coord
	if(!is.null(rangefilter))
		{
		geocoord$name	<- inds$name[indsfilter&rangefilter]
		}else{
		geocoord$name	<- inds$name[indsfilter]
		}
	mygeocoord			<<- coord
	mygeocols			<- mycols
	# PLOTTING:
	if(!is.null(export))
		{
		plotname		<- ifelse(addaxislabels,paste(exportname,"withaxes",sep="."),paste(exportname,"no_axes",sep="."))
		plotname		<- ifelse(!is.null(msnmatrix),paste(plotname,"MinimumSpanningTree",sep="."),plotname)
		plotname		<- ifelse(!is.null(distdf),paste(plotname,"network",paste(distdf$dmin[1],"-",distdf$dmax[1],sep=""),sep="."),plotname)
		deviationlabel	<- ifelse(is.null(mydeviation),"exactlocation","withdeviation")
		pointslabel		<- ifelse(dolabels,ifelse(printname,"samplenames","samplenrs"),"points")
		borderlabel		<- ifelse(showborders,"withborders","withoutborders")
		if(export=="pdf"){pdf(paste(plotname,pointslabel,borderlabel,deviationlabel,mybg,"Rmaps.pdf",sep="."))}
		if(export=="wmf"){win.metafile(paste(plotname,pointslabel,borderlabel,mybg,deviationlabel,"Rmaps.wmf",sep="."))}
		if(!silent){cat(paste("Writing out file called:", exportname,sep=" "),sep="\n")}
		}
	ww2 		<- maps::map('world', wrap=c(0-longthreshold,360-longthreshold), plot=FALSE, fill=TRUE)
	bordercol	<- ifelse(showborders,"white",NA)
	if(is.null(rangefilter))
		{
		myxlim		<- c(min(mygeocoord$longitude,na.rm=TRUE),max(mygeocoord$longitude,na.rm=TRUE))
		myylim		<- c(min(mygeocoord$latitude,na.rm=TRUE),max(mygeocoord$latitude,na.rm=TRUE))
		}else{
		myxlim		<- c(min(allcoord$longitude,na.rm=TRUE),max(allcoord$longitude,na.rm=TRUE))
		myylim		<- c(min(allcoord$latitude,na.rm=TRUE),max(allcoord$latitude,na.rm=TRUE))
		}
	myxrange	<- myxlim[2]-myxlim[1]
	myyrange	<- myylim[2]-myylim[1]
	myxlim		<- c(myxlim[1]-xmargin*myxrange,myxlim[2]+xmargin*myxrange)
	myylim		<- c(myylim[1]-ymargin*myyrange,myylim[2]+ymargin*myyrange)
	par(bg=mybg)
	maps::map(ww2,ylim=myylim,xlim=myxlim,col=mapcol,border=bordercol,fill=TRUE)
	#map(ww2,ylim=c(30,80),xlim=c(-10,280),col=mapcol,border=bordercol,fill=TRUE)	# for bears
	if(!is.null(shapelist))
		{
		for(k in c(1:length(shapelist)))
			{
			plot(shapelist[[k]],col=addshapecol[k],border=addshapecol[k],add=T,lwd=1)
			}
		}
	if(!is.null(msnmatrix))
		{
		# minimum spanning tree generated with the pegas functions:
		# Computes a minimum spanning tree:
		# mst:	using Kruskal's algorithm, 
		# msn:	using Bandelt et al.'s algorithm
		# rmst:	using randomized minimum spanning tree algorithm (Paradis 2018).
		#		
		# X		<- mysambar$mytree_distmat
		# d 	<- dist(X)
		# PC 	<- prcomp(X)
		# M 	<- mst(d)
		# x		<- as.matrix(M)	# this is the expected msnmatrix
		#
		# It is expected that the distance matrix and hence the subsequent haplotype have been generated for similar datasubset (as defined by inds$filter)
		cat("Adding minimum spanning network...",sep="\n")
		x		<- as.matrix(msnmatrix)
		ind1vec	<- msnmatrix[,1]
		ind2vec	<- msnmatrix[,2]
		distvec	<- msnmatrix[,3]
		distvec	<- distvec/mean(distvec)
		for(k in c(1:nrow(x)))
			{
			ind1	<- ind1vec[k]
			ind2	<- ind2vec[k]
			coord1	<- unlist(mygeocoord[ind1,])
			coord2	<- unlist(mygeocoord[ind2,])
			#mycol	<- ifelse(distvec[k]<3,"grey40","grey80")
			mycol	<- "grey40"
			segments(x0=coord1[1],y0=coord1[2],x1=coord2[1],y1=coord2[2],lwd=msnlwd,col=mycol)
			}
		}
	if(!is.null(distdf))
		{
		# expects dataframe generated with haplodistmat function (from haploblock data)
		nbins		<- length(mybreaks)-1
		bincolours	<- c("white","grey95","grey75","yellow","orange","red")
		mylabels	<- c(0:(nbins-1))
		mylwds		<- c(c(0,0.25),seq(1,(nbins-2)))
		#
		dropinds	<- inds$name[!inds$filter]	
		distdf		<- distdf[!(distdf$name1%in%dropinds|distdf$name2%in%dropinds),]
		#
		distdf$bin	<- as.vector(cut(distdf$prop,mybreaks,labels=mylabels))
		distdf$col	<- as.vector(cut(distdf$prop,mybreaks,labels=bincolours))
		distdf$lwd	<- as.vector(cut(distdf$prop,mybreaks,labels=mylwds))
		#
		mybins		<- mylabels[mylabels>=plotbin]
		for(mybin in mybins)
			{
			distdf2				<- distdf[distdf$bin==mybin,]
			if(nrow(distdf2)>0)
				{
				for(k in c(1:nrow(distdf2)))
					{
					ind1		<- distdf2$name1[k]
					ind2		<- distdf2$name2[k]
					#cat(paste(ind1,ind2,sep="_"),sep="\n")
					ind1x		<- geocoord$longitude[geocoord$name==ind1]
					ind2x		<- geocoord$longitude[geocoord$name==ind2]
					ind1y		<- geocoord$latitude[geocoord$name==ind1]
					ind2y		<- geocoord$latitude[geocoord$name==ind2]
					segments(x0=ind1x,y0=ind1y,x1=ind2x,y1=ind2y,lwd=0.5,col=distdf2$col[k])
					}
				}
			}
		points(geocoord$longitude,geocoord$latitude,pch=16,col="grey20",cex=0.5)
		dmin	<- distdf$dmin[1]
		dmax	<- distdf$dmax[1]
		mtext(side=3,paste(dmin," <= d < ",dmax,sep=""),line=-1.5,cex=1.5)
		legend(legendpos2,legend=paste(">",rev(mybreaks[(plotbin+1):nbins]),sep=""),bty="n",fill=rev(bincolours[(plotbin+1):nbins]),cex=legendcex,title="frequency:")
		}
	if(dolabels)
		{
		if(printname)
			{
			text(coord,labels=mysamplenames,col=mycols,cex=mycex,pch=mypch)
			}else{
			text(coord,labels=mysamplenrs,col=mycols,cex=mycex,pch=mypch)
			}
		}else{
		points(coord,col="black",bg=mycols,cex=mycex,pch=mypch,lwd=pchlwd)
		if(any(mypch<=20))
			{
			pchbool	<- mypch<=20
			points(coord[pchbool,],col=mycols[pchbool],cex=mycex,pch=mypch[pchbool])
			}
		}
	if(!is.null(textdf))
		{
		cat("Adding text...",sep="\n")
		text(x=textdf$x,y=textdf$y,textdf$label,col=as.character(textdf$col),cex=textcex)
		}
	if(!is.null(linesdf))
		{
		cat("Adding lines...",sep="\n")
		for(k in c(1:nrow(linesdf)))
			{
			segments(x0=linesdf$x0[k],x1=linesdf$x1[k],y0=linesdf$y0[k],y1=linesdf$y1[k],lty=linesdf$lty[k],lwd=linesdf$lwd[k],col=linesdf$col[k])
			}
		}
	if(!is.null(legendtxt)&!is.null(legendcol))
		{
		cat("Adding legend...",sep="\n")
		legend(legendpos,legend=legendtxt,fill=legendcol,bty='n',cex=legendcex)
		}
	box(col=boxcol,lwd=boxlwd)
	if(!is.null(export)){dev.off()}
	#
	mysambar$geocoord	<<- coord
	mysambar$geocols	<<- mycols
	cat("Geographical coordinates stored at mysambar$geocoord.",sep="\n")
	}

shiftranges<-function(longthreshold=15)
	{
	# in order to recentre map we have to adjust the coordinates in the input data
	# this function does so
	# every point occurring west of the line -longthreshold (default: -15) will be converted as follows: 
	# oldvalue = 180+(180-abs(oldvalue))
	#
	# get overview of range:
	# length(shape2@polygons) equals nrow(shape2)
	# so it equal to the entries in the dataframe
	# however, some elements in shape2@polygons have more than one dataframe with coordinates
	# e.g.: 
	# shape2@polygons[[1]]@Polygons[[1]]@coords
	# shape2@polygons[[1]]@Polygons[[2]]@coords
	# etc
	# this function first counts numbers of coordinate dataframes per entry
	mygenusshape2		<<- mygenusshape
	nrangesvec			<<- vector()
	for(i in c(1:nrow(mygenusshape)))
		{
		nrangesvec[[i]]	<<- length(mygenusshape@polygons[[i]]@Polygons)
		}
	# next it checks which longitude coordinates are negative (i.e. west of Greenwich):
	rangeslist	<<- list()
	for(i in c(1:nrow(mygenusshape)))
		{
		nranges			<- nrangesvec[i]
		myboolvec		<- vector()
		for(j in c(1:nranges))
			{
			mylongitudes	<- mygenusshape@polygons[[i]]@Polygons[[j]]@coords[,1]
			westhemi		<- any((mylongitudes+180)<(180-longthreshold))
			myboolvec[j]	<- westhemi
			if(westhemi)
				{
				mynewlongitudes	<- 180+(180-abs(mylongitudes))
				mygenusshape2@polygons[[i]]@Polygons[[j]]@coords[,1]	<<-  mynewlongitudes
				}
			}
		rangeslist[[i]]		<<- myboolvec 
		}
	mygenusshape_backup		<<- mygenusshape
	mygenusshape			<<- mygenusshape2
	}

getsingleshape<-function(myprefix="data_0",mydir=".")
	{
	shape2 			<<- readOGR(dsn=mydir,layer=myprefix)
	mygenusshape	<<- shape2
	mydata 			<<- mygenusshape@data
	myextent 		<- as.vector(extent(mygenusshape))
	if("binomial"%in%colnames(mydata))
		{
		mydata$species		<<- mydata$binomial
		}
	if("BINOMIAL"%in%colnames(mydata))
		{
		mydata$species		<<- mydata$BINOMIAL
		}
	}

# map species range using package Maps (originally called 'plotsingle2'):
mapsingleshape<-function(export=NULL,plotratios=1,plottitle=NULL,exportname=NULL,mycolours=NULL,transparency_level=0.85,x_lim=c(-10,280),y_lim=c(25,80),mybg="white",boxcol="grey90",boxlwd=1,shapelist=NULL,addshapecol="grey50",addloc=FALSE,myfilter=NULL,mycoord=NULL,mycoordcol=NULL,mycoordcol2=NULL,mypchs=16,myrange=NULL,range_fac=0.02,mycex=1,showborders=TRUE,mylegend=NULL,mylegendcol=NULL,mylegendlty=NULL,legendcex=0.75,legendpos="bottom",legend2df=NULL,legend2title=NULL,legend2pos="bottomright",legend2cex=2,addrefuge=FALSE,linesdf=NULL,markbool=NULL,reverse_pchcol=FALSE,pchlwd=0.5)
	{
	if(is.null(mycolours))
		{
		mycolours	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1")
		}
	if(is.null(mypchs))
		{
		return(cat("ERROR: mypchs is NULL.",sep="\n"))
		}
	myextent 		<- as.vector(extent(mygenusshape)) 
	# mygenusshape has been generated by typing as.data.frame(shape2), this results in the error:
	# Error in extent(mygenusshape): c("x", "y") %in% names(x) are not all TRUE
	if("binomial"%in%colnames(mydata))
		{
		species 		<- as.vector(unique(mydata$binomial))	
		mydata$species	<- mydata$binomial
		}else{
		cat("WARNING: columnname 'binomial' not present. Trying 'BINOMIAL' instead...",sep="\n")
		if("BINOMIAL"%in%colnames(mydata))
			{
			species 		<- as.vector(unique(mydata$BINOMIAL))
			mydata$species	<- mydata$BINOMIAL
			}else{
			return(cat("WARNING: columnname 'BINOMIAL' also not present. Type 'colnames(mydata) to observe the name of column with species names.",sep="\n"))
			}
		}
	species 		<- sort(species)
	#
	xrange			<- diff(myextent[1:2])
	yrange			<- diff(myextent[3:4])
	#
	# plot with different width/height ratios, so you can choose optimal settings:
	if(is.null(plotratios))
		{
		cat("Plotratios is set to NULL. Maps will be generated with a range of height/width ratios.",sep="\n")  
		plotratios	<- seq(0.2,1.2,0.1)
		}
	for(k in plotratios)
		{
		# k is a correction factor to adjust ratio between height and width:
		cat(paste("heigth/width ratio: ",k,sep=""),sep="\n")		
		#myratio			<- (k*xrange)/yrange		
		myratio				<- plotratios[k]
		if(!is.null(export))
			{
			mycoordlabel	<- ifelse(is.null(mycoord),"no_locations","with_sample_locations")
			exportname		<- ifelse(is.null(exportname),"Species_range",exportname)
			borderlabel		<- ifelse(showborders,ifelse(addrefuge,"withborders_withECmodel","withborders"),ifelse(addrefuge,"noborders_withECmodel","noborders"))
			if(export=="pdf"){pdf(paste(exportname,mycoordlabel,borderlabel,mybg,"pdf",sep="."),height=6,width=6*myratio)}
			if(export=="png"){png(paste(exportname,mycoordlabel,borderlabel,mybg,"png",sep="."),height=2000,width=2000*myratio)}
			if(export=="wmf"){win.metafile(paste(exportname,mycoordlabel,borderlabel,mybg,"wmf",sep="."),height=6,width=6*myratio)}
			}
		ww2 			<- maps::map('world', wrap=c(-15,345), plot=FALSE, fill=TRUE)
		bordercol		<- ifelse(showborders,"white",NA)
		par(bg=mybg)
		maps::map(ww2,ylim=y_lim,xlim=x_lim,col="grey95",border=bordercol,fill=TRUE)
		#map(ww2,ylim=c(25,80),xlim=c(-10,280),col="grey95",border=bordercol,fill=TRUE)
		for (j in c(1:length(species)))
			{
			myspecies	<- species[j]
			mycolour	<- mycolours[j]
			myrgb		<- col2rgb(mycolour)
			mytranscol	<- rgb(myrgb[1],myrgb[2],myrgb[3],max=255,alpha=transparency_level*255)
			selection 	<- which(mydata$species==myspecies) 
			if(!is.null(myfilter))
				{
				filterrgb		<- col2rgb("grey80")
				filtertranscol	<- rgb(filterrgb[1],filterrgb[2],filterrgb[3],max=255,alpha=transparency_level*255)
				plot(mygenusshape[selection&!myfilter,],add=TRUE,border=rgb(0,0,0,0),lwd=1,col=filtertranscol)
				plot(mygenusshape[selection&myfilter,],add=TRUE,border=rgb(0,0,0,0),lwd=1,col=mytranscol)
				}else{
				plot(mygenusshape[selection&myfilter,],add=TRUE,border=rgb(0,0,0,0),lwd=1,col=mytranscol)
				}
			}
		if(addloc)
			{
			# depreciated (locations of roe deer samples)
			points(126,43,col="black",pch=16,cex=2)
			points(8,50,col="black",pch=16,cex=2)
			}
		if(!is.null(myrange))
			{
			#myrange		<-data.frame("long"=c(100,150,180,170),"lat"=c(40,20,30,50))
			if(!"longitude"%in%colnames(myrange)|!"latitude"%in%colnames(myrange))
				{
				cat("WARNING: myrange input df does not contain columns 'longitude' and 'latitude'. Not drawing polygons.",sep="\n") 
				}else{
				myrange				<- myrange[order(myrange$longitude,myrange$latitude),]
				#longmean			<- 1/2*(max(myrange$longitude,na.rm=TRUE)+min(myrange$longitude,na.rm=TRUE))
				#myrange$longitude	<- ifelse(myrange$longitude<longmean,(1-range_fac)*myrange$longitude,(1+range_fac)*myrange$longitude)
				#latmean			<- 1/2*(max(myrange$latitude,na.rm=TRUE)+min(myrange$latitude,na.rm=TRUE))
				#myrange$latitude	<- ifelse(myrange$latitude<latmean,(1-range_fac)*myrange$latitude,(1+range_fac)*myrange$latitude)
				myrange2 			<- SpatialPolygons(list(Polygons(list(Polygon(myrange)), ID=1)))
				# install.packages("smoothr")
				# library(smoothr)
				myrange3 		<- smoothr::smooth(myrange2, method = "chaikin")
				mydf			<- myrange3@polygons[[1]]@Polygons[[1]]@coords
				polygon(mydf[,1],y=mydf[,2],col="blue",border=NA)
				}
			}
		if(!is.null(shapelist))
			{
			# is it really necessary to use a for-loop? Might also work simply as follows:
			# plot(shapelist[[1],col=addshapecol,border=addshapecol,add=T)		
			for(k in c(1:length(shapelist)))
				{
				plot(shapelist[[k]],col=addshapecol[k],border=addshapecol[k],add=T)
				}
			}
		if(!is.null(mycoord))
			{
			if(!is.null(mycoordcol))
				{
				mycols	<- mycoordcol
				}else{
				mycols	<- "black"	
				}
			if(!is.null(mycoordcol2))
				{
				mycols2	<- mycoordcol2
				mylwd	<- rep(0.5,nrow(mycoord))	
				}else{
				mycols2	<- rep("black",nrow(mycoord))
				mylwd	<- rep(0.5,nrow(mycoord))
				}
			if(!is.null(markbool))
				{
				mylwd[markbool]		<- 3
				points(mycoord,col=mycols2,bg=mycols,cex=mycex,pch=mypchs,lwd=mylwd)
				}else{
				points(mycoord,col=mycols,cex=mycex,pch=mypchs,lwd=mylwd)
				}
			if(any(mypchs>20))
				{
				pchbool	<- mypchs>20
				if(reverse_pchcol)
					{
					points(mycoord[pchbool,],bg="grey50",col=mycols[pchbool],cex=mycex,pch=mypchs[pchbool],lwd=pchlwd)
					}else{
					points(mycoord[pchbool,],col="grey50",bg=mycols[pchbool],cex=mycex,pch=mypchs[pchbool],lwd=pchlwd)
					}
				}	
			if(any(mypchs<=20))
				{
				pchbool	<- mypchs<=20
				points(mycoord[pchbool,],col=mycols[pchbool],cex=mycex,pch=mypchs[pchbool])
				}
			#if(!is.null(markbool))
			#	{
			#	points(mycoord[markbool,],col=mycols2[markbool],bg=mycols[markbool],cex=mycex,pch=mypchs,lwd=3)
			#	}
			#if(!is.null(markbool))
			#	{
			#	points(mycoord[markbool,],col="black",cex=1.5,pch=20)
			#	}
			}
		if(!is.null(linesdf))
			{
			cat("Adding line segments...",sep="\n")
			for(k in c(1:nrow(linesdf)))
				{
				segments(x0=linesdf$x0[k],x1=linesdf$x1[k],y0=linesdf$y0[k],y1=linesdf$y1[k],lty=linesdf$lty[k],lwd=linesdf$lwd[k],col=linesdf$col[k])
				}
			}
		if(addrefuge)
			{
			addrefuge_function()
			}
		if(!is.null(mylegend)&!is.null(myfilter))
			{
			if(!is.null(mylegend))
				{
				if(!is.null(mylegendcol))
					{
					if(!is.null(mylegendlty))
						{
						legend(legendpos,legend=mylegend,lty=mylegendlty,col=mylegendcol,bty='n',cex=legendcex,lwd=2)
						}else{
						legend(legendpos,legend=mylegend,fill=mylegendcol,bty='n',cex=legendcex)
						}
					}else{
					legend(legendpos,legend=mylegend,fill=c("grey80",mycolour),bty='n',cex=legendcex)
					}
				}else{
				legend(legendpos,legend=mylegend,fill=c(mycolours),bty='n',cex=legendcex)
				}
			}
		#if(length(mypchs)>1)
		#	{
		#	mylegend2	<- c("1a","1b","2a","3a","3b","4","5")
		#	legend2pch	<- c(24,25,8,21,23,22,4)
		#	pchdf		<- data.frame("name"=mylegend2,"pch"=legend2pch)
		#	legendpos2	<- "bottomright"
		#	legend(legendpos2,legend=mylegend2,pch=legend2pch,col="black",pt.bg="black",bty='n',cex=legendcex,title="mt-DNA:")
		#	}
		# 22-08-2022: replaced lines above with:
		if(!is.null(legend2df))
			{
			if(!"col"%in%colnames(legend2df))
				{
				legend2df$col	<- "black"
				}
			if(!"col2"%in%colnames(legend2df))
				{
				legend2df$col2	<- "black"
				}
			if(is.null(legend2title))
				{
				legend2title	<- ""
				}
			if(reverse_pchcol)
				{
				legend(legend2pos,legend=legend2df$name,pch=legend2df$pch,pt.bg=legend2df$col2,col=legend2df$col,bty='n',cex=legend2cex,title=legend2title)
				}else{
				legend(legend2pos,legend=legend2df$name,pch=legend2df$pch,col=legend2df$col2,pt.bg=legend2df$col,bty='n',cex=legend2cex,title=legend2title)
				}
			}
		box(col=boxcol,lwd=boxlwd)
		if(!is.null(plottitle))
			{
			mtext(side=3,line=0.5,plottitle,cex=2)
			}
		if(!is.null(export))
			{
			dev.off()
			cat("Map(s) exported to directory:",sep="\n")
			cat(getwd(),sep="\n") 
			}
		}
	}



# 25-06-2022: function needed to automatically generate input for plotcladetree()
findcladenr<-function(mytree=mysambar$mytree,clustervec=inds$K_4,clustercolvec=inds$colK_4)
	{
	if("phytools" %in% rownames(installed.packages()) == FALSE){install.packages("phytools")}
	if("phytools" %in% (.packages()) == FALSE){library("phytools")}
	#
	myclades	<- unique(clustervec[inds$filter])
	myclades	<- myclades[!is.na(myclades)]
	nclades		<- length(myclades)
	#
	mytree2	<- mytree
	# next line is needed to avoid the error: Error in if (nd == rootnd) break : missing value where TRUE/FALSE needed
	mytree2$edge.length[mytree2$edge.length<0]	<- 0
	#
	cladedf			<- data.frame("node"=NA,"colour"=NA)
	for(k in c(1:nclades))
		{
		cat(k,sep="\n")
		myclade				<- myclades[k]
		mybool				<- clustervec==myclade&!is.na(clustervec)
		indnames			<- inds$name[mybool]
		mynode				<- findMRCA(mytree2,indnames)
		cladedf$node[k]		<- mynode
		#cladedf$colour[k]	<- clustercolvec[mybool][1]
		}
	return(cladedf)
	}

# 18-06-2022: function to create unrooted tree with highlighted clades, using ggtree
# Needs as input a dataframe with node numbers and colours of the clades.
# The clades can be determined by observing dendrograms, or, more objectively, using the find.clusters function.  
plotcladetree<-function(mytree=mysambar$mytree,colourdf=NULL,exportname="mytree",silent=TRUE,listtips=TRUE)
	{
	if("ggtree" %in% rownames(installed.packages()) == FALSE)
		{
		cat("WARNING: package 'ggtree' not found. Installing now...",sep="\n")
		if(!require("BiocManager", quietly = TRUE)){install.packages("BiocManager")}
		BiocManager::install("ggtree")
		}
	if("ggtree" %in% (.packages()) == FALSE){library("ggtree")}
	#
	if(is.null(mytree))
		{
		return(cat("ERROR: specify an (existing) phylo object to the mytree flag.",sep="\n"))	
		}
	# plot node labels:
	cat("Plotting tree showing node numbers.",sep="\n")
	p	<- ggtree(mytree,layout="unrooted",lwd=0.5)
	p + geom_tiplab() + geom_text(aes(label=node), hjust=-.3,cex=0.5,col="red")
	ggsave("mytree_nodelabels.pdf")
	#
	if(is.null(colourdf))
		{
		cat("No input dataframe specified to colourdf flag. Not plotting tree with highlighted clades.",sep="\n")  
		return(cat("You may want to observe the 'mytree_nodelabels.pdf' file to find the node numbers of the clades you want to highlight.",sep="\n"))
		}
	if(any(!c("node","colour")%in%colnames(colourdf)))
		{
		return(cat("ERROR: input dataframe specied to colourdf should contain columns called 'node' and 'colour'.",sep="\n"))
		}
	if(!"transparancy"%in%colnames(colourdf))
		{
		colourdf$transparancy	<- 0.8
		}
	cat("Plotting unrooted tree with highlighted clades...",sep="\n")
	p	<- ggtree(mytree,layout="unrooted",lwd=1.5)
	for(k in c(1:nrow(colourdf)))
		{
		if(!silent){cat(k,sep="\n")}
		p <- p + geom_hilight(node=colourdf$node[k],fill=colourdf$colour[k],alpha=colourdf$transparancy[k],colour=NA) 
		}
	print(p)
	ggsave(paste(exportname,"highlighted_clades.pdf",sep="_"))
	cat("The tree file with highlighted clades (with default name 'mytree_highlighted_clades.pdf') has been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	if(listtips)
		{
		cat("Listing tip labels per clade...",sep="\n")  
		p		<- ggtree(mytree,layout="unrooted",lwd=1.5)
		tiplist	<- list()
		for(k in c(1:nrow(colourdf)))
			{
			if(!silent){cat(k,sep="\n")}
			nodenr			<- colourdf$node[k]
			tiplist[[k]]	<- as.data.frame(ggtree:::getSubtree(tree=p,node=nodenr))$label[as.data.frame(ggtree:::getSubtree(tree=p,node=nodenr))$isTip]
			}
		cat("Adding information to inds dataframe...",sep="\n")
		inds$nodenr		<<- NA
		inds$nodecol	<<- NA
		for(k in c(1:nrow(colourdf)))
			{
			indbool					<- inds$name%in%tiplist[[k]] 
			inds$node[indbool]		<<- colourdf$node[k]
			inds$nodecol[indbool]	<<- colourdf$colour[k]
			}
		cat("Information added to the columns inds$node and inds$nodecol.",sep="\n")
		}
	}

run_find.clusters_bic<-function(maxK=20,percvector=c(20,40,60,80,95),niter=1000)
	{
	# Calculate BIC-values for different combinations of K and number of pca-axes (the latter chosen to correspond to certain percentages of explained variance)
	# Findings: 
	# - 80% and 95% explained variance are identical, 
	# - 60% explained variance leads to some K based on elbow-principle, and less fluctuating for higher K (no overfitting?) 
	# - no difference observed between niter=100 and niter=10000 
	#
	mygeno	<- mygenlight[inds$filter,snps$filter]
	nperc			<- length(percvector)
	bicmat			<- matrix(NA,nrow=maxK,ncol=nperc)
	colnames(bicmat)<- paste("p",percvector,sep="_")
	rownames(bicmat)<- paste("K",c(1:maxK),sep="_")
	for(i in c(1:nperc))
		{
		myperc			<- percvector[i]
		cat(paste("Explained percentage: ",myperc,".",sep=""),sep="\n")
		mygrp 			<- find.clusters(mygeno,max.n.clust=maxK,pca.select="percVar",perc.pca=myperc,choose.n.clust=FALSE,n.iter=niter)		
		bicmat[,i]		<- mygrp$Kstat
		}
	bicdf			<- as.data.frame(bicmat)	
	#
	# plot:
	mymin			<- min(bicdf)
	mymax			<- max(bicdf)
	mycols			<- c("black","grey20","grey40","grey60","grey80")
	pdf("BIC_curve.pdf")
	plot(bicdf[,1],ylim=c(mymin,mymax),type="l",ylab="BIC",xlab="K",col=mycols[1],lwd=2)
	for(i in c(2:nperc))
		{
		lines(bicdf[,i],col=mycols[i],lwd=2)
		}
	legend("bottomleft",fill=rev(mycols),legend=paste(rev(percvector),"%",sep=""),bty='n')
	dev.off()
	}

run_find.clusters<-function(mygeno=mygenlight,indsfilter=inds$filter,longthreshold=15,mybg="white",symbolcex=2,showborders=FALSE,doexport=FALSE,maxK=5,myperc=60,plotsize=10,niter=100,mycoord=NULL,myfactor=2,mycex=0.75,exportname="Myclusters",dolabels=FALSE)
	{
	mycolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(any(!c("longitude3","latitude")%in%colnames(inds)))
		{
		return(cat("ERROR: inds dataprovide a dataframe with longitude and latitude to mycoord flag.",sep="\n"))
		}
	# determine ratio between longitude range and latitude range:
	lonmin		<- min(inds$longitude3)
	lonmax 		<- max(inds$longitude3)
	londiff 	<- lonmax-lonmin
	latmin 		<- min(inds$latitude)
	latmax 		<- max(inds$latitude)
	latdiff 	<- latmax-latmin
	mymargin	<- 0.2
	lonmin		<- lonmin-mymargin*londiff		# add margin
	lonmax		<- lonmax+mymargin*londiff		# add margin
	latmin		<- latmin-mymargin*latdiff		# add margin
	latmax		<- latmax+mymargin*latdiff		# add margin
	x_coord 	<- c(lonmin,lonmax,lonmax,lonmin) 
	y_coord 	<- c(latmin,latmin,latmax,latmax)
	xym 		<- cbind(x_coord, y_coord)
	myratio		<- (lonmax-lonmin)/(latmax-latmin)
	myratio2	<- (latmax-latmin)/(lonmax-lonmin)
	#
	# plot range:
	ww2 		<- maps::map('world', wrap=c(0-longthreshold,360-longthreshold), plot=FALSE, fill=TRUE)
	bordercol	<- ifelse(showborders,"white",NA)
	exportname	<- ifelse(dolabels,paste(exportname,"labels",sep="_"),exportname)
	### K: 2 to 5:
	graphics.off()
	if(myratio>1)
		{
		if(doexport){pdf(paste(exportname,"K2_5",myperc,"perc.pdf",sep="."),width=plotsize,height=plotsize*4*myratio2*myfactor)}
		layout(matrix(c(1:4),4,1,byrow = TRUE))
		}else{
		if(doexport){pdf(paste(exportname,"K2_5",myperc,"perc.pdf",sep="."),height=plotsize,width=plotsize*4*myratio*myfactor)}
		layout(matrix(c(1:4),1,4,byrow = TRUE))
		}
	par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5,bg=mybg)
	for(ndemes in c(2:5))
		{
		cat(paste("Number of demes: ",ndemes,sep=""),sep="\n")
		mygrp 							<- find.clusters(mygeno[inds$filter,snps$filter],n.clust=ndemes,pca.select="percVar",perc.pca=myperc,choose.n.clust=FALSE,n.iter=niter)
		inds$findclade					<<- NA
		inds$findclade[indsfilter]		<<- mygrp$grp
		coloursvec						<- mycolours[1:ndemes]
		inds$findcladecol				<<- NA
		inds$findcladecol[indsfilter]	<<- coloursvec[as.factor(mygrp$grp)]
		#
		maps::map(ww2,ylim=c(latmin,latmax),xlim=c(lonmin,lonmax),col="grey90",border=bordercol,fill=TRUE)
		if(dolabels)
			{
			#plot(inds$longitude3[indsfilter],inds$latitude[indsfilter],col="white",xlab="",ylab="",xaxt='n',yaxt='n',cex=3,pch=16)
			text(inds$longitude3[indsfilter],inds$latitude[indsfilter],col=inds$findcladecol[inds$filter],inds$name[indsfilter],cex=1)
			}else{
			points(inds$longitude3[indsfilter],inds$latitude[indsfilter],col=inds$findcladecol[inds$filter],xlab="",ylab="",xaxt='n',yaxt='n',cex=symbolcex,pch=16)
			}
		mtext(paste("K=",ndemes,sep=""),side=3,cex=1.5)
		colnames(inds)[colnames(inds)=="findclade"]		<<- paste("K",ndemes,sep="_")
		colnames(inds)[colnames(inds)=="findcladecol"]	<<- paste("colK",ndemes,sep="_")
		}
	if(doexport){dev.off()}
	#
	if(maxK>5)
		 {
		### K: 6 to 9:
		graphics.off()
		if(myratio>1)
			{
			if(doexport){pdf(paste(exportname,"K6_9",myperc,"perc.pdf",sep="."),width=plotsize,height=plotsize*4*myratio2*myfactor)}
			layout(matrix(c(1:4),4,1,byrow = TRUE))
			}else{
			if(doexport){pdf(paste(exportname,"K6_9",myperc,"perc.pdf",sep="."),height=plotsize,width=plotsize*4*myratio*myfactor)}
			layout(matrix(c(1:4),1,4,byrow = TRUE))
			}
		par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5,bg=mybg)
		for(ndemes in c(6:9))
			{
			mygrp 							<- find.clusters(mygeno[inds$filter,snps$filter],n.clust=ndemes,pca.select="percVar",perc.pca=myperc,choose.n.clust=FALSE,n.iter=niter)
			inds$findclade					<<- NA
			inds$findclade[indsfilter]		<<- mygrp$grp
			coloursvec						<- mycolours[1:ndemes]
			inds$findcladecol				<<- NA
			inds$findcladecol[indsfilter]	<<- coloursvec[as.factor(mygrp$grp)]
			#
			maps::map(ww2,ylim=c(latmin,latmax),xlim=c(lonmin,lonmax),col="grey90",border=bordercol,fill=TRUE)
			if(dolabels)
				{
				#plot(inds$longitude3[indsfilter],inds$latitude[indsfilter],col="white",xlab="",ylab="",xaxt='n',yaxt='n',cex=3,pch=16)
				text(inds$longitude3[indsfilter],inds$latitude[indsfilter],col=inds$findcladecol[inds$filter],inds$name[indsfilter],cex=1)
				}else{
				points(inds$longitude3[indsfilter],inds$latitude[indsfilter],col=inds$findcladecol[inds$filter],xlab="",ylab="",xaxt='n',yaxt='n',cex=symbolcex,pch=16)
				}
			mtext(paste("K=",ndemes,sep=""),side=3,cex=1.5)
			colnames(inds)[colnames(inds)=="findclade"]		<<- paste("K",ndemes,sep="_")
			colnames(inds)[colnames(inds)=="findcladecol"]	<<- paste("colK",ndemes,sep="_")
			}
		if(doexport){dev.off()}
		}
	#
	### K: 10 to 13:
	if(maxK>9)
		{
		graphics.off()
		if(myratio>1)
			{
			if(doexport){pdf(paste(exportname,"K10_13",myperc,"perc.pdf",sep="."),width=plotsize,height=plotsize*4*myratio2*myfactor)}
			layout(matrix(c(1:4),4,1,byrow = TRUE))
			}else{
			if(doexport){pdf(paste(exportname,"K10_13",myperc,"perc.pdf",sep="."),height=plotsize,width=plotsize*4*myratio*myfactor)}
			layout(matrix(c(1:4),1,4,byrow = TRUE))
			}
		par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5,bg=mybg)
		for(ndemes in c(10:13))
			{
			mygrp 							<- find.clusters(mygeno[inds$filter,snps$filter],n.clust=ndemes,pca.select="percVar",perc.pca=myperc,choose.n.clust=FALSE,n.iter=niter)
			inds$findclade					<<- NA
			inds$findclade[indsfilter]		<<- mygrp$grp
			coloursvec						<- mycolours[1:ndemes]
			inds$findcladecol				<<- NA
			inds$findcladecol[indsfilter]	<<- coloursvec[as.factor(mygrp$grp)]
			#
			maps::map(ww2,ylim=c(latmin,latmax),xlim=c(lonmin,lonmax),col="grey90",border=bordercol,fill=TRUE)
			if(dolabels)
				{
				#plot(inds$longitude3[indsfilter],inds$latitude[indsfilter],col="white",xlab="",ylab="",xaxt='n',yaxt='n',cex=3,pch=16)
				text(inds$longitude3[indsfilter],inds$latitude[indsfilter],col=inds$findcladecol[inds$filter],inds$name[indsfilter],cex=1)
				}else{
				points(inds$longitude3[indsfilter],inds$latitude[indsfilter],col=inds$findcladecol[inds$filter],xlab="",ylab="",xaxt='n',yaxt='n',cex=symbolcex,pch=16)
				}
			mtext(paste("K=",ndemes,sep=""),side=3,cex=1.5)
			colnames(inds)[colnames(inds)=="findclade"]		<<- paste("K",ndemes,sep="_")
			colnames(inds)[colnames(inds)=="findcladecol"]	<<- paste("colK",ndemes,sep="_")
			}
		if(doexport){dev.off()}
		}
	# remove duplicate columns:
	inds 			<<- inds[, !duplicated(colnames(inds), fromLast = TRUE)]
	}

runfindclusters<-function(my_df=mydistdf,dropvec=NULL,thresvec=c(60000,35500),mypchs=c(21,25,22,24,23,8),mycolours=NULL,do_tmrca=TRUE,do_silent=TRUE)
	{
	if(is.null(my_df))
		{
		return(cat("ERROR: please specify an existing dataframe to the my_df flag.",sep="\n"))
		}
	if(!"dxy"%in%colnames(my_df))
		{
		return(cat("ERROR: input dataframe does not contain column 'dxy'.",sep="\n"))
		}
	if(is.null(mycolours))
		{
		mycolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
		}
	thresvec	<- thresvec[order(thresvec,decreasing=TRUE)]
	nthres		<- length(thresvec)
	if(nthres!=2)
		{
		return(cat("ERROR: expects two threshold values (not more, not less).",sep="\n"))
		}
	nclustervec	<<- vector()
	clist2		<<- list()
	for(thresnr in c(1:nthres))
		{
		findclusters(mydf=my_df,mythres=thresvec[thresnr],drop_ind=dropvec,use_tmrca=do_tmrca,silent=do_silent)
		clist2[[thresnr]]	<<- clist
		}
	if(nthres==2)
		{
		cat("Creating hierarchy.",sep="\n")
		parentlist		<- clist2[[1]]
		offspringlist	<- clist2[[2]]
		hlist			<<- parentlist
		#
		for(i in c(1:length(parentlist)))
			{
			cat(i,sep="\n")
			pcluster		<- unlist(parentlist[[i]])
			hlist[[i]]		<<- list()
			hlist[[i]][[1]]	<<- pcluster 
			boolnrs			<- which(sapply(offspringlist,function(x) any(pcluster %in% x)))
			for(j in c(1:length(boolnrs)))
				{
				boolnr				<- boolnrs[j]
				hlist[[i]][[j+1]]	<<- unlist(offspringlist[[boolnr]])
				if(length(hlist)==15){return(cat("ERROR: too many clusters.",sep="\n"))}
				}
			}
		cat("Hierarchical clustering stored in list object 'hlist'.",sep="\n")
		}
	#
	# add information to inds dataframe:
	cat("Adding information to inds dataframe...",sep="\n")
	inds$clade1		<<- NA
	inds$clade1col	<<- NA
	inds$clade2		<<- NA
	for(i in c(1:length(hlist)))
		{
		cat(i,sep="\n")
		plist		<- hlist[[i]]
		pcluster 	<- unlist(plist[[1]])
		inds$clade1[inds$name%in%pcluster]		<<- paste("c",i,sep="")
		inds$clade1col[inds$name%in%pcluster]	<<- mycolours[i]
		for(j in c(2:length(plist)))
			{
			mysubcluster	<- plist[[j]]
			inds$clade2[inds$name%in%mysubcluster]		<<- paste("c",i,letters[j-1],sep="")
			inds$clade2pch[inds$name%in%mysubcluster]	<<- mypchs[j-1]
			}
		}
	cat("Information added to columns inds$clade1, inds$clade1col, and inds$clade2.",sep="\n")
	}

findclusters<-function(mydf=mydistdf,mythres=30000,silent=TRUE,drop_ind=NULL,use_tmrca=TRUE)
	{
	if(is.null(mydf))
		{
		return(cat("ERROR: please specify an existing dataframe to the mydf flag.",sep="\n"))
		}
	if(!"dxy"%in%colnames(mydf))
		{
		return(cat("ERROR: input dataframe does not contain column 'dxy'.",sep="\n"))
		}
	if(!is.null(drop_ind))
		{
		cat("Dropping individual(s)...",sep="\n")
		if(any(!drop_ind%in%c(mydf$name1,mydf$name2)))
			{
			return(cat("ERROR: one or more individuals specified to drop_ind flag not present in dataframe.",sep="\n")) 
			}
		dropdf	<- mydf[!(mydf$name1%in%drop_ind|mydf$name2%in%drop_ind),]
		}else{
		dropdf	<- mydf
		}
	myinds	<- unique(c(dropdf$name1,dropdf$name2))
	ninds	<- length(myinds)
	# 
	slist 			<<- vector(mode="list",length=ninds)
	names(slist)	<<- myinds	
	#
	for(i in c(1:ninds))
		{
		myind		<- myinds[i]
		if(!silent){cat(myind,sep="\n")}
		inddf		<- dropdf[dropdf$name1==myind&dropdf$name2!=myind,]
		if(use_tmrca)
			{
			newgroup	<- c(inddf$name2[inddf$tmrca_y<mythres],myind)
			}else{
			newgroup	<- c(inddf$name2[inddf$dxy<mythres],myind)
			}
		if(length(newgroup)>1)
			{
			newgroup	<- newgroup[order(newgroup)]
			}
		slist[[i]]	<<- newgroup
		if(i==1)
			{
			clist	<<- list(newgroup)
			}else{
			boolnr	<- which(sapply(clist,function(x) any(newgroup %in% x)))
			if(length(boolnr)==0)
				{
				if(!silent){cat("No intersection. Adding new cluster.",sep="\n")}
				clist[[length(clist)+1]]	<<- newgroup  
				}else{
				nhits		<- length(boolnr)
				if(!silent){cat(paste("Elements of new cluster present in ",nhits," previously defined cluster(s). Combining.",sep=""),sep="\n")}
				newgroup					<- unique(c(unlist(clist[boolnr]),newgroup))
				clist[boolnr]				<<- NULL
				clist[[length(clist)+1]]	<<- newgroup 
				}
			}
		}
	# check if output is as expected:
	if(any(!myinds%in%unlist(clist)))
		{
		return(cat("ERROR: Missing individual in output list.",sep="\n"))
		}
	if(any(duplicated(unlist(clist))))
		{
		return(cat("ERROR: Duplicated individual in output list.",sep="\n"))
		}
	ngroups		<- length(clist)
	for(i in c(1:ngroups))
		{
		if(!silent){cat(i,sep="\n")}
		myinds1		<- unlist(clist[[i]])
		for(j in c(1:ngroups))
			{
			if(i!=j)
				{
				myinds2	<- unlist(clist[[j]])
				subdf	<<- dropdf[(dropdf$name1%in%myinds1&dropdf$name2%in%myinds2)|(dropdf$name1%in%myinds2&dropdf$name2%in%myinds1),]
				if(any(subdf$tmrca_y<mythres))
					{
					return(cat(paste("ERROR: Clusters ",i," and ",j," should be merged.",sep=""),sep="\n"))
					}
				}
			}	
		}	
	#
	# add dropped individual(s) to cluster with closest individual:
	mylengths	<- lengths(clist,use.names = TRUE)
	clist		<<- clist[order(mylengths,decreasing=TRUE)]
	if(!is.null(drop_ind))
		{
		cat("Adding dropped individuals...",sep="\n")
		for(i in c(1:length(drop_ind)))
			{
			myind		<- drop_ind[i]
			cat(myind,sep="\n")
			#if(!silent){cat(myind,sep="\n")}
			inddf		<- mydf[(mydf$name1==myind&!mydf$name2%in%drop_ind)|(mydf$name2==myind&!mydf$name1%in%drop_ind),]
			if(use_tmrca)
				{
				inddf		<- inddf[order(inddf$tmrca_y,decreasing=FALSE),]	
				}else{
				inddf		<- inddf[order(inddf$dxy,decreasing=FALSE),]
				}
			inddf		<<- inddf
			if(nrow(inddf)==0)
				{
				return(cat("ERROR: zero retained rows.",sep="\n"))
				}
			ind2		<- c(inddf$name1[1],inddf$name2[1])
			ind2		<- ind2[ind2!=myind]
			ind2		<<- ind2
			boolnr		<- which(sapply(clist,function(x) ind2 %in% x))
			boolnr		<<- boolnr
			oldgroup	<- unlist(clist[[boolnr]])
			newgroup	<- c(oldgroup,myind)
			clist[[boolnr]]	<<- newgroup[order(newgroup)] 
			}
		}
	cat("Done. Clusters stored at clist.",sep="\n")
	}
			
findclusters_old<-function(mythres=30000,silent=TRUE)
	{
	mydf	<- mydistdf
	myinds	<- unique(c(mydf$name1,mydf$name2))
	ninds	<- length(myinds)
	# 
	mylist	<<- list()	
	#
	for(i in c(1:ninds))
		{
		myind		<- myinds[i]
		if(!silent){cat(myind,sep="\n")}
		inddf		<- mydf[mydf$name1==myind&mydf$name2!=myind,]
		newgroup	<- c(inddf$name2[inddf$tmrca_y<mythres],myind)
		newgroup	<- newgroup[order(newgroup)]
		mylist[[i]]	<<- newgroup
		if(i==1)
			{
			mylist2	<<- mylist
			}else{
			boolnr	<- which(sapply(mylist2,function(x) myind %in% x))
			if(length(boolnr)==0)
				{
				if(!silent){cat("Individual not yet present. Adding new cluster.",sep="\n")}
				mylist2[[length(mylist2)+1]]	<<- newgroup  
				}else{
				nhits		<- length(boolnr)
				if(!silent){cat(paste("Individual present in ",nhits," previously defined cluster(s).",sep=""),sep="\n")}
				boolvec1	<- vector(length=nhits)
				boolvec2	<- vector(length=nhits)
				for(k in c(1:nhits))
					{
					mynr			<- boolnr[k]
					oldgroup		<- unlist(mylist2[mynr])
					boolvec1[k]		<- all(newgroup%in%oldgroup)
					boolvec2[k]		<- all(oldgroup%in%newgroup)
					}
				if(any(boolvec1&boolvec2))
					{
					if(!silent){cat("Identical subset. Not adding new cluster.",sep="\n")}
					}else{
					if(any(boolvec1&!boolvec2))
						{
						if(!silent){cat("New subset is a subset of previous subset. Not adding new cluster.",sep="\n")}
						}else{
						if(any(boolvec2&!boolvec1))
							{
							if(!silent){cat("Previous subset is a subset of current subset. Adding new cluster.",sep="\n")}
							if(!silent){cat("Adding new subset and removing previous subset.",sep="\n")}
							myoldnr				<- which(boolvec2&!boolvec1)
							mylist2[[myoldnr]]	<<- newgroup 
							}else{
							cat("Intersect, no subset. Combining subsets.",sep="\n")
							newgroup			<- unique(c(unlist(mylist2[boolnr]),newgroup))
							mylist2[boolnr]		<- NULL
							mylist2[[myoldnr]]	<<- newgroup 
							}
						}
					}
				}
			}
		}
	names(mylist)	<<- myinds
	}

maplea<-function(maxdemes=6,radiusratio=30,exporttype=NULL,popnames=mysambar$populations,plotperpop=FALSE,addlabels=FALSE)
	{
	npops			<- length(popnames)
	indstemp		<- inds[order(inds$pop),]
	mycoord			<- indstemp[indstemp$filter,c("longitude","latitude")]
	mypopnames		<- indstemp$pop[indstemp$filter]
	mysamplenrs		<- indstemp$nr[indstemp$filter]
	mydemes			<- c(2:maxdemes)
	totalnr			<- length(mydemes)
	#for(ndemes in mydemes)
	for(mynr in c(1:totalnr))
		{
		ndemes			<- mydemes[mynr]
		#myqmatrix		<- mysambar$leaqmatrixlist[[ndemes-1]]
		myqmatrix		<- mysambar$leaqmatrixlist[[mynr]]
		export_name		<- paste("LEA.qmatrixmap.K",ndemes,sep="")
		my_title		<- paste("K = ",ndemes,sep="")
		mapqmatrix(coord=mycoord,qmatrix=myqmatrix,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mytitle=my_title)
		if(plotperpop&npops>1)
			{
			for(my_pop	in popnames)
				{
				popqmatrix	<- myqmatrix[mypopnames==my_pop,]
				popcoord	<- mycoord[mypopnames==my_pop,]
				if(addlabels)
					{
					export_name	<- paste(paste("LEA.qmatrixmap.K",ndemes,"withlabels",sep=""),my_pop,sep=".")
					}else{
					export_name	<- paste(paste("LEA.qmatrixmap.K",ndemes,sep=""),my_pop,sep=".")
					}
				my_title	<- paste("K = ",ndemes,sep="")
				my_title2	<- my_pop
				if(addlabels)
					{
					my_labels	<- mysamplenrs[mypopnames==my_pop]
					}else{
					my_labels	<- NULL
					}
				if(nrow(unique(popcoord))==1)
					{
					cat(paste("Only one geographical position found for",my_pop,"population. Skipping.",sep=" "),sep="\n")
					}else{
					mapqmatrix(coord=popcoord,qmatrix=popqmatrix,aligncolours=FALSE,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mylabels=my_labels,mytitle=my_title,mytitle2=my_title2)
					}
				}
			}
		}
	}

mapdapc<-function(maxdemes=5,radiusratio=30,exporttype=NULL,popnames=mysambar$populations,plotperpop=FALSE,addlabels=FALSE)
	{
	mycoord			<- inds[inds$filter,c("longitude","latitude")]
	mypopnames		<- inds$pop[inds$filter]
	npops			<- length(mysambar$populations)
	mysamplenrs		<- inds$nr[inds$filter]
	mydemes			<- c(2:maxdemes)
	for(ndemes in mydemes)
		{
		myqmatrix		<- mysambar$dapcqmatrixlist[[ndemes-1]]
		export_name		<- paste("dapc.qmatrixmap.K",ndemes,sep="")
		export_name		<- paste(export_name,"meta",sep=".")
		my_title		<- paste("K = ",ndemes,sep="")
		mapqmatrix(coord=mycoord,qmatrix=myqmatrix,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mytitle=my_title)
		if(plotperpop&npops>1)
			{
			for(my_pop	in popnames)
				{
				popqmatrix	<- myqmatrix[mypopnames==my_pop,]
				popcoord	<- mycoord[mypopnames==my_pop,]
				if(addlabels)
					{
					export_name	<- paste(paste("dapc.qmatrixmap.K",ndemes,"withlabels",sep=""),my_pop,sep=".")
					}else{
					export_name	<- paste(paste("dapc.qmatrixmap.K",ndemes,sep=""),my_pop,sep=".")
					}
				my_title	<- paste("K = ",ndemes,sep="")
				my_title2	<- my_pop
				if(addlabels)
					{
					my_labels	<- mysamplenrs[mypopnames==my_pop]
					}else{
					my_labels	<- NULL
					}
				popunique	<- unique(popcoord)
				if(nrow(popunique)==1)
					{
					cat(paste("Only 1 geographical position found for",my_pop,"population. Skipping.", sep=" "),sep="\n")
					}else{
					mapqmatrix(coord=popcoord,qmatrix=popqmatrix,aligncolours=FALSE,radius_ratio=radiusratio,export=exporttype,exportname=export_name,mylabels=my_labels,mytitle=my_title,mytitle2=my_title2)
					}
				}
			}
		}
	}
	
mapqmatrix<-function(coord=NULL,qmatrix=NULL,popnames=mysambar$populations,mycols=NULL,radius_ratio=30,doinstall=FALSE,aligncolours=TRUE,export=NULL,exportname="qmatrix.map",mylabels=NULL,mytitle=NULL,mytitle2=NULL,silent=TRUE)
	{
	# radius_ratio is the ratio between radius and either longitude or latitude span (the smaller of the two)
	# e.g: if longitude ranges from 10 to 20, and radius_ratio is set to 40, the radius of the piecharts will equal 10/40 = 0.25. 
	if(is.null(coord))
		{
		return(cat("ERROR: you should input a matrix with geographical coordinates (i.e. longitude and latitude) of your samples to coord flag",sep="\n"))
		}
	if(is.null(qmatrix))
		{
		return(cat("ERROR: you should input a qmatrix to qmatrix flag.",sep="\n"))
		}
	if(is.null(mycols))
		{
		mycols	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","deepskyblue","greenyellow","indianred1","gray20")
		}
	if(doinstall)
		{
		myrepos='http://cran.us.r-project.org'
		# add.pie function is part of package mapplots:
		install.packages("mapplots",repos='http://cran.us.r-project.org')
		library(mapplots)
		# geographical map from rworldmap:
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos)}
		if("rworldmap" %in% (.packages()) == FALSE) 					{library(rworldmap)}
		}
	npops		<- length(popnames)
	nclusters	<- ncol(qmatrix)
	ncolours	<- ifelse(nclusters>npops,nclusters,npops)
	# attempt to get colours aligned with population colours:
	if(aligncolours&npops>1&nclusters<=npops)
		{
		mycols			<- mycols[1:ncolours]
		popcoord		<- data.frame(pop=popnames,col=mycols,long=NA,lat=NA)
		for(mypop in popnames)
			{
			popcoord$long[popcoord$pop==mypop]	<- mean(inds$longitude[inds$pop==mypop&inds$filter])
			popcoord$lat[popcoord$pop==mypop]	<- mean(inds$latitude[inds$pop==mypop&inds$filter])
			}
		myqdf				<- as.data.frame(qmatrix)
		myqdf$max			<- apply(qmatrix,1,which.max)	
		myqdf$colour		<- NA
		mycolours			<- vector()
		for(i in c(1:ncol(qmatrix)))
			{
			mylong			<- mean(coord$longitude[myqdf$max==i])
			mylat			<- mean(coord$latitude[myqdf$max==i])
			mycol			<- as.vector(popcoord$col[which.min(abs(mylong-popcoord$long)+abs(mylat-popcoord$lat))])
			myqdf$colour[myqdf$max==i]	<- mycol
			mycolours[i]	<- mycol
			}
		if(any(duplicated(mycolours)))
			{
			cat("No clear agreement between geographic locations of predefined populations and those of the inferred clusters.",sep="\n")
			cat("Defaulting to random colour assignment.",sep="\n")
			mycolours			<- mycols[1:ncolours]
			}
		}else{
		mycolours				<- mycols[1:ncolours]
		}
	# plot:
	if("rworldmap"%in%(.packages()) == FALSE){library(rworldmap)}
	newmap 		<- getMap(resolution = "low")
	myratio		<- (max(coord$longitude)-min(coord$longitude))/max((coord$latitude)-min(coord$latitude))
	if(!is.null(export))
		{
		if(myratio<1)
			{
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8/myratio,width=6)}
			}else{
			if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8,width=6*myratio)}
			}
		if(!silent){cat(paste("Writing pdf file called:", exportname,sep=" "),sep="\n")}
		}
	#testcoord	<<- coord
	plot(coord,xlab="",ylab="",type="n",las=1)
	plot(newmap,add=T,col="grey90",border="white")
	box(col="grey90")
	longrange	<- max(coord$longitude)-min(coord$longitude)
	latrange	<- max(coord$latitude)-min(coord$latitude)
	if(latrange<longrange)
		{
		myradius	<- latrange/radius_ratio
		}else{
		myradius	<- longrange/radius_ratio
		}
	for (i in 1:nrow(qmatrix))
		{
		add.pie(z=qmatrix[i,],x=coord[i,1],y=coord[i,2],labels="",radius=myradius,col=mycolours)
		}
	if(!is.null(mylabels))
		{
		text(mylabels,x=coord[,1],y=coord[,2],cex=1,col="white")
		}
	mtext("Longitude",side=1,line=2.75,cex=1.5)
	mtext("Latitude",side=2,line=2.75,cex=1.5)
	if(!is.null(mytitle)){mtext(mytitle,side=3,line=0,cex=1.5)}
	if(!is.null(mytitle2)){mtext(mytitle2,side=3,line=1.25,cex=1.5)}
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Closed pdf file.",sep="\n")}
		}
	}	

multi_mantel_plot<-function(popnames=mysambar$populations,doexport=FALSE,silent=TRUE)
	{
	if(!"pidf_meta" %in% names(mysambar))
		{
		calcpi(pi_per_pop=FALSE)
		}
	# between all populations:
	if(!silent){cat("between and within populations...",sep="\n")}
	mantel_plot(pi_df=mysambar$pidf_metalist[[1]],export=doexport,exportname="Mantel.meta.withlegend",addlegend=TRUE)
	mantel_plot(pi_df=mysambar$pidf_metalist[[1]],export=doexport,exportname="Mantel.meta",addlegend=FALSE)
	# between all populations, excluding within population comparisons:
	if(!silent){cat("between populations...",sep="\n")}
	mantel_plot(pi_df=mysambar$pidf_metalist[[1]],export=doexport,exportname="Mantel.meta.onlybetweenpops.withlegend",addlegend=TRUE,only_betweenpop=TRUE)
	mantel_plot(pi_df=mysambar$pidf_metalist[[1]],export=doexport,exportname="Mantel.meta.onlybetweenpops",addlegend=FALSE,only_betweenpop=TRUE)
	#
	# within each population:
	nrpops	<- length(popnames)
	if(nrpops>1)
		{
		if(!"pidf_pop" %in% names(mysambar))
			{
			if(!silent){cat("calculating pi...",sep="\n")}
			calcpi(pi_per_pop=TRUE)
			}
		if(!silent){cat("per population...",sep="\n")}
		for(mypopname in popnames)
			{
			if(!silent){cat(mypopname,sep="\n")}
			mypopdf		<- mysambar$pidf_poplist[[which(names(mysambar$pidf_poplist)==mypopname)]]
			export_name	<- paste("Mantel",mypopname,"within",sep=".")
			mantel_plot(pi_df=mypopdf,export=doexport,exportname=export_name,addlegend=FALSE)
			}
		}
	}
	
# 22_05_2019: depends on output of calcpi (flag 'perpop' can be false I think) 	
seqdivplot<-function(popnames=mysambar$populations,nsites=NULL,export=FALSE)
	{
	if(!("pidf_meta" %in% names(mysambar)))
		{
		calcpi(pi_per_pop=FALSE)
		}
	pi_df				<- mysambar$pidf_metalist[[1]]
	pi_df$nsegsites		<- NA
	nsnps				<- nrow(snps)
	npops				<- length(popnames)
	mycols				<- mysambar$mycolours[1:npops]
	combipoptable		<- combn(popnames,m=2)
	combicoltable		<- combn(mycols,m=2)
	combicolvector		<- vector()
	combipopvector		<- vector()
	npairwise			<- ncol(combicoltable)
	ntotal				<- npops+npairwise
	for(i in c(1:npairwise))
		{
		mycol1				<- combicoltable[1,i]
		mycol2				<- combicoltable[2,i]
		mycolfunc3 			<- colorRampPalette(c(mycol1,mycol2))
		combicolvector[i]	<- mycolfunc3(3)[2]
		combipopvector[i]	<- ifelse(combipoptable[1,i]<combipoptable[2,i],paste(combipoptable[1,i],combipoptable[2,i],sep="_"),paste(combipoptable[2,i],combipoptable[1,i],sep="_"))
		}
	for(i in c(1:nrow(pi_df)))
		{
		mypop1				<- pi_df$pop1[i]
		mypop2				<- pi_df$pop2[i]
		mymaf1				<- snps[,paste("maf",mypop1,sep="_")]
		mymaf2				<- snps[,paste("maf",mypop2,sep="_")]
		pi_df$comparison[i]<-ifelse(pi_df$pop1[i]==pi_df$pop2[i],pi_df$pop1[i],ifelse(pi_df$pop1[i]<pi_df$pop2[i],paste(pi_df$pop1[i],pi_df$pop2[i],sep="\n"),paste(pi_df$pop2[i],pi_df$pop1[i],sep="\n")))
		pi_df$comparison2[i]<-ifelse(mypop1==mypop2,"within","between")
		pi_df$nsegsites[i]	<- length(mymaf1[mymaf1>0|mymaf2>0])
		}
	# plot:
	if(!is.null(nsites))
		{
		if(!is.null(nsites))
			{
			if(length(nsites)>1)
				{
				cat("Length of vector input to nsites flag is greater than 1. This suggests that SNP datasets are derived from different genomic regions.",sep="\n")
				return(cat("Therefore, SambaR will not calculate genome wide sequence divergence.",sep="\n"))
				}
			}
		#pi_df$genomepi	<- pi_df$ndiffpersite*nsnps/nsites*100
		pi_df$genomepi	<- pi_df$ndiffpersite*pi_df$nsegsites/nsites*100
		if(export){pdf("Divergence.betweensamples.genomewide.pdf",width=ntotal*1,height=7.5)}
		layout(matrix(c(rep(1,npops),(rep(2,npairwise))),nrow=1,ncol=ntotal))
		par(oma=c(10,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
		mymin					<- min(pi_df$genomepi,na.rm=TRUE)
		mymax					<- max(pi_df$genomepi,na.rm=TRUE)
		boxplot(pi_df$genomepi[pi_df$comparison2=="within"]~pi_df$comparison[pi_df$comparison2=="within"],las=3,ylim=c(mymin,mymax),col=mycols[order(popnames)],ylab="",xlab="")
		boxplot(pi_df$genomepi[pi_df$comparison2=="between"]~pi_df$comparison[pi_df$comparison2=="between"],las=3,ylim=c(mymin,mymax),col=combicolvector[order(combipopvector)],yaxt='n',xlab="")
		mtext(side=2,"Sequence dissimilarity (%)",line=2.5,cex=1.75,outer=TRUE,las=0)
		if(export){dev.off()}
		}else{
		if(export){pdf("Divergence.betweensamples.snpsonly.pdf",width=ntotal*1,height=7.5)}
		layout(matrix(c(rep(1,npops),(rep(2,npairwise))),nrow=1,ncol=ntotal))
		par(oma=c(10,5,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2)
		mymin					<- min(pi_df$ndiffpersite,na.rm=TRUE)
		mymax					<- max(pi_df$ndiffpersite,na.rm=TRUE)
		boxplot(pi_df$ndiffpersite[pi_df$comparison2=="within"]~pi_df$comparison[pi_df$comparison2=="within"],las=3,ylim=c(mymin,mymax),col=mycols,ylab="",xlab="")
		boxplot(pi_df$ndiffpersite[pi_df$comparison2=="between"]~pi_df$comparison[pi_df$comparison2=="between"],las=3,ylim=c(mymin,mymax),col=combicolvector,yaxt='n',xlab="")
		mtext(side=2,"SNP dissimilarity",line=2.5,cex=1.75,outer=TRUE,las=0)
		if(export){dev.off()}
		}
	#pi_df<<- pi_df
	}

# 21-06-2022: renamed, originally called popmantel
fstmantel<-function()
	{
	# fst:
	fstmat				<- mysambar$popneimatrix
	fstmat[lower.tri(fstmat)]	<- fstmat[upper.tri(fstmat)]
	fst_distmatrix		<- as.dist(fstmat)
	#
	# geo:
	popcoorddf			<- inds[inds$filter,c("pop","longitude2","latitude")]
	poplong 			<- aggregate(popcoorddf$longitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
	poplat 				<- aggregate(popcoorddf$latitude,by=list(popcoorddf$pop),FUN=mean,na.rm=TRUE)
	colnames(poplong)	<- c("pop","longitude")
	poplong$latitude	<- poplat$x 
	npops				<- nrow(poplong)
	geo_distmatrix		<- dist(poplong[,c("longitude","latitude")])
	#
	plot(geo_distmatrix,fst_distmatrix,pch=16,cex=0.75,col="grey",ylab="",xlab="")
	geomat				<- as.matrix(geo_distmatrix)
	colnames(geo_distmatrix)	<- poplong$pop
	rownames(geo_distmatrix)	<- poplong$pop
	geodist				<<- geo_distmatrix
	fstmat				<<- fstmat
	}

# 21_06_2022: depreciated, replaced by new dxymantel function.
mantel_plot_old<-function(gdistmat=NULL,pi_df=mysambar$pidf_metalist[[1]],export=FALSE,addlegend=TRUE,exportname="Mantel",silent=TRUE,only_betweenpop=FALSE,only_withinpop=FALSE,my_pops=NULL)
	{
	# extract dataset info:
	if(is.null(nrow(pi_df)))
		{
		return(cat("ERROR: pi_df does not exist.",sep="\n"))
		}
	popnames			<- as.vector(unique(c(pi_df$pop1,pi_df$pop2)))
	my_inds				<- as.vector(unique(c(pi_df$ind1,pi_df$ind2)))
	npops				<- length(popnames)
	ninds				<- nrow(my_inds)
	mycols				<- mysambar$mycolours[1:npops]
	# prepare matrices:
	colour_matrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=TRUE,onlybetweenpop=only_betweenpop)
	my_cols				<- colour_matrix[lower.tri(colour_matrix)]
	if(!is.null(my_pops))
		{
		pi_distmatrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=FALSE,onlybetweenpop=only_betweenpop,onlywithinpop=only_withinpop,mypops=my_pops[inds$filter])
		}else{
		pi_distmatrix		<- pidf2matrix(pidf=pi_df,myinds=my_inds,do_colour=FALSE,onlybetweenpop=only_betweenpop,onlywithinpop=only_withinpop)
		}
	pi_distmatrix		<- as.dist(pi_distmatrix)
	geo_distmatrix		<- dist(inds[my_inds,c("longitude","latitude")])
	if(!silent)
		{
		pi_distmat		<<- pi_distmatrix
		geo_distmat		<<- geo_distmatrix 
		}
	if(length(as.vector(geo_distmatrix))>2)
		{
		mantel.lm			<- lm(as.vector(pi_distmatrix)~as.vector(geo_distmatrix))
		mantel_pvalue		<- as.vector(round(summary(mantel.lm)$coefficients[,4],4)[2])
		mantel_r2			<- round(summary(mantel.lm)$r.squared,4)
		}
	#
	# plot:
	if(export){pdf(paste(exportname,"pdf",sep="."))}
	plot(geo_distmatrix,pi_distmatrix,pch=16,cex=0.75,col=my_cols,ylab="",xlab="")
	mtext("Geographical distance (degrees)",side=1,line=2.5,cex=2)
	mtext("Genetic distance (pi)",side=2,line=2.5,cex=2)
	if(addlegend&npops>1)
		{
		combipoptable		<- combn(popnames,m=2)
		combipopvector		<- paste(combipoptable[1,],combipoptable[2,],sep="_")	
		combicoltable		<- combn(mycols,m=2)
		combicolvector		<- vector()
		for(i in c(1:ncol(combicoltable)))
			{
			mycol1				<- combicoltable[1,i]
			mycol2				<- combicoltable[2,i]
			mycolfunc3 			<- colorRampPalette(c(mycol1,mycol2))
			combicolvector[i]	<- mycolfunc3(3)[2]
			}
		mycex	<- ifelse(ncol(combipoptable)<10,1.25,ifelse(ncol(combipoptable)>30,ifelse(ncol(combipoptable)>40,0.4,0.5),0.75))	
		if(only_betweenpop)
			{
			legend("bottomright",legend=combipopvector,fill=combicolvector,cex=mycex,bty='n')
			}else{
			legend("bottomright",legend=c(popnames,combipopvector),fill=c(mycols,combicolvector),cex=mycex,bty='n')
			}
		}
	# regression R2 and p-value:
	if(length(as.vector(geo_distmatrix))>2)
		{
		abline(mantel.lm,lwd=2)
		}
	legend("topright",legend=c(paste("R2 = ",mantel_r2,sep=""),paste("p-value = ",mantel_pvalue,sep="")),lty=2,col=c(NA,NA),bty='n',cex=1.5)
	#
	if(npops==1)
		{
		mtext(popnames,side=3,line=0.25,cex=2)
		}
	if(export){dev.off()}
	#
	#mytest	<- mantel.rtest(geo_distmat,pi_distmat,nrepet = 9999)
	#abline(lm(pi_distmatrix ~ geo_distmatrix),lty=2,lwd=2)
	}

runtess3<-function(export="pdf",nloci=NULL,maxK=6,myrepos='http://cran.us.r-project.org')
	{
	# get required packages:
	if("sp" %in% rownames(installed.packages()) == FALSE) {install.packages("sp",repos=myrepos)}
	if("tess3r" %in% rownames(installed.packages()) == FALSE)  {install_github("bcm-uga/TESS3_encho_sen")}
	if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages("rworldmap",repos=myrepos)}
	library(sp)
	library(tess3r)
	library(rworldmap)
	# If you can not install tess with install_github, you might try to install from binary.
	# To do so, first download as zip from: "bcm-uga/TESS3_encho_sen"
	# install.packages(mypath=...,repos=NULL,type="binary")
	#
	# create TESS3 object:
	mycoord					<- as.matrix(inds[inds$filter,c("longitude","latitude")])	# in tess3 first latitude, then longitude. Input for tess2tess: first column longitude, second column latitude. If you reverse the order, you will eventually get an ERROR when plotting
	mytess3					<- list()
	if(!is.null(nloci))
		{
		mygeno				<- as.matrix(mygenlight)[inds$filter,c(1:nloci)]
		}else{
		mygeno				<- as.matrix(mygenlight)[inds$filter,snps$filter]
		}
	mytess3$X				<- mygeno
	mytess3$coord			<- as.matrix(inds[inds$filter,c("latitude","longitude")])	
	#
	# run the analysis:
	tessout  				<<- tess3(X = mytess3$X, coord = mycoord, K = 1:maxK, ploidy = 2, openMP.core.num = 4)
	#
	# Cluster plot: the best choice for the K value is mostly (but not strictly) when the cross-validation curve exhibits a plateau or starts increasing.
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Tess.numberofclusters.pdf")}
		}
	plot(tessout,pch=19,col ="blue",xlab ="Number of ancestral populations",ylab ="Cross-Validation score",type='l')
	if(!is.null(export)){dev.off()}
	# other plots still to be incorporated
	}

maptess<-function(use_lea=FALSE,mydemes=c(2:5),export=NULL,marine=TRUE,mysize=10,myfactor=0.5,mycex=0.75,multiplot=FALSE,myresolution=c(600,600),ncolour=20,myrepos='http://cran.us.r-project.org')  
	{
	# by default this function expects to find in the global environment an object called 'tessout', output of tess3 function of the tess3r package.
	# tessout is generated with SambaR's runtess3 function.
	# if (use_lea is TRUE, function expects to find mysambar$leaqmatrixlist
	#
	# multiplot is designed for 4 tiles
	#
	my.colors	<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20","deepskyblue","greenyellow","indianred1")
	my.palette 	<- CreatePalette(my.colors,(ncolour+1))
	for(i in c(1:length(my.palette)))
		{
		my.palette[i][[1]]	<- my.palette[i][[1]][1:ncolour]
		}
	# map.max: all colours
	# map.all: only one colour
	# mapmethod	<- ifelse(mapmax,"map.max","map.all")
	#
	if(use_lea)
		{
		if(is.null(mysambar$leaqmatrixlist))
			{
			return(cat("WARNING: LEA qmatrix not found. Not creating map.",sep="\n")) 
			}
		}
	# select data:
	mysubset   	<- as.matrix(mygenlight)[inds$filter,snps$filter]
	tesscoord	<- as.matrix(inds[inds$filter,c("longitude","latitude")])
	nsamples	<- nrow(mysubset)
	tesscoord2	<- as.data.frame(tesscoord)
	#
	if(marine)
		{
		# if needed, load required packages:
		if("sp" %in% rownames(installed.packages()) == FALSE) {install.packages("sp",repos=myrepos)}
		if("rworldmap" %in% rownames(installed.packages()) == FALSE) {install.packages("rworldmap",repos=myrepos)}
		if("raster" %in% rownames(installed.packages()) == FALSE) {install.packages("raster",repos=myrepos)}
		library(sp)
		library(rworldmap)
		library(raster)
		newmap 		<- getMap(resolution = "low")
		}
	# create polygon:
	lonmin		<- min(tesscoord[,1])
	lonmax 		<- max(tesscoord[,1])
	londiff 	<- lonmax-lonmin
	latmin 		<- min(tesscoord[,2])
	latmax 		<- max(tesscoord[,2])
	latdiff 	<- latmax-latmin
	lonmin		<- lonmin-0.2*londiff		# add margin
	lonmax		<- lonmax+0.2*londiff		# add margin
	latmin		<- latmin-0.2*latdiff		# add margin
	latmax		<- latmax+0.2*latdiff		# add margin
	x_coord 	<- c(lonmin,lonmax,lonmax,lonmin) 
	y_coord 	<- c(latmin,latmin,latmax,latmax)
	xym 		<- cbind(x_coord, y_coord)
	p			<- Polygon(xym)
	ps 			<- Polygons(list(p),1)
	sps			<- SpatialPolygons(list(ps))
	myratio		<- (lonmax-lonmin)/(latmax-latmin)
	#
	graphics.off()
	if((!is.null(export)))
		{
		if(multiplot)
			{
			# see below, within for-loop, for single plots:
			if(use_lea)
				{
				exportname	<- paste("LEA.allK.map",nsamples,"samples.pdf",sep=".")
				}else{
				exportname	<- paste("Tess.allK.map",nsamples,"samples.pdf",sep=".")
				}
			if(myratio>1)
				{
				if(export=="pdf"){pdf(exportname,height=mysize,width=mysize*myratio)}
				}else{
				if(export=="pdf"){pdf(exportname,height=mysize*1/myratio,width=mysize)}
				}
			}
		}
	if(multiplot)
		{
		layout(matrix(c(1:4),2,2,byrow = TRUE))
		par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5)
		}
	for(ndemes in mydemes)
		{
		cat(paste("Plotting map for K = ",ndemes,sep=""),sep="\n")
		if(use_lea)
			{
			mymatrix			<- mysambar$leaqmatrixlist[[ndemes-1]]
			colnames(mymatrix)	<- NULL
			# reorder:
			indstemp			<- inds[inds$filter,]
			indstemp			<- indstemp[order(indstemp$poplong),]
			mymatrix			<- mymatrix[order(indstemp$name),]
			# convert to tess qmatrix class:
			myqmatrix			<- as.qmatrix(mymatrix)
			}else{
			myqmatrix 			<- qmatrix(tessout, K = ndemes)
			}
		if(!is.null(export)&(!multiplot))
			{
			if(use_lea)
				{
				exportname	<- paste("LEA.map",ndemes,"clusters",nsamples,"samples.pdf",sep=".")
				}else{
				exportname	<- paste("Tess.map",ndemes,"clusters",nsamples,"samples.pdf",sep=".")
				}
			if(myratio>1)
				{
				if(export=="pdf"){pdf(exportname,height=mysize,width=mysize*myratio*myfactor)}
				}else{
				if(export=="pdf"){pdf(exportname,height=mysize*1/myratio*myfactor,width=mysize)}
				}
			}
		if(marine)
			{
			if(multiplot)
				{
				if(ndemes==2){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "",xaxt='n')}
				if(ndemes==3){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "",xaxt='n',yaxt='n')}
				if(ndemes==4){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "")}
				if(ndemes==5){plot(myqmatrix,tesscoord, method = "map.max", cex = mycex, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "",yaxt='n')}
				}else{
				plot(myqmatrix,tesscoord, method = "map.max", cex = .5, map.polygon=sps, interpol = FieldsKrigModel(10), main = "", resolution = myresolution, col.palette = my.palette, xlab = "", ylab = "")
				points(tesscoord2$longitude,tesscoord2$latitude,pch=16,cex=mycex,col="black")
				mtext(text="Latitude",cex=1.75,side=2,line=-2,outer=TRUE)
				mtext(text="Longitude",cex=1.75,side=1,line=-2.5,outer=TRUE)
				}
			plot(newmap, xlim=xrange, ylim=yrange, add=TRUE,col="grey85",border="white")
			points(tesscoord2$longitude,tesscoord2$latitude,pch=16,cex=mycex,col="black")
			mtext(text=(paste("K = ",ndemes,sep="")),side=3,cex=1.5,line=0)
			box(lwd=0.5)
			}else{
			#if(ndemes==2){colpalette	<- my.palette}
			#if(ndemes==3){colpalette	<- my.palette[c(2,1,3,4,5)]}
			#if(ndemes==4){colpalette 	<- my.palette[c(3,5,1,2,4)]}
			#if(ndemes==5){colpalette 	<- my.palette[c(1,3,2,5,4)]}
			colpalette 	<- my.palette[1:ndemes]
			plot(myqmatrix, tesscoord, method ="map.max", interpol=FieldsKrigModel(10), main="Ancestry coefficients", xlab="Longitude", ylab="Latitude", resolution=c(300,300), cex=mycex, col.palette = colpalette)
			points(tesscoord2$longitude,tesscoord2$latitude,pch=16,cex=mycex,col="black")
			box(lwd=0.5)
			}
		if(!(is.null(export))&!(multiplot)){dev.off()}
		}
	if(multiplot)
		{
		mtext(text="Latitude",cex=2.25,side=2,line=1,outer=TRUE)
		mtext(text="Longitude",cex=2,side=1,line=1.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	}

# Generate dummy longitude and latitude data, needed to run tess3r:
dummycoord<-function(new_coord=TRUE,plot_coord=TRUE,indsfilter=inds$filter,range=3)
	{
	if(new_coord)
		{
		inds$longitude	<<- NA
		inds$latitude	<<- NA
		inds$longitude[inds$pop=="Busen"]	<<- 4.9+runif(nrow(inds[inds$pop=="Busen",]))*range
		inds$longitude[inds$pop=="Barff"]	<<- 6.9+runif(nrow(inds[inds$pop=="Barff",]))*range
		inds$longitude[inds$pop=="Norway"]	<<- 8.9+runif(nrow(inds[inds$pop=="Norway",]))*range
		inds$latitude[inds$pop=="Busen"]	<<- 52.3+runif(nrow(inds[inds$pop=="Busen",]))*range
		inds$latitude[inds$pop=="Barff"]	<<- 50.3+runif(nrow(inds[inds$pop=="Barff",]))*range
		inds$latitude[inds$pop=="Norway"]	<<- 48.3+runif(nrow(inds[inds$pop=="Norway",]))*range
		}
	if(plot_coord)
		{
		plot(inds$longitude[indsfilter],inds$latitude[indsfilter])
		points(inds$longitude[inds$pop=="Busen"&indsfilter],inds$latitude[inds$pop=="Busen"&indsfilter],col="blue")
		points(inds$longitude[inds$pop=="Barff"&indsfilter],inds$latitude[inds$pop=="Barff"&indsfilter],col="green")
		points(inds$longitude[inds$pop=="Norway"&indsfilter],inds$latitude[inds$pop=="Norway"&indsfilter],col="red")
		}
	}

getgeneland<-function(myrepos='http://cran.us.r-project.org',noupdates=TRUE,mylib=NULL,mypath="C:/Users/Tatiana/Menno/Programs/Geneland/Geneland_4.0.8.zip")
	{
	if(is.null(mylib))
		{
		if("devtools" %in% rownames(installed.packages()) == FALSE)		{install.packages("devtools",repos=myrepos)}
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos)}
		if("coda" %in% rownames(installed.packages()) == FALSE)			{install.packages("coda",repos=myrepos)}
		if("Geneland" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="binary")}
		}else{
		if("rworldmap" %in% rownames(installed.packages()) == FALSE)	{install.packages("rworldmap",repos=myrepos,lib=mylib)}
		if("coda" %in% rownames(installed.packages()) == FALSE)			{install.packages("coda",repos=myrepos,lib=mylib)}
		if("Geneland" %in% rownames(installed.packages()) == FALSE)		{install.packages(mypath,repos=NULL,type="source",lib=mylib)}
		}
	if("rworldmap" %in% (.packages()) == FALSE) 						{library(rworldmap)}
	if("coda" %in% (.packages()) == FALSE) 								{library(coda)}
	if("Geneland" %in% (.packages()) == FALSE) 							{library(Geneland)}
	library(coda)
	library(Geneland)
	newmap <<- getMap(resolution = "low")
	# I wrote a function to convert from genlight to structure format.
	# Originally, I used dartR to do this conversion. This package depends on several other packages:
	# if("directlabels" %in% rownames(installed.packages()) == FALSE)		{install.packages("directlabels",repos=myrepos)}
	# if("PopGenReport" %in% rownames(installed.packages()) == FALSE)		{install.packages("PopGenReport",repos=myrepos)}
	# if("leaflet" %in% rownames(installed.packages()) == FALSE)			{install.packages("leaflet",repos=myrepos)}
	# if("pca3d" %in% rownames(installed.packages()) == FALSE)			{install.packages("pca3d",repos=myrepos)}
	# if("rrBLUP" %in% rownames(installed.packages()) == FALSE)			{install.packages("rrBLUP",repos=myrepos)}
	# if("dartr" %in% rownames(installed.packages()) == FALSE)			{install.packages("dartr",repos=myrepos)}
	# or from binary:
	# install.packages("C:/Users/Tatiana/Menno/Programs/dartr/dartR_1.1.11.zip",repos=NULL,type="binary")
	# library(dartR)
	}

# ADDITIONAL ANALYSIS: Geneland
# Because Geneland takes a while to run, the user has to call these functions separately. 
# SambaR expects to find within the inds dataframe columns named ‘longitude’ and ‘latitude’ (included during execution of the importdata() function).  

# Geneland needs to be installed from either a zipfile (Windows) or tarball (Unix). You can download these files from: https://i-pri.org/special/Biostatistics/Software/Geneland/distrib/
# To install on a Windows computer, type on R command line:
# getgeneland(mypath="C:/path/to/Geneland_4.0.8.zip",mylib=NULL)
# To install on a Unix computer, type on R command line:
# getgeneland(mypath="/path/to/Geneland_4.0.8.tar.gz",mylib="/path/to/your/storage/dir/")
# To run Geneland and subsequently plot the output, type:
# runandplotgeneland(my_iter=10000,burnin_fraction=0.2,my_thin=100,nloci=1000)
# The settings my_iter, burnin_fraction, and my_thin can be used the alter the MCMC chain settings. The flag nloci determines how many (randomly selected) loci will be used for the analysis. This number can, obviously, not exceed the number of retained snps in your snps dataframe. Depending on the capacities of your computer, there are limits to the combinations of my_iter, my_thin and nloci. If you set these values too high, you will encounter an error about memory allocation. Therefore you might not be able to use all your snps. 
# The output will be stored in the folder ‘Genelandoutput’ in the structure directory. 

# I don't mention Geneland anymore in the manual. Why not?
# When running Geneland, I have to subset the data because of memory allocation limits.
# You could argue to select loci with high minor allele frequencies (more informative), but I am afraid this is a biased representation of the dataset, which might affect the outcome
# So instead I sample randomly.	
# 10000 iterations for 1000 loci does not resolve population structure correctly according to my trials.
# I assigned to my Busen, Barff and Norway samples random geographical locations, clustered per population but with slight overlap
# The overlapping samples were wrongly assigned. 
# 100000 iterations with 1000 loci is not possible on my computer (memory allocation ERROR)
# 100000 iterations with 100 loci does not find the right structure (not even close)   
# 100000 iterations with 450 loci is not possible on my computer (memory allocation ERROR)
# 100000 iterations with 400 loci ... memory allocation ERROR when outputting results
# 100000 iterations with 200 loci does not resolve population structure correctly (not even closely)
# 1000 iterations with 1000 loci does not resolve population structure correctly either
# 10000 iterations with 2000 loci overclusters
# 10000 iterations with 2000 loci and correlated set to FALSE, underclusters
runandplotgeneland<-function(my_iter=10000,burnin_fraction=0.2,my_thin=100,doanalysis=TRUE,doplots=TRUE,initK=5,Kmax=8,nloci=1000,correlation=FALSE)
	{
	# mysambar$mycolours has 8 default colours, hence Kmax=8 
	if(!("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
		{
		return(cat("ERROR: No longitude and/or latitude column present in inds dataframe.",sep="\n"))
		}
	savediter	<- my_iter/my_thin
	myburn		<- savediter*burnin_fraction
	cat(paste("Number of iterations before thinning:",my_iter,sep=" "),sep="\n")
	cat(paste("Number of iterations after thinning:",savediter,sep=" "),sep="\n")	
	cat(paste("Burn-in (after thinning):",myburn,sep=" "),sep="\n")
	myfolder	<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	if(doanalysis)
		{
		rungeneland(myiter=my_iter,var_npop=TRUE,n_init=initK,popmax=Kmax,mythinning=my_thin,myburn=myburn,nloc=nloci,correlated=correlation)
		checkconvergence(myburnin=myburn,export="pdf")
		}
	if(doplots)
		{
		cat("Creating plots using Geneland functions...",sep="\n")
		genelandplotting(myburnin=myburn)
		cat("Creating additional plots using SambaR functions...",sep="\n")
		scattergeneland(myiter=my_iter,myburnin=myburn,gradient=FALSE,export="pdf",makeplots=TRUE)
		scattergeneland(myiter=my_iter,myburnin=myburn,gradient=TRUE,export="pdf",makeplots=TRUE)
		cat("Analysis finished.",sep="\n")
		myendtime	<- Sys.time()
		exportname	<- paste(myfolder,"endtime.txt",sep="")
		write.table(myendtime,exportname,quote=FALSE,col.names=FALSE)
		}
	}	

rungeneland<-function(myiter=10000,var_npop=TRUE,n_init=5,popmax=8,mythinning=100,myburnin=2,nloc=1000,correlated=FALSE)
	{
	# since we filter on maf, we can be sure that all loci have 2 alleles per loci, and so 2 columns per locus once we converted from genlight to structure.
	nind					<- nrow(inds[inds$filter,])
	genlight2structure(snpsfilter=snps$filter,indsfilter=inds$filter)
	geno					<- mysambar$mystructure[,c(3:ncol(mysambar$mystructure))]
	# subsample:
	#mysample				<- sample(c(1:(ncol(geno)-1)),nloc,replace=FALSE)
	#mysample2				<- c(mysample,(mysample+1))
	#mysample				<- mysample2[order(mysample2)]
	geno					<- geno[,c(1:(nloc*2))]
	coord					<- inds[inds$filter,c("longitude","latitude")]
	myfolder				<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	dir.create(myfolder)
	cat("Running MCMC analyses...",sep="\n")
	myfreqmodel				<- ifelse(correlated,"Correlated","Uncorrelated")
	MCMC(coordinates=coord,delta.coord=0,geno.dip.codom=geno,varnpop=var_npop,npopinit=n_init,spatial=TRUE,freq.model=myfreqmodel,nit=myiter,thinning=mythinning,rate.max=nind,npopmax=popmax,nb.nuclei.max=3*nind,path.mcmc=myfolder)
	PostProcessChain(coordinates=coord,path.mcmc=myfolder,nxdom=100,nydom=100,burnin=myburnin)
	}
		
# as of 26_03_2019 depreciated:	
rungeneland_old<-function(myiter=10000,var_npop=TRUE,n_init=6,popmax=10,mythinning=100,myburnin=2)
	{
	nind					<- nrow(inds[inds$filter,])
	cat("Converting from genlight to structure format...",sep="\n")
	# since we filter on maf, we can be sure that all loci have 2 alleles per loci.
	mymatrix				<- as.matrix(mygenlight[inds$filter,snps$filter])
	#mymatrix				<- mymatrix[,c(1:1000)]
	nloci					<- ncol(mymatrix)
	tempgl					<- as.genlight(mymatrix)
	mycoorddf				<- as.matrix(cbind(inds$latitude[1:ninds],inds$longitude[1:ninds]))
	colnames(mycoorddf)		<- c("lat","lon")
	tempgl$other$latlong	<- mycoorddf
	gl2structure(tempgl,outfile="mydata.stru",outpath=mysambar$inputfilesdir,v=0)
	mystructure				<- read.structure("mydata.stru",n.ind=nind,n.loc=nloci,onerowperind=FALSE,col.lab=0,col.pop=0,col.others=2,row.marknames=1)
	geno					<- as.matrix(mystructure)
	coord					<- inds[inds$filter,c("longitude","latitude")]
	myfolder				<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	dir.create(myfolder)
	cat("Running MCMC analyses...",sep="\n")
	MCMC(coordinates=coord,delta.coord=0,geno.dip.codom=geno,varnpop=var_npop,npopinit=n_init,spatial=TRUE,freq.model="Correlated",nit=myiter,thinning=mythinning,rate.max=nind,npopmax=popmax,nb.nuclei.max=3*nind,path.mcmc=myfolder)
	PostProcessChain(coordinates=coord,path.mcmc=myfolder,nxdom=100,nydom=100,burnin=myburnin)
	}

checkconvergence<-function(myburnin=2,export=NULL)
	{
	myfolder		<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	conver			<- read.table(paste(myfolder,"log.posterior.density.txt",sep=""),header=FALSE)
	colnames(conver)<-"posterior"
	conver$nr		<-c(1:nrow(conver))
	# plot myway:
	# plot(conver$nr,conver$posterior,type='l',ylab="Log posterior density",xlab="Iteration (x 1000)")
	# abline(v=myburnin,lty=2)
	# plot with coda:
	mychain			<- conver$posterior[c(myburnin:nrow(conver))]
	myconver		<- as.mcmc.list(lapply(as.data.frame(mychain), mcmc))	# convert to mcmc object
	if(!is.null(export))
		{
		exportname	<- paste(myfolder,"Traceplot.pdf",sep="")
		if(export=="pdf"){pdf(exportname)}
		}
	plot(myconver)
	if(!is.null(export)){dev.off()}
	# test:
	mydf			<- as.data.frame(matrix(nrow=4,ncol=4))
	colnames(mydf)	<- c("frac1","frac2","Z","p")
	mydf$frac1		<- c(0.1,0.2,0.3,0.5)
	mydf$frac2		<- c(0.5,0.6,0.7,0.1)
	for(i in c(1:4))
		{
		myfrac1			<- mydf$frac1[i]
		myfrac2			<- mydf$frac2[i]	
		gewekeout		<- geweke.diag(myconver,frac1=myfrac1,frac2=myfrac2)
		myzvalue		<- gewekeout$mychain[[1]]
		mypvalue 		<- pnorm(-abs(myzvalue))
		mydf$Z[i]		<- myzvalue
		mydf$p[i]		<- mypvalue
		}
	exportname	<- paste(myfolder,"Geweke.diag.output.txt",sep="")
	write.table(mydf,exportname,quote=FALSE,col.names=FALSE,row.names=TRUE)
	# if you have done multiple runs, you can use gelman diagnostics (which compares chains of each run)
	# gelmanout		<- gelman.diag(myconver,confidence = 0.95,transform=FALSE,autoburnin=TRUE,multivariate=TRUE)
	}

genelandplotting<-function(myburnin=2)
	{
	coord		<- inds[inds$filter,c("longitude","latitude")]
	myfolder	<- paste(mysambar$structuredir,"Genelandoutput/",sep="/")
	setwd(myfolder)
	# Geneland built in plotting functions:
	# Plot number of clusters:
	Plotnpop(path.mcmc=myfolder,burnin=myburnin,printit=TRUE,file="Number_of_Clusters.pdf",format="pdf")
	# Map clusters geographically:
	PosteriorMode(coordinates=coord,path.mcmc=myfolder,printit=TRUE,file="Genelandmap.pdf",format="pdf") 
	PlotTessellation(coordinates=coord,path.mcmc=myfolder,printit=TRUE,path=myfolder)
	graphics.off()
	}	

scattergeneland<-function(myiter=1000,myburnin=2,gradient=TRUE,export=NULL,makeplots=TRUE,mapresolution="low")
	{
	myfolder	<- paste(mysambar$structure,"Genelandoutput/",sep="/")
	newmap 		<- getMap(resolution = mapresolution)
	sampledata	<- read.table(paste(myfolder,"proba.pop.membership.indiv.txt",sep=""),header=FALSE)
	nK			<- ncol(sampledata)-2
	colnames(sampledata)<-c("longitude","latitude",(paste("c",c(1:nK),sep="")))
	nbins		<- length(table(sampledata$c1,sampledata$c2))
	nsamples	<- nrow(sampledata)
	myxlim		<- c(min(sampledata$longitude),max(sampledata$longitude))
	myylim		<- c(min(sampledata$latitude),max(sampledata$latitude))
	myratio		<- (max(sampledata$longitude)-min(sampledata$longitude))/max((sampledata$latitude)-min(sampledata$latitude))
	# set mapping colours:
	sampledata$col	<- NA
	for(i in c(1:nsamples))
		{
		sampledata$col[i]	<- rgb(sampledata$c1[i],sampledata$c2[i],sampledata$c3[i])
		}
	# How many clusters identified?
	temp		<- sampledata[,c(3:9)]	
	temp2		<- sapply(temp,sum)
	nclusters	<- length(temp2[temp2>0])
	# col2 is generated kind of the same, but allowing for more colours (although difference between the other colours not very clear:)
	sampledata$col2	<- NA
	sampledata$col3	<- NA
	sampledata$blend<- NA
	colourvector	<- mysambar$mycolours
	for(i in c(1:nsamples))
		{
		myrow				<- sampledata[i,c(3:9)]
		mymax1				<- order(myrow)[length(myrow)]
		mysecond1			<- order(myrow)[length(myrow)-1]
		mymax2				<- as.vector(unlist(myrow[mymax1]))
		mysecond2			<- as.vector(unlist(myrow[mysecond1]))
		mycol1				<- colourvector[mymax1]
		mycol2				<- colourvector[mysecond1]
		#mycolfunc1 		<- colorRampPalette(c(mycol2,mycol1))
		mycolfunc1 			<- colorRampPalette(c("black",mycol1))
		mycolramp			<- mycolfunc1(nbins)
		mybin				<- mymax2*(nbins-1)+1
		sampledata$col2[i]	<- mycolramp[mybin]
		sampledata$blend[i]	<- ifelse(mymax2==1,FALSE,TRUE)
		sampledata$col3[i]	<- mycol1
		}
	if(gradient)
		{
		mycols	<- sampledata$col2
		}else{
		mycols	<- sampledata$col3	
		}
	myqmatrix2	<<- sampledata
	#
	if(makeplots)
		{
		# Plot:
		# Multitile plot:
		if(!is.null(export))
			{
			if(gradient)
				{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.multitile.gradient.scatter.pdf",sep=".")
				}else{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.multitile.scatter.pdf",sep=".")
				}
			exportname2	<- paste(myfolder,exportname,sep="")
			if(nclusters==2){pdf(exportname2,height=6,width=6*2*myratio)}
			if(nclusters==3){pdf(exportname2,height=6,width=6*3*myratio)}
			if(nclusters==4){pdf(exportname2,height=12,width=6*2*myratio)}
			if(nclusters==5){pdf(exportname2,height=12,width=6*3*myratio)}
			if(nclusters==6){pdf(exportname2,height=12,width=6*3*myratio)}
			if(nclusters==7){pdf(exportname2,height=12,width=6*4*myratio)}
			if(nclusters==8){pdf(exportname2,height=12,width=6*4*myratio)}
			}
		if(nclusters==2){layout(matrix(c(1:2),1,2,byrow = TRUE))}
		if(nclusters==3){layout(matrix(c(1:3),1,3,byrow = TRUE))}
		if(nclusters==4){layout(matrix(c(1:4),2,2,byrow = TRUE))}
		if(nclusters==5){layout(matrix(c(1:5),2,3,byrow = TRUE))}
		if(nclusters==6){layout(matrix(c(1:6),2,3,byrow = TRUE))}
		if(nclusters==7){layout(matrix(c(1:7),2,4,byrow = TRUE))}
		if(nclusters==8){layout(matrix(c(1:8),2,4,byrow = TRUE))}
		par(mar=c(1.5,1.5,1,1),oma=c(3,3,1.5,1),cex.axis=1.5,cex.lab=2.5,cex.main=2.5)
		for(i in c(1:nclusters))	
			{
			mycluster	<- sampledata[,i+2]
			select		<- mycluster>0.5
			plot(sampledata$longitude[select],sampledata$latitude[select],col=mycols[select],pch=16,cex=1.5,ylim=myylim,xlim=myxlim)
			plot(newmap,add=T,col="grey90",border="grey")
			points(sampledata$longitude[select],sampledata$latitude[select],col=mycols[select],pch=16,cex=1.5)
			box()
			}
		mtext(text="Latitude",cex=2,side=2,line=1,outer=TRUE)
		mtext(text="Longitude",cex=2,side=1,line=1.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		#
		# Singletile plot:
		if(!is.null(export))
			{
			if(gradient)
				{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.singletile.gradient.scatter.pdf",sep=".")
				}else{
				exportname	<- paste(myiter,"iter",myburnin,"burnin.singletile.scatter.pdf",sep=".")
				}
			exportname2	<- paste(myfolder,exportname,sep="/")
			pdf(exportname2,height=6,width=6*myratio)
			}
		par(mar=c(0.5,0.5,0.5,0.5),oma=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		plot(newmap, xlim=myxlim, ylim=myylim,col="grey85",border="grey")
		points(sampledata$longitude,sampledata$latitude,pch=16,cex=1.5,col=mycols)
		if(!is.null(export)){dev.off()}
		}
	# export results as qmatrix
	myqmatrix3            		<- cbind(inds$name[inds$filter],inds$longitude[inds$filter],inds$latitude[inds$filter],myqmatrix2)
	colnames(myqmatrix3)[1:3]	<- c("name","longitude","latitude") 
	write.table(myqmatrix3,paste(myfolder,"myqmatrix.txt",sep=""),quote=FALSE,col.names=TRUE,row.names=TRUE)
	}

	
# End of geographic map functions   
###############################################################################################################







###############################################################################################################
# Population differentiation analyses

# This function executes all genetic distance analyses at once:
calcdistance<-function(silent=TRUE,nchroms=NULL,do_distplot=TRUE,do_comparefst=TRUE,dostamppfst=TRUE,only_geneflow=FALSE,dopoptree=TRUE,dodistgenpop=TRUE,do_dxy=TRUE)
	{
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(length(mysambar$populations)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate genetic distance between populations. Execution halted.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
		my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	#
	setwd(mysambar$divergencedir)
	#
	if(only_geneflow)
		{
		setwd(mysambar$inputdatadir)
		return(cat("Gene flow analyses are now part of the new wrapper function 'inferdemography()'.",sep="\n"))
		}
	# Execute analyses:
	# myamova()
	cat("Calculating Nei's genetic distance using stamppNeisD function of the package 'StAMPP'...",sep="\n")
	pop_neimatrix(export="eps")
	pop_neimatrix(export="pdf")
	pop_neimatrix(export="png")
	if(mysambar$os=="Windows"){pop_neimatrix(export="wmf")}
	if(length(mysambar$poporder)>2&dopoptree)
		{
		# 22-09-2021:
		cat("Creating population phylogenies from Nei genetic distances. If you receive an error after this line, set the flag dopoptree to FALSE.",sep="\n") 
		getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
		getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
		getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=FALSE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
		getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
		write.tree(mysambar$poptree,file=paste("Poptree.neiD.newick.txt",sep="."),digits=0,tree.names=FALSE)
		}
	cat("Calculating Pearson's correlation coefficient and variance fst values...",sep="\n")
	runWrightFst()
	cat("Plotting Pearson's correlation coefficient...",sep="\n")
	plotfst(export="eps",inputvector=mysambar$pearsonvector,exportname="MAF_corr_pop",plottitle="Pearson's correlation coefficient")
	plotfst(export="pdf",inputvector=mysambar$pearsonvector,exportname="MAF_corr_pop",plottitle="Pearson's correlation coefficient")
	plotfst(export="png",inputvector=mysambar$pearsonvector,exportname="MAF_corr_pop",plottitle="Pearson's correlation coefficient")
	if(mysambar$os=="Windows"){plotfst(export="wmf",inputvector=mysambar$pearsonvector,exportname="Maf_corr_pop",plottitle="Pearson's correlation coefficient")}
	cat("Plotting variance among population minor allele frequencies...",sep="\n")
	plotfst(export="eps",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="MAF variance")
	plotfst(export="pdf",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="MAF variance")
	plotfst(export="png",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="MAF variance")
	if(mysambar$os=="Windows"){plotfst(export="wmf",inputvector=mysambar$varfstvector,exportname="MAF_variance",plottitle="Variance MAF")}
	cat("Plotting Wright 1943 fst...",sep="\n")
	plotfst(export="eps",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")
	plotfst(export="pdf",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")
	plotfst(export="png",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")
	if(mysambar$os=="Windows"){plotfst(export="wmf",inputvector=mysambar$Wrightfstvector,exportname="Wright1943_fst",plottitle="Wright (1943) fst")}
	if(!is.null(nchroms))
		{
		cat("Creating Manhattan fst plot...",sep="\n")
		# manhattan fst plots for each pairwise population comparison:
		multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
		multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
		multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
		multichromfst(exporttype="pdf",nrchroms=nchroms,popnames=mysambar$populations)
		}
	cat("Calculating pairwise Nei 1977 Fst...",sep="\n")
	locusNeiFst()
	cat("Calculating pairwise Cockerham & Weir 1987 Fst...",sep="\n")
	run_locusWCfst(export="pdf",silent=silent)	# histogram, depends on locusWCfst	
	if(mysambar$os=="Windows"){run_locusWCfst(export="wmf")}
	if(length(mysambar$populations)<=5&do_distplot)
		{
		if(!silent){cat("Fdist_multiplot",sep="\n")}
		cat("Generating Fdist plots. If you run into an error after this line, set the flag do_distplot to FALSE (i.e. 'calcdistance(do_distplot=FALSE)').",sep="\n")
		Fdist_multiplot(export="eps")	# He-Fst scatterplot, depends on Fdist_plot
		Fdist_multiplot(export="pdf")
		Fdist_multiplot(export="png")
		if(mysambar$os=="Windows"){Fdist_multiplot(export="wmf")}
		}
	if("mafSDtop1000"%in%colnames(snps))
		{
		if(!silent){cat("Fdist_multiplot",sep="\n")}
		Fdist_plot(my_dataset="metapop",showlabels=FALSE,exporttype="pdf",axislabels=TRUE,addsd=TRUE,dothin=TRUE,silent=TRUE)
		}
	#cat("Calculating pairwise Weir & Cockerham 1983 multilocus Fst...",sep="\n")
	#if(do_sambarFst)
	#	{
	#	multiLocusWeirFst(export="eps")
	#	multiLocusWeirFst(export="pdf")
	#	multiLocusWeirFst(export="png")
	#	if(mysambar$os=="Windows"){multiLocusWeirFst(export="wmf")}
	#	}
	# 18-05-2020: switch to accepted method, which also outputs p-value (through bootstrapping):  
	if(dostamppfst)
		{
		cat("Calculating pairwise Weir & Cockerham 1983 Fst using Stampp. If you run into an error, set the flag dostamppfst to FALSE.",sep="\n")
		runstamppFst(n_boots=100,export="eps")
		runstamppFst(n_boots=100,export="pdf")
		runstamppFst(n_boots=100,export="png")
		if(mysambar$os=="Windows"){runstamppFst(n_boots=100,export="wmf")}
		}
	#
	if(dodistgenpop)
		{
		cat("Calculating distances between populations using dist.genpop() function of the package 'adegenet'...",sep="\n")
		cat("If you run into an error, set the flag dodistgenpop to FALSE.",sep="\n")
		popdistances()	# this function also combines all distances scores into one table
		#
		# 28-10-2021:
		cat("Creating heatmaps with Reynolds genetic distance estimates calculated with the function dist.genpop()...",sep="\n")
		pop_reynoldsmatrix(export="eps")
		pop_reynoldsmatrix(export="pdf")
		pop_reynoldsmatrix(export="png")
		if(mysambar$os=="Windows"){pop_reynoldsmatrix(export="wmf")}
		# If any Nan in matrix, you will get the error: Error in hclust(DD, method = method, ...) : NA/NaN/Inf in foreign function call (arg 10))
		# 11-10-2022: bug fix: getpoptree expected population names and colours in alphabetic order, resulting in incorrect topology
		# still, output tree appears incorrect (but not because of Sambar bug, but because of the metric itself).
		if(length(mysambar$poporder)>2&dopoptree)
			{
			cat("Creating NJ and UPGMA populations tree using as input Reynolds genetic distance matrix...",sep="\n")
			cat("If you receive an error after this line, set the flag dopoptree to FALSE.",sep="\n") 
			getpoptree(mymatrix=mysambar$popreynoldmatrix,popnames=mysambar$poporder,popcolours=mysambar$colorder,exportlabel="Reynolds",donj=FALSE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popreynoldmatrix,popnames=mysambar$poporder,popcolours=mysambar$colorder,exportlabel="Reynolds",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popreynoldmatrix,popnames=mysambar$poporder,popcolours=mysambar$colorder,exportlabel="Reynolds",donj=FALSE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
			getpoptree(mymatrix=mysambar$popreynoldmatrix,popnames=mysambar$poporder,popcolours=mysambar$colorder,exportlabel="Reynolds",donj=TRUE,edgecolors=TRUE,mytype="phylogram",labelcex=1.5)
			}
		}
	cat("Plotting correlation between pairwise distance estimation methods...",sep="\n")
	cat("If you receive an error after this line, rerun the calcdistance function with the flag do_comparefst set to FALSE.",sep="\n")
	if(do_comparefst)
		{
		if(dodistgenpop)
			{
			comparefstplot(export="pdf")
			}else{
			cat("Not running the function 'comparefstplot' because the flag 'dodistgenpop' has been set to FALSE.",sep="\n")
			}
		}
	if(!silent){cat("Exporting Nei-table.",sep="\n")}
	exportneitable()
	if(!silent){cat("Exporting scatter plots showing comparisons between genetic distance estimates.",sep="\n")}
	poppairscatter(export="pdf",plotname="Poppair_NeiDvsWC1983Fst",xscore=mysambar$popneivector,yscore=mysambar$WC1983fstvector,xlabel="Nei's genetic distance (D)",ylabel="Weir & Cockerham 1983 Fst",yline=4.5)
	poppairscatter(export="pdf",plotname="Poppair_NeiDvsWright1943Fst",xscore=mysambar$popneivector,yscore=mysambar$Wrightfstvector,xlabel="Nei's genetic distance (D)",ylabel="Wright 1943 Fst")
	poppairscatter(export="pdf",plotname="Poppair_Wright1943Fst_WC1983Fst",xscore=mysambar$Wrightfstvector,yscore=mysambar$WC1983fstvector,xlabel="Wright 1943 Fst",ylabel="Weir & Cockerham 1983 Fst")
	if(!is.null(nchroms))
		{
		cat("Sliding window analyses...",sep="\n")
		#
		# ALL CHROMS:
		# to create windowfstdf and create a single plot with sliding window fst values for all possible population pairwise comparisons with multiple tiles (one tile per chromosome)
		# mycomparisons should be a vector with numbers specifying which population comparisons to include
		# select either 'WeirFst' or 'Wrightfst'
		# runWrightFst()
		plotwindowfst(fst_type="Wrightfst",n_chroms=nchroms,export="pdf",mycomparisons=NULL,window_nsnps=50,window_step=10,window_bp=5000000,window_stepbp=250000,popnames=mysambar$populations,ntiles=18,mychroms=NULL,ystep=0.1,addX=TRUE,myyrange=NULL,my_lwd=1.5,silent=TRUE,mysep="_")
		# 
		run_locusWCfst(popnames=mysambar$populations,export=NULL,silent=TRUE,doplot=FALSE)
		plotwindowfst(fst_type="WeirFst",n_chroms=nchroms,export="pdf",mycomparisons=NULL,window_nsnps=50,window_step=10,window_bp=5000000,window_stepbp=250000,popnames=mysambar$populations,ntiles=18,mychroms=NULL,ystep=0.1,addX=TRUE,myyrange=NULL,my_lwd=1.5,silent=TRUE,mysep="_")
		#
		# SINGLE CHROM:
		# plotchromfst(chromname="HiC_scaffold_11")
		}
	if(do_dxy)
		{
		cat("Calculating Dxy (mean raw distance between populations)...",sep="\n")
		cat("If you run into an error after this line, or if the calculation takes too long, rerun the calcdistance function with the flag do_dxy set to false (i.e. 'calcdistance(do_dxy=FALSE)')",sep="\n")
		popmeandxy()
		cat("Creating boxplots with between sample genetic distances...",sep="\n")  
		cat("Again, if you run into an error after this line, or if the calculation takes too long, rerun the calcdistance function with the flag do_dxy set to false (i.e. 'calcdistance(do_dxy=FALSE)')",sep="\n")
		seqdivplot(nsites=NULL,export=TRUE)
		}
	cat("Analysis finished.",sep="\n")
	setwd(mysambar$inputdatadir)
	}
	
# maf versus longitude
# only useful in case of dense sampling
plotgradient<-function(populations=mysambar$populations)
	{
	# exclu
	popmafdf			<- snps[snps$filter,grep("maf_",colnames(snps))]
	mynames				<- colnames(popmafdf)
	colnames(popmafdf)	<- gsub("maf_","",mynames)
	popmafdf			<- popmafdf[,(colnames(popmafdf)%in%populations)]
	popmafdf			<- popmafdf[,order(colnames(popmafdf))]
	#
	longdf				<- aggregate(inds$longitude3,by=list(inds$pop),FUN=mean)
	colnames(longdf)	<- c("pop","longitude")
	longdf				<- longdf[longdf$pop%in%populations,]
	longdf$nr			<- c(1:nrow(longdf))
	longdf				<- longdf[order(longdf$longitude),]
	# 
	# reorder popmafdf:
	popmafdf			<- popmafdf[,longdf$nr]
	#
	npops				<- length(populations)
	nsnps				<- nrow(popmafdf)
	plot(longdf$long,popmafdf[1,],ylim=c(0,1),col="white")
	for (k in c(1:nsnps))
		{
		lines(longdf$long,popmafdf[k,])
		}
	}

popdistances<-function(silent=TRUE,popnames=mysambar$populations,do_overwrite=TRUE)
	{
	# error in popdistances: trying to get slot 'all.names' from an object of a basic class ("function") with no slots.
	if(is.null(mysambar$genpop)|do_overwrite)
		{
		cat("Creating genpop object...",sep="\n")
		minortemp			<- snps[,paste("mac",mysambar$populations,sep="_")]
		alltemp				<- snps[,paste("n",mysambar$populations,sep="_")]
		majortemp			<- alltemp-minortemp
		colnames(minortemp)	<- mysambar$populations
		colnames(majortemp)	<- mysambar$populations
		snpnames			<- snps$name2
		snpnames			<- paste(c(1:length(snpnames)),snpnames,sep="_")	# this is in case chrom is set to unknown, which can result in snps with same snps$name2
		rownames(majortemp)	<- paste(snpnames,"1",sep=".")
		rownames(minortemp)	<- paste(snpnames,"2",sep=".")
		mymatrix			<- rbind(majortemp,minortemp)
		mymatrix			<- t(mymatrix[order(rownames(mymatrix)),])
		mygenpop			<- as.genpop(mymatrix)
		mysambar$genpop		<<- mygenpop
		cat("Genpop object saved as mysambar$genpop.",sep="\n")
		}else{
		mygenpop			<- mysambar$genpop 
		}
	locusnames	<- names(mygenpop@all.names)
	if(any(duplicated(locusnames)))
		{
		# 21-07-2022: attempt to prevent 'ERROR: please name column as [LOCUS].[ALLELE]'
		locusnames	<<- locusnames
		return(cat("ERROR: duplicated locus names in genpop object. To find out which, type: 'locusnames[duplicated(locusnames)]'.",sep="\n"))
		}
	#
	if(!silent){cat("combinames",sep="\n")}
	combitable				<- combn(popnames,m=2)
	ncombi					<- ncol(combitable)
	combinames				<- paste(combitable[1,],combitable[2,],sep="_")
	npairwise				<- length(combinames)
	#
	if(!silent){cat("popdistlist",sep="\n")}
	popdistlist				<- list()
	mymethods				<- c("Nei_D_1972_adegenet","Edwards_1971_adegenet","Reynolds_Weir_Cockerham_1983_adegenet","Rodgers_1972_adegenet","Provesti_1975_adegenet")
	myshortnames			<- c("NeiD1972_ad","Edwards1971_ad","RWC1983_ad","Rodgers1972_ad","Provesti1975_ad") 
	popdistdf				<- as.data.frame(matrix(NA,ncol=length(mymethods),nrow=npairwise))
	colnames(popdistdf)		<- myshortnames
	rownames(popdistdf)		<- combinames
	if(!silent){cat("mypopdist",sep="\n")}
	for (k in c(1:5))
		{
		mymethod			<- mymethods[k]
		if(!silent){cat(mymethod,sep="\n")}
		mypopdist			<- round(adegenet::dist.genpop(mygenpop,method=k,diag=FALSE,upper=FALSE),4)
		mypopdist			<- as.matrix(mypopdist)
		tpopdist			<- t(mypopdist)
		popdistvec			<- tpopdist[lower.tri(tpopdist,diag=FALSE)]
		popdistdf[,k]		<- popdistvec 
		popdistlist[[k]]	<- mypopdist 
		write.table(as.matrix(mypopdist),paste("Distmatrix",mymethod,"txt",sep="."),quote=FALSE,sep="\t")
		}
	#
	# add other scores:
	if(!silent){cat("add scores",sep="\n")}
	if(!is.null(mysambar$popneivector))
		{
		if(!silent){cat("popneivector",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$popneivector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "NeiD1972_st"
		}else{
		if(!silent){cat("popneivector not present",sep="\n")}
		}
	if(!is.null(mysambar$WC1983fstvector))
		{	
		if(!silent){cat("WC1983fst",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$WC1983fstvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "WC1983_st"
		}else{
		if(!silent){cat("WC1983fstvector not present",sep="\n")}
		}
	if(!is.null(mysambar$WC1983pvector))
		{	
		if(!silent){cat("WC1983p",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$WC1983pvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "WC1983p_st"
		}else{
		if(!silent){cat("WC1983pvector not present",sep="\n")}
		}
	if(!is.null(mysambar$WC1983logpvector))
		{	
		if(!silent){cat("WC1983logp",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$WC1983logpvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "WC1983logp_st"
		}else{
		if(!silent){cat("WC1983pvector not present",sep="\n")}
		}
	if(!is.null(mysambar$Wrightfstvector))
		{
		if(!silent){cat("Wrightfst",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$Wrightfstvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "Wright1943_sa"
		}else{
		if(!silent){cat("Wrightfstvector not present",sep="\n")}
		}
	if(!is.null(mysambar$varfstvector))
		{
		if(!silent){cat("varfst",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$varfstvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "variance_sa"
		}else{
		if(!silent){cat("varfstvector not present",sep="\n")}
		}
	if(!is.null(mysambar$pearsonvector))
		{
		if(!silent){cat("pearson",sep="\n")}
		popdistdf$tempdistscore			<- mysambar$pearsonvector
		colnames(popdistdf)[colnames(popdistdf)=="tempdistscore"]	<- "Pearson_r_sa"
		}else{
		if(!silent){cat("pearsonvector not present",sep="\n")}
		}
	write.table(popdistdf,"Population_distances.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
	mysambar$popdistdf		<<- popdistdf
	if(!silent)
		{
		cat("Distance scores have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

comparefstplot<-function(export=NULL)
	{
	distdf2				<- mysambar$popdistdf[,!(colnames(mysambar$popdistdf)%in%c("WC1983p_st","WC1983logp_st","variance_sa","Pearson_r_sa"))]
	if(!is.null(export))
		{
		pdf("Compare_pairwise_distmethods.pdf",height=8,width=8)
		}
	mymax		<- max(distdf2,na.rm=TRUE)+0.025
	pairs(distdf2,xlim=c(0,mymax),lower.panel=NULL,ylim=c(0,mymax),pch=16,las=2,cex=0.5)
	if(!is.null(export)){dev.off()}
	}

# AMOVA
# Depends on package StamPP'
myamova<-function(permutations=10)
	{
	nei 			<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=FALSE)
	amovaresults	<<- stamppAmova(nei,mygenlight[inds$filter,snps$filter],perm=permutations)	
	return(amovaresults)
	}

# depends on plotkaryo
multiplotkaryo<-function(nrchroms=NULL,exporttype=NULL,popnames=mysambar$populations,silent=TRUE,mystat="Wrightfst",mystatdf=NULL,mystepsize=0.2)
	{
	# mystat and mystatdf can also be 'Dfst' and 'windowfstdf' 
	if(is.null(mystatdf))
		{
		mystatdf	<- snps[,grep(mystat,colnames(snps))]
		}
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	mycolours		<- as.vector(unique(inds$popcol))
	combicoltable	<- combn(mycolours,m=2)	
	for(combinr in c(1:ncombi))
		{
		mypair		<- paste(combitable[1,combinr],combitable[2,combinr],sep="_")
		if(!silent){cat(mypair,sep="\n")}
		mystatvalues<- paste(mystat,mypair,sep="_")
		mycolfunc 	<- colorRampPalette(c(combicoltable[1,combinr],combicoltable[2,combinr]))
		my_combicol	<- mycolfunc(3)[2]
		if(!silent){cat(mystatvalues,sep="\n")}
		plotkaryo(export=exporttype,popnames=mysambar$populations,n_chroms=nrchroms,mychrom=NULL,stepsize=mystepsize,mycol="blue",mycol2="darkred",windowdf=mystatdf,inputvalues=mystatvalues)
		}
	}

plotkaryo<-function(popnames=mysambar$populations,n_chroms=NULL,mychrom=NULL,stepsize=0.2,mycol="blue",mycol2="darkred",export=NULL,windowdf=NULL,inputvalues=NULL)
	{
	# for example: windowdf=windowfstdf,inputvalues="Dfst_ABC_Eurasia_polar"
	mytest1<-(1/stepsize)
	mytest2<-round(mytest1)
	if(mytest1%%mytest2!=0)
		{
		return(cat("ERROR: 1/stepsize should be a round number.",sep="\n"))  
		}
	# BiocManager::install("karyoploteR")
	# library(karyoploteR)
	#
	# example:
	# mykaryo 		<- toGRanges(data.frame(chr=c("A","B"),start=c(1,1),end=c(100,200)))
	# kp 			<- plotKaryotype(genome=mykaryo,plot.type=6)
	# myregionsdf	<- data.frame(chr=c("A","A","B","B"),start=c(1,50,1,100),end=c(50,100,100,200),name=c("A1","A2","B1","B2"),col=c("darkred","blue","blue","darkred"))
	# myregions 	<- toGRanges(myregionsdf)
	# kpRect(kp,data=myregions,y0=0,y1=1,col=fstbins,data.panel="ideogram",border=NA)
	#
	# windowdf: a dataframe containing the columns 'chr','start','end', as well as a column as defined by inputvalues (which will be plotted).
	if(is.null(windowdf))
		{
		return(cat("ERROR: windowdf does not exist.",sep="\n"))
		}
	if(any(!c('chr','start','end')%in%colnames(windowdf)))
		{
		return(cat("ERROR: windowdf should contain columns called 'chr','start' and 'end'.",sep="\n"))
		}
	if(!inputvalues%in%colnames(windowdf))
		{
		return(cat("ERROR: column name defined by inputvalues flag not present in dataframe defined by windowdf flag.",sep="\n"))
		}
	if(!is.null(mychrom))
		{
		windowdf	<- windowdf[windowdf$chr==mychrom,]
		plottype	<- 1	# space above graph for plotting data
		}else{
		plottype	<- 6
		}
	regionvalues	<- as.vector(windowdf[,inputvalues])
	myregionsdf		<- windowdf[,c("chr","start","end")]
	myregions 		<- toGRanges(myregionsdf)
	mybreaks		<- round(seq(-1,1,stepsize),2)
	#
	if(!is.null(export))
		{
		if(is.null(mychrom))
			{
			myplotname	<- paste("Genomewide_window",inputvalues,sep="_")
			myheight	<- 8
			myheigth2	<- 800
			mywidth		<- 8
			mywidth2	<- 800
			}else{
			myplotname	<- paste("Chrom_window",mychrom,inputvalues,sep="_")
			myheight	<- 6
			myheigth2	<- 600
			mywidth		<- 12
			mywidth2	<- 1200
			}
		if(export=="eps"){postscript(paste(myplotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(myplotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(myplotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(myplotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	if(!is.null(mychrom))
		{
		snpstemp	<- snps[snps$chr2==mychrom,c("chr2","chrlength")] 
		snpstemp	<- unique(snpstemp)
		snpstemp	<- snpstemp[order(snpstemp$chr2),]
		mykaryo		<- data.frame("chr"=snpstemp$chr2,start=1,"end"=snpstemp$chrlength)
		}else{
		snpstemp	<- snps[snps$chr2<=n_chroms,c("chr2","chrlength")] 
		snpstemp	<- unique(snpstemp)
		snpstemp	<- snpstemp[order(snpstemp$chr2),]
		mykaryo		<- data.frame("chr"=snpstemp$chr2,start=rep(1,n_chroms),"end"=snpstemp$chrlength)
		}
	kp 			<- plotKaryotype(genome=mykaryo,plot.type=plottype)
	#
	## define colours:
	# positive values:
	poscolfunc 				<- colorRampPalette(c("grey90",mycol))
	negcolfunc 				<- colorRampPalette(c(mycol2,"grey90"))
	poscols					<- poscolfunc(round(1/stepsize))
	negcols					<- negcolfunc(round(1/stepsize))
	bincols					<- c(negcols,poscols)
	fstbins					<- as.vector(cut(regionvalues,mybreaks,labels=bincols))
	fstbins[regionvalues==-1]<- mycol2
	mycolfunc2 				<- colorRampPalette(c("white","grey90"))
	fstbins[is.na(regionvalues)] <- mycolfunc2(5)[2]
	kpRect(kp,data=myregions,y0=0,y1=1,col=fstbins,data.panel="ideogram",border=NA)
	# 
	if(!is.null(mychrom))
		{
		x					<- windowdf$start
		npops				<- length(popnames)
		mycolours			<- mysambar$mycolours[1:npops]	
		combitable			<- combn(popnames,m=2)
		combicoltable		<- combn(mycolours,m=2)
		npairwise			<- ncol(combitable)
		mycolvec			<- vector()
		mynamesvec			<- vector()
		for (i in (1:npairwise))
			{
			combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
			fstvalues		<- as.vector(windowdf[,names(windowdf) == paste("Wrightfst",combiname,sep = "_")])
			# as colour we are going to use a blend of the two population colours:
			mycol1			<- combicoltable[1,i]
			mycol2			<- combicoltable[2,i]
			mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
			mycol			<- mycolfunc3(3)[2]
			mynamesvec[i]	<- combiname
			mycolvec[i]		<- mycol
			kpLines(kp,chr=mychrom,x=x,y=fstvalues,col=mycol,lwd=2)
			}
		legend("topright",legend=mynamesvec,fill=mycolvec,bty='n',cex=1.5)
		}else{
		# legend:
		if(any(regionvalues[!is.na(regionvalues)]<0))
			{
			fstbinleg	<- as.vector(cut(seq(-1,1,0.01),mybreaks))
			fstbinleg	<- unique(fstbinleg)
			fstbinleg[2]<- paste("[-1,",-1+round(stepsize,2),"]",sep="")
			fstbinleg[1]<- "NA"
			fstbincol	<- as.vector(cut(seq(-1,1,stepsize),mybreaks,labels=bincols))
			fstbincol[1]<- mycolfunc2(5)[2]
			}else{
			fstbinleg	<- as.vector(cut(seq(0,1,0.01),mybreaks))
			fstbinleg	<- unique(fstbinleg)
			fstbinleg[2]<- paste("[0,",round(stepsize,2),"]",sep="")
			fstbinleg[1]<- "NA"
			fstbincol	<- as.vector(cut(seq(0,1,stepsize),mybreaks,labels=bincols))
			fstbincol[1]<- mycolfunc2(5)[2]
			}
		fstbinleg	<<- fstbinleg
		legend("bottomright",legend=fstbinleg,fill=fstbincol,bty='n',cex=1.5)
		}
	if(!is.null(export)){dev.off()}
	}

plotscatterkaryo<-function()
	{
	kp <- plotKaryotype(plot.type = 4, ideogram.plotter = NULL, labels.plotter = NULL)
	kpAddCytobandsAsLine(kp)
	kpAddChromosomeNames(kp, srt=45)
	points <- unlist(tileGenome(kp$chromosome.lengths, tilewidth = 100e3))
	points$y <- rnorm(n = length(points), mean = 0.5, sd = 0.1)
	kpPoints(kp, data = points, col=colByChr(points, colors = "rainbow"))
	#kpPoints(kp, data = points, col=colByChr(points, colors = "brewer.set1"), r1=0.45)
	#kpPoints(kp, data = points, col=colByChr(points, colors = "2blues"), r0=0.55)
	}

mafsd<-function(popnames=mysambar$populations)
	{
	npops				<- length(popnames)
	if(npops>1)
		{
		popmafs 			<- snps[,grep("maf_",colnames(snps))]
		snps$sd_popmaf		<<- apply(popmafs,1,function(x) sd(x))
		}else{
		snps$sd_popmaf		<<- NA
		}
	}

# Sliding window Fst:
# Depends on package 'zoo'
windowfst<-function(chrom=1,width=50,step=10,winbp=5000000,stepbp=250000,fsttype="WeirFst",popnames=mysambar$populations,selectcombi=NULL,snpselection=snps$filter2,mycolours=mysambar$mycolours,yrange=c(0,0.4),yby=0.1,xrange=c(0,160000000),xby=25,addlegend=FALSE,xaxislabels=TRUE,region=NULL,mylwd=1.5,addchrom=TRUE,legendcex=1,silent=TRUE,addhe=FALSE)
	{
	npops	<- length(popnames)
	# if winbp and stepbp are not NULL, statistics per region are calculated as well.
	if(fsttype!="WeirFst"&fsttype!="Wrightfst")
		{
		return(cat("ERROR: fsttype should be either 'WeirFst' or 'Wrightfst'.",sep="\n"))
		}
	# region is a two element vector (startpoint and endpoint) to highlight a particular area
	xrange				<- xrange/1000000
	selection			<- snps$chr2==chrom&snpselection
	combitable			<<- combn(popnames,m=2)
	combicoltable		<<- combn(mycolours,m=2)
	#
	# selectcombi should be a boolean vector or an integer vector
	if(!is.null(selectcombi))
		{	
		combitable		<<- as.matrix(combitable[,selectcombi])
		combicoltable	<<- as.matrix(combicoltable[,selectcombi])
		}
	combicolours		<<- rep(NA,ncol(combitable))
	combivector			<<- paste(combitable[1,],combitable[2,],sep="_")
	winmidpoint			<- rollapply(snps$pos[selection],width,mean,by=step,na.rm=TRUE)
	windowoutput		<<- as.data.frame(matrix(NA,nrow=length(winmidpoint),ncol=ncol(combitable)+1))
	colnames(windowoutput)<<- c(combivector,"pos")
	windowoutput$pos	<<- winmidpoint
	#
	if((!is.null(winbp))&(!is.null(stepbp)))
		{
		if(!silent){cat("Calculating fst for regions with fixed number of bp (as defined by winbp and stepbp flags)...",sep="\n")}
		# 31-3-20: alternative way: for regions of fixed length instead of for fixed number of SNPs
		chrlength		<- mean(snps$chrlength[snps$chr2==chrom],na.rm=TRUE)
		chrname			<- as.vector(unique(snps$chr[snps$chr2==chrom]))
		mystarts		<- seq(0,chrlength,stepbp)+1
		myends			<- mystarts-1+winbp
		mymid			<- (mystarts-1+myends)/2
		n_win			<- length(mystarts)
		windowdf		<<- data.frame("chr"=rep(chrom,n_win),"chrlength"=rep(chrlength,n_win),"start"=mystarts,"end"=myends,"mid"=mymid)
		windowdf$end	<<- ifelse(windowdf$end>windowdf$chrlength,windowdf$chrlength,windowdf$end)
		windowdf$nsnps	<<- NA
		windowdf$he		<<- NA
		windowdf$maf	<<- NA
		chr_snps	<- snps[snps$chr2==chrom,]
		for(j in c(1:n_win))
			{
			mystart				<- windowdf$start[j]
			myend				<- windowdf$end[j]
			regionsnps			<- chr_snps[chr_snps$pos>mystart&chr_snps$pos<=myend,]
			windowdf$nsnps[j]	<<- nrow(regionsnps)
			windowdf$he[j]		<<- mean(regionsnps$hetero,na.rm=TRUE)
			windowdf$maf[j]		<<- mean(regionsnps$maf,na.rm=TRUE)
			windowdf$HWEchi2[j]	<<- mean(regionsnps$HWEchi2,na.rm=TRUE)
			}
		}else{
		if(!silent){cat("Calculating fst for regions consisting of fixed number of SNPs (as defined by width and step flags)...",sep="\n")}
		}
	#
	# for pairwise population comparisons:
	npairwise	<- ncol(combitable)
	for (i in (1:npairwise))
		{
		combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
		if(!silent){cat(combiname,sep="\n")} 
		fstvalues		<- snps[selection,names(snps) == paste(fsttype,combiname,sep = "_")]
		#fstvalues		<- snps[selection,names(snps) == paste("WeirFst",combiname,sep = "_")]
		# Sliding window:		
		fstmean 		<- rollapply(fstvalues,width,mean,by=step,na.rm=TRUE)
		#fstsd 			<- rollapply(fstvalues,width,sd,by=step,na.rm=TRUE)
		windowoutput[names(windowoutput) == combivector[i]] <<- fstmean
		#
		if(!is.null(winbp)&!is.null(stepbp))
			{
			# 31-3-20: alternative way: for regions of fixed length instead of for fixed number of SNPs:
			fstvalues		<- chr_snps[,names(snps) == paste(fsttype,combiname,sep = "_")]
			windowdf$meanfst<<- NA	
			for(j in c(1:n_win))
				{
				#cat(j,sep="\n")
				mystart		<- windowdf$start[j]
				myend		<- windowdf$end[j]
				mybool		<- chr_snps$pos>mystart&chr_snps$pos<=myend
				if(any(mybool))
					{
					#cat("mybool",sep="\n")
					regionfst		<- fstvalues[mybool]
					if(any(!is.na(regionfst)))
						{
						#cat("mean_fst",sep="\n")
						windowdf$meanfst[j]	<<- mean(regionfst,na.rm=TRUE)
						}else{
						windowdf$meanfst[j]	<<- NA
						}
					}else{
					windowdf$meanfst[j]		<<- NA
					}
				}
			names(windowdf)[names(windowdf)=="meanfst"] <<- paste(fsttype,combiname,sep = "_")
			}
		}
	if(!is.null(winbp)&!is.null(stepbp))
		{
		n_col			<- ncol(windowdf)
		windowoutput2	<- windowdf[,c((n_col-npairwise+1):n_col)]
		}
	# Plot:
	# plot first line:
	# as colour we are going to use a blend of the two population colours:
	mycol1			<- combicoltable[1,1]
	mycol2			<- combicoltable[2,1]
	mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
	mycol			<- mycolfunc3(3)[2]
	combicolours[1]	<<- mycol
	if(xaxislabels)
		{
		if((!is.null(winbp))&(!is.null(stepbp)))
			{
			plot(windowdf$mid/1000000,windowoutput2[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}else{
			plot(windowoutput$pos/1000000,windowoutput[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}
		axis(2, at=seq((yrange[1]+yby/2),yrange[2],by=yby),las=1)
		axis(1, at=seq((xrange[1]),xrange[2],by=xby),las=1)
		}else{
		if((!is.null(winbp))&(!is.null(stepbp)))
			{
			plot(windowdf$mid/1000000,windowoutput2[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}else{
			plot(windowoutput$pos/1000000,windowoutput[,1],type="l",ylim=yrange,yaxt='n',xaxt='n',ann=FALSE,xlim=xrange,col=mycol,lwd=mylwd)
			}
		axis(2, at=seq((yrange[1]+yby/2),yrange[2],by=yby),las=1)
		}
	if(!is.null(region))
		{
		rect(xleft=region[1],ybottom=-1,xright=region[2],ytop=1,col="grey",border=NA)
		if(!is.null(winbp)&is.null(stepbp))
			{
			lines(windowdf$mid/1000000,windowoutput2[,1],col=mycol,lwd=mylwd)
			}else{
			lines(windowoutput$pos/1000000,windowoutput[,1],col=mycol,lwd=mylwd)
			}
		}else{
		if((!is.null(winbp))&(!is.null(stepbp))&addhe)
			{
			if(!silent){cat("Adding polygon...",sep="\n")}
			polygon(x=c(windowdf$mid/1000000,rev(windowdf$mid/1000000)),y=c(rep(0,nrow(windowdf)),rev(windowdf$he)),col="grey",border=NA)
			lines(windowdf$mid/1000000,windowoutput2[,1],type="l",col=mycol,lwd=mylwd)
			if(addlegend){legend("topright",y=0.2,"Heterozygosity",fill="grey",cex=legendcex,bty="n")}
			#lines(windowdf$mid/1000000,windowdf$he)
			#lines(windowdf$mid/1000000,windowdf$nsnps/max(windowdf$nsnps,na.rm=TRUE),lty=2)
			#lines(windowdf$mid/1000000,windowdf$maf,col="red")
			#lines(windowdf$mid/1000000,(windowdf$HWEchi2/max(windowdf$HWEchi2,na.rm=TRUE)),col="green")
			}
		}
	if(addchrom)
		{
		mtext(chrname,3,line=-1,cex=0.75)
		}
	# plot optional extra lines:
	if(ncol(combitable)>1)
		{
		for (z in (2:(ncol(combitable))))
			{
			# as colour we are going to use a blend of the two population colours:
			mycol1		<- combicoltable[1,z]
			mycol2		<- combicoltable[2,z]
			mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
			mycol		<- mycolfunc3(3)[2]
			combicolours[z]	<<- mycol
			if((!is.null(winbp))&(!is.null(stepbp)))
				{
				lines(windowdf$mid/1000000,windowoutput2[,z],type="l",col=mycol,lwd=mylwd)
				}else{
				lines(windowoutput$pos/1000000,windowoutput[,z],type="l",col=mycol,lwd=mylwd)
				}
			title((paste("chromosome",chrom, sep = " ")),line = 1)
			}
		}
	if(addlegend){legend("topleft",y=0.2,combivector,fill=combicolours,cex=legendcex,bty="n")}
	}

# depends on windowfst
# to plot a single chromosome
plotchromfst<-function(chromname="HiC_scaffold_11")
	{
	pdf(paste("WindowFst",chromname,"fst.pdf",sep="."),width=12,height=7)
	par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,4,2),cex.axis=1.5)
	windowfst(chrom=chromname,width=20,mylwd=2.5,step=2,selectcombi=c(1,2,3,4,5,6),yrange=c(0,1),yby=0.1,xrange=c(0,110000000),xby=5,addlegend=TRUE,addchrom=TRUE)
	mtext("Position along chromosome (Mb)",side=1,line=2.5,outer=TRUE,cex=2)
	mtext("Fst",side=2,line=1.25,outer=TRUE,cex=2)
	dev.off()
	}

# depends on function windowfst()
# to plot all chromosomes	
plotwindowfst<-function(window_nsnps=50,window_step=10,window_bp=5000000,window_stepbp=250000,mycomparisons=NULL,popnames=mysambar$populations,mycolours=mysambar$mycolours,fst_type="WeirFst",n_chroms=NULL,ntiles=18,mychroms=NULL,ystep=0.1,export=NULL,addX=TRUE,myyrange=NULL,my_lwd=1,silent=TRUE,mysep="_",legend_cex=1.25)
	{
	mycurrentdir	<- getwd()
	# window_nsnps=50,window_step=10,window_bp=5000000,window_stepbp=250000
	windowsize	<- ifelse(is.null(window_bp),paste(window_snps,"SNPs",sep=""),paste(window_bp/1000000,"Mb",sep=""))
	if(fst_type!="WeirFst"&fst_type!="Wrightfst")
		{
		return(cat("ERROR: fst_type should be either 'WeirFst' or 'Wrightfst'.",sep="\n"))
		}
	# This function calculates fst values per window for each chromosome, and stores the window specific values in a dataframe called windowfstdf. 
	# It will also create plots, but not fancy ones, so probably you would like to use the output (windowfstdf dataframe) as input for plotkaryo() function.
	setwd(mysambar$selectiondir)
	npops			<- length(popnames)
	windowfstlist	<- list()
	if(is.null(mycomparisons))
		{
		mycomparisons=seq(1:ncol(combn(popnames,m=2)))
		}
	if(is.null(mychroms))
		{
		if(is.null(n_chroms))
			{
			return(cat("Provide an input value to the n_chroms flag",sep="\n"))
			}else{
			mychroms	<- c(1:n_chroms)
			maxlength	<- max(snps$chrlength[snps$chr2<=n_chroms],na.rm=TRUE)  
			}	
		}
	nchroms		<- length(mychroms)
	ntabs		<- ceiling(nchroms/ntiles)
	#
	# get yrange:
	if(is.null(myyrange))
		{
		myfstdf 	<- snps[,grep(paste(fst_type,"_",sep=""),colnames(snps))]
		myfstdf		<- myfstdf[,colnames(myfstdf)!=paste(fst_type,"metapop",sep=mysep)] 
		fstmin		<- min(myfstdf,na.rm=TRUE)
		fstmax		<- max(myfstdf,na.rm=TRUE)
		myyrange	<- c(fstmin,fstmax)
		}
	if(is.null(maxlength))
		{
		myxrange=c(0,160000000)
		}else{
		myxrange=c(0,maxlength)
		}
	for (n in c(1:ntabs))
		{ 
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Window_Fst_allchroms",fst_type,windowsize,n,"eps",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="pdf"){pdf(paste("Window_Fst_allchroms",fst_type,windowsize,n,"pdf",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="png"){png(paste("Window_Fst_allchroms",fst_type,windowsize,n,"png",sep="."),family=mysambar$myfont,width=540,height=720)}
			if(export=="wmf"){win.metafile(paste("Window_Fst_allchroms",fst_type,windowsize,n,"wmf",sep="."),family=mysambar$myfont,width=6,height=8)}
			}
		layout(matrix(c(c(c(1:(ntiles/2)),ntiles+1),c((ntiles/2+1):(ntiles+1))),nrow=(ntiles/2+1),ncol=2,byrow=FALSE))
		#layout(matrix(c(1:ntiles),(ntiles/2),2,byrow=FALSE))
		par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))
		if(n<ntabs)
			{
			chromset	<- mychroms[((n-1)*ntiles+1):(ntiles*n)]
			}else{
			chromset	<- mychroms[((n-1)*ntiles+1):length(mychroms)]
			}
		for (chromname in chromset)
			{
			cat(paste("Scaffold: ",chromname,sep=""),sep="\n")
			if(chromname%%(ntiles/2)==0)
				{
				windowfst(chrom=chromname,fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=TRUE,mylwd=my_lwd)
				}else{
				if(mychroms[nchroms]==chromname&&addX==FALSE)
					{
					windowfst(chrom=chromname,fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=TRUE,mylwd=my_lwd)
					}else{
					windowfst(chrom=chromname,fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=FALSE,mylwd=my_lwd)
					}
				}
			# add data to list:
			windowfstlist[[chromname]]	<- windowdf 	# this works because snps$chr2 consists of numbers (1 for biggest chrom, 2 for second biggest chrom, etc)
			}
		# 13-4-2020: this doesn't work anymore since using snps$chr2 instead of snps$chr 
		#if(addX&n==ntabs)
		#	{
		#	windowfst(chrom="X",fsttype=fst_type,selectcombi=mycomparisons,width=window_nsnps,step=window_step,winbp=window_bp,stepbp=window_stepbp,yrange=myyrange,xrange=myxrange,yby=ystep,xaxislabels=TRUE,mylwd=my_lwd)
		#	}
		if(fst_type=="WeirFst")
			{
			mtext("Cockerham & Weir 1987 Fst", side=2, line=1, outer=TRUE,cex=1.5)
			}
		if(fst_type=="Wrightfst")
			{	
			mtext("Wright 1943 Fst", side=2, line=1, outer=TRUE,cex=1.5)
			}
		mtext("Position along chromosome (Mb)", side=1, line=-3.5, outer=TRUE,cex=1.25)
		# addlegend:
		if(n==ntabs)
			{
			nempty	<- ifelse(addX,(ntabs*ntiles-length(mychroms)-1+1),(ntabs*ntiles-length(mychroms)+1))
			for(mycounter in c(1:(nempty)+1))
				{
				plot(1,type ="n",axes=FALSE,xlab="",ylab="")	
				}
			}else{
			plot(1,type= "n",axes=FALSE,xlab="",ylab="")
			}
		if(length(mycomparisons)<10){legend(x="bottom",legend=combivector,horiz=T,fill=combicolours,border=combicolours,cex=legend_cex,bty="n")}
		if(!is.null(export)){dev.off()}
		}
	windowfstdf		<<- do.call(rbind,windowfstlist)
	cat("Window fst values have been saved in a dataframe called 'windowfstdf'.",sep="\n")
	setwd(mycurrentdir)
	}

# Correlation between allele frequencies:
# This measure was first published by Sewall Wright in 1943 (Wright, 1943, see equation 48 and the SambaR manual).   
runWrightFst<-function(popnames=mysambar$populations,popcols=mysambar$mycolours)
	{
	if(length(popnames)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate genetic distance. Execution halted."))
		}
	npops			<- length(popnames)
	nsnps			<- nrow(snps)
	combitable		<- combn(popnames,m=2)
	mysambar$pairpop1		<<- combitable[1,]
	mysambar$pairpop2		<<- combitable[2,]
	mysambar$pairpopcol1	<<- vector()
	mysambar$pairpopcol2	<<- vector()
	for(k in c(1:ncol(combitable)))
		{
		mysambar$pairpopcol1[k]	<<- popcols[which(popnames==mysambar$pairpop1[k])]
		mysambar$pairpopcol2[k]	<<- popcols[which(popnames==mysambar$pairpop2[k])]
		}
	#
	pearsonvector	<- vector()
	varfstvector	<- vector()
	Wrightfstvector	<- vector()
	pops2$wrightfst	<<- NA
	#
	for(i in 1:ncol(combitable))
		{
		pop1		<- combitable[1,i]
		pop2		<- combitable[2,i]
		my_dataset	<- paste(pop1,pop2,sep="_")
		mypoppair	<- ifelse(pop1<pop2,paste(pop1,pop2,sep="_"),paste(pop2,pop1,sep="_"))
		if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
			maf1	<- as.vector(snps[,paste("maf",pop1,sep="_")])
			}else{
			return(cat(paste("No maf vector present for ",pop1,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop2,sep="_")%in%colnames(snps))
			{
			maf2	<- as.vector(snps[,paste("maf",pop2,sep="_")])
			}else{
			return(cat(paste("No maf vector present for ",pop2,".",sep=""),sep="\n"))
			}
		missfilter			<- !(is.na(maf1)|is.na(maf2))
		#
		# correlation between minor allele frequencies:
		pearsonvector[i]	<- round(cor(maf1[missfilter],maf2[missfilter],method="pearson"),2)
		#
		# fst based on variation between minor allele frequencies:
		# varfst = E( MAFmeta - MAFpop )^2 / npops
		popmafs			<- snps[,paste("maf",c(pop1,pop2),sep="_")]
		npop1			<- nrow(inds[inds$filter&inds$pop==pop1,])
		npop2			<- nrow(inds[inds$filter&inds$pop==pop2,])
		nboth			<- npop1+npop2
		combimaf		<- (npop1*popmafs[,1]+npop2*popmafs[,2])/nboth
		mydevmat		<- matrix(NA,nrow=nsnps,ncol=2)
		mydevmat		<- (popmafs-combimaf)^2 
		snpvar			<- (mydevmat[,1]*npop1+mydevmat[,2]*npop2)/nboth
		Wrightfst		<- ifelse(snpvar==0,0,snpvar/(combimaf*(1-combimaf)))
		snpdev			<- sqrt(snpvar)
		snps$dev		<<- snpdev
		snps$Wrightfst	<<- Wrightfst
		names(snps)[names(snps) == "dev"] 		<<- paste("dev",my_dataset,sep = "_")
		names(snps)[names(snps) == "Wrightfst"] <<- paste("Wrightfst",my_dataset,sep = "_")
		varfstvector[i]		<- mean(snpdev[snps$filter&missfilter&is.finite(snpvar)],na.rm=TRUE) 
		Wrightfstvector[i]	<- mean(Wrightfst[snps$filter&missfilter&is.finite(Wrightfst)],na.rm=TRUE) 
		pops2$wrightfst[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]	<<- mean(Wrightfst[snps$filter&missfilter&is.finite(Wrightfst)],na.rm=TRUE)  
		#
		# varfst:
		# varfst is a very intuitive measure: if you calculate fst this way, it is easy to understand what it means.
		# for example: a fst of 0.04 means that for each locus the difference between the metapop minor allele frequency and the population minor allele frequency is sqrt(0.04)=0.2. 
		# which would be the case if MAFpop1=0.1 and MAFpop2=0.5. 
		#
		# Wright 1943 fst:
		# The maximum varfst value is 0.25, namely when the metapop allele frequency is 0.5, and mafpop1=0 and mafpop2=1.
		# The mean distance between metapop MAF and populations MAF is in that case 0.5 (sqrt(0.25)).
		# Hence, the range of devfst is not 0 to 1, but 0 to 0.25 (given a mean MAF of 0.5).
		# It can be mathematically shown that for population pairs which are fixated for different alleles (i.e. MAFpop=1 and MAFpop2=0), varfst equals: p(1-p). This is the maximum possible value.
		# As in our example: 0.5(1-0.5)=0.25.
		# For a quick and dirty proof: 
		# randomly drawing alleles from a biallelic locus within a meta population, represents a binomial probability, because you can either draw allele A or a. 
		# For binomial distributions it is known that the mean equals np and the variance equals np(1-p). 
		# Anyway, we could represent fst as a ratio between the observed variance and maximum possible variance, to get a scale ranging between 0 and 1.
		# This can also be defined as the ratio between variance within the mean variance within population and the variance in the total population:
		# varfst = E( MAFmeta - MAFpop )^2 / npops
		# varmeta = pq = p(1-p)
		}
	#
	pops2$fst2				<<- pops2$wrightfst/(1-pops2$wrightfst)
	varfstvector			<- round(varfstvector,4)
	Wrightfstvector			<- round(Wrightfstvector,4)
	#
	wfstmat				<- matrix(NA,nrow=npops,ncol=npops)
	rownames(wfstmat)	<- popnames
	colnames(wfstmat)	<- popnames
	varfstmat			<- wfstmat
	for(i in c(1:npops))
		{
		for(j in c(1:npops))
			{
			if(i!=j)
				{
				mypop1			<- popnames[i]
				mypop2			<- popnames[j]
				wfstmat[i,j]	<- Wrightfstvector[(mysambar$pairpop1==mypop1&mysambar$pairpop2==mypop2)|(mysambar$pairpop1==mypop2&mysambar$pairpop2==mypop1)]
				varfstmat[i,j]	<- varfstvector[(mysambar$pairpop1==mypop1&mysambar$pairpop2==mypop2)|(mysambar$pairpop1==mypop2&mysambar$pairpop2==mypop1)]
				}
			}
		}
	#
	mysambar$varfstvector	<<- varfstvector
	mysambar$Wrightfstvector<<- Wrightfstvector
	mysambar$varfstmatrix	<<- varfstmat
	mysambar$Wrightfstmatrix<<- wfstmat
	mysambar$pearsonvector	<<- pearsonvector
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

LKtest<-function(pop1="pheno1",pop2="pheno2")
	{
	if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
		maf1	<- as.vector(snps[,paste("maf",pop1,sep="_")])
		}else{
		return(cat(paste("No maf vector present for ",pop1,".",sep=""),sep="\n"))
		}
	if(paste("maf",pop2,sep="_")%in%colnames(snps))
		{
		maf2	<- as.vector(snps[,paste("maf",pop2,sep="_")])
		}else{
		return(cat(paste("No maf vector present for ",pop2,".",sep=""),sep="\n"))
		}
	#
	## calculate Wright Fst:
	popmafs				<- as.vector(snps[,paste("maf",c(pop1,pop2),sep="_")])
	npop1				<- nrow(inds[inds$filter&inds$type,])
	npop2				<- nrow(inds[inds$filter&(!inds$type),])
	nboth				<- npop1+npop2
	combimaf			<- (npop1*popmafs[,1]+npop2*popmafs[,2])/nboth
	mydevmat			<- matrix(NA,nrow=nrow(snps),ncol=2)
	mydevmat			<- (popmafs-combimaf)^2 
	snpvar				<- (mydevmat[,1]*npop1+mydevmat[,2]*npop2)/nboth
	fstvec				<- ifelse(snpvar==0,0,snpvar/(combimaf*(1-combimaf)))
	snps$Wrightfst_pheno<<- fstvec
	#	
	## Lewontin-Krakauer test:
	npops				<- 2
	fstmean				<- mean(fstvec[snps$filter2],na.rm=TRUE)
	snps$lkscore		<<- ((npops-1)*fstvec)/fstmean
	snps$lkpvalue		<<- pchisq(lkscore,df=(npops-1),lower.tail=FALSE)
	}

# 16-10-2021: still under construction:
FLKtest<-function()
	{
	# The variation of allele frequencies (p) within a single population over time is given by the formula:
	# Var(p)	<- Ft*p0*(1-p0)
	# in which:
	# - p0 denotes the allele frequence at T=0
	# - Ft, or Wright-Fisher fixation index, denotes the expected amount of genetic drift within a population after t generations.
	#	Ft = 1-(1-1/(2*Ne))^t  = t/(2Ne)
	#
	# In a kinship matrix, these Ft values are on the diagonal. They are denoted as Fi, in which i denotes population i.   
	# The off-diagonal values in a kinship matrix indicates the fixation index in an ancestral population of populations i and j. These values are denoted as f_ij.  	
	# In case of a stairlike phylogeny (radiation-like dispersal), all off-diagonal values equal zero.
	# The kinship matrix itself is denoted with the symbol F.
	# 
	# Thus, the expected variance of allele frequencies in population i (p_i) is given by:
	# Var(p_i)		<- Fi*p0*(1-p0)
	# The expected covariance of allele frequencies in population i and j is given by:
	# Cov(p_i,p_j)	<- Fi*p0*(1-p0)
	# The expected variance of allele frequencies in the metapopulation (p) is given by the matrix population:
	# Var(p)		<- F*p0*(1-p0)
	#
	# p0 is estimated as:
	# p0 = 	1'_n*(F^-1)*p	# divided by:
	#		1'_n*(F^-1)*1_n
	# in which: 
	# 1_n:	n-vector of 1's (length of number of populations)
	# 1'_n:	?
	#
	# This function constructs a kinship matrix following the algorithm of the FLK test (Bonhomme et al. 2013).
	#
	popnames			<- mysambar$populations
	npops				<- length(popnames)
	# calculate Reynolds distance:
	if(is.null(mysambar$popdistdf))
		{
		popdistances()
		}
	# get distance matrix:
	distvec				<- mysambar$popdistdf[,"Reynolds_Weir_Cockerham_1983_adegenet",drop=FALSE]
	mattemp				<- matrix(NA,nrow=npops,ncol=npops)
	colnames(mattemp)	<- popnames
	rownames(mattemp)	<- popnames
	mattemp[lower.tri(mattemp)]	<- distvec[,1]
	distmat						<- t(mattemp)
	distmat[lower.tri(distmat)]	<- mattemp[lower.tri(mattemp)]
	#
	# Neighbour-joining tree:
	mytree				<- phangorn::NJ(distmat)
	branchlengths		<- mytree[2]$edge.length
	#
	# Kinship matrix:
	kinmatrix			<- matrix(0,nrow=npops,ncol=npops)
	colnames(kinmatrix)	<- popnames[mytree$edge[,2]]
	rownames(kinmatrix)	<- popnames[mytree$edge[,2]]
	diag(kinmatrix)		<- branchlengths
	kinmatrix[2,1]		<- 0			# mytree[2]$node.length ? 
	kinmatrix[1,2]		<- 0			# mytree[2]$node.length ?
	#
	}

plotfst<-function(popnames=mysambar$populations,export=NULL,inputvector=mysambar$pearsonvector,exportname="Mafcorr.pop",plottitle="Pearson's correlation coefficient",mycex=2.5,labcex=2.5)
	{
	# this expects output of mafcorr() function
	npops			<- length(popnames)
	# plot correlation:
	m2				<- matrix(NA,nrow=npops,ncol=npops)
	m2[lower.tri(m2, diag=FALSE)] <- inputvector
	mymatrix 			<- t(m2)
	rownames(mymatrix)	<- popnames
	colnames(mymatrix)	<- popnames
	ordermat			<- mymatrix
	mymatrix[lower.tri(mymatrix, diag=TRUE)] <-	0
	#
	# reorder populations (27-04-2021):
	ordermat[lower.tri(ordermat,diag=FALSE)]<- inputvector
	ordermat			<- ordermat[mysambar$popordernr,mysambar$popordernr]
	ordermat			<- round(ordermat,3)
	ordermat[lower.tri(ordermat,diag=TRUE)] <-	0
	#
	# plot:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),1)
	if(max(mymatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
		}
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(ordermat==0,NA,ordermat),
	notecol="black",notecex=mycex,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=labcex,cexRow=labcex,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	if(!is.null(plottitle))
		{
		mtext(plottitle, side = 3, line = 1, cex = 2.5)	
		}
	if(!is.null(export)){dev.off()}
	}

# depends on chromfst
multichromfst<-function(exporttype=NULL,nrchroms=NULL,popnames=mysambar$populations,silent=TRUE)
	{
	combitable		<- combn(popnames,m=2)
	ncombi			<- ncol(combitable)
	mycolours		<- as.vector(unique(inds$popcol))
	combicoltable	<- combn(mycolours,m=2)	
	myfstdf			<- snps[,grep("Wrightfst",colnames(snps))]
	for(combinr in c(1:ncombi))
		{
		my_fst		<- colnames(myfstdf)[combinr]
		mycolfunc 	<- colorRampPalette(c(combicoltable[1,combinr],combicoltable[2,combinr]))
		my_combicol	<- mycolfunc(3)[2]
		mypair		<- paste(combitable[1,combinr],combitable[2,combinr],sep="_")
		if(!silent){cat(my_fst,sep="\n")}
		if(!silent){cat(mypair,sep="\n")}
		chromfst(export=exporttype,n_chroms=nrchroms,myfst=my_fst,mycol=my_combicol,wideplot=TRUE,plotlabel=mypair)
		}
	}
	
chromfst<-function(export=NULL,n_chroms=NULL,myfst=NULL,mycol="darkorchid4",wideplot=FALSE,plotlabel=NULL,nsnpsplot=FALSE,yaxislabel="Fst",labcex=2.25)
	{
	if(is.null(n_chroms))
		{
		return(cat("Error: provide a value to the n_chroms flag.",sep="\n"))
		}
	if(is.null(myfst))
		{
		return(cat("Error: provide a string (Wrightfst_pop1_pop2) to the myfst flag.",sep="\n"))
		}
	snpstemp	<- snps[snps$chr2<=n_chroms&snps$filter,]
	snpstemp	<- snpstemp[order(snpstemp$chr2,snpstemp$pos),]
	if(!is.null(export))
		{
		if(wideplot)
			{
			mysize2	<- 4
			mysize	<- 14
			mysize4	<- 400
			mysize3	<- 1400
			plotname<- ifelse(is.null(plotlabel),"Chrom.fst",paste("Chrom.fst",plotlabel,sep="_"))
			}else{
			mysize2	<- 6
			mysize	<- 6
			mysize4	<- 600
			mysize3	<- 600
			plotname<- ifelse(is.null(plotlabel),"Chrom.fst.chromindex",paste("Chrom.fst.chromindex",plotlabel,sep="_"))
			}
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize2)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),,family=mysambar$myfont,width=mysize,height=mysize2)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mysize3,height=mysize4)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize2)}
		}
	par(mar=c(5,6.5,1,1),cex.axis=2)
	fstvalues	<- as.vector(snpstemp[,myfst])
	mycols		<- as.vector(snpstemp$chrcol)
	mycols		<- ifelse(mycols!="black",mycol,mycols)
	mycols2		<- as.vector(unique(mycols))
	if(wideplot)
		{
		plot(fstvalues,col=mycols,pch=16,cex=1.25,ylim=c(0,1),xlab="",ylab="",las=1)
		mtext(side=1,"SNP index",cex=labcex,line=3.5)
		}else{
		stripchart(fstvalues~chr2,data=snpstemp,vertical=TRUE,col=mycols2,method="jitter",pch=16,cex=0.5,bg="bisque",las=2,ylab="")
		mtext(side=1,"Chromosome index",cex=labcex,line=3.5)
		}
	mtext(side=2,yaxislabel,cex=labcex,line=4)
	if(!is.null(export)){dev.off()}
	if(nsnpsplot)
		{
		if(!is.null(export)){dev.off()}
		#
		# plot mean fst per chrom:
		if(!is.null(export))
			{
			plotname	<- ifelse(is.null(plotlabel),"Chrom.fst_vs_nsnps",paste("Chrom.fst_vs_nsnps",plotlabel,sep="_"))
			if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=6,height=6)}
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),,family=mysambar$myfont,width=6,height=6)}
			if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=600,height=600)}
			if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=6,height=6)}
			}
		par(mar=c(5,5,1,1))
		snpstemp	<- snpstemp[is.finite(fstvalues)&!is.na(fstvalues),]
		fstvalues	<- as.vector(snpstemp[,myfst])
		chrommeanfst<- aggregate(fstvalues,by=list(snpstemp$chr),FUN=mean)
		chromnsnps	<- aggregate(snpstemp$nsnps,by=list(snpstemp$chr),FUN=mean)
		plot(chromnsnps$x,chrommeanfst$x,xlab="",ylab="",pch=16,las=1,col="white")
		text(chromnsnps$x,chrommeanfst$x,as.character(chrommeanfst$Group.1),xlab="",ylab="",cex=1,las=1)
		mtext(side=1,"# SNPs per chrom",cex=2,line=3)
		mtext(side=2,"Chromosome mean ratio fst",cex=2,line=3)
		if(!is.null(export)){dev.off()}
		}
	}

# 23-05-2023: 
pops2matrix<-function(plot_label=NULL,my_Breaks=NULL,nr_breaks=8,doplot=TRUE,myscore=NULL,zero_diagonal=FALSE,return_object=TRUE,dofilter=FALSE,add_legend=TRUE,leg_posx=0.25,leg_posy=0.5,leg_cex=4,value_cex=3,my_col="orange",add_labels=TRUE,add_sidebars=TRUE,label_cex=2.5)
	{
	if(is.null(myscore))
		{
		return(cat("ERROR: specify column name (present in pops2 dataframe).",sep="\n"))
		}
	npops				<- length(mysambar$populations2)
	mymatrix			<- matrix(NA,nrow=npops,ncol=npops)
	colnames(mymatrix)	<- mysambar$populations2
	rownames(mymatrix)	<- mysambar$populations2
	if(!myscore%in%colnames(pops2))
		{
		return(cat("ERROR: specified column not present in pops2 dataframe.",sep="\n"))
		}
	myvector			<- as.vector(pops2[,myscore])
	for(i in c(1:npops))
		{
		mypop1	<- mysambar$populations2[i]
		for(j in c(1:npops))
			{
			if(i==j&zero_diagonal)
				{
				mymatrix[i,j]	<- 0
				}else{
				mypop2			<- mysambar$populations2[j]
				mymatrix[i,j]	<- myvector[(pops2$pop1==mypop1&pops2$pop2==mypop2)|(pops2$pop1==mypop2&pops2$pop2==mypop1)]
				}
			}
		}
	if(dofilter)
		{
		popfilter		<- mysambar$populations2%in%mysambar$populations
		mymatrix		<- mymatrix[popfilter,popfilter]
		pop_names		<- mysambar$populations		
		}else{
		popfilter		<- rep(TRUE,npops)
		pop_names		<- mysambar$populations2
		}
	if(doplot)
		{
		myplotname		<- ifelse(is.null(plot_label),"Popmatrix",paste("Popmatrix",plot_label,sep="_"))
		myplotname		<- ifelse(dofilter,paste(myplotname,"popfilter",sep="_"),myplotname)
		plotpopmatrix(exportname=paste(myplotname,"labels",sep="_"),addlabels=add_labels,showvalues=TRUE,popnames=pop_names,mymatrix=mymatrix,nrbreaks=nr_breaks,addlegend=add_legend,plotlabelcex=8,export="pdf",plotlabel=plot_label,myBreaks=my_Breaks,legposx=leg_posx,legposy=leg_posy,legcex=leg_cex,valuecex=value_cex,mycol=my_col,addsidebars=add_sidebars,label_cex)
		plotpopmatrix(exportname=myplotname,addlabels=add_labels,showvalues=FALSE,popnames=pop_names,mymatrix=mymatrix,nrbreaks=nr_breaks,addlegend=add_legend,plotlabelcex=8,export="pdf",plotlabel=plot_label,myBreaks=my_Breaks,legposx=leg_posx,legposy=leg_posy,legcex=leg_cex,valuecex=value_cex,mycol=my_col,addsidebars=add_sidebars,labelcex=label_cex)
		}
	if(return_object)
		{
		return(mymatrix)
		}
	}

# 10-10-2022: General function to plot matrices with pairwise population scores
# Note: no NA below diagonal, otherwise due to reordering data will be lost
# the function replaces below-diagonal values with zero after reordering
plotpopmatrix<-function(exportname="Popmatrix",popnames=mysambar$populations,mymatrix=NULL,export=NULL,ndecimals=3,mycol="orange",plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,valuecex=3,addlabels=TRUE,labelcex=2.5,addsidebars=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,legposx=0.25,legposy=0.5,legcex=5,addpoplegend=FALSE,poplegposx=0.25,poplegposy=0.5,poplegcex=4)
	{
	if(is.null(mymatrix))
		{
		return(cat("ERROR: specify an input matrix to the mymatrix flag.",sep="\n"))
		}
	npops				<- length(popnames)
	if(length(popnames)==1)
		{
		return(cat("ERROR: at present only 1 population defined. Not possible to plot pairwise population estimates.",sep="\n"))
		}
	if(ncol(mymatrix)!=npops)
		{
		return(cat("ERROR: number of columns does not correspond with number of populations.",sep="\n"))
		}
	if(nrow(mymatrix)!=npops)
		{
		return(cat("ERROR: number of rows does not correspond with number of populations.",sep="\n"))
		}
	if(any(is.na(mymatrix)))
		{
		return(cat("ERROR: no NA-values allowed.",sep="\n"))
		}
	myvec1	<- mymatrix[upper.tri(mymatrix,diag=FALSE)]
	myvec2	<- mymatrix[lower.tri(mymatrix,diag=FALSE)]
	myvec1	<- myvec1[order(myvec1)]
	myvec2	<- myvec2[order(myvec2)]
	if(any(myvec1!=myvec2))
		{
		return(cat("ERROR: because of reordering, input matrix should be symmetric relative to diagonal.",sep="\n"))
		}
	if(is.null(colnames(mymatrix)))
		{
		cat("WARNING: input matrix does not have column names. Assuming alphabetic ordering.",sep="\n")
		colnames(mymatrix)	<- popnames
		}
	if(is.null(rownames(mymatrix)))
		{
		cat("WARNING: input matrix does not have row names. Assuming alphabetic ordering.",sep="\n")
		rownames(mymatrix)	<- popnames
		}
	# prepare plot:
	if(is.null(myBreaks))
		{
		mymatrix			<- round(mymatrix,ndecimals)
		floor_dec 			<- function(x, level=1) round(x - 5*10^(-level-1), level)
		ceiling_dec 		<- function(x, level=1) round(x + 5*10^(-level-1), level)
		mymin				<- floor_dec(min(mymatrix,na.rm=TRUE),1)
		if(max(mymatrix,na.rm=TRUE)==1)
			{
			mymax			<- 1
			}else{
			mymax			<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
			}
		myBreaks			<- seq(mymin,mymax,(mymax-mymin)/nrbreaks)
		}
	testbreaks			<<- myBreaks
	mycolfunc 			<- colorRampPalette(c("white",mycol))
	myColours			<- c(mycolfunc(length(myBreaks)-1))
	#
	# reorder populations (27-04-2021):
	if(any(colnames(mymatrix)!=mysambar$poporder))
		{
		ordermat			<- mymatrix
		ordermat			<- ordermat[mysambar$popordernr,mysambar$popordernr]
		ordermat[lower.tri(ordermat,diag=FALSE)] <-	0
		ordermat			<- round(ordermat,ndecimals)
		}else{
		ordermat			<- round(mymatrix,ndecimals)
		ordermat[lower.tri(ordermat,diag=FALSE)] <-	0
		}
	#
	graphics.off()
	if(!is.null(export))
		{
		mysize		<- 3+npops*1.75
		mysize2		<- 300+npops*150
		exportname	<- ifelse(showvalues,paste(exportname,"withvalues",sep="."),paste(exportname,"NOvalues",sep="."))
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	if(addsidebars)
		{
		mysidecolors	<- mysambar$colorder
		}else{
		mysidecolors	<- NA
		}
	if(addlabels)
		{
		mypoplabels		<- mysambar$poporder
		}else{
		mypoplabels		<- NA
		}
	if(showvalues)
		{
		heatpos	<- heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),labRow=mypoplabels,labCol=mypoplabels,key=FALSE,Rowv=NA,Colv=NA,
		scale="none",RowSideColors=mysidecolors,ColSideColors=mysidecolors,col=myColours,breaks=myBreaks,dendrogram="none",trace="none",
		srtRow=45,srtCol=45,margins=c(12,12),cexCol=labelcex,cexRow=labelcex,cellnote=ifelse(ordermat==0,NA,ordermat),notecol="black",notecex=valuecex)
		#mtext("population", side = 1, cex = 2, line = 3.5)
		#mtext("population", side = 4, cex = 2, line = 0.5)
		}else{
		heatpos	<- heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),labRow=mypoplabels,labCol=mypoplabels,key=FALSE,Rowv=NA,Colv=NA,
		scale="none",RowSideColors=mysidecolors,ColSideColors=mysidecolors,col=myColours,breaks=myBreaks,dendrogram="none",trace="none",
		srtRow=45,srtCol=45,margins=c(12,12),cexCol=labelcex,cexRow=labelcex)
		}
	if(!is.null(plotlabel))
		{
		mtext(plotlabel, side = 3, line = labelline, cex = plotlabelcex)	
		}
	if(addlegend)	
		{
		mylimits	<- paste("(",round(heatpos$colorTable$low,3),",",round(heatpos$colorTable$high,3),"]",sep="")	# 16-11-2023: interval notation: correction from [,) to (,]
		legend(x=legposx,y=legposy,legend=mylimits,fill=myColours,bty='n',cex=legcex,title=legendtitle)
		}
	if(addpoplegend)
		{
		legend(x=poplegposx,y=poplegposy,legend=mysambar$poporder,fill=mysambar$colorder,bty='n',cex=poplegcex)
		}
	if(!is.null(export)){dev.off()}
	}

# Reynolds genetic distance
# depends on popdistances function
pop_reynoldsmatrix<-function(export=NULL,popnames=mysambar$populations)
	{
	npops		<- length(popnames)
	if(is.null(mysambar$popdistdf))
		{
		return(cat("ERROR: mysambar$popdistdf is missing. Did you run the popdistances function?",sep="\n")) 
		}
	# get distance matrix:
	if(!"RWC1983_ad"%in%colnames(mysambar$popdistdf))
		{
		return(cat("ERROR: column 'RWC1983_ad' not present in mysambar$popdistdf. Did you run the popdistances function?",sep="\n")) 
		}
	distvec						<- mysambar$popdistdf[,"RWC1983_ad",drop=FALSE]
	mattemp						<- matrix(NA,nrow=npops,ncol=npops)
	colnames(mattemp)			<- popnames
	rownames(mattemp)			<- popnames
	mattemp[lower.tri(mattemp)]	<- distvec[,1]
	distmat						<- t(mattemp)
	distmat[lower.tri(distmat)]	<- mattemp[lower.tri(mattemp)]
	#
	# reorder populations (27-04-2021):
	ordermat					<- distmat[mysambar$popordernr,mysambar$popordernr]
	ordermat[lower.tri(ordermat,diag=FALSE)] <-	0
	ordermat					<- round(ordermat,3)
	#
	# prepare plot:
	floor_dec 					<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec 				<- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin						<- floor_dec(min(ordermat,na.rm=TRUE),1)
	if(max(ordermat,na.rm=TRUE)==1)
		{
		mymax					<- 1
		}else{
		mymax					<- ceiling_dec(max(ordermat,na.rm=TRUE),1)
		}
	myBreaks					<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 					<- colorRampPalette(c("white","orange"))
	myColours					<- c(mycolfunc(length(myBreaks)-1))
	#
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("Reynoldsmatrix.pop.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("Reynoldsmatrix.pop.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("Reynoldsmatrix.pop.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("Reynoldsmatrix.pop.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(ordermat==0,NA,ordermat),
	notecol="black",notecex=2.5,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	mtext("Reynolds genetic distance", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	#
	mytmatrix					<- t(mymatrix)
	mysambar$popreynoldvector	<<- mytmatrix[lower.tri(mytmatrix,diag=FALSE)]
	diag(ordermat)				<- 0
	mysambar$popreynoldmatrix	<<- ordermat
	}

# Nei's genetic distance
pop_neimatrix<-function(popnames=mysambar$populations,export=NULL,mycol="orange",mycex=2.5,labelcex=2.5)
	{
	npops				<- length(popnames)
	if(length(popnames)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate Nei's genetic distance. Execution halted."))
		}
	mymatrix			<- stamppNeisD(mygenlight[inds$filter,snps$filter],pop=TRUE)
	colnames(mymatrix)	<- rownames(mymatrix)
	mymatrix			<- mymatrix[popnames,popnames]
	ordermat			<- mymatrix
	#
	# prepare plot:
	mymatrix[lower.tri(mymatrix, diag=FALSE)] <-	0
	mymatrix			<- round(mymatrix,3)
	floor_dec 			<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec 		<- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin				<- floor_dec(min(mymatrix,na.rm=TRUE),1)
	if(max(mymatrix,na.rm=TRUE)==1)
		{
		mymax			<- 1
		}else{
		mymax			<- ceiling_dec(max(mymatrix,na.rm=TRUE),1)
		}
	myBreaks			<- seq(mymin,mymax,(mymax-mymin)/5)
	mycolfunc 			<- colorRampPalette(c("white",mycol))
	myColours			<- c(mycolfunc(length(myBreaks)-1))
	#
	# reorder populations (27-04-2021):
	ordermat			<- ordermat[mysambar$popordernr,mysambar$popordernr]
	ordermat[lower.tri(ordermat,diag=FALSE)] <-	0
	ordermat			<- round(ordermat,3)
	#
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("Neimatrix.pop.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("Neimatrix.pop.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("Neimatrix.pop.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("Neimatrix.pop.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(ordermat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(ordermat==0,NA,ordermat),
	notecol="black",notecex=mycex,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=labelcex,cexRow=labelcex,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	#mtext("population", side = 1, cex = 2, line = 3.5)
	#mtext("population", side = 4, cex = 2, line = 0.5)
	mtext("Nei's genetic distance", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	mytmatrix				<- t(mymatrix)
	mysambar$popneivector	<<- mytmatrix[lower.tri(mytmatrix,diag=FALSE)]
	mysambar$popneimatrix	<<- mymatrix
	#
	combitable				<- combn(popnames,m=2)
	mysambar$pairpop1		<<- combitable[1,]
	mysambar$pairpop2		<<- combitable[2,]
	}

# 04_10_2021:
# Below function is alternative to the more simple command:
# ordermat=mat[mysambar$popordernr,mysambar$popordernr]
# Note that the above single line command (and below function as well in fact) only works if values above and below diagonal are identical.
reordermat<-function(myvector=mysambar$popneivector)
	{
	popnames				<- mysambar$populations
	npops					<- length(popnames)
	mymat					<- matrix(0,nrow=npops,ncol=npops)
	colnames(mymat)			<- popnames
	rownames(mymat)			<- popnames
	mymat[lower.tri(mymat)]	<- myvector
	tmat					<- t(mymat)
	mymat[upper.tri(mymat)]	<- tmat[upper.tri(tmat)]
	#
	# reorganize order:
	mydf					<- data.frame("x"=rep(mysambar$popordernr,each=npops),"y"=rep(mysambar$popordernr,npops),"z"=NA)
	for(k in c(1:nrow(mydf)))
		{
		x				<- mydf$x[k]
		y				<- mydf$y[k]
		mydf$z[k]		<- mymat[x,y]
		}
	ordermat			<- matrix(mydf$z,npops,npops,byrow=TRUE)
	colnames(ordermat)	<- mysambar$poporder
	rownames(ordermat)	<- mysambar$poporder
	return(ordermat)
	}



# 22-09-2021, edited on 04-10-2021 (earlier version contained an issue with reordering)
exportneitable<-function(popnames=mysambar$populations)
	{
	if(is.null(mysambar$popneivector))
		{
		return(cat("ERROR: mysambar$popneivector not present.",sep="\n"))
		}
	# Nei's D:
	neimat	<- reordermat(myvector=mysambar$popneivector)
	if(!is.null(mysambar$Wrightfstvector))
		{
		# Wright Fst:
		wrightmat				<- reordermat(myvector=mysambar$Wrightfstvector)
		mymat					<- neimat
		mymat[lower.tri(mymat)]	<- wrightmat[lower.tri(wrightmat)]
		write.table(round(mymat,3),"NeiD_above_WrightFst_below.txt",row.names=TRUE,col.names=TRUE,sep="\t",quote=FALSE)
		}
	if(!is.null(mysambar$WC1983fstvector))
		{
		# Weir and Cockerham Fst:
		wcmat					<- reordermat(myvector=mysambar$WC1983fstvector)
		mymat					<- neimat
		mymat[lower.tri(mymat)]	<- wcmat[lower.tri(wcmat)]
		write.table(round(mymat,3),"NeiD_above_WC1983Fst_below.txt",row.names=TRUE,col.names=TRUE,sep="\t",quote=FALSE)
		}
	}

# tree for populations:
# This shows genetic difference between populations, not evolutionary relationship!
# i.e. a recently diverged founder population can be genetically more distant from the source population than a bigger population which diverged earlier. 
# 28-08-2023: ERROR: when using a tree specified to mytree or inputnewickfile, the colours are off
# 27-09-2023: when to use tipcolours, when to use popcolours?
getpoptree<-function(mymatrix=mysambar$popneimatrix,exportlabel="neiD",popnames=mysambar$populations,popcolours=mysambar$mycolours,inputnewickfile=NULL,mytree=NULL,tree_angle=0,nshorten=0,labelcex=1.5,nodelabelcex=0.75,nodelabelcol="grey50",mytype="phylogram",myheight=NULL,mywidth=NULL,mylwd=2,edgecolors=TRUE,donj=TRUE,silent=TRUE,doexport=TRUE,addnodelabels=TRUE,maxnodelabel=NULL,myroot=NULL,writetree=FALSE,plotdirection="rightwards",x_lab=NULL,x_line=0,marknode=FALSE,marklabelcex=0.5,addaxis=TRUE)
	{
	#install.packages("phangorn")
	#library(phangorn)
	# 22-09-2021: replaced following line:
	# mymatrix[lower.tri(mymatrix)]	<- mymatrix[upper.tri(mymatrix)]
	# 22-09-2021: with the following lines:
	if(!is.null(inputnewickfile))
		{
		cat("Importing tree in newick format...",sep="\n")
		if(!file.exists(inputnewickfile))
			{
			cat(paste("ERROR: Specified tree file (",inputnewickfile,") not found in directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		mytree		<- ape::read.tree(inputnewickfile)
		}else{
		if(!is.null(mytree))
			{
			if(class(mytree)!="phylo")
				{
				return(cat("ERROR: Specified object to mytree flag is not a phylo object.",sep="\n"))
				}else{
				cat("Plotting tree specified in phylo object specified to mytree flag...",sep="\n")
				}
			}else{
			if(is.null(mymatrix))
				{
				return(cat("ERROR: input matrix (defined using mymatrix flag) does not exist. If input matrix is mysambar$popneimatrix (default), did you run the pop_neimatrix() function?",sep="\n"))
				}
			mymatrix						<- t(mymatrix)
			#mymatrix[lower.tri(mymatrix)]	<- mytmatrix[lower.tri(mytmatrix)]
			colnames(mymatrix)				<- popnames
			colnames(mymatrix)				<- popnames
			}
		}
	if(is.null(mytree))
		{
		if(!donj)
			{
			mytree						<- phangorn::upgma(mymatrix)
			}else{
			mytree						<- phangorn::NJ(mymatrix)
			}
		popcolours2			<- popcolours
		}else{
		# It seems that in case of using an input tree, a colour correction is needed:
		cat("Reassigning population colours...",sep="\n")
		popcolours2	<- vector()
		for(k in c(1:length(mytree$tip.label)))
			{
			mypop			<- mytree$tip.label[k]
			popcolours2[k]	<- mysambar$colorder[mysambar$poporder==mypop]
			}	
		}
	if(any(!mytree$tip.label%in%popnames))
		{
		return(cat("ERROR: one or more populations specified in tree not present in popnames vector (by default: mysambar$populations).",sep="\n"))
		}
	if(any(!popnames%in%mytree$tip.label))
		{
		return(cat("ERROR: one or more populations specified in popnames vector (by default: mysambar$populations) not present in tree.",sep="\n"))
		}
	#mycolors2 				<- rep("black",Nedge(mytree))
	mycolors2 				<- rep("black",nrow(mytree$edge))	#25-10-2023
	npops					<- length(popnames)
	#
	if(edgecolors)
		{
		if(!silent){cat("Defining edge colours...",sep="\n")}
		tipindex				<- which(mytree$edge[,2]%in%c(1:npops))
		poporder				<- mytree$edge[tipindex,2]
		#
		# correction 20-09-2023 to fix colours:
		newcolvec				<- rep(NA,npops)
		for(k in c(1:npops))
			{
			mypop				<- mytree$tip.label[poporder[k]]
			#cat(mypop,sep="\n")
			newcolvec[k]		<- popcolours[popnames==mypop]
			}
		mycolors2[tipindex]		<- newcolvec
		}		
	if(!is.null(myroot))
		{
		cat("ERROR: flag 'myroot' has been unabled. To include root, use commands 'myrootedtree=root(mysambar$poptree,outgroup='outgroupname',resolve.root=TRUE)' and getpoptree(mytree=myrootedtree).",sep="\n")
		#mytree				<- root(mytree,outgroup=myroot,resolve.root=TRUE)
		}
	# plot:
	treemethod	<- ifelse(donj,"NJ","UPGMA")
	plotname	<- ifelse(donj,paste("Poptree",exportlabel,treemethod,mytype,"pdf",sep="."),paste("Poptree",exportlabel,treemethod,mytype,"pdf",sep="."))
	if(doexport)
		{
		if(is.null(myheight)&is.null(mywidth))
			{
			pdf(plotname)
			}else{
			pdf(plotname,height=myheight,width=mywidth)
			}
		}
	labelangle	<- ifelse(mytype=="phylogram","horizontal","axial")
	#
	# DEFINE TIP COLOURS:
	tipindex	<- which(mytree$edge[,2]%in%c(1:npops))
	tiporder	<- mytree$edge[tipindex,2]
	tipcolours	<- popcolours[tiporder]
	#
	# PLOT:
	#plot.phylo(mytree,cex=labelcex,font=3,adj=0,edge.color=mycolors2,tip.color=popcolours2,lwd=mylwd,edge.width=mylwd,show.node.label=FALSE,type=mytype,lab4ut=labelangle)
	if(nshorten==0)
		{
		plot.phylo(mytree,cex=labelcex,font=3,adj=0,edge.color=mycolors2,tip.color=popcolours2,lwd=mylwd,edge.width=mylwd,show.node.label=FALSE,type=mytype,lab4ut=labelangle,direction=plotdirection,rotate.tree=tree_angle)
		}else{
		cat(paste("Plotting tree with ",nshorten," shortened branches...",sep=""),sep="\n")
		ape::plotBreakLongEdges(mytree,n=nshorten,cex=labelcex,font=3,adj=0,edge.color=mycolors2,tip.color=popcolours2,lwd=mylwd,edge.width=mylwd,show.node.label=FALSE,type=mytype,lab4ut=labelangle,direction=plotdirection,rotate.tree=tree_angle)
		}
	if(addnodelabels)
		{
		if(!is.null(mytree$node.label))
			{
			if(!silent){cat("Adding node labels...",sep="\n")}
			# this are node labels (e.g. support values), not tip labels (e.g. sample names, stored at mytree$label)
			if(!is.null(maxnodelabel))
				{
				mytree$node.label	<- ifelse(mytree$node.label>=maxnodelabel,NA,mytree$node.label)
				}
			if(marknode)
				{
				if(is.null(maxnodelabel)){maxnodelabel=0.75}
				mytree$node.label	<- ifelse(mytree$node.label<=maxnodelabel,"#",NA)
				exampletree			<<- mytree
				nodelabels(mytree$node.label,frame="n",cex=nodelabelcex,xpd=TRUE,col="red")
				}else{
				nodelabels(mytree$node.label,adj=c(1.3,-0.5),frame="n",cex=nodelabelcex,font=3,xpd=TRUE,col=nodelabelcol)
				}
			}else{
			if(!silent){cat("Nodelabels not present.",sep="\n")}
			}
		}
	if(addaxis){axis(side=1)}
	if(!is.null(x_lab)){mtext(side=1,x_lab,cex=labelcex,line=x_line)}
	if(doexport){dev.off()}
	mysambar$poptree		<<- mytree
	if(writetree)
		{
		write.tree(mysambar$poptree,file=paste("Poptree",exportlabel,treemethod,"newick.txt",sep="."),append=FALSE)
		}
	}


# Nei_1977_Fst	(until 17-06-2020 called Wright Fst)
locusNeiFst<-function(popnames=mysambar$populations,histo=FALSE,export=NULL)
	{
	combitable		<- combn(popnames,m=2)
	# Prepare plot:
	graphics.off()
	if(histo)
		{
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Nei1977_Fst.eps",family=mysambar$myfont,width=10,height=7)}
			if(export=="pdf"){pdf("Nei1977_Fst.pdf",family=mysambar$myfont,width=10,height=7)}
			if(export=="png"){png("Nei1977_Fst.png",family=mysambar$myfont,width=1000,height=720)}
			if(export=="wmf"){win.metafile("Nei1977_Fst.wmf",family=mysambar$myfont,width=10,height=7)}
			}
		par(mfrow=c(1,ncol(combitable)),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		maf2pops		<- glMean(mygenlight[inds$filter&inds$pop==combitable[1,i]|inds$pop==combitable[2,i],])		
		expHt			<- 2*maf2pops*(1-maf2pops)
		mafpop1			<- snps[names(snps) == paste("maf",combitable[1,i],sep="_")]
		mafpop2			<- snps[names(snps) == paste("maf",combitable[2,i],sep="_")]
		expHs			<- 0.5*((2*mafpop1[,1]*(1-mafpop1[,1]))+(2*mafpop2[,1]*(1-mafpop2[,1])))		# I included [,1] to avoid problems when snps-dataset contain multiple column with the same name
		snps$NeiFst		<<- (expHt-expHs)/expHt 
		# Names of both populations combined:
		combiname		<- paste(combitable[1,i],combitable[2,i],sep="_")
		# Plot:
		if(histo)
			{
			hist(snps$NeiFst[snps$filter],50,main=combiname,xlab="Wright Fst")
			}
		# Change name of column in snps dataset:
		names(snps)[names(snps) == "NeiFst"] <<- paste("NeiFst",combiname,sep = "_")			
		}
	if(histo)
		{
		if(!is.null(export)){dev.off()}
		}
	inds <<- inds[, !duplicated(colnames(inds), fromLast = TRUE)] 
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

runstamppFst<-function(n_boots=100,popnames=mysambar$populations,export=NULL,do_analysis=TRUE,mycex=2.5,labcex=2.5)
	{
	mymatrix	<- as.matrix(mygenlight[inds$filter,snps$filter])
	indstemp	<- droplevels(inds[inds$filter,])
	mymatrix	<- mymatrix[order(indstemp$pop),]
	indstemp2	<- indstemp[order(indstemp$pop),]
	tempgenlight<- as.genlight(mymatrix)
	pop(tempgenlight)<- indstemp2$pop
	npops		<- as.vector(length(unique(indstemp2$pop)))
	# sambarfunction_calcdistance:
	##### CALCDISTANCE #####
	# sambarfunction_calcdistance:
	### Fst analyses:
	# sambarfunction_calcdistance:
	if(do_analysis)
		{
		myfstout					<- stamppFst(tempgenlight, nboots = n_boots, percent = 95, nclusters = 1)
		myfstvalues					<- round(myfstout$Fsts[lower.tri(myfstout$Fsts,diag=FALSE)],4)
		mypvalues					<- myfstout$Pvalues[lower.tri(myfstout$Pvalues,diag=FALSE)]
		mylogpvalues				<- -log10(mypvalues)
		mylogpvalues[is.infinite(mylogpvalues)]	<- 20
		mysambar$WC1983fstvector	<<- myfstvalues
		mysambar$WC1983pvector		<<- round(mypvalues,12)
		mysambar$WC1983logpvector	<<- mylogpvalues
		}else{
		cat("Using previously generated Stampp fst-values...",sep="\n")
		myfstvalues		<- mysambar$WC1983fstvector
		mypvalues		<- mysambar$WC1983pvector
		mylogpvalues	<- mysambar$WC1983logpvector 
		}
	### FST
	fstmat				<- matrix(NA,nrow=npops,ncol=npops)
	fstmat[lower.tri(fstmat, diag=FALSE)] <- myfstvalues
	fstmat 				<- t(fstmat)
	rownames(fstmat)	<- popnames
	colnames(fstmat)	<- popnames
	orderfstmat			<- fstmat
	fstmat[lower.tri(fstmat,diag=TRUE)] <-	0
	#
	# reorder populations (27-04-2021):
	orderfstmat[lower.tri(orderfstmat,diag=FALSE)]	<- myfstvalues
	orderfstmat			<- orderfstmat[mysambar$popordernr,mysambar$popordernr]
	orderfstmat[lower.tri(orderfstmat,diag=TRUE)] 	<-	0
	#
	### P-VALUES
	pmat				<- matrix(NA,nrow=npops,ncol=npops)
	pmat[lower.tri(pmat,diag=FALSE)] <- mypvalues
	pmat 				<- t(pmat)
	rownames(pmat)		<- popnames
	colnames(pmat)		<- popnames
	orderpmat			<- pmat
	pmat[lower.tri(pmat,diag=TRUE)] <-	0
	#
	# reorder populations (27-04-2021):
	orderpmat[lower.tri(orderpmat,diag=FALSE)]<- mypvalues
	orderpmat			<- orderpmat[mysambar$popordernr,mysambar$popordernr]
	orderpmat[lower.tri(orderpmat,diag=TRUE)] <-	0
	#	
	if(npops>2)
		{
		myfstmatrix	<- round(orderfstmat,3)
		mypmatrix	<- round(orderpmat,12)
		mycolfunc 	<- colorRampPalette(c("white","orange"))
		floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
		ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
		mymin		<- floor_dec(min(myfstmatrix,na.rm=TRUE),1)
		if(max(myfstmatrix,na.rm=TRUE)==1)
			{
			mymax	<- 1
			}else{
			mymax	<- ceiling_dec(max(myfstmatrix,na.rm=TRUE),1)
			}
		myBreaks	<- seq(mymin,mymax,(mymax-mymin)/10)
		myColours	<- c(mycolfunc(length(myBreaks)-1))
		#
		if(!is.null(export))
			{
			mysize	<- 3+npops*1.75
			mysize2	<- 300+npops*150
			if(export=="eps"){postscript("WC_1984_Fst_pvalues.eps",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="pdf"){pdf("WC_1984_Fst_pvalues.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="png"){png("WC_1984_Fst_pvalues.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
			if(export=="wmf"){win.metafile("WC_1984_Fst_pvalues.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
			}
		heatmap.2(mypmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=mypmatrix,
		notecol="black",notecex=mycex,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=labcex,cexRow=labcex,Colv=NA,scale="none",
		col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
		mtext("Weir & Cockerham 1984 Fst p-values", side = 3, line = 1, cex = 2.5)	
		if(!is.null(export)){dev.off()}
		#
		if(!is.null(export))
			{
			mysize	<- 3+npops*1.75
			mysize2	<- 300+npops*150
			if(export=="eps"){postscript("WC_1984_Fst.eps",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="pdf"){pdf("WC_1984_Fst.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
			if(export=="png"){png("WC_1984_Fst.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
			if(export=="wmf"){win.metafile("WC_1984_Fst.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
			}
		heatmap.2(myfstmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(myfstmatrix==0,NA,myfstmatrix),
		notecol="black",notecex=mycex,labCol=mysambar$poporder,labRow=mysambar$poporder,Rowv=NA,cexCol=labcex,cexRow=labcex,Colv=NA,scale="none",
		col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
		mtext("Weir & Cockerham 1984 Fst", side = 3, line = 1, cex = 2.5)	
		if(!is.null(export)){dev.off()}
		}else{
		cat("Omitting heatmap because 2 populations only (1 pairwise comparison).",sep="\n")
		}
	mysambar$stampp_fstmat	<<- orderfstmat
	mysambar$stampp_pmat	<<- orderpmat
	}

# Weir and Cockerham Fst: 	
locusWCfst<-function(my_dataset=NULL,mycol="grey",do_plot=TRUE)
	{
	if(is.null(my_dataset))
		{
		return(cat("ERROR: provide input (i.e. pop1_pop2) to the my_dataset flag.",sep="\n"))
		}
	if(my_dataset=="pheno")
		{
		pop_1		<- "pheno1" 
		pop_2		<- "pheno2"
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		}
	mafpop1			<- snps[names(snps) == paste("maf",pop_1,sep="_")]	
	mafpop2			<- snps[names(snps) == paste("maf",pop_2,sep="_")]
	# I included [,1] to avoid problems when snps dataset contain multiple columns with the same name.
	pop1f0			<- (mafpop1[,1]*mafpop1[,1])+((1-mafpop1[,1])*(1-mafpop1[,1]))
	pop2f0			<- (mafpop2[,1]*mafpop2[,1])+((1-mafpop2[,1])*(1-mafpop2[,1]))
	f1				<- (mafpop1[,1]*mafpop2[,1])+((1-mafpop1[,1])*(1-mafpop2[,1]))	
	snps$WeirHe		<<- 1-f1 
	snps$WeirFst	<<- (0.5*(pop1f0+pop2f0)-f1)/snps$WeirHe
	my_dataset2		<- paste(pop_1,pop_2,sep="\n")
	# Plot:
	if(do_plot)
		{
		hist(snps$WeirFst[snps$filter],50,main=my_dataset2,col=mycol,xlim=c(0,1),breaks=seq(0,1,0.02),ylim=c(0,(nrow(snps[snps$filter,])/6)),xlab="")
		}
	# Change names of columns in snps dataset:
	names(snps)[names(snps) == "WeirHe"] <<- paste("WeirHe",my_dataset,sep = "_")		
	names(snps)[names(snps) == "WeirFst"] <<- paste("WeirFst",my_dataset,sep = "_")			
	# If the function has been run multiple times, duplicated columns can arise. 
	# This is not only redundant, but can also lead to ERRORs. To remove duplicated columns:
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]	
	}

# requires locusWCfst
run_locusWCfst<-function(popnames=mysambar$populations,mycolours=mysambar$mycolours,export=NULL,silent=TRUE,doplot=TRUE)
	{
	npops			<- length(mysambar$populations)
	if(npops==1)
		{
		return(cat("Currently only 1 population defined. Not possible to calculate Fst measures.",sep="\n"))
		}
	combitable		<- combn(popnames,m=2)
	combicoltable	<- combn(mycolours,m=2)	
	ncombi			<- ncol(combitable)
	npops			<- length(mysambar$populations)
	#
	# Prepare histogram plot:
	if(doplot)
		{
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("WC_Fst.eps",family=mysambar$myfont,width=5*ncombi+2,height=7)}
			if(export=="pdf"){pdf("WC_Fst.pdf",family=mysambar$myfont,width=5*ncombi+2,height=7)}
			if(export=="png"){png("WC_Fst.png",family=mysambar$myfont,width=200*ncombi+75,height=700)}
			if(export=="wmf"){win.metafile("WC_Fst.wmf",family=mysambar$myfont,width=5*ncombi+2,height=7)}
			}
		par(mfrow=c(1,ncol(combitable)+1),mai=c(0.75,1,0.75,0.25),oma=c(1,1,2,1),cex.main=2,cex.lab=2,cex.axis=1.5)
		}
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		mypop_1		<- combitable[1,i]
		mypop_2		<- combitable[2,i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		mypoppair	<- paste(my_pops[1],my_pops[2],sep="_")
		if(!silent){cat(mypoppair,sep="\n")}
		# As colour we are going to use a blend of the two population colours:
		mycol1			<- combicoltable[1,i]
		mycol2			<- combicoltable[2,i]
		mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
		mycol3			<- mycolfunc3(3)[2]
		locusWCfst(my_dataset=mypoppair,mycol=mycol3,do_plot=doplot)
		if(doplot)
			{
			mtext("WC Fst",cex=2,side=1,line=3)
			}
		}
	#mtext("Weir & Cockerham Fst",cex=2,side=1,line=-1.5,outer=TRUE)	# not handy if user wants to subselect tiles
	#
	# WeirHe_meta:
	if(npops==2)
		{
		mypop_1		<- combitable[1,1]
		mypop_2		<- combitable[2,1]
		myhe		<- snps[,paste("WeirHe",my_pops[1],my_pops[2],sep="_")]
		snps$WeirHe_metapop			<<- myhe
		}else{
		snps2		<- snps
		if("WeirHe_pheno" %in% colnames(snps2))
			{
			snps2$WeirHe_pheno	<- NULL
			}
		if("WeirHe_metapop" %in% colnames(snps2))
			{
			snps2$WeirHe_metapop	<- NULL
			}
		snpstemp					<- snps2[,grep("WeirHe_",colnames(snps2))]
		snps$WeirHe_metapop			<<- apply(snpstemp,1,function(x){mean(x,na.rm=TRUE)})
		}
	# WeirFst_meta:
	if(npops==2)
		{
		mypop_1		<- combitable[1,1]
		mypop_2		<- combitable[2,1]
		myfst		<- snps[,paste("WeirFst",mypop_1,mypop_2,sep="_")]
		snps$WeirFst_metapop		<<- myfst
		}else{
		snps2		<- snps
		if("WeirFst_pheno" %in% colnames(snps2))
			{
			snps2$WeirFst_pheno	<-NULL
			}
		if("WeirFst_metapop" %in% colnames(snps2))
			{
			snps2$WeirFst_metapop<-NULL
			}
		snpstemp	<- snps2[,grep("WeirFst_",colnames(snps2))]
		snps$WeirFst_metapop		<<- apply(snpstemp,1,function(x){mean(x,na.rm=TRUE)})
		}
	if(doplot)
		{
		hist(snps$WeirFst_metapop[snps$filter],50,main="metapop",col="white",xlim=c(0,1),breaks=seq(0,1,0.02),ylim=c(0,(nrow(snps[snps$filter,])/6)),xlab="")
		mtext("WC Fst",cex=2,side=1,line=3)
		if(!is.null(export)){dev.off()}
		}
	# If the function has been run multiple times, duplicated columns can arise. 
	# This is not only redundant, but can also lead to ERRORs. To remove duplicated columns:
	snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}	
	
Fdist_plot<-function(my_dataset="Busen_Norway",showlegend=FALSE,showlabels=TRUE,exporttype=NULL,axislabels=TRUE,add_borders=FALSE,add_outliers=FALSE,outliercex=2,addsd=FALSE,y_axis='s',x_axis='s',my_labels=NULL,dothin=TRUE,silent=TRUE,legendpheno=FALSE)
	{
	#cat(my_dataset,sep="\n")
	WeirHe		<- snps[,names(snps) == paste("WeirHe",my_dataset,sep="_")]
	WeirFst		<- snps[,names(snps) == paste("WeirFst",my_dataset,sep="_")]
	nsnps		<- nrow(snps[snps$filter,])
	mycex		<- ifelse(nsnps>10000,0.5,ifelse(nsnps>5000,1,1.25))
	if(dothin)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf		<- as.data.frame(cbind(WeirHe,WeirFst))
		mydf		<- unique(mydf[snps$filter2,])
		WeirHe2		<- mydf$WeirHe
		WeirFst2	<- mydf$WeirFst
		}else{
		WeirHe2		<- WeirHe
		WeirFst2	<- WeirFst
		}
	if(!is.null(exporttype))
		{
		myplotlabels<- ifelse(is.null(my_labels),my_dataset,paste(my_labels[1],my_labels[2],sep="_"))
		plotname	<- ifelse(add_outliers,paste("Fdist.outliers",myplotlabels,sep="."),paste("Fdist",myplotlabels,sep="."))
		if(exporttype=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=7,height=7)}
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=7,height=7)}
		if(exporttype=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=700,height=700)}
		if(exporttype=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=7,height=7)}
		}
	#plot(WeirHe2[1:5],WeirFst2[1:5],main="",xlim=c(0,1),ylim=c(0,1),pch=16,cex=mycex,xlab="",ylab="",yaxt=y_axis,xaxt=x_axis,las=1,col="grey50")
	# 01-05-2021: for some reason previous line was in use (only first 5 SNPs)
	plot(WeirHe2,WeirFst2,main="",xlim=c(0,1),ylim=c(0,1),pch=16,cex=mycex,xlab="",ylab="",yaxt=y_axis,xaxt=x_axis,las=1,col="grey50")
	if(add_borders)
		{
		# Boundaries of He-Fst space:
		wche				<- seq(0,1,0.01)
		wcfst1				<- (2*wche-1)/wche
		wcfst1[wcfst1<0]	<- NA
		wcfst2				<- wche
		points(wche,wcfst1,type='l',col="grey")
		points(wche,wcfst2,type='l',col="grey")
		points(WeirHe2,WeirFst2,pch=16,cex=mycex,col="grey65")
		if(!showlegend&my_dataset!="pheno") 
			{
			text(x=0.4,y=0.5,"Left border:\nMAFpop1 = 0\n| MAFpop2 = 0",adj=1,cex=1.75)
			text(x=0.6,y=0.2,"Right border:\nMAFpop1 =\n1 - MAFpop2",adj=0,cex=1.75)
			}
		}
	if(add_outliers)
		{
		snpcolnames		<- colnames(snps)
		if(!silent){cat("OutFLANK",sep="\n")}
		mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
		add_outflankout	<- mycolumn%in%snpcolnames
		#
		noutflankout	<- 0
		nbayescanout	<- 0
		nfsthetout		<- 0
		ngwdsout		<- 0
		npcadaptout		<- 0
		bayescan_other	<- FALSE	# do outliers occur in other comparisons?
		fsthet_other	<- FALSE
		gwds_other		<- FALSE
		outflank_other	<- FALSE
		pcadapt_other	<- FALSE
		#
		if(add_outflankout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("OutFLANK",my_dataset,sep="_")]
			noutflankout	<- length(outlierfilter[outlierfilter])
			if(noutflankout==0)
				{
				cat("WARNING: no outliers found by one of the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^OutFLANK', names(snps))] 
				alltestdf		<- alltestdf[,seq(1,ncol(alltestdf),3)]
				outflank_other	<- any(as.matrix(alltestdf))
				}
				
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="orange",pch=15,cex=outliercex)
			}
		#
		if(!silent){cat("Bayescan",sep="\n")}
		mycolumn			<- paste("bayescanout",my_dataset,sep="_")
		addbayescanout		<- mycolumn%in%snpcolnames
		if(addbayescanout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("bayescanout",my_dataset,sep="_")]
			nbayescanout	<- length(outlierfilter[outlierfilter])
			if(nbayescanout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^bayescanout', names(snps))] 
				bayescan_other	<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="red",pch=17,cex=outliercex)
			}
		#
		if(!silent){cat("Fsthet",sep="\n")}
		mycolumn			<- paste("fsthetout",my_dataset,sep="_")
		addfsthetout		<- mycolumn%in%snpcolnames
		if(addfsthetout)	
			{
			outlierfilter	<- snps[,names(snps) == paste("fsthetout",my_dataset,sep="_")]
			nfsthetout	<- length(outlierfilter[outlierfilter])
			if(nfsthetout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^fsthetout', names(snps))] 
				fsthet_other	<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="darkorchid4",pch=20,cex=outliercex)
			}
		#
		if(!silent){cat("GWDS",sep="\n")}
		mycolumn			<- paste("rfisherout",my_dataset,sep="_")
		addgwds				<- mycolumn%in%snpcolnames
		if(addgwds)	
			{
			outlierfilter	<- snps[,names(snps) == paste("rfisherout",my_dataset,sep="_")]
			ngwdsout		<- length(outlierfilter[outlierfilter])
			if(ngwdsout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^rfisherout', names(snps))] 
				gwds_other		<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="blue",pch=16,cex=outliercex)
			}else{
			cat(paste("The snps dataframe does not contain column with GWDS logp values for population pair ",my_dataset," and therefore GWDS outliers are omitted from the Fdist plot.",sep=""),sep="\n")
			}
		#
		if(!silent){cat("pcadapt",sep="\n")}
		mycolumn			<- paste("PCadaptout",my_dataset,sep="_")
		addpcadapt			<- mycolumn%in%snpcolnames
		if(addpcadapt)		
			{
			outlierfilter	<- snps[,names(snps) == paste("PCadaptout",my_dataset,sep="_")]
			npcadaptout		<- length(outlierfilter[outlierfilter])
			if(npcadaptout==0)
				{
				cat("WARNING: no outliers found by one the selected scans. Omitting this scan from the Fdistplot.",sep="\n")
				alltestdf		<- snps[, grep('^PCadaptout', names(snps))] 
				pcadapt_other	<- any(as.matrix(alltestdf))
				}
			points(WeirHe[outlierfilter&snps$filter2],WeirFst[outlierfilter&snps$filter2],col="darkgreen",pch=18,cex=outliercex)
			}else{
			cat(paste("The snps dataframe does not contain column with PCadapt logp values for population pair ",my_dataset," and therefore PCadapt outliers are omitted from the Fdist plot.",sep=""),sep="\n")
			cat(paste("If you are running the assocfisher command, or if you are running the selectionanalyses function with the flag 'do_pcadapt' set to FALSE, this is expected behaviour.",sep=""),sep="\n")
			}
		#
		}
	if(my_dataset=="pheno"|showlegend)
		{
		mylegend1	<- ifelse(addbayescanout&nbayescanout>0,"Bayescan",ifelse(bayescan_other&legendpheno,"Bayescan","nolegend"))
		mylegend2	<- ifelse(addfsthetout&nfsthetout>0,"Fsthet",ifelse(fsthet_other&legendpheno,"Fsthet","nolegend"))
		mylegend3	<- ifelse(addgwds&ngwdsout>0,"GWDS",ifelse(gwds_other&legendpheno,"GWDS","nolegend"))
		mylegend4	<- ifelse(add_outflankout&noutflankout>0,"OutFLANK",ifelse(outflank_other&legendpheno,"OutFLANK","nolegend"))
		mylegend5	<- ifelse(addpcadapt&npcadaptout,"PCadapt",ifelse(pcadapt_other&legendpheno,"PCadapt","nolegend"))
		mylegend	<- c(mylegend1,mylegend2,mylegend3,mylegend4,mylegend5)
		mylegend	<- mylegend[!mylegend=="nolegend"]
		#
		mycolour1	<- ifelse(addbayescanout&nbayescanout>0,"red",ifelse(bayescan_other&legendpheno,"red","nocolour"))
		mycolour2	<- ifelse(addfsthetout&nfsthetout>0,"darkorchid4",ifelse(fsthet_other&legendpheno,"darkorchid4","nocolour"))
		mycolour3	<- ifelse(addgwds&ngwdsout>0,"blue",ifelse(gwds_other&legendpheno,"blue","nocolour"))
		mycolour4	<- ifelse(add_outflankout&noutflankout>0,"orange",ifelse(outflank_other&legendpheno,"orange","nocolour"))
		mycolour5	<- ifelse(addpcadapt&npcadaptout,"darkgreen",ifelse(pcadapt_other&legendpheno,"darkgreen","nocolour"))
		mycolour	<- c(mycolour1,mycolour2,mycolour3,mycolour4,mycolour5)
		mycolour	<- mycolour[!mycolour=="nocolour"]
		#
		if(length(mylegend)!=0)
			{
			legend(x=0,y=0.95,legend=mylegend,fill=mycolour,bty='n',cex=2)
			}
		}
	if(showlabels)
		{
		if(my_dataset=="pheno"|my_dataset=="assoc1_assoc2")
			{
			if(is.null(my_labels))
				{
				mtext("typeA_typeB",side=3,line=-3,cex=2)
				}else{
				mtext(paste(my_labels[1],my_labels[2],sep="_"),side=3,line=-3,cex=2)
				}
			}else{
			mtext(my_dataset,side=3,line=-3,cex=2)
			}
		}
	if(axislabels)
		{
		mtext("Weir & Cockerham (1987) Fst", side = 2, cex = 2, line = 2.5)
		mtext("Weir & Cockerham (1987) He", side = 1, cex = 2, line = 3)
		}
	if(addsd)
		{
		points(snps$WeirHe_metapop[snps$mafSDtop1000],snps$WeirFst_metapop[snps$mafSDtop1000],col="grey",cex=0.75,pch=16)
		points(snps$WeirHe_metapop[snps$mafSDtop250],snps$WeirFst_metapop[snps$mafSDtop250],col="grey20",cex=0.75,pch=16)
		points(snps$WeirHe_metapop[snps$mafSDtop125],snps$WeirFst_metapop[snps$mafSDtop125],col="red",cex=0.75,pch=16)
		}
	if(!is.null(exporttype)){dev.off()}
	}	
	
# requires Fdist_plot
Fdist_multiplot<-function(popnames=mysambar$populations,export=NULL)
	{
	combitable	<- combn(popnames,m=2)
	npairwise	<- ncol(combitable)
	ntiles		<- ifelse(npairwise==1,1,ifelse((npairwise==2||npairwise==3||npairwise==4),3,5))
	ntabs		<- ceiling(ncol(combitable)/ntiles)
	for (n in c(1:ntabs))
		{ 	
		graphics.off()
		if(n<ntabs)
			{
			combisubtable	<- as.matrix(combitable[,c(((n-1)*ntiles+1):(n*ntiles))])		# 17-5-2019: as.matrix is needed in case we select one column only
			}else{
			combisubtable	<- as.matrix(combitable[,c(((n-1)*ntiles+1):ncol(combitable))]) # 17-5-2019: as.matrix is needed in case we select one column only
			}
		ncomparisons		<- ncol(combisubtable)
		myheight1			<- ntiles*8
		myheight2			<- ntiles*500
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Fdist",n,"eps",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			if(export=="pdf"){pdf(paste("Fdist",n,"pdf",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			if(export=="png"){png(paste("Fdist",n,"png",sep="."),family=mysambar$myfont,width=720,height=myheight2)}
			if(export=="wmf"){win.metafile(paste("Fdist",n,"wmf",sep="."),family=mysambar$myfont,width=10,height=myheight1)}
			}
		# If multiple plots (multiple pairwise comparisons), divide the screen:
		par(mfrow=c(ntiles,1),oma=c(5,7,1,1),mar=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		for (i in c(1:ncomparisons))
			{
			combiname	<- paste(combisubtable[1,i],combisubtable[2,i],sep="_")
			addborders	<- ifelse(i==1,TRUE,FALSE)
			Fdist_plot(my_dataset=combiname,axislabels=FALSE,add_borders=addborders)
			if(n<ntabs)
				{
				if(i==ntiles)
					{
					mtext("Weir & Cockerham (1987) He", side = 1, cex = 2.75, line = 4)
					}
				}else{
				if(i==(ncol(combisubtable)))
					{
					mtext("Weir & Cockerham (1987) He", side = 1, cex = 2.75, line = 4)
					}
				}
			}
		mtext("Weir & Cockerham (1987) Fst", side = 2, cex = 3, line = 3.5,outer=TRUE)
		if(!is.null(export)){dev.off()}
		}
	}	

# Multilocus Weir and Cockerham Fst
multiLocusWeirFst<-function(popnames=mysambar$populations,export=NULL)
	{
	# duplicated columns in snps dataframe will lead to ERRORs, so therefore we first execute: 
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	combitable			<- combn(popnames,m=2)
	multilocusweirfstvector		<- vector()
	npops				<- length(popnames)
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		pop1			<- combitable[1,i]
		pop2			<- combitable[2,i]
		# select columns with minor allele frequencies:
		mafpop1			<- snps[names(snps) == paste("maf",pop1,sep="_")]	
		temp			<- colnames(mafpop1)
		mafpop1			<- mafpop1[[temp]]
		mafpop2			<- snps[names(snps) == paste("maf",pop2,sep="_")]
		temp			<- colnames(mafpop2)
		mafpop2			<- mafpop2[[temp]]
		#test1			<<- mafpop1
		#test2			<<- mafpop2
		# filter:
		mafpop1			<- mafpop1[snps$filter]
		mafpop2			<- mafpop2[snps$filter] 	
		## first define the required variables:
		r				<- 2							# number of pops
		npop1			<- length(inds$name[inds$pop==pop1])
		npop2			<- length(inds$name[inds$pop==pop2])
		nmean			<- mean(npop1,npop2)					# mean sample size per pop
		nloci			<- length(mafpop1)					# number of loci
		nvar			<- (npop1^2)/(r*nmean)+(npop2^2)/(r*nmean)
		nc				<- (r*nmean - nvar)/(r-1)
		mafavg			<- 1/2*(mafpop1+mafpop2)	
		mafvarmat		<- matrix(nrow=3,ncol=nloci)
		for (j in c(1:nloci))
			{
			mafvarmat[1,j]	<- (npop1*(mafpop1[j]-mafavg[j])^2)/((r-1)*nmean)
			mafvarmat[2,j]	<- (npop2*(mafpop1[j]-mafavg[j])^2)/((r-1)*nmean)	
			mafvarmat[3,j]	<- mafvarmat[1,j]+mafvarmat[2,j]
			}
		mafvar			<- mafvarmat[3,]	
		# For he, assuming Hardy-Weinberg:
		he			<- 1/2*((2*mafpop1*(1-mafpop1))+(2*mafpop2*(1-mafpop2))) 
		## now we can calculate a, b and c:
		a			<- (nmean/nc)*(mafvar-(1/(nmean-1))*(mafavg*(1-mafavg)-mafvar*((r-1)/r)-1/4*he))
		b			<- (nmean/(nmean-1))*((mafavg*(1-mafavg))-(((r-1)/r)*mafvar)-((2*he*nmean-1)/(4*nmean)))  
		weirc		<- 1/2*he
		# now we can calculate the multilocus-Fst:
		multilocusweirfstvector[i]	<- round(sum(a)/(sum(a)+sum(b)+sum(weirc)),3)
		}
	# Visualize using heatmap
	myfstmatrix	<<- matrix(0,npops,npops)
	myfstmatrix[lower.tri(myfstmatrix, diag=FALSE)] <<- multilocusweirfstvector	# in two steps, to get the order right (we want it by row, rather than by column)
	myfstmatrix <<- t(myfstmatrix)						# in two steps, to get the order right (we want it by row, rather than by column)
	myfstmatrix	<<- round(myfstmatrix,3)
	mycolfunc 	<- colorRampPalette(c("white","orange"))
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(myfstmatrix,na.rm=TRUE),1)
	if(max(myfstmatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(myfstmatrix,na.rm=TRUE),1)
		}
	myBreaks	<- seq(mymin,mymax,(mymax-mymin)/10)
	myColours	<- c(mycolfunc(length(myBreaks)-1))
	if(!is.null(export))
		{
		mysize	<- 3+npops*1.75
		mysize2	<- 300+npops*150
		if(export=="eps"){postscript("WeirFst.multilocus.eps",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf("WeirFst.multilocus.pdf",family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png("WeirFst.multilocus.png",family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile("WeirFst.multilocus.wmf",family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(myfstmatrix,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=ifelse(myfstmatrix==0,NA,myfstmatrix),
	notecol="black",notecex=2.5,labCol=popnames,labRow=popnames,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	mtext("Weir & Cockerham 1983 multilocus Fst", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	# return a table:
	myfstmatrix				<<- rbind(combitable,multilocusweirfstvector)
	rownames(myfstmatrix)	<<- c("pop1","pop2","fst")
	myfstmatrix				<<- as.data.frame(myfstmatrix,stringsAsFactors = FALSE)
	colnames(myfstmatrix)	<<- c(1:ncol(myfstmatrix))
	}

mypopdivergencetable<-function()
	{
	mydf				<- rbind(myfstmatrix,mysambar$popneivector)
	rownames(mydf)[4]	<- "nei's D"
	write.table(mydf,"SambaR.popdivergence.stats.txt",row.names=TRUE,col.names=TRUE,quote=FALSE,sep="\t")
	}	

pidf2matrix_old<-function(pidf=pidf_meta[[1]],myinds=inds$nr[inds$filter],do_colour=FALSE)
	{
	ninds									<- length(myinds)
	m2										<- matrix(NA,nrow=ninds,ncol=ninds)
	if(do_colour)
		{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"colour"]
		diag(m2)							<- pidf[(1:ninds),"colour"]
		}else{
		m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		diag(m2)							<- pidf[(1:ninds),"ndiffpersite"]
		}
	colnames(m2)							<- myinds
	rownames(m2)							<- myinds
	pimatrix								<- t(m2)
	if(do_colour)
		{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"colour"]
		}else{
		pimatrix[lower.tri(pimatrix)]		<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
		}
	return(pimatrix)
	}	

pidf2matrix<-function(pidf=mysambar$pidf_meta[[1]],do_asd=FALSE,myinds=inds$nr[inds$filter],myindnames=inds$name[inds$filter],mypops=inds$pop[inds$filter],quickmethod=TRUE,do_colour=FALSE,onlybetweenpop=FALSE,onlywithinpop=FALSE)
	{
	if(is.null(pidf))
		{
		return(cat("ERROR: no (existing) dataframe specified to pidf dataframe.",sep="\n"))
		}
	ninds		<- length(myinds)
	nexprows	<- ninds+((ninds*(ninds-1))/2)
	if(nexprows!=nrow(pidf))
		{
		return(cat("ERROR: number of rows of specified pidf does not correspond with expected number based on current filter settings. First rerun the calcpi function.",sep="\n"))
		}else{
		cat("Input dataframe has the expected length.",sep="\n")
		}
	cat("Creating distance matrix...",sep="\n") 
	# 24-05-2023: 'quick method' replaced with more reliable 'slow method':
	if(quickmethod)
		{
		cat("WARNING: using quick (less reliable) method to convert data into distance matrix...",sep="\n")
		m2										<- matrix(NA,nrow=ninds,ncol=ninds)
		if(do_colour)
			{
			m2[lower.tri(m2)]					<- pidf[(ninds+1):nrow(pidf),"colour"]				# below diagonal between individual colours
			diag(m2)							<- pidf[(1:ninds),"colour"]							# on diagonal individual colours	
			}else{
			if(do_asd)
				{
				m2[lower.tri(m2)]				<- pidf[(ninds+1):nrow(pidf),"ASD"]				# below diagonal between individual scores
				diag(m2)						<- pidf[(1:ninds),"ASD"]						# on diagonal individual scores
				}else{
				m2[lower.tri(m2)]				<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]	# below diagonal between individual scores
				diag(m2)						<- pidf[(1:ninds),"ndiffpersite"]				# on diagonal individual scores
				}
			}
		colnames(m2)							<- myindnames
		rownames(m2)							<- myindnames
		mymatrix								<- t(m2)
		if(do_colour)
			{
			mymatrix[lower.tri(mymatrix)]		<- pidf[(ninds+1):nrow(pidf),"colour"]
			}else{
			if(do_asd)
				{
				mymatrix[lower.tri(mymatrix)]		<- pidf[(ninds+1):nrow(pidf),"ASD"]
				}else{
				mymatrix[lower.tri(mymatrix)]		<- pidf[(ninds+1):nrow(pidf),"ndiffpersite"]
				}
			}
		}else{
		# 24-05-2023: new lines:
		mymatrix									<- matrix(NA,nrow=ninds,ncol=ninds)
		colnames(mymatrix)							<- myindnames
		rownames(mymatrix)							<- myindnames
		if(do_colour)
			{
			mycolumn	<- pidf$colour
			}else{
				{
				if(do_asd)
					{
					mycolumn	<- pidf$ASD
					}else{
					mycolumn	<- pidf$ndiffpersite
					}
				}
			}
		for(i in c(1:length(myindnames)))
			{
			myind1	<- myindnames[i]
			for(j in c(1:length(myindnames)))
				{
				myind2	<- myindnames[j]
				mymatrix[i,j]	<- mycolumn[(pidf$name1==myind1&pidf$name2==myind2)|(pidf$name1==myind2&pidf$name2==myind1)] 
				}
			}
		}
	### until here changes on 24-05-2023	
	if(onlybetweenpop)
		{
		for(i in c(1:ninds))
			{
			for(j in c(1:ninds))
				{
				mypop1	<- mypops[i]
				mypop2	<- mypops[j]
				if(mypop1==mypop2)
					{
					mymatrix[i,j]			<- NA
					}
				}
			}
		}
	if(onlywithinpop)
		{
		for(i in c(1:ninds))
			{
			for(j in c(1:ninds))
				{
				mypop1	<- mypops[i]
				mypop2	<- mypops[j]
				if(mypop1!=mypop2)
					{
					mymatrix[i,j]			<- NA
					}
				}
			}
		}
	return(mymatrix)
	}	

# End of population differentiation analyses 
###############################################################################################################









###############################################################################################################
# Demographic analyses
# 03-04-2022: Originally part of calcdistance function. Stand-alone function since SambaR_v1.07.

inferdemography<-function(Kmin=2,Kmax=6,my_bg="white",axis_col="black",nchroms=NULL,silent=TRUE,do_LEA=TRUE,do_Dstats=TRUE,D_triplets=NULL,do_hybridindex=FALSE,do_hybridcheck=FALSE,do_binaryD=FALSE,f4_outgroup=NULL,do_f4=FALSE,do_f3=TRUE,plot_f2heatmap=TRUE,f3_triplets=NULL,f3_preparefiles=TRUE,f3_maxmiss=0.1,f3_plottitle="f3-score",f3_legendcex=1.25,do_Dfst=FALSE,my_root=NULL,max_ntriplets=60,do_jackknife=TRUE,jk_blocksize=1000000,minjkblocks=50,bayesassmatrix=NULL,pop_order=mysambar$poporder,short_pop=NULL,colour_vector=mysambar$colorder,LEAperpop=FALSE,LEAheightfactor=0.75,LEAwidthfactor=0.1,LEAaxiscex=1.5,LEAlabelcex=1.75,LEAyaxiscex=1.25,LEAylabel=NULL,shortpop_nr_chars=3)
	{
	### GENE FLOW ANALYSES
	# many options:
	# - D calculation implemented in SAMBAR (according to algorithm of Simon H Martin)
	# - Dfst calculation implemented in SAMBAR (not validated, experimental algorithm)
	# - R package HybridCheck
	# - R package StrataG (related to HybridCheck?)
	# - R package Admixtools2 (f3 and f4 statistics)
	# - R package admixr (many statistics, mostly based on admixtools)
	# - additional analyses: functions for generating inputfiles and plotting output files of Bayesass software 
	#
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(length(mysambar$populations)==1)
		{
		return(cat("At present only 1 population defined. No need to calculate genetic distance between populations. Execution halted.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}	
		my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	#
	setwd(mysambar$demographydir)
	if(!is.null(bayesassmatrix))
		{
		plotmigration(myinputmatrix=bayesassmatrix,mycolours=NULL,export="pdf",addaxis=FALSE,addlabels=TRUE,use_current_dir=FALSE)
		}
	if(!do_LEA)
		{
		cat("Skipping LEA ancestry calculations because the flag do_LEA is set to FALSE.",sep="\n")
		}else{
		if("LEA" %in% (.packages()) == FALSE)
			{
			cat("Package LEA not installed or loaded. Skipping LEA admixture analyses.",sep="\n")
			}else{
			cat("Creating admixture barplot using LEA...",sep="\n")
			runLEA(mindemes=Kmin,maxdemes=Kmax,poporder=pop_order)
			if(!silent){cat("Plotting cross-entropy criterion...",sep="\n")}
			LEAceplot(export="eps",mindemes=Kmin,maxdemes=Kmax)
			LEAceplot(export="pdf",mindemes=Kmin,maxdemes=Kmax)
			LEAceplot(export="png",mindemes=Kmin,maxdemes=Kmax)
			if(mysambar$os=="Windows"){LEAceplot(export="wmf",mindemes=Kmin,maxdemes=Kmax)}
			if(!silent){cat("eps",sep="\n")}
			LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="eps",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="eps",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			if(!silent){cat("pdf",sep="\n")}
			LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,addindname=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			#if(!silent){cat("png",sep="\n")}
			#LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="png",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			#LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="png",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
			if(!silent){cat("wmf",sep="\n")}
			if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",poporder=pop_order,shortpop=short_pop,addindnr=TRUE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
			if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",poporder=pop_order,shortpop=short_pop,addindnr=FALSE,ylabel=LEAylabel,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
			#
			# full population name (axiscex and shortpop_nrchars):
			LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",borderlwd=1,bordercol="white",dolabelcol=TRUE,popnames=mysambar$populations,poporder=mysambar$poporder,addindname=FALSE,order_on_longitude=FALSE,shortpop_nrchars=12,heightfactor=LEAheightfactor,addindnr=FALSE,axiscex=0.75)
			LEAstructureplot(mindemes=Kmin,maxdemes=Kmax,export="pdf",borderlwd=1,bordercol="white",dolabelcol=FALSE,popnames=mysambar$populations,poporder=mysambar$poporder,addindname=FALSE,order_on_longitude=FALSE,shortpop_nrchars=12,heightfactor=LEAheightfactor,addindnr=FALSE,axiscex=0.75)
			#
			# optionally order by longitude:
			if(("latitude" %in% colnames(inds)&"longitude" %in% colnames(inds)))
				{
				if(any(is.na(inds$longitude))|any(is.na(inds$latitude)))
					{
					cat("No missing values allowed in longitude and latitude column.",sep="\n")
					cat("SambaR will not order LEA structure plots by longitude.",sep="\n")
					}else{
					if(!silent){cat("LEAstructureplot by longitude",sep="\n")}
					runLEA(mindemes=Kmin,maxdemes=Kmax,order_on_longitude=TRUE)
					LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
					LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=FALSE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)	
					LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,addindname=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
					if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
					if(mysambar$os=="Windows"){LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="wmf",addindnr=FALSE,ylabel=LEAylabel,order_on_longitude=TRUE,colourvector=colour_vector,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)}
					}
				}
			if(any(as.vector(inds$pop)!=as.vector(inds$pop2))&LEAperpop)
				{
				cat("Running LEA per population.",sep="\n")
				for (my_pop in mysambar$populations)
					{
					cat(my_pop,sep="\n")
					nrinds	<- nrow(inds[inds$pop==my_pop&inds$filter,])
					if(nrinds<3)
						{
						cat("Less than 3 individuals. Skipping LEA admixture plot.",sep="\n")
						}else{
						runLEA(mindemes=Kmin,maxdemes=6,popnames=mysambar$populations,order_on_longitude=FALSE,focuspop=my_pop)
						indspop		<- inds[inds$pop==my_pop&inds$filter,]
						mysubpops	<- unique(as.vector(indspop$pop2))
						mysubpops	<- mysubpops[order(mysubpops)]
						LEAstructureplot(mybg=my_bg,axiscol=axis_col,mindemes=Kmin,maxdemes=Kmax,export="pdf",addindnr=TRUE,ylabel=LEAylabel,order_on_longitude=FALSE,poporder=pop_order,shortpop=short_pop,colourvector=colour_vector,focuspop=my_pop,popnames=mysubpops,heightfactor=LEAheightfactor,widthfactor=LEAwidthfactor,axiscex=LEAaxiscex,labelcex=LEAlabelcex,yaxiscex=LEAyaxiscex,shortpop_nrchars=shortpop_nr_chars)
						}
					}
				}
			}
		}
	#
	if(length(mysambar$populations)<3)
		{
		return(cat("ERROR: less than 3 populations. Not possible to perform gene flow analyses other than LEA ancestry calculations.",sep="\n"))
		}
	if(do_f3)
		{
		if(f3_preparefiles)
			{
			# first create ped-file:
			runadmixtools(silent=FALSE,tripletdf=f3_triplets,myprefix="metapop.retainedinds.filter.number",overwriteped=TRUE,max_miss=f3_maxmiss)
			# next on command line prompt convert into bed-file using plink:
			# plink --file metapop.retainedinds.filter.number --allow-extra-chr --make-bed --recode A --out metapop.retainedinds.filter.number
			# Note, after reset of filter settings, all admixtools folders need to be deleted, and the PED and BED-file should be recreated, to avoid downstream errors.
			return(cat("After having created the bed-file with plink, rerun the inferdemography function as follows: inferdemography(do_f3=TRUE,f3_preparefiles=FALSE).",sep="\n"))
			}else{
			runadmixtools(silent=FALSE,tripletdf=NULL,myprefix="metapop.retainedinds.filter.number",overwriteped=FALSE,max_miss=f3_maxmiss,calcf4=do_f4)
			f3table(mythres=0)
			if(plot_f2heatmap)
				{
				cat("Creating f2-heatmap...",sep="\n")
				cat("If you receive an error after this line, set the flag 'do_f2heatmap' to FALSE.",sep="\n")
				plotpopmatrix(exportname="f2_matrix_6bins",popnames=mysambar$populations,mymatrix=apply(mysambar$f2_blocks,1:2,mean),nrbreaks=6,addlegend=TRUE,export="pdf",legcex=6,plotlabel="f2-score")
				plotpopmatrix(exportname="f2_matrix_10bins",popnames=mysambar$populations,mymatrix=apply(mysambar$f2_blocks,1:2,mean),nrbreaks=10,addlegend=TRUE,export="pdf",legcex=6,plotlabel="f2-score")
				plotpopmatrix(exportname="f2_matrix_14bins",popnames=mysambar$populations,mymatrix=apply(mysambar$f2_blocks,1:2,mean),nrbreaks=14,addlegend=TRUE,export="pdf",legcex=6,plotlabel="f2-score")
				}
			cat("Creating heatmap highlighting negative f3 scores...",sep="\n")
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=-0.01,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=-0.005,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=-0.002,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=-0.001,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=0.05,f3thres=0,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0001,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0002,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.00025,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0005,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.00075,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.001,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.00125,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0015,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.00175,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.002,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.00225,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0025,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.003,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0035,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.004,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.0045,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			f3heatmap(creatematrix=TRUE,pthres=1,f3thres=0.005,export="pdf",exportname="f3heatmap",fillsquare=TRUE,plottitle=f3_plottitle,mybg=my_bg,legendcex=f3_legendcex)
			cat("Creating boxplot with f3 scores...",sep="\n")
			popboxplot(myscore=mysambar$f3df_all$est,popvector=mysambar$f3df_all$pop1,addstripchart=TRUE,yline=0,ylabel="f3-score",export="pdf",exportname="f3boxplot_SNP_f3",mycex=0.5,labcex=2.5)
			popboxplot(myscore=mysambar$f3df_all$est,popvector=mysambar$f3df_all$pop1,addstripchart=TRUE,yline=0,ylabel="f3-score",export="wmf",exportname="f3boxplot_SNP_f3",mycex=0.5,labcex=2.5)
			f3pvalues(mydf=mysambar$f3df,export="pdf",plotname="f3_pvalues",yline=5.75,f3thres=0)
			if(mysambar$os=="Windows"){f3pvalues(mydf=mysambar$f3df,export="wmf",plotname="f3_pvalues",yline=5.75,f3thres=0)}
			f3pvalues(mydf=mysambar$f3df,export="pdf",plotname="f3_pvalues",yline=5.75,f3thres=0.002)
			if(mysambar$os=="Windows"){f3pvalues(mydf=mysambar$f3df,export="wmf",plotname="f3_pvalues",yline=5.75,f3thres=0.002)}
			#
			# SEARCH FOR OPTIMAL ADMIXTURE GRAPH:
			# 1. prepare input files:
			# setwd(mysambar$demographydir)
			# inferdemography(do_LEA=FALSE,do_Dstats=FALSE,do_f3=TRUE,f3_triplets=NULL,f3_preparefiles=TRUE)
			# system("C:/path/to/plink --file metapop.retainedinds.filter.number --chr-set 80 --allow-extra-chr --make-bed --recode A --out metapop.retainedinds.filter.number")
			#	
			# 2. run analyses:
			# nadmixture	<- 1
			# findgraph(do_analyses=TRUE,out_group=f4_outgroup,nadmixture=1)
			#
			# 3. export plot:
			# myadmixgraph	<- mysambar$admixgraph
			# mybestscore	<- round(min(myadmixgraph$score,na.rm=TRUE))
			# mybestrun		<- which(myadmixgraph$score==min(myadmixgraph$score))
			# plot_graph(myadmixgraph$edges[[mybestrun]])
			# ggsave(paste("Admixturegraph",paste("nadmixture",mybestscore,sep=""),paste("score",mybestscore,sep=""),"png",sep="."))
			}
		}
	if(do_Dstats)
		{
		if(is.null(D_triplets))
			{
			cat("No input triplets dataframe defined. Finding all possible triplets...",sep="\n")
			if(is.null(mysambar$poptree))
				{
				pop_neimatrix(export="pdf")
				getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=0.75)
				}
			if(is.null(my_root))
				{
				return(cat("ERROR: please specify an outgroup population to the my_root flag.",sep="\n"))
				}
			findtriplets(mytree=mysambar$poptree,doexport=TRUE,makeglobal=FALSE,myroot=my_root)
			#
			# find all possible triplets:
			# mypops				<- mysambar$populations
			# my_triplets			<- as.data.frame(permutations(n=length(mypops),r=3,v=mypops,repeats.allowed=F))
			# colnames(my_triplets)	<- c("p1","p2","p3")
			# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
			# my_triplets$myorder	<- as.character(my_triplets$p2)>as.character(my_triplets$p1)
			# my_triplets$ingroup	<- ifelse(my_triplets$myorder,paste(my_triplets$p1,my_triplets$p2,my_triplets$p3,sep="_"),paste(my_triplets$p2,my_triplets$p1,my_triplets$p3,sep="_"))
			# my_triplets			<- my_triplets[(!duplicated(my_triplets$ingroup)),c(1:3)]
			my_triplets				<- rfdf[,c(1:3)]
			}else{
			my_triplets				<- D_triplets
			}
		mysambar$triplets			<<- my_triplets
		colnames(my_triplets)	<- c("p1","p2","p3")
		popvec					<- unique(c(my_triplets$p1,my_triplets$p2,my_triplets$p3))
		if(any(!popvec%in%mysambar$populations))
			{
			return(cat("ERROR: One or more population defined in Dstats triplets dataframe not found in retained dataset (mysambar$populations). Please edit the triplets dataframe.",sep="\n"))
			}
		ntriplets				<- nrow(my_triplets)
		if(ntriplets>max_ntriplets)
			{
			cat(paste("More than ",max_ntriplets," population triplets. Omitting ABBA-BABA statistics.",sep=""),sep="\n")
			cat("Provide a different value to the flag 'max_ntriplets' if you want to run ABBA-BABA analyses anyway.",sep="\n")
			cat("Alternatively, and preferably, define a shorter set of triplets to the my_triplets flag.",sep="\n")
			cat("The input to the my_triplets should be a dataframe with three columns called 'p1','p2', and 'p3', listing for each triplet the ingroup1, ingroup2, and the introgressor species.",sep="\n") 
			}else{
			cat("Calculating ABBA-BABA statistics...",sep="\n")
			calcD(popnames=mysambar$populations,snpfilter=snps$filter,silent=TRUE,mytriplets=my_triplets,dojackknife=do_jackknife,minblocks=minjkblocks,jkblocksize=jk_blocksize)
			plotD(export="eps")
			plotD(export="png")
			plotD(export="pdf")
			#if(mysambar$os=="Windows"){plotD(export="wmf")}	# file too big
			plotD(export="eps",shortpop=TRUE)
			plotD(export="png",shortpop=TRUE)
			plotD(export="pdf",shortpop=TRUE)
			#if(mysambar$os=="Windows"){plotD(export="wmf",shortpop=TRUE)}	# file too big
			plotD(export="eps",doboxplot=TRUE)
			plotD(export="png",doboxplot=TRUE)
			plotD(export="pdf",doboxplot=TRUE)
			#if(mysambar$os=="Windows"){plotD(export="wmf",doboxplot=TRUE)}	# file too big
			plotD(export="eps",shortpop=TRUE,doboxplot=TRUE)
			plotD(export="png",shortpop=TRUE,doboxplot=TRUE)
			plotD(export="pdf",shortpop=TRUE,doboxplot=TRUE)
			#if(mysambar$os=="Windows"){plotD(export="wmf",shortpop=TRUE,doboxplot=TRUE)}	# file too big		
			#
			barplotD(mydf=mysambar$dscores,export="pdf",silent=TRUE,plottitle=NULL,allcombi=FALSE,addnsnps=TRUE)
			barplotD(mydf=mysambar$dscores,export="pdf",silent=TRUE,plottitle=NULL,allcombi=TRUE,addnsnps=TRUE)
			#
			if(do_Dfst)
				{
				plotD(export="eps",plotDfst=TRUE)
				plotD(export="pdf",plotDfst=TRUE)
				plotD(export="png",plotDfst=TRUE)
				#if(mysambar$os=="Windows"){plotD(export="wmf",plotDfst=TRUE)}	# file too big
				plotD(export="eps",plotDfst=TRUE,shortpop=TRUE)
				plotD(export="pdf",plotDfst=TRUE,shortpop=TRUE)
				plotD(export="png",plotDfst=TRUE,shortpop=TRUE)
				#if(mysambar$os=="Windows"){plotD(export="wmf",plotDfst=TRUE,shortpop=TRUE)}	# file too big
				}
			}
		}
	if(do_hybridindex)
		{
		# depends on gghybrid package
		# under construction
		cat("WARNING: Hybrid index calculations (using gghybrid package) not yet available.",sep="\n") 
		# calchi(plothi=FALSE,plotcline=TRUE,parentinfo=TRUE)
		}
	if(do_hybridcheck)
		{
		cat("Calculating ABBA-BABA statistics using HybridCheck...",sep="\n")	
		# p-values don't make sense yet, so therefore only 1 block (no jackknife approach included).
		# Rather than using p-values in hybridcheck output, I should use same method as used in calcD.
		runhybridcheck(use_exampledata=FALSE,myquartet=NULL,popnames=mysambar$populations,nsnpsperblock=NULL,nblocks=1)
		plotD(mydf=hbdf,export="eps",shortpop=TRUE,methodname="HybridCheck")
		plotD(mydf=hbdf,export="png",shortpop=TRUE,methodname="HybridCheck")
		plotD(mydf=hbdf,export="pdf",shortpop=TRUE,methodname="HybridCheck")
		if(mysambar$os=="Windows"){plotD(mydf=hbdf,export="wmf",shortpop=TRUE,methodname="HybridCheck")}
		}
	if(do_binaryD)
		{
		# binary D (strataG package?):
		binaryD(exampledata=FALSE,fourpops=mysambar$populations,samplesize=200)
		plotD(mydf=myhbdf,export="pdf",methodname="HybridCheck",doboxplot=TRUE,shortpop=TRUE)
		}
	if(!is.null(nchroms))
		{
		chromD(n_chroms=nchroms,silent=TRUE)
		plotD(export="eps",n_chroms=nchroms)
		plotD(export="pdf",n_chroms=nchroms)
		plotD(export="png",n_chroms=nchroms)
		#if(mysambar$os=="Windows"){plotD(export="wmf",n_chroms=nchroms)}
		cat("D statistics plots have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	# karyotype:
	if(!is.null(nchroms))
		{
		cat("Sliding window analyses...",sep="\n")
		# window fst and Dfst:
		calcwindowDfst()													# calculate window Dfst
		multiplotkaryo(nrchroms=nchroms,exporttype="pdf",mystatdf=windowfstdf,mystat="Wrightfst")
		}
	#cat("Outputting summary table...",sep="\n")
	#mypopdivergencetable()
	cat("Analysis finished. Output saved in Demography subdirectory.",sep="\n")
	setwd(mysambar$inputdatadir)
	}

calchi<-function(plothi=FALSE,plotcline=TRUE,parentinfo=TRUE)
	{
	# calculate hybrid index using the package gghybrid:
	# install_github("ribailey/gghybrid")
	# library(gghybrid)
	# library(coda)
	#
	if(parentinfo)
		{
		# WITH PARENTAL REFERENCE:
		cat("Reading data...",sep="\n")
		dat			<- read.data("sparrow.stru",nprecol=2,MISSINGVAL=NA,NUMINDS=569)
		prepdata	<- data.prep(data=dat$data,loci=dat$loci,alleles=dat$alleles,S0=c("Kralove","Oslo"),S1="LesinaSPANISH",precols=dat$precols,AF.CIoverlap = FALSE)
		# run actual analysis:
		# recommended: nitt=3000,burnin=1000
		cat("Calculating hybrid index...",sep="\n")
		hindlabel1	<- esth(data.prep.object=prepdata$data.prep,read.data.precols=dat$precols,include.Source=TRUE,nitt=3000,burnin=1000)
		hindlabel2	<- esth(data.prep.object=prepdata$data.prep,read.data.precols=dat$precols,include.Source=TRUE,nitt=3000,burnin=1000)
		hindlabel3	<- esth(data.prep.object=prepdata$data.prep,read.data.precols=dat$precols,include.Source=TRUE,nitt=3000,burnin=1000)
		# if you want to visualize a traceplot, then include arguments:
		# plot.ind=c("PD07-254","PD07-160","PD07-159","PI07-110","PI08-498","PH08-285"),plot.col=c("blue","green","cyan","purple","magenta","red")
		}else{
		# WITHOUT PARENTAL REFERENCE:
		dat			<- read.data("sparrow.stru",nprecol=2,MISSINGVAL=NA,NUMINDS=569)
		prepdata	<- data.prep(data=dat$data,loci=dat$loci,alleles=dat$alleles,S0=c("Kralove","Oslo"),S1="LesinaSPANISH",precols=dat$precols,AF.CIoverlap = FALSE,return.locus.table = TRUE)
		# create marker info file:
		sparrowMarkers	<- prepdata$locus.data[,.(locus,S0_allele,S1_allele,S0.prop_0,S1.prop_0)]
		setnames(sparrowMarkers,c("S0_allele","S1_allele","S0.prop_0","S1.prop_0"),c("refAllele","alternateAllele","S0.prop_r","S1.prop_r"))
		fwrite(sparrowMarkers,"sparrowMarkers.csv")
		# Read in the sparrow data again, this time together with the new marker info file, and without specifying parental reference samples:
		dat 		<- read.data(file="sparrow.stru",nprecol=2,NUMINDS=569,MISSINGVAL=NA,marker.info.file = "sparrowMarkers.csv", sourceAbsent = TRUE);
		prepdata	<- data.prep(data=dat$data,loci=dat$loci,sourceAbsent=TRUE,marker.info=dat$marker.info,alleles=dat$alleles,precols=dat$precols,min.diff = 0.2)
		}
	#
	if(plothi)
		{
		cat("Plotting hybrid index...",sep="\n")
		# visualize posterior:
		# plot(hindlabel1$hi$h_posterior_mode,pch=16,cex=0.5)
		# points(hindlabel1$hi$h_cred_int_lower,pch=16,cex=0.5,col="red")
		# points(hindlabel1$hi$h_cred_int_upper,pch=16,cex=0.5,col="blue")
		#
		# plot test samples ordered along the x axis by the mean hybrid index calculated above and also by individual hybrid index ("POPID" is included as some population pairs may have identical mean hi).
		# also: add ablines to denote minimum and maximum values of parental populations
		abc <- plot_h(data=hindlabel1$hi,test.subject=hindlabel$test.subject,mean.h.by="POPID",sort.by=c("mean_h","POPID","h_posterior_mode"),col.group="POPID",group.sep="POPID",fill.source=TRUE,basic.lines=FALSE,
		source.col=c("blue","red"),source.limits=c("blue","red"),custom.abline=abline(h=0.76,col="grey",lty=2),cex=1,pch=16,cex.lab=1.5,cex.main=1.5,ylim=c(0,1))
		}
	# Combine the three results:
	setkey(hindlabel1$hi,INDLABEL);setkey(hindlabel2$hi,INDLABEL);setkey(hindlabel3$hi,INDLABEL)
	hindall	<- hindlabel1$hi[,.(Source,INDLABEL,POPID,beta_shape1,beta_shape2)][hindlabel2$hi[,.(INDLABEL,beta_shape1,beta_shape2)]][hindlabel3$hi[,.(INDLABEL,beta_shape1,beta_shape2)]]
	hindall[,rn:=seq(1,.N)]
	#
	# Evaluate whether MCMC-run converged using the Gelman-Rubin diagnostic per individual (ideally all samples should have a score below 1.2):
	# library(coda): needed for mcmc.list function
	hindall[,h_gelman:=coda::gelman.diag(mcmc.list(mcmc(qlogis(rbeta(10000,beta_shape1,beta_shape2))),mcmc(qlogis(rbeta(10000,i.beta_shape1,i.beta_shape2))),mcmc(qlogis(rbeta(10000,i.beta_shape1.1,i.beta_shape2.1)))))$psrf[1],by=rn]
	hist(hindall$h_gelman,breaks=50)
	#
	if(plotcline)
		{
		cat("Calculating cline...",sep="\n")
		# to show trace plot whilst running, add arguments plot.test.subject= c("A2ML1_SNP1","GTF2H2"),plot.col=c("orange","cyan"),plot.ylim = c(-3, 5),plot.pch.v.centre = c(1, 3), 
		gc=ggcline(data.prep.object=prepdata$data.prep,esth.object=hindlabel,esth.colname="h_posterior_mode",test.subject="locus",poolv=FALSE,poolcentre=FALSE,include.Source=TRUE,return.likmeans=TRUE,read.data.precols=dat$precols,
		fix.subject.v=FALSE,fix.value.v,fix.subject.centre=FALSE,fix.value.centre,prior.logitcentre=c(0,sqrt(50)),prior.logv=c(0,sqrt(10)),nitt=5000,burnin=2000,start.v = NULL,start.centre=NULL,
		init.var.v=NULL,init.var.centre = NULL,init.cov.vcentre = NULL,print.k = 50)
		#
		cat("Plotting cline...",sep="\n")
		plot_clinecurve(ggcline.object=gc$gc,cline.locus="CLTA",locus.column="locus",cline.col="#E495A5",cline.centre.line="CLTA",cline.centre.col="black")
		}
	}

# possibly have a look at 'strataG' to work with dnabin objects
# stratag: An r package for manipulating, summarizing and analysing population genetic data
# devtools::install_github('ericarcher/strataG', build_vignettes = FALSE,upgrade="never")
# library(strataG)
binaryD<-function(exampledata=FALSE,fourpops=NULL,snpselection=NULL,samplesize=200)
	{
	if(exampledata)
		{
		# data(MySequences)
		seqmat				<- as.character(as.matrix(MySequences))
		mypops				<- c("Norfolk","Lincolnshire","Cambridgeshire","Suffolk")
		pop1 				<- c("Seq1", "Seq2", "Seq3")			
		pop2 				<- c("Seq4", "Seq5", "Seq6")			
		pop3 				<- c("Seq7", "Seq8")					
		pop4 				<- c("Seq9", "Seq10")					
		poplist				<- list(pop1=c("Seq1","Seq2","Seq3"),pop2 = c("Seq4","Seq5","Seq6"),pop3 = c("Seq7","Seq8"),pop4 = c("Seq9","Seq10"))
		poplist2			<- list(pop1=rep(mypops[1],3),pop2 = rep(mypops[2],3), pop3 = rep(mypops[3],2), pop4 = rep(mypops[4],2))
		}else{
		if(is.null(fourpops))
			{
			return(cat("ERROR: Provide a vector with 4 population names to the 'fourpops' flags.",sep="\n"))
			}
		seqmat				<- as.character(as.matrix(mysambar$mydnabin))
		if(!is.null(snpselection))
			{
			seqmat				<- seqmat[,snpselection]
			}
		mypops				<- fourpops
		pop1				<- as.vector(inds$name[inds$pop==fourpops[1]&inds$filter])
		pop2				<- as.vector(inds$name[inds$pop==fourpops[2]&inds$filter])
		pop3				<- as.vector(inds$name[inds$pop==fourpops[3]&inds$filter])
		pop4				<- as.vector(inds$name[inds$pop==fourpops[4]&inds$filter])
		poplist				<- list(pop1= pop1,pop2 = pop2,pop3 = pop3,pop4 = pop4)
		poplist2			<- list(pop1=rep(mypops[1],length(pop1)),pop2 = rep(mypops[2],length(pop2)), pop3 = rep(mypops[3],length(pop3)), pop4 = rep(mypops[4],length(pop4)))
		}
	names(poplist)		<- mypops
	names(poplist2)		<- mypops
	# get all combinations: 
	myperms				<- permutations(n = 4, r = 4, v = c(1:4))
	tempquartets		<- expand.grid(poplist[[1]],poplist[[2]],poplist[[3]],poplist[[4]])
	temppopcombos		<- expand.grid(poplist2[[1]],poplist2[[2]],poplist2[[3]],poplist2[[4]])
	for (j in c(2:nrow(myperms)))
		{
		myperm			<- myperms[j,]
		permquartets	<- expand.grid(poplist[[myperm[1]]],poplist[[myperm[2]]],poplist[[myperm[3]]],poplist[[myperm[4]]])
		tempquartets	<- rbind(tempquartets,permquartets)
		permpopcombos	<- expand.grid(poplist2[[myperm[1]]],poplist2[[myperm[2]]],poplist2[[myperm[3]]],poplist2[[myperm[4]]])
		temppopcombos	<- rbind(temppopcombos,permpopcombos)
		}
	tempquartets$order			<- ifelse(as.character(tempquartets$Var3)<as.character(tempquartets$Var4),TRUE,FALSE)
	tempquartets$ingroup1		<- ifelse(tempquartets$order,as.character(tempquartets$Var3),as.character(tempquartets$Var4))
	tempquartets$ingroup2		<- ifelse(tempquartets$order,as.character(tempquartets$Var4),as.character(tempquartets$Var3))
	tempquartets$introgressor	<- as.character(tempquartets$Var2)
	tempquartets$out			<- as.character(tempquartets$Var1)
	tempquartets$quartet		<- paste(tempquartets$ingroup1,tempquartets$ingroup2,tempquartets$introgressor,tempquartets$out,sep="_")
	myquartets					<- tempquartets[!duplicated(tempquartets$quartet),c("ingroup1","ingroup2","introgressor","out")]
	#
	temppopcombos$ingroup1		<- ifelse(tempquartets$order,as.character(temppopcombos$Var3),as.character(temppopcombos$Var4))
	temppopcombos$ingroup2		<- ifelse(tempquartets$order,as.character(temppopcombos$Var4),as.character(temppopcombos$Var3))
	temppopcombos$introgressor	<- as.character(temppopcombos$Var2)
	temppopcombos$out			<- as.character(temppopcombos$Var1)
	mypopcombos					<- temppopcombos[!duplicated(tempquartets$quartet),c("ingroup1","ingroup2","introgressor","out")]
	colnames(mypopcombos)		<- c("in1_pop","in2_pop","intro_pop","out_pop")
	#
	nquartets	<- nrow(myquartets)
	if(nquartets>samplesize)
		{
		mysample	<- sample(c(1:nquartets),samplesize,replace=FALSE)
		myquartets	<- myquartets[mysample,]
		mypopcombos	<- mypopcombos[mysample,]
		nquartets	<- samplesize
		}
	#
	myhbdf			<- as.data.frame(cbind(myquartets,mypopcombos))
	myhbdf$quartet	<- paste(myhbdf$in1_pop,myhbdf$in2_pop,myhbdf$intro_pop,myhbdf$out_pop,sep="_")
	myp1			<- ifelse(nchar(as.vector(myhbdf$in1_pop))>2,substr(as.vector(myhbdf$in1_pop),1,2),as.vector(myhbdf$in1_pop))
	myp2			<- ifelse(nchar(as.vector(myhbdf$in2_pop))>2,substr(as.vector(myhbdf$in2_pop),1,2),as.vector(myhbdf$in2_pop))
	myp3			<- ifelse(nchar(as.vector(myhbdf$intro_pop))>2,substr(as.vector(myhbdf$intro_pop),1,2),as.vector(myhbdf$intro_pop))
	myp4			<- ifelse(nchar(as.vector(myhbdf$out_pop))>2,substr(as.vector(myhbdf$out_pop),1,2),as.vector(myhbdf$out_pop))
	myhbdf$mylabels	<- paste("(((",myp1,",",myp2,"),",myp3,"),",myp4,")",sep="")
	myhbdf			<<- myhbdf[order(myhbdf$quartet),]
	myhbdf$S		<<- NA
	myhbdf$ABBA		<<- NA
	myhbdf$BABA		<<- NA
	myhbdf$D		<<- NA
	for (quartetnr in c(1:nquartets))
		{
		cat(paste("Quartet ",quartetnr," out of ",nquartets,".",sep=""),sep="\n")
		mynames			<- as.vector(unlist(myquartets[quartetnr,]))	# indnames
		my_quartet		<- as.vector(unlist(mypopcombos[quartetnr,]))	# popnames: c("Norfolk","Lincolnshire","Cambridgeshire","Suffolk")
		submat			<- seqmat[rownames(seqmat)%in%mynames,]
		temp1			<<- submat
		subdnabin		<- as.DNAbin(submat)
		temp2			<<- subdnabin
		# myvs			<- variableSites(subdnabin)
		# n_vs			<<- ncol(myvs$site.freqs)
		MyAnalysis 		<- HC$new(subdnabin)
		temp3			<<- MyAnalysis
		if(nrow(as.matrix(MyAnalysis$DNA$FullSequence))!=nrow(submat))
			{
			cat("WARNING: HybridCheck removed identical sequences. ABBA-BABA calculations for this quartet halted.",sep="\n")
			}else{
			cat("Proceeding analyses...",sep="\n")
			# HCpoplist 			<- list(Norfolk = mynames[1],Lincolnshire = mynames[2],Cambridgeshire = mynames[3],Suffolk = mynames[4])
			HCpoplist 				<- list(HCpop1 = mynames[1],HCpop2 = mynames[2],HCpop3 = mynames[3], HCpop4 = mynames[4])
			names(HCpoplist)		<- my_quartet
			MyAnalysis$setPopulations(HCpoplist)
			#testquartet 			<- list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))
			testquartet 			<- list(c(P1 = my_quartet[1], P2 = my_quartet[2], P3 = my_quartet[3], A = my_quartet[4]))
			MyAnalysis$prepareFourTaxonTests(testquartet)
			MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=1L)
			# store results:
			fttdf 					<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
			myhbdf$S[quartetnr]		<<- fttdf$S[1]
			myhbdf$ABBA[quartetnr]	<<- fttdf$ABBA[1]
			myhbdf$BABA[quartetnr]	<<- fttdf$BABA[1]
			myhbdf$D[quartetnr]		<<- fttdf$D[1]
			}
		}
	cat("Results have been stored in a dataframe called 'myhbdf'.",sep="\n")
	}

# funcion to evaluate performance of HybridCheck
testhc<-function()
	{
	site1			<- c("c","c","t","t")
	site2			<- c("c","c","c","c")
	site3			<- c("c","t","c","t")
	site4			<- c("c","t","t","c")
	site5			<- c("y","t","t","c")
	site6			<- c("y","t","t","y")
	site7			<- c("a","a","a","a")
	mymat			<- cbind(site1,site2,site3,site4,site5,site6,site7)
	mymat			<<- mymat
	mynames			<- c("Seq1","Seq2","Seq3","Seq4")
	rownames(mymat)	<- mynames
	testdnabin		<- as.DNAbin(mymat)
	MyAnalysis 		<- HC$new(testdnabin)
	if(nrow(as.matrix(MyAnalysis$DNA$FullSequence))!=nrow(mymat))
		{
		cat("WARNING: HybridCheck removed identical sequences.",sep="\n")
		}else{
		cat(paste("Number of sequences: ",nrow(mymat),sep=""),sep="\n")
		cat(paste("Number of informative sites: ",length(MyAnalysis$DNA$InformativeBp),sep=""),sep="\n")
		#HCmat		<<- as.matrix(MyAnalysis$DNA$FullSequence)
		}
	HCpoplist 		<- list(Norfolk = mynames[1],Lincolnshire = mynames[2],Cambridgeshire = mynames[3],Suffolk = mynames[4])
	MyAnalysis$setPopulations(HCpoplist)
	testquartet 	<- list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))
	MyAnalysis$prepareFourTaxonTests(testquartet)
	MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=1L)
	fttdf 		<<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
	cat("Block estimates have been exported to a dataframe called 'fttdf'.",sep="\n")
	#
	# Conclusion:
	# Ambiguous (read: heterozygosite sites) are treated as if they are separate letters.
	# e.g.: 
	# yttc is not counted as abba site
	# ytty is counted as abba site
	}

# Use R package HybridCheck to calculate D:
runhybridcheck<-function(use_exampledata=FALSE,myquartet=NULL,popnames=mysambar$populations,nsnpsperblock=NULL,nblocks=1)
	{
	if("HybridCheck" %in% rownames(installed.packages()) == FALSE) {devtools::install_github("BenJWard/HybridCheck", build_vignettes = FALSE,upgrade="never")}
	if("HybridCheck" %in% (.packages()) == FALSE){library(HybridCheck)}
	if(use_exampledata)
		{
		cat("Running HybridCheck on example data set...",sep="\n")
		data(MySequences)
		MyAnalysis 	<- HC$new(MySequences)
		#  ls(MyAnalysis, all.names = TRUE)
		HCpoplist 	<- list(Norfolk = c("Seq1", "Seq2", "Seq3"),Lincolnshire = c("Seq4", "Seq5", "Seq6"),Cambridgeshire = c("Seq7", "Seq8"),Suffolk = c("Seq9", "Seq10"))
		MyAnalysis$setPopulations(HCpoplist)
		testquartet <- list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))
		MyAnalysis$prepareFourTaxonTests(testquartet)
		MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=10L)
		fttdf 		<<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
		cat("Block estimates have been exported to a dataframe called 'fttdf'.",sep="\n")
		}else{
		genlight2DNAbin()
		MyAnalysis 	<- HC$new(mysambar$mydnabin)
		HCpoplist	<- list()
		npops		<- length(popnames)
		for(j in c(1:npops))
			{
			my_pop					<- popnames[j]
			HCpoplist[[j]]			<- as.vector(inds$name[inds$filter&inds$pop==my_pop])
			names(HCpoplist)[j]		<- my_pop
			}
		MyAnalysis$setPopulations(HCpoplist)
		if(!is.null(myquartet))
			{
			testquartet 			<- list(c(P1 = myquartet[1], P2 = myquartet[2], P3 = myquartet[3], A = myquartet[4]))
			MyAnalysis$prepareFourTaxonTests(testquartet)
			}else{
			# perform analyses for all possible quartets.
			# first find all possible quartets:
			myquartets				<- as.data.frame(permutations(n=npops,r=4,v=popnames,repeats.allowed=F))
			colnames(myquartets)	<- c("P1","P2","P3","A")
			# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
			myquartets$myorder		<- as.character(myquartets$P2)>as.character(myquartets$P1)
			myquartets$ingroup		<- ifelse(myquartets$myorder,paste(myquartets$P1,myquartets$P2,myquartets$P3,sep="_"),paste(myquartets$P2,myquartets$P1,myquartets$P3,sep="_"))
			myquartets				<- myquartets[(!duplicated(myquartets$ingroup)),c(1:4)]
			# convert to list of named vectors:
			myquartetlist			<- list()
			nquartets				<- nrow(myquartets)
			for (j in c(1:nrow(myquartets)))
				{
				myvec				<- as.vector(myquartets[j,])
				myquartetlist[[j]]	<- c(P1 = as.character(unlist(myvec[1])), P2 = as.character(unlist(myvec[2])), P3 = as.character(unlist(myvec[3])), A = as.character(unlist(myvec[4])))
				}
			MyAnalysis$prepareFourTaxonTests(myquartetlist)
			}
		if(is.null(nsnpsperblock))
			{
			cat(paste("Running FourTaxonTests on ",nblocks," block(s).",sep=""),sep="\n")
			MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=NULL,numberOfBlocks=as.integer(nblocks))		# default of 1 (or 1L) means: give genome wide estimate only
			}else{
			cat(paste("Running FourTaxonTests on blocks of ",nsnpsperblock," SNPs.",sep=""),sep="\n")
			MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=nsnpsperblock,numberOfBlocks=NULL)
			}
		fttdf 		<<- MyAnalysis$tabulateFourTaxonTests(selections = "ALL", neat = TRUE, global = TRUE)
		fttdf$pvalue<<- round(fttdf$X2_P,5)
		cat("Block estimates have been exported to a dataframe called 'fttdf'.",sep="\n")
		#
		# extract final estimate per quartet:
		if(nblocks==1&is.null(nsnpsperblock))
			{
			hbdf			<- fttdf[,c("P1","P2","P3","A","ABBA","BABA","D","pvalue")]
			colnames(hbdf)	<- c("p1","p2","p3","out","ABBA","BABA","D","pvalue")
			}else{
			hbdf			<- fttdf[,c("P1","P2","P3","A","ABBA","BABA","D","D_jEstimate","D_jSD","pvalue")]
			colnames(hbdf)	<- c("p1","p2","p3","out","ABBA","BABA","blockD","D","D_sd","pvalue")
			hbdf$D_err 		<- hbdf$D_sd/sqrt(nblocks)
			hbdf$sign		<- ifelse(hbdf$pvalue>0.05,"NS",ifelse(hbdf$pvalue<=0.001,"**","*"))
			}
		hbdf$quartet		<- paste(hbdf$p1,hbdf$p2,hbdf$p3,hbdf$out,sep="_")
		hbdf				<<- hbdf[(!duplicated(hbdf$quartet)),]
		# Something is wrong with significance test. The p-values, abstracted from fttdf$X2_P column, don't seem to make sense.
		cat("Genome wide estimates have been exported to a dataframe called 'hbdf'.",sep="\n")
		}
	#
	###### EXPLANATION ######
	# PARAMETER SETTINGS:
	# Parameter settings are divided in 5 categories:
	# TripletGeneration	- Settings for Sequence Scan Combinations.
	# SSAnalysis 		- Settings for the sequence similarity scan step.
	# BlockDetection 	- Settings for detecting recombinant blocks from sequence similarity scan data generated from the sequence similarity scan step.
	# BlockDating 		- Settings for calculating the significance values and divergence time estimates, for recombinant blocks detected in the `BlockDetection` step.
	# Plotting:
	# To change parameter settings, use the setParameters method:
	# MyAnalysis$setParameters("TripletGeneration", DistanceThreshold = 0.1, PartitionStrictness = 1)
	#
	# IMPORT DATA
	# HybridCheck builds it owns environment called 'MyAnalysis'. The objects in this environment can be observed by typing: 
	# ls(MyAnalysis, all.names = TRUE) 
	# To view the functions used to import the data, type:
	# MyAnalysis$inputDNA
	# MyAnalysis$DNA$InputDNA
	# To view the data:
	# MyAnalysis$DNA$FullSequence
	# MyAnalysis$DNA$InformativeSequence
	# MyAnalysis$DNA$InformativeBp
	# Note: duplicated sequences are deleted, so you might end up with less sequences than expected.
	#
	# D-STATISTICS 4 TAXON TEST 	
	### step 1. Prepare the test: 
	# MyAnalysis$prepareFourTaxonTests(popCombos)
	# - Option 1:
	# If no arguments is provided to the method, then HybridCheck will generate every possible combination of four populations possible for your data. 
	# For every combination of four populations, HybridCheck then does a simple distance analysis to decide which population is designated as P1, P2, P3, and A for the purposes of the four taxon test. The test assumes the phylogeny: (((P1, P2), P3), A);  
	# - Option 2:
	# Alternatively you can feed in a list of named vectors (see 'testquartet' in example above). 
	# Each named vector is a combination of four populations to test, designated as P1, P2, P3 and A for the purposes of the test.
	#
	### step 2. Run the test:
	# MyAnalysis$runFourTaxonTests(selections="ALL",blockLength=20000L,numberOfBlocks=NULL)
	# Options:
	# - selections: 	"NOT.TESTED" (default) 	tells HybridCheck to run the test for all tests not previously run. 
	#					"ALL" 					tells HybridCheck to run all tests.
	#					or: a list of population combinations to run e.g. 'list(c(P1 = "Norfolk", P2 = "Lincolnshire", P3 = "Cambridgeshire", A = "Suffolk"))' 
	# - numberOfBlocks: divide data in blocks consisting of 20000 SNPs? (Didn't get this to work yet)
	# - blockLength:	divide data in 10 blocks. For example: divide a 400kb sequence in non-overlapping blocks of 40k sites (SNPs) 
	# The functions requires one of the two parameters `blockLength` or `numberOfBlocks` to be provided. It is used to calculate the number and size of Jack-knife blocks to use in the test.
	# Note: to switch between the two (either numberofBlocks or blockLength, first create MyAnalysis again (using the commands specified above) and then rerun the fourTaxonTest method. 
	# If blockLength is bigger than number of SNPs, you will get the error:
	# Error in seq.default(from = 1, to = dnaLen, by = fttRecord$blockLength) :  invalid '(to - from)/by'
	#
	### step 3. Get the results
	# fttdf <- MyAnalysis$tabulateFourTaxonTests(selections="ALL",neat=TRUE,global = TRUE)
	# Options:
	# - selections 		can be 'ALL' , 'TESTED', or a list of character vectors of length 4, each denoting a four taxon test by the names of the populations involved.
	# - neat			If TRUE, intermediate values used in calculation of the four taxon tests will be excluded. 
	# - global			If TRUE. then global statistics will be included in the tables. This returns a `data.frame` which can be assigned as a variable and manipulated, explored, and saved, using usual R commands and/or packages.
	}

calcwindowDfst<-function(popnames=mysambar$populations,mytriplets=NULL)
	{
	if(!exists("windowfstdf"))
		{
		return(cat("ERROR: No dataframe called 'windowfstdf'. First run plotwindowfst(fst_type='Wrightfst').",sep="\n"))
		}
	npops			<- length(popnames)
	if(npops<3)
		{
		return(cat("At present less than 3 population defined. ABBA-BABA tests require at least 3 populations (when not including the outgroup). Execution halted.",sep="\n"))
		}
	# find all possible quartets:
	if(is.null(mytriplets))
		{
		mytriplets				<- as.data.frame(permutations(n=npops,r=3,v=popnames,repeats.allowed=F))
		colnames(mytriplets)	<- c("p1","p2","p3")
		# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
		mytriplets$myorder		<- as.character(mytriplets$p2)>as.character(mytriplets$p1)
		mytriplets$ingroup		<- ifelse(mytriplets$myorder,paste(mytriplets$p1,mytriplets$p2,mytriplets$p3,sep="_"),paste(mytriplets$p2,mytriplets$p1,mytriplets$p3,sep="_"))
		mytriplets				<- mytriplets[(!duplicated(mytriplets$ingroup)),c(1:3)]
		}
	ntriplets				<- nrow(mytriplets)
	for(i in 1:ntriplets)
		{
		pop1		<- as.vector(mytriplets[i,1])
		pop2		<- as.vector(mytriplets[i,2])
		pop3		<- as.vector(mytriplets[i,3])
		# fst1:
		mypops		<- c(pop1,pop3)
		mypops		<- mypops[order(mypops)]
		pop_1		<- mypops[1]
		pop_3		<- mypops[2]
		if(paste("Wrightfst",pop_1,pop_3,sep="_")%in%colnames(windowfstdf))
			{
			fst1		<- as.vector(windowfstdf[,paste("Wrightfst",pop_1,pop_3,sep="_")])
			}else{
			return(cat(paste("ERROR: No Wright-fst estimates present for population pair ",pop_1," and ",pop_3,". First run plotwindowfst(fst_type='Wrightfst').",sep=""),sep="\n"))
			}
		# fst2
		mypops		<- c(pop2,pop3)
		mypops		<- mypops[order(mypops)]
		pop_2		<- mypops[1]
		pop_3		<- mypops[2]
		if(paste("Wrightfst",pop_2,pop_3,sep="_")%in%colnames(windowfstdf))
			{
			fst2	<- as.vector(windowfstdf[,paste("Wrightfst",pop_2,pop_3,sep="_")])
			}else{
			return(cat(paste("ERROR: No Wright-fst estimates present for population pair ",pop_2," and ",pop_3,". First run plotwindowfst(fst_type='Wrightfst').",sep=""),sep="\n"))
			}
		fst2		<- as.vector(windowfstdf[,paste("Wrightfst",pop_2,pop_3,sep="_")])
		#
		windowfstdf$Dfst	<<- (fst1-fst2)/(fst1+fst2)
		colnames(windowfstdf)[colnames(windowfstdf)=="Dfst"]	<<- paste("Dfst",pop_1,pop_2,pop_3,sep="_")
		}
	}

runfindgraph<-function(niterations=5,my_outgroup=NULL,n_admixture=0)
	{
	admixgraphlist	<<- list()
	admixgraphvec	<<- vector()
	for(iternr in c(1:niterations))
		{
		cat(paste("Iteration ",iternr," out of ",niterations,".",sep=""),sep="\n")
		findgraph(do_analyses=TRUE,out_group=my_outgroup,nadmixture=n_admixture,doplot=TRUE)
		myadmixgraph				<- mysambar$admixgraph
		admixgraphlist[[iternr]]	<<- myadmixgraph
		admixgraphvec[iternr]		<<- mysambar$admixgraphindex
		}
	}

# Note: this function produces empty files
# To avoid, simply copypaste the chunk onto the R command line.
runplotgraph<-function(n_admixture=0,examplerun=FALSE)
	{
	for(iternr in c(1:length(admixgraphlist)))
		{
		cat(iternr,sep="\n")
		myadmixgraph<- admixgraphlist[[iternr]]
		myscore		<- round(min(myadmixgraph$score,na.rm=TRUE))
		myindex		<- admixgraphvec[iternr] 
		plot_graph(myadmixgraph$edges[[iternr]])
		ggsave(paste("Admixturegraph",n_admixture,myscore,"png",sep="."))
		}
	cat("Plots have been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	if(examplerun)
		{
		n_admixture		<- 3
		findgraph(do_analyses=TRUE,out_group="SpainMO",nadmixture=n_admixture)
		myadmixgraph	<- mysambar$admixgraph
		mybestscore		<- round(min(myadmixgraph$score,na.rm=TRUE))
		mybestrun		<- which(myadmixgraph$score==min(myadmixgraph$score))
		plot_graph(myadmixgraph$edges[[mybestrun]])
		ggsave(paste("Admixturegraph",paste("nadmixture",n_admixture,sep=""),paste("score",mybestscore,sep=""),"png",sep="."))
		}
	}

findgraph<-function(do_analyses=TRUE,out_group=NULL,nadmixture=0,doplot=TRUE)
	{
	# produces a tibble with many graphs:
	if(do_analyses)
		{
		if(is.null(mysambar$f2_blocks))
			{
			cat("WARNING: object 'mysambar$f2_blocks' not found. Trying to generate now. Assuming to find in working directory ped and map files with the extension 'metapop.retainedinds.filter.number'.",sep="\n")
			runadmixtools(calcf3=FALSE,calcf4=FALSE,silent=TRUE,tripletdf=NULL,myprefix="metapop.retainedinds.filter.number",overwriteped=FALSE,max_miss=0.1)
			}
		cat("Running find_graph function (which searches for optimum admixture graph)...",sep="\n")
		admixgraph			<- find_graphs(data=mysambar$f2_blocks,numadmix=nadmixture,outpop=out_group)
		# also possible to specify an input tree as startpoint, but in that case how does output differ from input?
		# admixgraph		<- find_graphs(data=mysambar$f2_blocks,numadmix=2,outpop="Black",initgraphs=mysambar$admixgraph$edges[[79]])
		mysambar$admixgraph	<<- admixgraph
		cat("Admixture graph has been stored at mysambar$admixgraph.",sep="\n") 
		}
	# which graph has the best (i.e., lowest) score?
	myindex						<- which(mysambar$admixgraph$score==min(mysambar$admixgraph$score,na.rm=TRUE))
	mysambar$admixgraphindex	<<- myindex
	cat(min(mysambar$admixgraph$score,na.rm=TRUE),sep="\n")
	#
	if(doplot)
		{
		plot_graph(mysambar$admixgraph$edges[[myindex]])
		}
	}

getgenomef3<-function(mywd=NULL,reorder=TRUE,popcolours=NULL,popnames=NULL)
	{
	if(is.null(popnames))
		{
		return(cat("ERROR: please specify popnames.",sep="\n"))
		}
	if(is.null(popnames))
		{
		return(cat("ERROR: please specify popcolours.",sep="\n"))
		}
	if(!is.null(mywd))
		{
		setwd(mywd)	
		}
	cat("Searching for file names ending on 'admixscores.summary.txt' in the directory:",sep="\n")
	cat(getwd(),sep="\n")
	filenames 	<- list.files(pattern = ".*.admixscores.summary.txt")
	if(length(filenames)==0)
		{
		return(cat("ERROR: the directory does not contain files ending on 'admixscores.summary.txt'.",sep="\n"))
		}
	# assuming filenames are 'chrom1.admixscores.summary.txt':
	filenames2	<- sub("\\..*","",filenames)
	filenames3	<- as.numeric(substring(filenames2,6))
	filenames	<- filenames[order(filenames3,decreasing=F)]
	admixlist 	<- lapply(filenames,function(x)read.table(x,header=TRUE)) 
	ndf			<- length(admixlist)
	for(k in c(1:ndf))
		{
		cat(k,sep="\n")
		admixdf			<- admixlist[[k]]
		if(nrow(admixdf)==0)
			{
			cat("WARNING: no data.",sep="\n")
			admixdf			<- data.frame("triplet"=NA,"npos"=NA,"npos2"=NA,"nneg"=NA,"nneg2"=NA,"meanpos"=NA,"meanneg"=NA,"chrom"=k)
			}else{
			admixdf$chrom	<- k
			}
		admixlist[[k]]	<- admixdf
		}
	admixdf 		<- do.call(rbind,admixlist)
	admixdf$admixpop<- sub(".*_", "",admixdf$triplet) 
	admixdf			<- admixdf[!is.na(admixdf$admixpop),]
	admixdf$f3		<- (admixdf$npos2*admixdf$meanpos+admixdf$nneg2*admixdf$meanneg)/(admixdf$npos2+admixdf$nneg2)
	admixdf$prop	<- admixdf$nneg/(admixdf$npos+admixdf$nneg)
	#
	# overall genome-wide scores:
	# aggregate does not work when triplets do not occur in even numbers (i.e., when not all triplets have a score for each chromosome: range between 28 and 35)
	cat("Calculating for each triplet mean proportion of windows with negative f3-scores...",sep="\n")
	mytriplets		<- admixlist[[1]]$triplet	# assuming all triplets have a score for the first chromosome/scaffold
	ntriplets		<- length(mytriplets)
	admixdf2		<- data.frame("triplet"=mytriplets,"nchroms"=NA,prop=NA,propsd=NA,f3=NA,f3sd=NA) 
	for (k in c(1:ntriplets))
		{
		if(k%%1000==0){cat(paste(k," out of ",ntriplets,sep=""),sep="\n")}
		mytriplet			<- mytriplets[k]
		tripletdf			<- admixdf[admixdf$triplet==mytriplet,]
		admixdf2$nchroms[k]	<- nrow(tripletdf)
		admixdf2$prop[k]	<- mean(tripletdf$prop,na.rm=TRUE) 
		admixdf2$propsd[k]	<- sd(tripletdf$prop,na.rm=TRUE) 
		admixdf2$f3[k]		<- mean(tripletdf$f3,na.rm=TRUE) 
		admixdf2$f3sd[k]	<- sd(tripletdf$f3,na.rm=TRUE) 
		}
	admixdf2$anc1pop	<- sub("\\_.*","",admixdf2$triplet)
	admixdf2$anc2pop	<- gsub(".*_(.+)_.*", "\\1",admixdf2$triplet)
	admixdf2$admixpop	<- sub(".*_","",admixdf2$triplet)
	#
	anc2coldf	<- data.frame("anc2pop"=popnames,"anc2col"=popcolours)	
	admixdf2	<- merge(admixdf2,anc2coldf,by="anc2pop")
	#
	anc1coldf	<- data.frame("anc1pop"=popnames,"anc1col"=popcolours)	
	admixdf2	<- merge(admixdf2,anc1coldf,by="anc1pop")
	#
	admixcoldf	<- data.frame("admixpop"=popnames,"admixcol"=popcolours)	
	admixdf2	<- merge(admixdf2,admixcoldf,by="admixpop")
	#
	admixdf2	<- admixdf2[order(admixdf2$triplet),]
	if(reorder)
		{
		admixdf2$anc1	<- admixdf2$anc1pop
		admixdf2$anc2	<- admixdf2$anc2pop
		admixdf2$col1	<- admixdf2$anc1col
		admixdf2$col2	<- admixdf2$anc2col
		admixdf2$anc1pop<- ifelse(admixdf2$anc1<admixdf2$anc2,admixdf2$anc1,admixdf2$anc2)
		admixdf2$anc1col<- ifelse(admixdf2$anc1<admixdf2$anc2,admixdf2$col1,admixdf2$col2)
		admixdf2$anc2pop<- ifelse(admixdf2$anc1<admixdf2$anc2,admixdf2$anc2,admixdf2$anc1)
		admixdf2$anc2col<- ifelse(admixdf2$anc1<admixdf2$anc2,admixdf2$col2,admixdf2$col1)
		}
	admixlist		<<- admixlist 
	admixdf			<<- admixdf
	admixdf2		<- admixdf2[!duplicated(admixdf2),]
	admixdf2		<<- admixdf2
	cat("Data loaded. Per chromosome scores stored in admixdf and genome-wide scores (summary over all chromosomes) stored in admixdf2.",sep="\n")
	}

f3mean_vs_sd<-function(mydf=admixdf2,admixpop=NULL,popnames=NULL,popcolours=NULL,mythres=0.5,mybg="white",ymax=NULL,axiscol="black",export=NULL,plotname="Genome_f3_mean_vs_sd",fullrange=TRUE,addlegend=TRUE,legendcex=1.2,x_lab="Mean (all chromosomes)",y_lab="SD (over chromosomes)")
	{
	if(is.null(mydf))
		{
		return(cat("ERROR: specified dataframe does not exist.",sep="\n"))
		}
	if(is.null(popnames))
		{
		return(cat("ERROR: please specify popnames.",sep="\n"))
		}
	if(is.null(popnames))
		{
		return(cat("ERROR: please specify popcolours.",sep="\n"))
		}
	if(!is.null(export))
		{
		poplabel	<- ifelse(is.null(admixpop),"allpops",admixpop)
		rangelabel	<- ifelse(fullrange,"fullrange","smallrange")
		rangelabel	<- ifelse(mybg=="white",rangelabel,paste(rangelabel,mybg,sep="."))
		if(export=="eps"){postscript(paste(plotname,poplabel,rangelabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,poplabel,rangelabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,poplabel,rangelabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,poplabel,rangelabel,"wmf",sep="."),width=8,height=8)} 
		}
	if(!is.null(admixpop))
		{
		mydf	<- mydf[mydf$admixpop==admixpop,]
		}
	par(mar=c(4,5,2.5,1.5),cex.axis=2,cex.lab=2.5,cex.main=3,bg=mybg,col=axiscol,col.axis=axiscol,col.lab=axiscol,col.main=axiscol)
	myscore1	<- mydf$prop
	myscore2	<- mydf$propsd
	sdmax		<- max(myscore2,na.rm=TRUE)
	ymax		<- ifelse(is.null(ymax),sdmax,ymax)	
	if(is.null(admixpop))
		{
		plot(myscore1,myscore2,col=mydf$admixcol,pch=16,cex=1.25,xlim=c(0,1),ylim=c(0,ymax),xlab=x_lab,ylab=y_lab)
		if(addlegend){legend("topright",legend=popnames,fill=popcolours,border=popcolours,cex=legendcex,bty='n',title="Admixed population:")}
		mtext("Proportion windows with f3<0",side=3,line=0.5,cex=2)
		}else{
		if(nrow(mydf)==0)
			{
			return(cat("ERROR: specified population not found.",sep="\n"))
			}
		if(fullrange)
			{
			plot(myscore1,myscore2,bg=mydf$anc1col,col=mydf$anc2col,pch=21,cex=2,xlim=c(0,1),ylim=c(0,ymax),lwd=3,xlab=x_lab,ylab=y_lab)
			if(addlegend){legend("topright",legend=popnames,fill=popcolours,border=popcolours,cex=1.25,bty='n',title="Admixed population:")}
			}else{
			plot(myscore1,myscore2,bg=mydf$anc1col,col=mydf$anc2col,pch=21,cex=2,lwd=3,xlab=x_lab,ylab=y_lab)
			}
		mtext(admixpop,side=3,line=0.5,cex=2)
		}
	abline(v=mythres,lty=2)
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

runadmixtools<-function(calcf3=TRUE,calcf4=TRUE,silent=TRUE,tripletdf=NULL,myprefix="metapop.retainedinds.filter.number",overwriteped=FALSE,max_miss=0.1)
	{
	# f3 statistics as implemented in admixtools and admixtools2
	# see: 
	# Patterson et al. 2012 Ancient admixture in human history
	# Peter et al. 2016 Admixture, population structure and F-statistics
	# The most friendly introduction can be found at the github tutorial page of Admixtools2.
	#
	# Key measure is f2, which, like a Fst-statistic, quantifies the differences in allele frequencies (a and b) between population A and B:
	# f2(A,B) = (a-b)^2 
	# The measure f3 is a composite of f2.
	# Assume that you have the following phylogeny: ((A,B),C). Then f3 is defined as:
	# f3(A;B,C) = 0.5*(f2(A,B) + f2(A,C) - f2(B,C))
	#
	# How to interpret this?
	# Incorrect interpretation: 
	# If allele frequency in A is similar to C but different to B, then evidence for admixture between A and C.
	# Correct interpretation:
	# If allele frequency difference (AFD) between A and B is negatively correlated to AFD between A and C, then evidence for admixture between A and C.
	# In other words, it is about the covariance of allele frequencies.
	# A negative f3 implies that:
	# - the more similar allele frequencies are between A and B, the more different they are between A and C. 
	# - vice versa: the more dissimilar AFs are between A and B, the more similar they are between A and C.
	# 
	# The measure f4 is very similar to f3, but incorporating a fourth population.
	# Assume that you have the following phylogeny: ((A,B),C,D) (or/and (((A,B),C),D))?)
	# f4(A,B;B,C) = 0.5*(f2(A,B) + f2(A,C) - f2(B,C))
	#
	# A negative f3 indicates f2(A,C) < f2(B,C), indicating A is admixed between A and C.   
	#
	# To avoid error: File admixtools2/Baltic/Black_f2.rds not found!', you might have to delete the output of previous runs.
	# BiocManager::install("snpStats",suppressUpdates=TRUE)
	# library(snpStats)
	#
	# In case positional information contains row number and one single chromosome/haplotype only, you might encounter the error:
	# Warning: 35945 parsing failures.
	# row col expected actual
	# 1  -- a number     un
	# 2  -- a number     un
	# 3  -- a number     un
	# 4  -- a number     un
	# 5  -- a number     un
	# ... ... ........ ......
	# See problems(...) for more details.
	#
	if("admixtools" %in% rownames(installed.packages()) == FALSE)
		{
		cat("WARNING: package 'admixtools' has not been installed yet.",sep="\n")
		cat("Trying to install the package now...",sep="\n")
		devtools::install_github("uqrmaie1/admixtools")
		cat("Finished installing admixtools.",sep="\n")
		}
	if("admixtools" %in% (.packages()) == FALSE)
		{
		library("admixtools")
		}
	if(!is.null(tripletdf))
		{
		if(!is.data.frame(tripletdf))
			{
			return(cat("ERROR: input to tripletdf should be a dataframe.",sep="\n"))
			}
		}
	setwd(mysambar$demographydir)
	admixtools2folder	<- "admixtools2"
	if(file.exists(admixtools2folder))
		{
		if(!silent){cat("Setting working directory...",sep="\n")}
		setwd(file.path(mysambar$demographydir,admixtools2folder))
		}else{
		if(!silent){cat("Creating and setting working directory...",sep="\n")}
		dir.create(file.path(mysambar$demographydir,admixtools2folder))
		setwd(file.path(mysambar$demographydir,admixtools2folder))
		}
	# creating ped file
	if(!file.exists(paste(myprefix,"ped",sep=".")))
		{
		# if(!silent){cat("Exporting ped file...",sep="\n")}
		genlight2ped(snpsfilter=snps$filter,indsfilter=inds$filter,exportname=myprefix,quiet=TRUE)
		}else{
		if(overwriteped)
			{
			cat("Overwriting existing ped file because the flag 'overwriteped' is set to TRUE.",sep="\n")
			genlight2ped(snpsfilter=snps$filter,indsfilter=inds$filter,exportname=myprefix,quiet=TRUE)
			cat("PED and MAP files have been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			return(cat("Now first (re)create the bed-file. Use 'plink --make-bed --recode A' to convert the newly created ped-file to bed and afterwards rerun the function. Also delete existing admixtools subdirectories.",sep="\n"))
			}else{
			cat("WARNING: using existing ped file. If you want to generate a new ped file, set the flag 'overwriteped' to TRUE.",sep="\n")
			}
		}
	if(!file.exists(paste(myprefix,"bed",sep=".")))
		{	
		# still need to find out: how to write a binary bed file rather than a ped file
		# C:/Users/Menno_de_Jong/Documents/software/plink_win64_20200107/plink --noweb --cow --allow-extra-chr --file metapop.retainedinds.filter.number --recode A -out metapop.retainedinds.filter.number
		cat("ERROR: no bed file present. This is expected behaviour if you run this command for the first time for this dataset. Use 'plink --make-bed --recode A' to convert the newly created ped-file to bed and afterwards rerun the function.",sep="\n")
		cat("BED-file missing from directory:",sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	#
	if(!silent){cat("Calculating f2-statistics...",sep="\n")}
	# option 1: first write to file:
	extract_f2(pref=myprefix,admixtools2folder,maxmiss=max_miss,overwrite=TRUE,auto_only=FALSE)
	f2_blocks 		<- f2_from_precomp(admixtools2folder)
	mysambar$f2_blocks<<- f2_blocks
	#
	# option 2: store directly as R object without saving first as file:	
	# f2_blocks		<- f2_from_geno(pref=myprefix,admixtools2folder,maxmiss=max_miss)
	f2means			<- apply(f2_blocks,1:2,mean)
	#
	if(calcf3)
		{
		if(!silent){cat("Calculating f3-statistics...",sep="\n")}
		if(!is.null(tripletdf))
			{
			cat("For predefined set of populations...",sep="\n")
			mytriplets				<- tripletdf
			colnames(mytriplets)	<- c("pop1","pop2","pop3")
			popvec					<- unique(c(mytriplets$pop1,mytriplets$pop2,mytriplets$pop3))
			if(any(!popvec%in%mysambar$populations))
				{
				return(cat("ERROR: One or more population defined in f3 triplets dataframe not found in retained dataset (mysambar$populations). Please edit the triplets dataframe.",sep="\n"))
				}
			f3df			<- qp3pop(f2_blocks,pop1=as.matrix(tripletdf))
			}else{
			cat("For all population triplets...",sep="\n")
			f3df			<- qp3pop(f2_blocks)
			}
		myf3df				<- as.data.frame(f3df)
		#myf3df				<<- myf3df
		#
		if(!is.null(tripletdf))
			{
			if(!silent){cat("Reorder and combining ...",sep="\n")}
			myf3df$p			<- round(myf3df$p,8)
			myf3df$label		<- paste(myf3df$pop1,myf3df$pop2,myf3df$pop3,sep="_")
			tripletdf$label		<- paste(tripletdf$target,tripletdf$source1,tripletdf$source2,sep="_")
			tripletdf$nr		<- c(1:nrow(tripletdf))
			myf3df				<- merge(tripletdf,myf3df,by="label")
			myf3df				<- myf3df[order(myf3df$nr),]
			myf3df$mylabels		<- paste("(",myf3df$pop1,"; ",myf3df$pop2,",",myf3df$pop3,")",sep="")
			mysambar$f3df		<<- myf3df
			}else{
			myf3df				<- myf3df
			myf3df$mylabels		<- paste("(",myf3df$pop1,"; ",myf3df$pop2,",",myf3df$pop3,")",sep="")
			mysambar$f3df_all	<<- myf3df
			mysambar$f3df		<<- myf3df
			}
		if(!silent){cat("Results stored in dataframe 'mysambar$f3df'.",sep="\n")}
		}
	if(calcf4)
		{
		cat("Calculating f4-statistics...",sep="\n")
		# f4-statistics: 
		# f4 = (a-b)*(c-d)
		f4df					<- qpdstat(data=f2_blocks,f4mode=TRUE)
		f4df					<- as.data.frame(f4df)
		f4df$quartet			<- paste(f4df$pop1,f4df$pop2,f4df$pop3,f4df$pop4,sep="_")
		f4df$quartet2			<- NA
		for(k in c(1:nrow(f4df)))
			{
			myvec				<- as.vector(unlist(f4df[k,c("pop1","pop2","pop3","pop4")]))
			myvec				<- myvec[order(myvec)]
			f4df$quartet2[k]	<- paste(myvec,collapse="_")
			}
		myquartets				<- unique(f4df$quartet)
		f4df$ratio				<- NA
		f4df$ratio2				<- NA
		for(k in c(1:length(myquartets)))
			{
			myquartet			<- myquartets[k]
			mydf				<- f4df[f4df$quartet2==myquartet,]
			myvec				<- abs(mydf$est)
			myvec				<- myvec[order(myvec)]
			f4df$ratio[f4df$quartet2==myquartet]	<- (mean(myvec[2:3]))/myvec[1]
			f4df$ratio2[f4df$quartet2==myquartet]	<- ifelse(myvec[2]>myvec[3],myvec[2]/myvec[3],myvec[3]/myvec[2])
			}
		mysambar$f4df			<<- f4df
		#barplotf4()
		#
		# D-statistics:
		# D = (a-b)*(c-d) / ((a + b - 2*a*b) * (c + d - 2*c*d)), which is the same as (P(ABBA) - P(BABA)) / (P(ABBA) + P(BABA))
		cat("Calculating ABBA-BABA score using f4-statistics...",sep="\n")
		f4df2					<- qpdstat(data=myprefix)
		f4df2$quartet			<- paste(f4df2$pop1,f4df2$pop2,f4df2$pop3,f4df2$pop4,sep="_")
		mysambar$f4df_D			<<- as.data.frame(f4df2)
		}
	}

f3table<-function(mythres=0,ntriplets=8,popvec=mysambar$populations)
	{
	outdf		<- mysambar$f3df
	outdf$logp	<- round(-log10(outdf$p),2)
	outdf$p		<- NULL
	write.table(outdf,"f3scores.all.txt",quote=FALSE,col.names=TRUE,row.names=FALSE,sep="\t")
	#
	if(any(outdf$est<=mythres))
		{
		outdf		<- outdf[outdf$est<=mythres,]
		write.table(outdf,paste("f3scores.subset",mythres,"txt",sep="."),quote=FALSE,col.names=TRUE,row.names=FALSE,sep="\t")
		}
	#
	f3list		<- list()
	npops		<- length(popvec)
	maxtriplets	<- ((npops-1)*(npops-2))/2
	ntriplets	<- ifelse(maxtriplets<ntriplets,maxtriplets,ntriplets)
	for(j in c(1:npops))
		{
		mypop			<- popvec[j]
		mydf			<- mysambar$f3df
		mydf2			<- mydf[mydf$pop1==mypop,]
		mydf2			<- mydf2[order(mydf2$est),c(4,6,8)]
		colnames(mydf2)	<- c("f3_score","z_value","population_triplet")
		mydf3			<- head(mydf2,ntriplets)
		mydf3$f3_score	<- round(mydf3$f3_score,4)
		mydf3$z_value	<- round(mydf3$z_value,2)
		f3list[[j]]		<- mydf3
		}
	mydf4 <- do.call("rbind",f3list)
	mydf5 <- mydf4[,c(3,1,2)]
	write.table(mydf5,paste("f3scores",paste("bottom",ntriplets,"eachpop",sep=""),"txt",sep="."),quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
	cat("Table(s) exported to directory: ",sep="\n")
	cat(getwd(),sep="\n")
	}

# 25-08-2022: still under construction
barplotf4<-function()
	{
	qvec	<- vector()
	qvec[1]	<- "NE-Europe1_NE-Europe2_SpainCenter_SpainWest"
	qvec[2]	<- "NE-Europe2_SE-Europe_SpainCenter_SpainWest"
	qvec[3]	<- "NorthAfrica_Sardinia_SpainCenter_SpainWest"
	qvec[4]	<- "NE-Europe2_SE-Europe_NorthAfrica_Sardinia"
	qvec[5]	<- "Ireland_Scotland_SpainCenter_SpainWest"
	qvec[6]	<- "Ireland_Scotland_NE-Europe2_SE-Europe"
	qvec[7]	<- "NE-Europe1_NE-Europe2_NorthEurope_WestEurope"
	qvec[8]	<- "CzechiaEast_SE-Europe_NorthEurope_WestEurope"
	qvec[9]	<- "CzechiaEast_SE-Europe_CzechiaWest_WestEurope"
	qvec[10]	<- "NorthEurope_WestEurope_Norway_Sweden"
	qvec[11]<- "CzechiaEast_SE-Europe_Italy_Sardinia"
	#
	pdf("quartets.log.pdf",width=19,height=2.75)
	par(mfrow=c(1,11),mar=c(2,1,1,0.5),oma=c(1,6.5,2,2),cex.axis=1.5)
	for(k in c(1:11))
		{
		myvec		<- strsplit(qvec[k],"_")[[1]]
		myvec2		<- myvec[order(myvec)]
		myquartet	<- paste(myvec2,collapse="_")
		cat(myquartet,sep="\n")
		mydf		<- f4df[f4df$quartet2==myquartet,]
		#if(nrow(mydf)==0)
		#	{
		#	return(cat("ERROR: quartet not found.",sep="\n"))
		#	}
		mynr		<- which(mydf$quartet==qvec[k])
		x			<- c(1:3)
		x			<- x[x!=mynr]
		cat(mynr,sep="\n")
		mydf		<- mydf[c(mynr,x),]
		myyaxt		<- ifelse(k==1,"s","n")
		#barplot(abs(mydf$est),ylim=c(0,0.0075),yaxt=myyaxt,names.arg=c("q1","q2","q3"),space=0.1,las=1,cex.names=1.5,col="grey70",width=0.1)
		barplot(abs(mydf$est),ylim=c(0.00001,0.02),yaxt=myyaxt,names.arg=c("q1","q2","q3"),space=0.1,las=1,cex.names=1.5,col="grey70",width=0.1,log="y")
		mytext		<- paste("(",myvec[1],",",myvec[2],"),\n(",myvec[3],",",myvec[4],")",sep="")
		mtext(side=3,mytext,cex=0.75)
		}
	mtext(side=2,outer=TRUE,"f4-score",cex=1.5,line=5)
	dev.off()
	}

genomef3heatmap<-function(exporttype=NULL,myscore="f3",thresvec=c(0.55,0.56,0.57,0.58,0.59,0.6),my_bg="white",fill_square=FALSE,f3_thres=0.01,f3_thres2=0.57,add_labels=TRUE,add_legend=TRUE,legend_cex=1.25)
	{
	myf3df			<- admixdf2[,c("admixpop","anc1pop","anc2pop",myscore)]
	colnames(myf3df)<- c("pop1","pop2","pop3","score")
	myf3df$p		<- 0.01
	if(myscore=="f3")
		{
		myf3df$est		<- myf3df$score
		sub_title		<- NULL
		myf3df			<<- myf3df
		#
		cat("Plotting above diagonal: f3<0",sep="\n")
		f3heatmap(f3df=myf3df,export=exporttype,exportname="f3heatmap_window_f3",subtitle=sub_title,fillsquare=fill_square,addlabels=add_labels,addlegend=add_legend,legendcex=legend_cex)
		#
		cat("Plotting above diagonal: f3<0; and below diagonal: f3<f3_thres.",sep="\n")
		f3heatmap2(f3df=myf3df,export=exporttype,exportname="f3heatmap_window_f3",subtitle=sub_title,fillsquare=fill_square,addlabels=add_labels,addlegend=add_legend,legendcex=legend_cex,f3thres=f3_thres)
		#
		cat("Plotting above diagonal: f3<0; and below diagonal: prop(f3<0)>f3_thres2.",sep="\n")
		myf3df2			<- admixdf2[,c("admixpop","anc1pop","anc2pop","prop")]
		colnames(myf3df2)<- c("pop1","pop2","pop3","score")
		myf3df2$est		<- f3_thres2-myf3df2$score
		myf3df2$p		<- 0.01
		myf3df2			<<- myf3df2
		mysubtitle		<- "above diagonal: mean(f3)<0; below diagonal: prop(f3<0)>0.57"
		f3heatmap2(f3df=myf3df,f3df2=myf3df2,export=exporttype,mybg=my_bg,exportname=paste("f3heatmap_propVSwindow",f3_thres2,sep="_"),subtitle=mysubtitle,subtitlecex=1.75,fillsquare=fill_square,addlabels=add_labels,addlegend=add_legend,legendcex=legend_cex,f3thres=0)
		}else{
		#for(mythres in c(0.6,0.575,0.55,0.525,0.5,0.475,0.45,0.425))
		#for(mythres in c(0.555,0.56,0.565,0.57))
		for(mythres in thresvec) 	
			{
			cat(mythres,sep="\n")
			myf3df$est		<- mythres-myf3df$score
			myf3df			<<- myf3df
			sub_title		<- paste("Proportion 50Kb windows with f3<0: >",mythres,sep="")
			f3heatmap(f3df=myf3df,export=exporttype,mybg=my_bg,exportname=paste("f3heatmap_window_propneg",mythres,sep="_"),subtitle=sub_title,fillsquare=fill_square,addlegend=add_legend,legendcex=legend_cex)
			}
		}
	}

# 13-07-2022: like f3_heatmap, but adds below diagonal-values using different threshold.
# above diagonal: f3<0 (always)
# below diagonal: f3<0.01 (value specified to f3thres argument)
# Or, alternatively, if a second dataframe is specified to f3df2 flag, different test-scores (e.g. prop) below diagonal.
f3heatmap2<-function(creatematrix=TRUE,pthres=0.05,export=NULL,exportname="f3heatmap",f3thres=c(0.001,0.001),f3df=mysambar$f3df,f3df2=NULL,addlabels=TRUE,plottitle=NULL,mybg="white",subtitle=NULL,subtitlecex=2,NAcolour=NULL,addlegend=TRUE,fillsquare=FALSE,legendcex=1.25)
	{
	if(length(f3thres)==1){f3thres<-c(f3thres,f3thres)}
	if(is.null(f3df))
		{
		return(cat("ERROR: specified f3 dataframe (default: mysambar$f3df) does not exist. Did you run the runadmixtools function?",sep="\n"))
		}
	if(!is.null(f3df2))
		{
		cat("Input dataframe specified to f3df2 flag. Attempting to plot these scores below diagonal...",sep="\n")
		}else{
		f3df2		<- f3df
		}
	if(is.null(plottitle)&length(f3thres)==1)
		{	
		plottitle	<- paste("f3-score < ",f3thres,sep="")
		}
	popnames<- unique(f3df$pop1)
	npop	<- length(popnames)
	poporder<- mysambar$poporder
	popcols	<- mysambar$colorder
	if(length(poporder)!=npop)
		{
		return(cat("ERROR: number of populations in specified f3 dataframe (default: mysambar$f3df) does not correspond with number of populations in the mysambar$poporder vector. Rerun the runadmixtools function with the new filter settings.",sep="\n"))
		}
	if(creatematrix)
		{
		cat("Converting dataframe to matrix...",sep="\n")
		f3mat			<- matrix(NA,ncol=npop,nrow=npop*npop)
		colnames(f3mat)	<- popnames
		rownames(f3mat)	<- rep(popnames,npop)
		f3mat2			<- f3mat
		# columns:
		for(j in c(1:npop))
			{
			out1	<- poporder[j]	
			# rows (field):
			for(i in c(1:npop))
				{
				out2	<- poporder[i]
				# ABOVE DIAGONAL:
				if(i<j)
					{
					# rows (data entry within field):
					for(k in c(1:npop))
						{
						admixpop	<- poporder[k]
						rownr		<- which(f3df$pop1==admixpop&((f3df$pop2==out1&f3df$pop3==out2)|(f3df$pop2==out2&f3df$pop3==out1)))
						if(length(rownr)>1)
							{
							rownr	<<- rownr
							return(cat("ERROR: more than 1 row.",sep="\n"))
							}
						if(length(rownr)!=0)
							{
							myf3score				<- f3df$est[rownr]
							mypvalue				<- f3df$p[rownr]
							if(is.null(myf3score))
								{
								rownr				<<- rownr
								cat("WARNING: NULL-value.",sep="\n")
								}else{
								f3mat[(i-1)*npop+k,j] 	<- myf3score
								if(myf3score<f3thres[1]&mypvalue<=pthres)
									{
									f3mat2[(i-1)*npop+k,j]	<- k
									}else{
									f3mat2[(i-1)*npop+k,j]	<- 0
									}
								}
							}
						}
					}
				# BELOW DIAGONAL:
				if(i>j)
					{
					# rows (data entry within field):
					for(k in c(1:npop))
						{
						admixpop	<- poporder[k]
						rownr		<- which(f3df2$pop1==admixpop&((f3df2$pop2==out1&f3df2$pop3==out2)|(f3df2$pop2==out2&f3df2$pop3==out1)))
						if(length(rownr)>1)
							{
							rownr	<<- rownr
							return(cat("ERROR: more than 1 row.",sep="\n"))
							}
						if(length(rownr)!=0)
							{
							myf3score				<- f3df2$est[rownr]
							mypvalue				<- f3df2$p[rownr]
							if(is.null(myf3score))
								{
								rownr				<<- rownr
								cat("WARNING: NULL-value.",sep="\n")
								}else{
								f3mat[(i-1)*npop+k,j] 	<- myf3score
								if(myf3score<f3thres[2]&mypvalue<=pthres)
									{
									f3mat2[(i-1)*npop+k,j]	<- k
									}else{
									f3mat2[(i-1)*npop+k,j]	<- 0
									}
								}
							}
						}
					}
				}
			}
		mysambar$f3mat	<<- f3mat
		mysambar$f3mat2	<<- f3mat2	# contains population number of admixed population, needed for plotting 
		cat("Matrix with f3-scores stored at mysambar$f3mat.",sep="\n")
		}else{
		cat("WARNING: using existing matrix with f3-scores, stored at mysambar$f3mat.",sep="\n")
		f3mat			<- mysambar$f3mat
		f3mat2			<- mysambar$f3mat2
		}
	#
	if(fillsquare)
		{
		cat("Filling square to make admixed population better visible...",sep="\n")
		f3mat3			<- f3mat2
		# columns:
		for(j in c(1:npop))
			{
			out1	<- poporder[j]	
			# rows (field):
			for(i in c(1:npop))
				{
				out2	<- poporder[i]
				#if(i<j)
				#	{
					squarevec					<- f3mat2[c(((i-1)*npop):(i*npop-1)),j]
					squarevec[is.na(squarevec)]	<- 0
					nadmix						<- length(squarevec[squarevec>0])
					if(nadmix>0)
						{
						mystart		<- (i-1)*npop+1
						myend		<- i*npop
						if(nadmix==1)
							{
							admixpopnr				<- max(squarevec)
							f3mat3[mystart:myend,j]	<- rep(admixpopnr,npop)
							}else{
							squarevec				<- squarevec[order(squarevec,decreasing=TRUE)]
							}
						if(nadmix>1)
							{
							admixpopnr		<- head(squarevec,nadmix)
							mybreakvec		<- rep(NA,nadmix-1)	
							for(breaknr in c(1:(nadmix-1)))
								{
								mybreakvec[breaknr]	<- floor(mystart+(breaknr*npop/nadmix))
								}
							startvec		<- c(mystart,mybreakvec+1)
							endvec			<- c(mybreakvec,myend)
							for(binnr in c(1:nadmix))
								{
								binstart	<- startvec[binnr]
								binend		<- endvec[binnr]
								f3mat3[binstart:binend,j]		<- admixpopnr[binnr]
								}
							}
						#cat(admixpopnr,sep="\n")
						#cat(paste(i,j,sep="_"),sep="\n")
						#cat(paste(out1,out2,poporder[admixpopnr],sep="_"),sep="\n")
						}
					#}
				}
			}
		mysambar$f3mat3	<<- f3mat3
		}
	#
	# plot:
	cat("Creating heatmap...",sep="\n")
	graphics.off()
	if(!is.null(export))
		{
		exportname	<- ifelse(mybg=="white",exportname,paste(exportname,mybg,sep="."))
		exportname	<- ifelse(fillsquare,paste(exportname,"fullsquare",sep="."),exportname)
		exportname	<- paste(exportname,"2D",f3thres,sep=".")
		mysize	<- 10
		mysize2	<- 720
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	par(bg=mybg)
	myBreaks	<- seq(-0.5,npop+0.5,1)
	NAcolour	<- ifelse(is.null(NAcolour),mybg,NAcolour)
	cat(paste("NAcolour is set to: ",NAcolour,".",sep=""),sep="\n")
	myColours	<- c(NAcolour,popcols)
	if(fillsquare)
		{
		my_matrix	<- mysambar$f3mat3
		}else{
		my_matrix	<- mysambar$f3mat2
		}
	heatmap.2(my_matrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=NA,labCol=NA,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,RowSideColors=rep(popcols,each=npop),ColSideColors=popcols,
	dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
	#
	if(addlabels)
		{
		mtext("Ancestral population 1", side = 1, cex = 2, line = 3)
		mtext("Ancestral population 2", side = 4, cex = 2, line = 0)
		}
	mtext(plottitle,side=3,line=1,cex=3)
	if(!is.null(subtitle))
		{
		mtext(subtitle,side=3,line=-0.5,cex=subtitlecex)
		}
	if(addlegend)
		{
		legend(x=0.1,y=0.75,legend=mysambar$poporder,fill=mysambar$colorder,border=mysambar$colorder,bty='n',cex=legendcex)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Heatmap has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}



# 13-07-2022: like f3_heatmap, but adds below diagonal-values using different threshold.
# above diagonal: f3<0 (always)
# below diagonal: f3<0.01 (value specified to f3thres argument)
# Or, alternatively, if a second dataframe is specified to f3df2 flag, different test-scores (e.g. prop) below diagonal.
f3heatmap2_old<-function(creatematrix=TRUE,pthres=0.05,export=NULL,exportname="f3heatmap",f3thres=0.001,f3df=mysambar$f3df,f3df2=NULL,addlabels=TRUE,plottitle="f3-score",mybg="white",subtitle=NULL,subtitlecex=2,NAcolour=NULL,addlegend=TRUE,fillsquare=FALSE,legendcex=1.25)
	{
	if(is.null(f3df))
		{
		return(cat("ERROR: specified f3 dataframe (default: mysambar$f3df) does not exist. Did you run the runadmixtools function?",sep="\n"))
		}
	if(!is.null(f3df2))
		{
		cat("Input dataframe specified to f3df2 flag. Attempting to plot these scores below diagonal...",sep="\n")
		}else{
		f3df2		<- f3df
		}
	popnames<- unique(f3df$pop1)
	npop	<- length(popnames)
	poporder<- mysambar$poporder
	popcols	<- mysambar$colorder
	if(length(poporder)!=npop)
		{
		return(cat("ERROR: number of populations in specified f3 dataframe (default: mysambar$f3df) does not correspond with number of populations in the mysambar$poporder vector. Rerun the runadmixtools function with the new filter settings.",sep="\n"))
		}
	if(creatematrix)
		{
		cat("Converting dataframe to matrix...",sep="\n")
		f3mat			<- matrix(NA,ncol=npop,nrow=npop*npop)
		colnames(f3mat)	<- popnames
		rownames(f3mat)	<- rep(popnames,npop)
		f3mat2			<- f3mat
		# columns:
		for(j in c(1:npop))
			{
			out1	<- poporder[j]	
			# rows (field):
			for(i in c(1:npop))
				{
				out2	<- poporder[i]
				# ABOVE DIAGONAL:
				if(i<j)
					{
					# rows (data entry within field):
					for(k in c(1:npop))
						{
						admixpop	<- poporder[k]
						rownr		<- which(f3df$pop1==admixpop&((f3df$pop2==out1&f3df$pop3==out2)|(f3df$pop2==out2&f3df$pop3==out1)))
						if(length(rownr)>1)
							{
							rownr	<<- rownr
							return(cat("ERROR: more than 1 row.",sep="\n"))
							}
						if(length(rownr)!=0)
							{
							myf3score				<- f3df$est[rownr]
							mypvalue				<- f3df$p[rownr]
							if(is.null(myf3score))
								{
								rownr				<<- rownr
								cat("WARNING: NULL-value.",sep="\n")
								}else{
								f3mat[(i-1)*npop+k,j] 	<- myf3score
								if(myf3score<0&mypvalue<=pthres)
									{
									f3mat2[(i-1)*npop+k,j]	<- k
									}else{
									f3mat2[(i-1)*npop+k,j]	<- 0
									}
								}
							}
						}
					}
				# BELOW DIAGONAL:
				if(i>j)
					{
					# rows (data entry within field):
					for(k in c(1:npop))
						{
						admixpop	<- poporder[k]
						rownr		<- which(f3df2$pop1==admixpop&((f3df2$pop2==out1&f3df2$pop3==out2)|(f3df2$pop2==out2&f3df2$pop3==out1)))
						if(length(rownr)>1)
							{
							rownr	<<- rownr
							return(cat("ERROR: more than 1 row.",sep="\n"))
							}
						if(length(rownr)!=0)
							{
							myf3score				<- f3df2$est[rownr]
							mypvalue				<- f3df2$p[rownr]
							if(is.null(myf3score))
								{
								rownr				<<- rownr
								cat("WARNING: NULL-value.",sep="\n")
								}else{
								f3mat[(i-1)*npop+k,j] 	<- myf3score
								if(myf3score<f3thres&mypvalue<=pthres)
									{
									f3mat2[(i-1)*npop+k,j]	<- k
									}else{
									f3mat2[(i-1)*npop+k,j]	<- 0
									}
								}
							}
						}
					}
				}
			}
		mysambar$f3mat	<<- f3mat
		mysambar$f3mat2	<<- f3mat2	# contains population number of admixed population, needed for plotting 
		cat("Matrix with f3-scores stored at mysambar$f3mat.",sep="\n")
		}else{
		cat("WARNING: using existing matrix with f3-scores, stored at mysambar$f3mat.",sep="\n")
		f3mat			<- mysambar$f3mat
		f3mat2			<- mysambar$f3mat2
		}
	#
	if(fillsquare)
		{
		cat("Filling square to make admixed population better visible...",sep="\n")
		f3mat3			<- f3mat2
		# columns:
		for(j in c(1:npop))
			{
			out1	<- poporder[j]	
			# rows (field):
			for(i in c(1:npop))
				{
				out2	<- poporder[i]
				#if(i<j)
				#	{
					squarevec					<- f3mat2[c(((i-1)*npop):(i*npop-1)),j]
					squarevec[is.na(squarevec)]	<- 0
					nadmix						<- length(squarevec[squarevec>0])
					if(nadmix>0)
						{
						mystart		<- (i-1)*npop+1
						myend		<- i*npop
						mymid1		<- floor((mystart+myend)/2)
						mymid2		<- mymid1+1
						if(nadmix==1)
							{
							admixpopnr				<- max(squarevec)
							f3mat3[mystart:myend,j]	<- rep(admixpopnr,npop)
							}
						if(nadmix==2)
							{
							squarevec				<- squarevec[order(squarevec,decreasing=2)]
							admixpopnr				<- head(squarevec,2)
							f3mat3[mystart:mymid1,j]<- admixpopnr[1]
							f3mat3[mymid2:myend,j]	<- admixpopnr[2]
							}
						if(nadmix>2)
							{
							# 18-05-2022: currently not yet option to display more than two colours per field:
							cat(paste("WARNING: max than 2 admixed population for this pair of ancestral populations: ",out1," and ",out2,". Randomly displaying one admixed population.",sep=""),sep="\n")
							admixpopnr				<- max(squarevec)
							f3mat3[mystart:myend,j]	<- rep(admixpopnr,npop)
							}
						#cat(admixpopnr,sep="\n")
						#cat(paste(i,j,sep="_"),sep="\n")
						#cat(paste(out1,out2,poporder[admixpopnr],sep="_"),sep="\n")
					#	}
					}
				}
			}
		mysambar$f3mat3	<<- f3mat3
		}
	#
	# plot:
	cat("Creating heatmap...",sep="\n")
	graphics.off()
	if(!is.null(export))
		{
		exportname	<- ifelse(mybg=="white",exportname,paste(exportname,mybg,sep="."))
		exportname	<- ifelse(fillsquare,paste(exportname,"fullsquare",sep="."),exportname)
		exportname	<- paste(exportname,"2D",f3thres,sep=".")
		mysize	<- 10
		mysize2	<- 720
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	par(bg=mybg)
	myBreaks	<- seq(-0.5,npop+0.5,1)
	NAcolour	<- ifelse(is.null(NAcolour),"white",NAcolour)
	myColours	<- c(NAcolour,popcols)
	if(fillsquare)
		{
		my_matrix	<- mysambar$f3mat3
		}else{
		my_matrix	<- mysambar$f3mat2
		}
	heatmap.2(my_matrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=NA,labCol=NA,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,RowSideColors=rep(popcols,each=npop),ColSideColors=popcols,
	dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
	#
	if(addlabels)
		{
		mtext("Ancestral population 1", side = 1, cex = 2, line = 3)
		mtext("Ancestral population 2", side = 4, cex = 2, line = 0)
		}
	mtext(plottitle,side=3,line=1,cex=3)
	if(!is.null(subtitle))
		{
		mtext(subtitle,side=3,line=-0.5,cex=subtitlecex)
		}
	if(addlegend)
		{
		legend(x=0.1,y=0.75,legend=mysambar$poporder,fill=mysambar$colorder,border=mysambar$colorder,bty='n',cex=legendcex)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Heatmap has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

f3pvalues<-function(mydf=mysambar$f3df,export=NULL,plotname="f3_pvalues",yline=5.75,f3thres=0)
	{
	mydf2<-mydf[mydf$est<f3thres,]
	if(nrow(mydf2)<=1)
		{
		return(cat("Not enough data points for plotting f3 p-values.",sep="\n"))
		}
	if(!is.null(export))
		{
		plotname	<- paste(plotname,paste("threshold",f3thres,sep=""),sep=".")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,7.5,2,1),cex.axis=1.5,cex.lab=2,cex.main=2)
	plot(-log10(mydf2$p),mydf2$est,pch=16,cex=1.5,xlab="log10(p-value)",ylab="",las=1)
	mtext(side=2,line=yline,"f3-score",cex=2)
	abline(v=-log10(0.05),col="red")
	if(!is.null(export))
		{
		dev.off()
		#cat("Scatterplot has been exported to the directory:",sep="\n")
		#cat(getwd(),sep="\n")
		}
	}

f3heatmap<-function(creatematrix=TRUE,pthres=0.05,f3thres=0,minthres=FALSE,export=NULL,exportname="f3heatmap",f3df=mysambar$f3df,addlabels=TRUE,plottitle="f3-score",mybg="white",subtitle=NULL,NAcolour=NULL,addlegend=TRUE,fillsquare=FALSE,legendcex=1.25,oldmethod=FALSE,checkpops=FALSE)
	{
	if(is.null(f3df))
		{
		return(cat("ERROR: specified f3 dataframe (default: mysambar$f3df) does not exist. Did you run the runadmixtools function?",sep="\n"))
		}
	popnames<- unique(c(f3df$pop1,f3df$pop2,f3df$pop3))
	npop	<- length(popnames)
	poporder<- mysambar$poporder
	popcols	<- mysambar$colorder
	if(length(poporder)!=npop&checkpops)
		{
		return(cat("ERROR: number of populations in specified f3 dataframe (default: mysambar$f3df) does not correspond with number of populations in the mysambar$poporder vector. Rerun the runadmixtools function with the new filter settings.",sep="\n"))
		}
	if(creatematrix)
		{
		cat("Converting dataframe to matrix...",sep="\n")
		f3mat			<- matrix(NA,ncol=npop,nrow=npop*npop)
		colnames(f3mat)	<- popnames
		rownames(f3mat)	<- rep(popnames,npop)
		f3mat2			<- f3mat
		# columns:
		for(j in c(1:npop))
			{
			out1	<- poporder[j]	
			# rows (field):
			for(i in c(1:npop))
				{
				out2	<- poporder[i]
				if(i<j)
					{
					# rows (data entry within field):
					for(k in c(1:npop))
						{
						admixpop	<- poporder[k]
						rownr		<- which(f3df$pop1==admixpop&((f3df$pop2==out1&f3df$pop3==out2)|(f3df$pop2==out2&f3df$pop3==out1)))
						if(length(rownr)>1)
							{
							rownr	<<- rownr
							return(cat("ERROR: more than 1 row.",sep="\n"))
							}
						if(length(rownr)!=0)
							{
							myf3score				<- f3df$est[rownr]
							mypvalue				<- f3df$p[rownr]
							if(is.null(myf3score))
								{
								rownr				<<- rownr
								cat("WARNING: NULL-value.",sep="\n")
								}else{
								f3mat[(i-1)*npop+k,j] 	<- myf3score
								if(minthres)
									{
									mybool	<- myf3score>f3thres&mypvalue<=pthres
									}else{
									mybool	<- myf3score<f3thres&mypvalue<=pthres
									}		
								if(mybool)
									{
									f3mat2[(i-1)*npop+k,j]	<- k
									}else{
									f3mat2[(i-1)*npop+k,j]	<- 0
									}
								}
							}
						}
					}
				}
			}
		mysambar$f3mat	<<- f3mat
		mysambar$f3mat2	<<- f3mat2	# contains population number of admixed population, needed for plotting 
		cat("Matrix with f3-scores stored at mysambar$f3mat.",sep="\n")
		}else{
		cat("WARNING: using existing matrix with f3-scores, stored at mysambar$f3mat.",sep="\n")
		f3mat			<- mysambar$f3mat
		f3mat2			<- mysambar$f3mat2
		}
	#
	if(fillsquare)
		{
		cat("Filling square to make admixed population better visible...",sep="\n")
		f3mat3			<- f3mat2
		# columns:
		for(j in c(1:npop))
			{
			out1	<- poporder[j]	
			# rows (field):
			for(i in c(1:npop))
				{
				out2	<- poporder[i]
				if(i<j)
					{
					#cat(paste(out1,out2,sep="_"),sep="\n")
					#squarevec					<- f3mat2[c(((i-1)*npop):(i*npop-1)),j]
					squarevec					<- f3mat2[c((((i-1)*npop)+1):((i*npop))),j]		## correction 20-09-2023
					squarevec[is.na(squarevec)]	<- 0
					nadmix						<- length(squarevec[squarevec>0])
					if(nadmix>0)
						{
						mystart		<- (i-1)*npop+1
						myend		<- i*npop
						if(nadmix==1)
							{
							admixpopnr				<- max(squarevec)
							f3mat3[mystart:myend,j]	<- rep(admixpopnr,npop)
							}else{
							squarevec				<- squarevec[order(squarevec,decreasing=TRUE)]
							}
						if(nadmix>1)
							{
							admixpopnr		<- head(squarevec,nadmix)
							mybreakvec		<- rep(NA,nadmix-1)	
							for(breaknr in c(1:(nadmix-1)))
								{
								# mybreakvec[breaknr]	<- floor(mystart+(breaknr*npop/nadmix))
								# edit 20-09-2023: 
								if(breaknr%%2!=0)
									{
									mybreakvec[breaknr]	<- floor(mystart+(breaknr*npop/nadmix))-1	
									}else{
									mybreakvec[breaknr]	<- floor(mystart+(breaknr*npop/nadmix))
									}
								}
							startvec		<- c(mystart,mybreakvec+1)
							endvec			<- c(mybreakvec,myend)
							for(binnr in c(1:nadmix))
								{
								binstart	<- startvec[binnr]
								binend		<- endvec[binnr]
								f3mat3[binstart:binend,j]		<- admixpopnr[binnr]
								}
							}
						#cat(admixpopnr,sep="\n")
						#cat(paste(i,j,sep="_"),sep="\n")
						#cat(paste(out1,out2,poporder[admixpopnr],sep="_"),sep="\n")
						}
					}
				}
			}
		mysambar$f3mat3	<<- f3mat3
		}
	#
	# plot:
	cat("Creating heatmap...",sep="\n")
	graphics.off()
	if(!is.null(export))
		{
		exportname	<- ifelse(mybg=="white",exportname,paste(exportname,mybg,sep="."))
		exportname	<- paste(exportname,paste("f3threshold",f3thres,sep=""),sep="_")
		exportname	<- paste(exportname,paste("pthreshold",pthres,sep=""),sep="_")
		exportname	<- ifelse(fillsquare,paste(exportname,"fullsquare",sep="."),exportname)
		mysize		<- 10
		mysize2		<- 720
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	par(bg=mybg)
	myBreaks	<- seq(-0.5,npop+0.5,1)
	NAcolour	<- ifelse(is.null(NAcolour),mybg,NAcolour)
	cat(paste("NAcolour is set to: ",NAcolour,".",sep=""),sep="\n")
	myColours	<- c(NAcolour,popcols)
	if(fillsquare)
		{
		my_matrix	<- mysambar$f3mat3
		}else{
		my_matrix	<- mysambar$f3mat2
		}
	heatmap.2(my_matrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=NA,labCol=NA,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,RowSideColors=rep(popcols,each=npop),ColSideColors=popcols,
	dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
	#
	if(addlabels)
		{
		mtext("Ancestral population 1", side = 1, cex = 2, line = 3)
		mtext("Ancestral population 2", side = 4, cex = 2, line = 0)
		}
	mtext(plottitle,side=3,line=1,cex=3)
	if(is.null(subtitle))
		{
		subtitle	<- paste("f3-threshold = ",f3thres,"; pvalue-threshold = ",pthres,sep="")
		}
	mtext(subtitle,side=3,line=-0.5,cex=1.75)
	if(addlegend)
		{
		legend(x=0.1,y=0.75,legend=mysambar$poporder,fill=mysambar$colorder,border=mysambar$colorder,bty='n',cex=legendcex)
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Heatmap has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

calcf3<-function(mafdf=NULL)
	{
	# e.g.:
	# mydf 				<- snps[,c("maf_Westcoast","maf_Alaska","maf_zoohybrid")]
	# colnames(mydf)	<- c("pop1","pop2","admixpop")
	# calcf3(mafdf=mydf)
	if(is.null(mafdf))
		{
		return(cat("ERROR: provide dataframe with minor allele frequencies of three populations, with column names 'pop1','pop2','admixpop'.",sep="\n"))
		}
	mafpop1			<- mafdf$pop1
	mafpop2			<- mafdf$pop2
	mafadmix		<- mafdf$admixpop
	#
	# b and c are the introgressors, a is the putatively admixed population:
	f2ab			<<- mean((mafadmix-mafpop1)^2,na.rm=TRUE)
	f2ac			<<- mean((mafadmix-mafpop2)^2,na.rm=TRUE)
	f2bc			<<- mean((mafpop1-mafpop2)^2,na.rm=TRUE)			
	# f3 statistic:
	f3_admix		<<- 0.5*(f2ab+f2ac-f2bc)
	}

# simulations:
runcalcf3sim<-function(mean_maf=0.15,t_1=30,t_2=60,n_inds=100000,n_snps=1000)
	{
	myratios	<<- vector()
	myadmixs	<<- seq(0,1,0.05)
	for(k in c(1:length(myadmixs)))
		{
		cat(k,sep="\n")
		calcf3(meanmaf=mean_maf,t1=t_1,t2=t_2,ninds=n_inds,nruns=1000,nsnps=n_snps,admix=myadmixs[k],plot_ac=FALSE)
		myratios[k]	<<- mean(f2ab_admix)/mean(f2ab)
		}
	graphics.off()
	plot(myadmixs,myratios)
	}

# simulations:
calcf3sim<-function(meanmaf=0.15,t1=20,t2=40,ninds=100,nruns=1000,nsnps=100,admix=0.5,plot_ac=FALSE,do_analysis=TRUE)
	{
	if(do_analysis)
		{
		# t1: split a and b			in ngen ago
		# t2: split (ab) and c		in ngen ago
		f3		<<- vector()
		f2ab	<<- vector()
		f2ac	<<- vector()
		f2bc	<<- vector()
		#
		f3_admix	<<- vector()
		f2ab_admix	<<- vector()
		f2ac_admix	<<- vector()
		f2bc_admix	<<- vector()
		#
		for(i in c(1:nruns))
			{
			startmaf	<<- rbinom(n=nsnps,size=2*ninds,prob=meanmaf)/(2*ninds)
			#
			# population C:
			maf3		<<- startmaf
			for (k in c(1:t2))
				{
				maf3	<<- rbinom(n=nsnps,size=2*ninds,prob=maf3)/(2*ninds)
				}
			# population A and B:
			xmaf		<<- startmaf
			for (k in c(1:(t2-t1)))
				{
				xmaf	<<- rbinom(n=nsnps,size=2*ninds,prob=xmaf)/(2*ninds)
				}
			maf1		<<- xmaf
			maf2		<<- xmaf
			for(k in c(1:t1))
				{
				maf1	<<- rbinom(n=nsnps,size=2*ninds,prob=maf1)/(2*ninds)
				maf2	<<- rbinom(n=nsnps,size=2*ninds,prob=maf2)/(2*ninds)
				}
			maf1admix	<<- (1-admix)*maf1+admix*maf3
			#
			# f2 statistics:
			f2ab[i]	<<- mean((maf1-maf2)^2)
			f2ac[i]	<<- mean((maf1-maf3)^2)
			f2bc[i]	<<- mean((maf2-maf3)^2)
			# f3 statistic:
			f3[i]		<<- 0.5*(f2ab[i] + f2ac[i] - f2bc[i])
			#
			# with admixture:
			# f2 statistics:
			f2ab_admix[i]	<<- mean((maf1admix-maf2)^2)
			f2ac_admix[i]	<<- mean((maf1admix-maf3)^2)
			f2bc_admix[i]	<<- mean((maf2-maf3)^2)			# not different from f2bc
			# f3 statistic:
			f3_admix[i]		<<- 0.5*(f2ab_admix[i] + f2ac_admix[i] - f2bc_admix[i])
			}
		}
	mymin	<- min(c(f2ab,f2ac,f2bc,f2ab_admix,f2ac_admix))
	mymax	<- max(c(f2ab,f2ac,f2bc,f2ab_admix,f2ac_admix))
	#
	par(mfrow=c(1,3),oma=c(6,2,2,2))
	plot(f2ab,f2ac,xlim=c(mymin,mymax),ylim=c(mymin,mymax),col="grey90",pch=16,xlab="f2(a,b)",ylab=c("other f2 scores"))
	points(f2ab,f2bc,col="grey30")
	points(f2ab_admix,f2ac_admix,col="lightsteelblue4")
	#points(f2ab_admix,f2bc,col="darkblue")
	lines(c(0,1),c(0,t2/t1))
	legend("bottomright",legend=c("f2(ab) f2(ac)","f2(ab) f2(ac) admix","f2(ab) f2(bc)"),fill=c("grey90","lightsteelblue4","grey30"),bty='n',cex=1.5)
	#legend("bottomright",legend=c("f2(ab) f2(ac)","f2(ab) f2(ac) admix","f2(ab) f2(bc)","f2(ab) f2(bc) admix"),fill=c("darkred","darkgreen","blue","orange"),bty='n',cex=1.5)
	#
	mydf	<- data.frame("score"=c(rep("1 f2(a,b)",nruns),rep("2 f2(a,b) A",nruns),rep("3 f2(a,c)",nruns),rep("4 f2(a,c) A",nruns),rep("5 f2(a,b) + f2(a,c)",nruns),rep("6 f2(a,b) + f2(a,c) A",nruns),rep("7 f2(b,c)",nruns)),"value"=c(f2ab,f2ab_admix,f2ac,f2ac_admix,f2ab+f2ac,f2ab_admix+f2ac_admix,f2bc))
	boxplot(mydf$value~mydf$score,las=2,col=c("grey90","lightsteelblue4","grey90","lightsteelblue4","grey90","lightsteelblue4","grey30"),ylab="",xlab="")
	mtext("f3 scores",side=3,cex=1.5)
	#
	mymin	<- min(c(f3,f3_admix))
	mymax	<- max(c(f3,f3_admix))
	hist(f3,col="grey50",xlim=c(mymin,mymax))
	hist(f3_admix,add=TRUE)
	abline(v=0,lty=2)
	#
	if(plot_ac)
		{
		# f2(a,c)_admix/f2(a,c) ratio as a function of admix proportion (irrespective of t2/t1 ratio):
		n		<- seq(1,20,1)
		admix	<- (n-1)/n 
		myratio	<- 1/(n^2)
		mypredicted	<- (1-admix)^2	
		graphics.off()
		plot(admix,myratio,type='l')
		points(admix,mypredicted,col="red")
		#
		# hence myratio is (1-admix)^2
		#
		# hence, f3 is given by the function:
		# f3 = ((t2/t1)*p^2-p+1) * f2(A,B) + (1-p)^2 * f2(A,C) - f2(B,C)
		# in which p represents the proportion of admixture from C into A
		# x = a*(p-0.25)^2+b?
		}
	}

# 03-06-2022: check whether triplets are consistent with topology:
# input population tree can be generated with the commands:
# pop_neimatrix(export="pdf")
# getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=0.75)
findtriplets<-function(mytree=NULL,tripletdf=NULL,tipnames=NULL,silent=TRUE,newickfile=NULL,nexusfile=NULL,tripletfile=NULL,prunedf=NULL,plottree=FALSE,doexport=FALSE,makeglobal=FALSE,myroot=NULL)
	{
	my_repos	<- 'http://cran.us.r-project.org'
	if("ape" %in% rownames(installed.packages()) == FALSE) {install.packages("ape",repos=my_repos)}	
	if("phangorn" %in% rownames(installed.packages()) == FALSE) {install.packages("phangorn",repos=my_repos)}	
	if("ape" %in% (.packages()) == FALSE){library("ape")}
	if("phangorn" %in% (.packages()) == FALSE){library("phangorn")}
	#
	### READ TREE ###
	if(!is.null(newickfile))
		{
		cat("Importing tree in newick format...",sep="\n")
		if(!file.exists(newickfile))
			{
			cat("ERROR: Specified tree file not found in directory:",sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		mytree			<- ape::read.tree(newickfile)
		}
	if(!is.null(nexusfile))
		{
		cat("Importing tree in nexus format...",sep="\n")
		if(!file.exists(nexusfile))
			{
			cat("ERROR: Specified tree file not found in directory:",sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		mytree			<- ape::read.nexus(nexusfile)
		}
	if(is.null(mytree))
		{
		return(cat("ERROR: please specify an (existing) input tree.",sep="\n"))	
		}
	if(class(mytree)!="phylo")
		{
		return(cat("ERROR: specified tree should be a 'phylo' object.",sep="\n"))	
		}
	if(!is.null(myroot))
		{
		if(!myroot%in%mytree$tip.label)
			{
			return(cat("ERROR: specified root not present in phylogeny.",sep="\n"))
			}
		cat("Rooting tree...",sep="\n")
		mytree	<- root(mytree,myroot,resolve.root=TRUE)
		}
	if(!is.rooted(mytree))
		{
		return(cat("ERROR: tree is unrooted. Please specify a root to the myroot flag.",sep="\n")) 
		}
	#
	### PRUNING TREE ####
	if(!is.null(prunedf))
		{
		if(nrow(prunedf)!=length(mytree$tip.label))
			{
			return(cat("ERROR: Number of samples in prunedf does not correspond with number of samples in input topology.",sep="\n"))
			}
		if(any(!(c("name","pop")%in%colnames(prunedf))))
			{
			return(cat("ERROR: prunedf should contain the columns 'name' and 'pop'.",sep="\n"))
			}
		cat("Pruning the tree by keeping one randomly selected individual per population...",sep="\n")
		thindf				<- prunedf[!duplicated(prunedf$pop),]
		thintree			<- keep.tip(phy=mytree,tip=thindf$name)
		mylabels			<- thintree$tip.label
		for(k in c(1:nrow(thindf)))
			{
			mysample		<- mylabels[k]
			mypop			<- thindf$pop[thindf$name==mysample]
			mylabels[k]		<- mypop 
			}
		thintree$tip.label	<- mylabels
		mytree				<- thintree
		}
	### READ TRIPLETS DATAFRAME ###
	if(!is.null(tripletfile))
		{
		cat("Importing txt-file with triplets...",sep="\n")
		if(!file.exists(tripletfile))
			{
			cat("ERROR: Specified triplet file not found in directory:",sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		tripletdf 		<- read.table(tripletfile,header=TRUE)
		}
	if(is.null(tripletdf))
		{
		if(is.null(tipnames))
			{
			cat("WARNING: no (existing) input triplets dataframe defined, and no (existing) tipnames defined either. Generating a dataframe will all possible triplets.",sep="\n")
			tipnames		<- mytree$tip.label
			}else{
			cat("No input triplet dataframe defined. Generating a dataframe with all possible triplets for samples/populations specified to tipnames flag.",sep="\n")
			}
		npops				<- length(tipnames)
		tripletdf			<- as.data.frame(permutations(n=npops,r=3,v=tipnames,repeats.allowed=F))
		colnames(tripletdf)	<- c("p1","p2","p3")
		}else{
		cat("Evaluating triplets specified in input triplets dataframe...",sep="\n")
		colnames(tripletdf)[colnames(tripletdf)=="P1"]	<- "p1"
		colnames(tripletdf)[colnames(tripletdf)=="P2"]	<- "p2"
		colnames(tripletdf)[colnames(tripletdf)=="P3"]	<- "p3"
		if(any(!c("p1","p2","p3")%in%colnames(tripletdf)))
			{
			return(cat("ERROR: input triplet dataframe should contain columns named 'p1', 'p2' and 'p3' (case-sensitive).",sep="\n"))	
			}
		if(is.null(tipnames))
			{
			tipnames		<- unique(c(tripletdf$p1,tripletdf$p2,tripletdf$p3))
			npops			<- length(tipnames)
			}else{
			popvec	<- unique(c(tripletdf$p1,tripletdf$p2,tripletdf$p3))
			if(any(!popvec%in%tipnames)|any(!tipnames%in%popvec))
				{
				return(cat("ERROR: population names in triplets dataframe do not correspond with population names in input tipnames vector.",sep="\n"))
				}
			}
		}
	if(any(!unique(c(tripletdf$p1,tripletdf$p2,tripletdf$p3)%in%mytree$tip.label)))
		{
		return(cat("ERROR: one or more names in triplets dataframe (columns p1, p2 and p3) are not present in tiplabels of phylogeny.",sep="\n"))
		}
	# for our analysis no difference between (((A,B),C)) and (((B,A),C)). Delete (((B,A),C)):
	cat("Checking triples dataframe for occurrence of ((A,B),C) and ((B,A),C), and if present, removing ((B,A),C).",sep="\n") 
	tripletdf$myorder		<- as.character(tripletdf$p2)>as.character(tripletdf$p1)
	tripletdf$triplet		<- ifelse(tripletdf$myorder,paste(tripletdf$p1,tripletdf$p2,tripletdf$p3,sep="_"),paste(tripletdf$p2,tripletdf$p1,tripletdf$p3,sep="_"))
	tripletdf				<- tripletdf[(!duplicated(tripletdf$triplet)),]
	ntriplets				<- nrow(tripletdf)
	rfdf					<<- tripletdf
	#
	if(makeglobal)
		{
		reftree				<<- mytree
		mytripletdf			<<- tripletdf 
		if(exists("thintree"))
			{	
			thintree		<<- thintree
			}
		}
	### CALCULATE ROBINSON-FOULDS SCORE ####
	cat("Checking whether triplets are consistent with topology...",sep="\n")
	rfdf$RF					<<- NA
	for(i in c(1:nrow(tripletdf)))
	#for(i in c(1:30))
		{
		if(i%%25000==0){cat(paste(i," out of ",nrow(tripletdf),".",sep=""),sep="\n")}
		in1					<- tripletdf$p1[i]
		in2					<- tripletdf$p2[i]
		intro				<- tripletdf$p3[i]
		mynewick			<<- paste("((",in1,",",in2,"),",intro,");",sep="")
		triplettree 		<<- read.tree(text=mynewick)	
		subtree				<<- keep.tip(phy=mytree,tip=c(in1,in2,intro))
		if(makeglobal)
			{
			mynewick			<<- mynewick
			triplettree 		<<- triplettree	
			subtree				<<- subtree
			}
		if(!is.binary(subtree))
			{
			return(cat("ERROR: non-binary subtree.",sep="\n"))
			}
		# phangorn package:
		# cat("Calculating Robinson-Foulds distance.",sep="\n")
		rfdf$RF[i]			<<- RF.dist(tree1=subtree,tree2=triplettree,check.labels=TRUE,rooted=TRUE)
		}
	nconsistent		<- length(rfdf$RF[rfdf$RF==0&!is.na(rfdf$RF)])
	ndiscordant		<- length(rfdf$RF[rfdf$RF!=0&!is.na(rfdf$RF)])
	cat(paste("Number of topology-consistent triplets: ",nconsistent,".",sep="") ,sep="\n")
	cat(paste("Number of topology-discordant triplets: ",ndiscordant,".",sep="") ,sep="\n")
	cat("Robinson-Foulds scores are stored in dataframe 'rfdf'.\nA score of 0 indicates that the triplet topology is consistent with the input tree (and hence can be used for ABBA-BABA calculations).",sep="\n") 
	if(plottree)
		{
		plot(mytree,type="unrooted")
		}
	if(doexport)
		{
		write.table(rfdf,"triplets.robinsonfould.all.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
		write.table(rfdf[rfdf$RF==0,],"triplets.robinsonfould.filter.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
		cat("The table has also been exported to the files 'triplets.robinsonfould.all.txt' and 'triplets.robinsonfould.filter.txt' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 25-08-2022: check whether quartets are consistent with topology:
# input population tree can be generated with the commands:
# pop_neimatrix(export="pdf")
# getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=0.75)
findquartets<-function(mytree=NULL,quartetdf=NULL,tipnames=NULL,silent=TRUE,newickfile=NULL,nexusfile=NULL,quartetfile=NULL,plottree=FALSE,doexport=FALSE,makeglobal=FALSE,myroot=NULL)
	{
	my_repos	<- 'http://cran.us.r-project.org'
	if("ape" %in% rownames(installed.packages()) == FALSE) {install.packages("ape",repos=my_repos)}	
	if("phangorn" %in% rownames(installed.packages()) == FALSE) {install.packages("phangorn",repos=my_repos)}	
	if("ape" %in% (.packages()) == FALSE){library("ape")}
	if("phangorn" %in% (.packages()) == FALSE){library("phangorn")}
	#
	### READ TREE ###
	if(!is.null(newickfile))
		{
		cat("Importing tree in newick format...",sep="\n")
		if(!file.exists(newickfile))
			{
			cat("ERROR: Specified tree file not found in directory:",sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		mytree			<- ape::read.tree(newickfile)
		}
	if(!is.null(nexusfile))
		{
		cat("Importing tree in nexus format...",sep="\n")
		if(!file.exists(nexusfile))
			{
			cat("ERROR: Specified tree file not found in directory:",sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		mytree			<- ape::read.nexus(nexusfile)
		}
	if(is.null(mytree))
		{
		return(cat("ERROR: please specify an (existing) input tree.",sep="\n"))	
		}
	if(class(mytree)!="phylo")
		{
		return(cat("ERROR: specified tree should be a 'phylo' object.",sep="\n"))	
		}
	if(!is.null(myroot))
		{
		if(!myroot%in%mytree$tip.label)
			{
			return(cat("ERROR: specified root not present in phylogeny.",sep="\n"))
			}
		cat("Rooting tree...",sep="\n")
		mytree	<- root(mytree,myroot,resolve.root=TRUE)
		}
	if(!is.rooted(mytree))
		{
		return(cat("ERROR: tree is unrooted. Please specify a root to the myroot flag.",sep="\n")) 
		}
	#
	### READ QUARTETS DATAFRAME ###
	if(!is.null(quartetfile))
		{
		cat("Importing txt-file with quartets...",sep="\n")
		if(!file.exists(quartetfile))
			{
			cat("ERROR: Specified quartet file not found in directory:",sep="\n")
			return(cat(getwd(),sep="\n"))
			}
		quartetdf 		<- read.table(quartetfile,header=TRUE)
		}
	if(is.null(quartetdf))
		{
		if(is.null(tipnames))
			{
			cat("WARNING: no (existing) input quartets dataframe defined, and no (existing) tipnames defined either. Generating a dataframe will all possible quartets.",sep="\n")
			tipnames		<- mytree$tip.label
			}else{
			cat("No input quartet dataframe defined. Generating a dataframe with all possible quartets for samples/populations specified to tipnames flag.",sep="\n")
			}
		npops				<- length(tipnames)
		quartetdf			<- as.data.frame(permutations(n=npops,r=4,v=tipnames,repeats.allowed=F))
		#quartetdf			<- as.data.frame(t(combn(mysambar$populations2,4)))
		#write.table(quartetdf,"allquartets.txt",col.names=FALSE,row.names=FALSE,quote=FALSE,sep="\t")
		colnames(quartetdf)	<- c("p1","p2","p3","p4")
		}else{
		cat("Evaluating quartets specified in input quartets dataframe...",sep="\n")
		colnames(quartetdf)[colnames(quartetdf)=="P1"]	<- "p1"
		colnames(quartetdf)[colnames(quartetdf)=="P2"]	<- "p2"
		colnames(quartetdf)[colnames(quartetdf)=="P3"]	<- "p3"
		colnames(quartetdf)[colnames(quartetdf)=="P4"]	<- "p4"
		if(any(!c("p1","p2","p3","p4")%in%colnames(quartetdf)))
			{
			return(cat("ERROR: input quartet dataframe should contain columns named 'p1', 'p2', 'p3' and 'p4' (case-sensitive).",sep="\n"))	
			}
		if(is.null(tipnames))
			{
			tipnames		<- unique(c(quartetdf$p1,quartetdf$p2,quartetdf$p3,quartetdf$p4))
			npops			<- length(tipnames)
			}else{
			popvec	<- unique(c(quartetdf$p1,quartetdf$p2,quartetdf$p3,quartetdf$p4))
			if(any(!popvec%in%tipnames)|any(!tipnames%in%popvec))
				{
				return(cat("ERROR: population names in quartets dataframe do not correspond with population names in input tipnames vector.",sep="\n"))
				}
			}
		}
	if(any(!unique(c(quartetdf$p1,quartetdf$p2,quartetdf$p3,quartetdf$p4)%in%mytree$tip.label)))
		{
		return(cat("ERROR: one or more names in quartets dataframe (columns p1, p2, p3 and p4) are not present in tiplabels of phylogeny.",sep="\n"))
		}
	cat(paste("Number of quartets: ", nrow(quartetdf),".",sep=""),sep="\n")
	# for our analysis no difference between (((A,B),(C,D)) and ((B,A),(C,D)), ((A,B),(D,C)) or ((B,A),(D,C)). Delete ((B,A),(C,D)), ((A,B),(D,C)) or ((B,A),(D,C)):
	cat("Checking quartets dataframe for occurrence of (((A,B),(C,D)), ((B,A),(C,D)), ((A,B),(D,C)) or ((B,A),(D,C)), and if present, selecting one only.",sep="\n") 
	quartetdf$quartet		<- NA
	for(k in c(1:nrow(quartetdf)))
		{
		myvec					<- as.vector(unlist(quartetdf[k,c("p1","p2","p3","p4")]))
		myvec					<- myvec[order(myvec)]
		quartetdf$quartet[k]	<- paste(myvec,collapse="_")
		}
	quartetdf				<- quartetdf[(!duplicated(quartetdf$quartet)),]
	nquartets				<- nrow(quartetdf)
	cat(paste("Number of quartets: ", nquartets,".",sep=""),sep="\n")
	rfdf					<<- quartetdf
	#
	if(makeglobal)
		{
		reftree				<<- mytree
		myquartetdf			<<- quartetdf 
		}
	### CALCULATE ROBINSON-FOULDS SCORE ####
	cat("Checking whether quartets are consistent with topology...",sep="\n")
	rfdf$RF					<<- NA
	for(i in c(1:nrow(quartetdf)))
	#for(i in c(1:30))
		{
		if(i%%25000==0){cat(paste(i," out of ",nrow(quartetdf),".",sep=""),sep="\n")}
		in1					<- quartetdf$p1[i]
		in2					<- quartetdf$p2[i]
		out1				<- quartetdf$p3[i]
		out2				<- quartetdf$p4[i]
		mynewick			<<- paste("((",in1,",",in2,"),(",out1,",",out2,"));",sep="")
		quartettree 		<<- read.tree(text=mynewick)	
		subtree				<<- keep.tip(phy=mytree,tip=c(in1,in2,out1,out2))
		if(makeglobal)
			{
			mynewick			<<- mynewick
			quartettree 		<<- quartettree	
			subtree				<<- subtree
			}
		if(!is.binary(subtree))
			{
			return(cat("ERROR: non-binary subtree.",sep="\n"))
			}
		# phangorn package:
		# cat("Calculating Robinson-Foulds distance.",sep="\n")
		rfdf$RF[i]			<<- RF.dist(tree1=subtree,tree2=quartettree,check.labels=TRUE,rooted=TRUE)
		}
	nconsistent		<- length(rfdf$RF[rfdf$RF==0&!is.na(rfdf$RF)])
	ndiscordant		<- length(rfdf$RF[rfdf$RF!=0&!is.na(rfdf$RF)])
	cat(paste("Number of topology-consistent quartets: ",nconsistent,".",sep="") ,sep="\n")
	cat(paste("Number of topology-discordant quartets: ",ndiscordant,".",sep="") ,sep="\n")
	cat("Robinson-Foulds scores are stored in dataframe 'rfdf'.\nA score of 0 indicates that the quartet topology is consistent with the input tree (and hence can be used for ABBA-BABA calculations).",sep="\n") 
	if(plottree)
		{
		plot(mytree,type="unrooted")
		}
	if(doexport)
		{
		write.table(rfdf,"quartets.robinsonfould.all.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
		write.table(rfdf[rfdf$RF==0,],"quartets.robinsonfould.filter.txt",quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
		cat("The table has also been exported to the files 'quartets.robinsonfould.all.txt' and 'quartets.robinsonfould.filter.txt' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}


# 04-04-2022: heatmap for Dstats:
Dheatmap<-function(export=NULL,exportname="Dstats_heatmap",do_analyses=TRUE,creatematrix=TRUE,introgressors=mysambar$poporder,ingroups=mysambar$poporder,silent=TRUE,do_jackknife=FALSE,block_size=1000000,my_root=NULL)
	{
	nout					<- length(introgressors)
	nin						<- length(ingroups)
	combitable				<- combn(ingroups,m=2)
	npairs					<- ncol(combitable)
	if(do_analyses)
		{
		# function to evaluate which population triplets are congruent with the phylogeny
		#mydf				<- data.frame("ingroup1"=combitable[1,],ingroup2=combitable[2,])
		#mydf				<- mydf[rep(seq_len(nrow(mydf)),each=nout),]
		#mydf$introgressor	<- rep(introgressors,npairs)
		#mydf$clustering		<- NA			
		#
		# calculate distances between populations:
		#if(is.null(mysambar$popneivector))
		#	{
		#	cat("Calculating Nei's distances...",sep="\n")
		#	pop_neimatrix()
		#	}else{
		#	cat("Using existing vector with Nei's distances...",sep="\n")
		#	}
		#neivec				<- mysambar$popneivector
		#pairpop1			<- mysambar$pairpop1
		#pairpop2			<- mysambar$pairpop2
		#
		#for (k in c(1:nrow(mydf)))
		#	{
		#	if(!silent){cat(paste(k," out of ",nrow(mydf),sep=""),sep="\n")}
		#	in1				<- mydf$ingroup1[k]
		#	in2				<- mydf$ingroup2[k]
		#	intro			<- mydf$introgressor[k]
		#	if(in1==intro|in2==intro)
		#		{
		#		mydf$clustering[k]	<- "self-comparison"
		#		}else{
		#		dist_in			<- neivec[(pairpop1==in1&pairpop2==in2)|(pairpop1==in2&pairpop2==in1)]
		#		dist_out1		<- neivec[(pairpop1==in1&pairpop2==intro)|(pairpop1==intro&pairpop2==in1)]
		#		dist_out2		<- neivec[(pairpop1==in2&pairpop2==intro)|(pairpop1==intro&pairpop2==in2)]
		#		mydf$clustering[k]<- ifelse((dist_in>dist_out1)|(dist_in>dist_out2),"conflict","congruent")
		#		}
		#	}
		#mysambar$alltripletsdf	<<- mydf
		cat("Finding all possible triplets...",sep="\n")
		if(is.null(mysambar$poptree))
			{
			pop_neimatrix(export="pdf")
			getpoptree(mymatrix=mysambar$popneimatrix,exportlabel="neiD",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=0.75)
			}
		if(is.null(my_root))
			{
			return(cat("ERROR: please specify an outgroup population to the my_root flag.",sep="\n"))
			}
		findtriplets(mytree=mysambar$poptree,doexport=TRUE,makeglobal=FALSE,myroot=my_root)
		rfdf$clustering			<<- ifelse(rfdf$RF==0&!is.na(rfdf$RF),"congruent","conflict")
		mysambar$alltripletsdf	<<- rfdf
		#
		# run ABBA-BABA analyses:
		calcD(popnames=mysambar$populations,snpfilter=snps$filter,silent=FALSE,mytriplets=mydf[mydf$clustering=="congruent",],dojackknife=do_jackknife,jkblocksize=block_size,minblocks=50)
		write.table(mysambar$dscores,"Dstats.alltriplets.txt",sep="\t",col.names=TRUE,row.names=FALSE,quote=FALSE)
		}else{
		cat("WARNING: using existing dataframe mysambar$dscores because the flag do_analyses is set to FALSE.",sep="\n") 
		}
	##### 
	# combine results:
	tdf			<- mysambar$alltripletsdf
	if(all(c("ingroup1","ingroup2","introgressor")%in%colnames(tdf)))
		{
		tdf$pops	<- paste(tdf$ingroup1,tdf$ingroup2,tdf$introgressor,sep="_")
		}else{
		tdf$pops	<- paste(tdf$p1,tdf$p2,tdf$p3,sep="_")
		colnames(tdf)[colnames(tdf)=="p1"]	<- "ingroup1"
		colnames(tdf)[colnames(tdf)=="p2"]	<- "ingroup2"
		colnames(tdf)[colnames(tdf)=="p3"]	<- "introgressor"
		}
	if("sign2"%in%colnames(mysambar$dscores))
		{
		ddf		<- mysambar$dscores[,c("p1","p2","p3","D","sign2")]
		}else{
		ddf		<- mysambar$dscores[,c("p1","p2","p3","D")]
		}
	ddf$pops	<- paste(ddf$p1,ddf$p2,ddf$p3,sep="_")
	tdf			<- merge(tdf,ddf,by="pops",all=TRUE)
	tdftemp		<<- tdf
	#
	poporder	<- mysambar$poporder
	popcols		<- mysambar$colorder
	#
	if(creatematrix)
		{
		cat("Converting dataframe to matrix...",sep="\n")
		# Matrix with ingroup1 as row, ingroup2 as column, and introgressor as entry within field:
		dmat			<- matrix(NA,ncol=nin,nrow=nin*nout)
		colnames(dmat)	<- ingroups
		rownames(dmat)	<- rep(introgressors,nin)
		dmat2			<- dmat
		# columns:
		for(j in c(1:nin))
			{
			in2			<- ingroups[j]	
			# rows (field):
			for(i in c(1:nin))
				{
				in1		<- ingroups[i]
				# rows (data entry within field):
				for(k in c(1:nout))
					{
					# i: ingroup1 		(row block)
					# j: ingroup2 		(column)
					# k: introgressor 	(row)
					dfrow		<- (i-1)*nout+k
					if(!silent){cat(paste("i=" ,i, " j=" ,j, " k=" ,k, " row=" ,dfrow,sep=""),sep="\n")}
					intropop	<- introgressors[k]
					rownr		<- which(tdf$introgressor==intropop&((tdf$ingroup1==in1&tdf$ingroup2==in2)|(tdf$ingroup1==in2&tdf$ingroup2==in1)))
					if(length(rownr)>1)
						{
						return(cat("ERROR: more than 1 row selected.",sep="\n"))
						}
					if(length(rownr)!=0)
						{
						mytype		<- tdf$clustering[rownr]
						mydscore	<- tdf$D[rownr]
						if(mytype=="self-comparison")
							{
							dmat[dfrow,j]	<- 100
							dmat2[dfrow,j]	<- 100
							}
						if(mytype=="conflict")
							{	
							dmat[dfrow,j]	<- 1000
							dmat2[dfrow,j]	<- 1000
							}
						if(mytype=="congruent")
							{
							dmat[(j-1)*nout+k,j]	<- mydscore
							if(!"sign2"%in%colnames(tdf))
								{	
								# if p-values are absent:
								if(i<j)
									{
									if(mydscore<0)
										{
										dmat2[dfrow,j]	<- k
										}else{
										dmat2[dfrow,j]	<- -10
										}
									}else{
									if(mydscore<0)
										{
										dmat2[dfrow,j]	<- -10
										}else{
										dmat2[dfrow,j]	<- k
										}
									}
								}else{
								# if p-values are present:
								mypvalue		<- ifelse(tdf$sign2[rownr]=="NS",1,0)
								if(mypvalue==1)
									{
									# if non-significant
									dmat2[dfrow,j]<- -100
									}else{
									if(i<j)
										{
										if(mydscore<0)
											{
											dmat2[dfrow,j]<- k
											}else{
											dmat2[dfrow,j]<- -10
											}
										}else{
										if(mydscore<0)
											{
											dmat2[dfrow,j]<- -10
											}else{
											dmat2[dfrow,j]<- k
											}
										}
									}
								}
							}
						}
					}
				}
			}
		mysambar$dmat	<<- dmat
		mysambar$dmat2	<<- dmat2
		}else{
		cat("WARNING: using existing matrix mysambar$dmat2 because the flag creatematrix is set to FALSE.",sep="\n") 
		}
	if(ncol(mysambar$dmat2)!=nin)
		{
		return(cat("ERROR: number of columns of mysambar$dmat2 does not equal number of ingroups.",sep="\n"))
		}
	if(nrow(mysambar$dmat2)!=nin*nout)
		{
		return(cat("ERROR: number of rows of mysambar$dmat2 does not equal product of number of ingroups and number of introgressors.",sep="\n"))
		}
	# colours:
	ingroupcols			<- vector()
	for(k in c(1:nin))
		{
		ingroupcols[k]	<- mysambar$colorder2[mysambar$poporder2==ingroups[k]]
		}
	introcols			<- vector()
	for(k in c(1:nout))
		{
		introcols[k]	<- mysambar$colorder2[mysambar$poporder2==introgressors[k]]
		}
	#myBreaks	<- c(-150,-15,seq(0.5,nout+0.5,1),150,1500) 
	#myColours	<- c("snow","snow",introcols,"white","grey98")
	#heatmap.2(mysambar$dmat2,lhei=c(0.5,4),lwid=c(0.5,4),labRow=NA,labCol=NA,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,RowSideColors=rep(ingroupcols,each=nout),ColSideColors=ingroupcols,
	#dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
	#heatmap.2(mysambar$dmat,lhei=c(0.5,4),lwid=c(0.5,4),labRow=NA,labCol=NA,Rowv=NA,Colv=NA,scale="none",
	#dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
	#
	cat("Creating heatmap...",sep="\n")
	graphics.off()
	if(!is.null(export))
		{
		mysize	<- 10
		mysize2	<- 720
		if(export=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	# colour coding:
	# 1 to k:	colour	introgressor population
	# -100:		grey90	non-significant D-score
	# -10: 		grey90	introgression, but into ingroup-mate
	# 100: 		white	self-comparison
	# 1000: 	grey99	conflicting quartet (and hence outstanding D-score)
	myBreaks	<- c(-150,-15,seq(0.5,nout+0.5,1),150,1500) 
	myColours	<- c("snow","snow",introcols,"white","grey98")
	heatmap.2(mysambar$dmat2,lhei=c(0.5,4),lwid=c(0.5,4),labRow=NA,labCol=NA,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,RowSideColors=rep(ingroupcols,each=nout),ColSideColors=ingroupcols,
	dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,ylab="",xlab="",srtRow=0,key=FALSE,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow=-0.5,offsetCol=-0.5)
	mtext("Ingroup 1", side = 1, cex = 1.5, line = 4)
	mtext("Ingroup 2", side = 4, cex = 1.5, line = 1)
	mtext("D-score",side = 3,line=1,cex=3)
	#mtext(subtitle,side=3,line=0,cex = 2)
	#legend(x=0.1,y=0.7,legend=mysambar$poporder,fill=mysambar$colorder,border=mysambar$colorder,bty='n',cex=1)
	if(!is.null(export))
		{
		dev.off()
		cat("Heatmap has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		# Double-check if following statements are true:
		cat("Interpret as follows: ingroup1 as columns, ingroup2 as rows, and introgressor as entry within field.",sep="\n")
		cat("Below diagonal: ingroup1 closer to outgroup (BABA).",sep="\n")
		cat("Above diagonal: ingroup2 closer to introgressor (ABBA).",sep="\n")
		}
	}

# formula based on:
# Durand et al. 2011, Testing for Ancient Admixture between Closely Related Populations
calcD<-function(popnames=mysambar$populations,snpfilter=snps$filter,mytriplets=NULL,silent=FALSE,dojackknife=TRUE,minblocks=50,jkblocksize=1000000,storematrix=TRUE,ancestral="major")
	{
	# mytriplets should be a dataframe with three columns (ingroup1, ingroup2, and in the third column the introgressor)
	npops			<- length(popnames)
	if(npops<3)
		{
		return(cat("At present less than 3 population defined. ABBA-BABA tests require at least 3 populations (when not including the outgroup). Execution halted.",sep="\n"))
		}
	#
	if(!is.null(snpfilter))
		{
		myfilter	<- snpfilter
		}else{
		myfilter	<- rep(TRUE,nrow(snps))
		}
	nsnps			<- nrow(snps[myfilter,])
	#
	# find all possible quartets:
	if(is.null(mytriplets))
		{
		if(!silent){cat("Calculating ABBA-BABA statistics for all population triplets...",sep="\n")}
		mytriplets			<- as.data.frame(permutations(n=npops,r=3,v=popnames,repeats.allowed=F))
		}else{
		if(!silent){cat("Calculating ABBA-BABA for predefined population triplets (as defined by input to mytriplets flag)...",sep="\n")}
		}
	colnames(mytriplets)	<- c("p1","p2","p3")
	popvec	<- unique(c(mytriplets$p1,mytriplets$p2,mytriplets$p3))
	if(any(!popvec%in%popnames))
		{
		return(cat("ERROR: One or more unexpected population names in triplets dataframe.",sep="\n"))
		}
	# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
	mytriplets$myorder		<- as.character(mytriplets$p2)>as.character(mytriplets$p1)
	mytriplets$ingroup		<- ifelse(mytriplets$myorder,paste(mytriplets$p1,mytriplets$p2,mytriplets$p3,sep="_"),paste(mytriplets$p2,mytriplets$p1,mytriplets$p3,sep="_"))
	mytriplets				<- mytriplets[(!duplicated(mytriplets$ingroup)),c(1:3)]
	ntriplets				<- nrow(mytriplets)
	# D statistics:
	ABBA			<- vector()
	BABA			<- vector()
	BBAA			<- vector()
	#
	AAAA			<- vector()
	BAAA			<- vector()
	ABAA			<- vector()
	AABA			<- vector()
	BBBA			<- vector()				 
	#
	dvec			<- vector()
	D_nsnps			<- vector()
	D_nsnps_Dpersnp	<- vector()	# number of SNPs with finite D-score if considered on a SNP by SNP basis
	if(storematrix)
		{
		mysambar$BBAAmat			<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		mysambar$ABBAmat			<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		mysambar$BABAmat			<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		mysambar$dmat				<<- matrix(NA,nrow=nsnps,ncol=ntriplets)
		colnames(mysambar$BBAAmat)	<<- mytriplets$ingroup 
		colnames(mysambar$ABBAmat)	<<- mytriplets$ingroup 
		colnames(mysambar$BABAmat)	<<- mytriplets$ingroup 
		colnames(mysambar$dmat)		<<- mytriplets$ingroup 
		}
	# Dfst statistics:
	Dfstvec			<- vector()
	Dfst_nsnps1		<- vector()
	Dfst_nsnps2		<- vector()
	# f statistics:
	ABBAnumerator	<- vector()
	BABAnumerator	<- vector()
	ABBAdenominator	<- vector()
	BABAdenominator	<- vector() 
	fnum			<- vector()
	fden			<- vector()
	fvec			<- vector()
	mysambar$flist	<<- list()
	for(i in c(1:ntriplets))
		{
		if(i%%5000==0){cat(paste(i," out of ",ntriplets,".",sep=""),sep="\n")}
		pop1		<- as.vector(mytriplets[i,1])
		pop2		<- as.vector(mytriplets[i,2])
		pop3		<- as.vector(mytriplets[i,3])
		if(paste("maf",pop1,sep="_")%in%colnames(snps))
			{
			p1	<- as.vector(snps[myfilter,paste("maf",pop1,sep="_")])
			}else{
			return(cat(paste("ERROR: No maf vector present for ",pop1,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop2,sep="_")%in%colnames(snps))
			{
			p2	<- as.vector(snps[myfilter,paste("maf",pop2,sep="_")])
			}else{
			return(cat(paste("ERROR: No maf vector present for ",pop2,".",sep=""),sep="\n"))
			}
		if(paste("maf",pop3,sep="_")%in%colnames(snps))
			{
			p3	<- as.vector(snps[myfilter,paste("maf",pop3,sep="_")])
			}else{
			return(cat(paste("ERROR: No maf vector present for ",pop3,".",sep=""),sep="\n"))
			}
		#
		# default assumption is that the minor allele is the derived allele, and the major allele the ancestral allele
		# how much do the results change if we made the opposite assumption?
		# answer: 
		# column 1 and 8 swap
		# columns 2-4 move to 5-7, and 5-7 to 2-4 
		# minor allele is more likely to be derived allele than a major allele: the lower the allele frequency, the higher the probability it mutated recently 
		if(ancestral=="minor")
			{
			p1		<- 1-p1
			p2		<- 1-p2
			p3		<- 1-p3
			}
		# probability of drawing ABBA and BABA, with A denoting the ancestral allele with frequency '1-p':
		ABBA[i] 	<- sum((1-p1)*p2*p3,na.rm=TRUE)	
		BABA[i]		<- sum(p1*(1-p2)*p3,na.rm=TRUE)	
		# probability of combination reflecting true topology:
		BBAA[i] 	<- sum(p1*p2*(1-p3),na.rm=TRUE)	
		# probability of other combinations:
		AAAA[i]		<- sum((1-p1)*(1-p2)*(1-p3),na.rm=TRUE)
		BAAA[i]		<- sum(p1*(1-p2)*(1-p3),na.rm=TRUE)
		ABAA[i]		<- sum((1-p1)*p2*(1-p3),na.rm=TRUE)
		AABA[i]		<- sum((1-p1)*(1-p2)*p3,na.rm=TRUE)
		BBBA[i]		<- sum(p1*p2*p3,na.rm=TRUE)					 
		#
		D_nsnps[i]	<- length(which(!is.na(p1*p2*(1-p3))))
		dvec[i]		<- (ABBA[i]-BABA[i])/(ABBA[i]+BABA[i])
		# store in matrix:
		if(storematrix)
			{
			mysambar$BBAAmat[,i]	<<- p1*p2*(1-p3)
			mysambar$ABBAmat[,i] 	<<- (1-p1)*p2*p3
			mysambar$BABAmat[,i]	<<- p1*(1-p2)*p3
			my_d					<- (mysambar$ABBAmat[,i]-mysambar$BABAmat[,i])/(mysambar$ABBAmat[,i]+mysambar$BABAmat[,i])
			mysambar$dmat[,i]		<<- my_d
			D_nsnps_Dpersnp[i]		<- length(which(is.finite(my_d)))
			}
		#
		# 12-04-2020: alternative way: Dfst using Wright Fst:
		mypops		<- c(pop1,pop3)
		mypops		<- mypops[order(mypops)]
		pop_1		<- mypops[1]
		pop_3		<- mypops[2]
		if(!(paste("Wrightfst",pop_1,pop_3,sep="_")%in%colnames(snps)))
			{
			cat("Fst estimate absent from snps dataframe. Running runWrightFst() function.",sep="\n")
			runWrightFst()
			if(!(paste("Wrightfst",pop_1,pop_3,sep="_")%in%colnames(snps)))
				{
				return(cat(paste("ERROR: No fst estimates present for population pair ",pop_1," and ",pop_3,", even after running the runWrightFst() function. Contact the developer of SambaR.",sep=""),sep="\n"))
				}
			}
		fst1	<- as.vector(snps[myfilter,paste("Wrightfst",pop_1,pop_3,sep="_")])
		#
		mypops		<- c(pop2,pop3)
		mypops		<- mypops[order(mypops)]
		pop_2		<- mypops[1]
		pop_3		<- mypops[2]
		if(!(paste("Wrightfst",pop_2,pop_3,sep="_")%in%colnames(snps)))
			{
			cat("Fst estimate absent from snps dataframe. Running runWrightFst() function.",sep="\n")
			runWrightFst()
			if(!(paste("Wrightfst",pop_2,pop_3,sep="_")%in%colnames(snps)))
				{
				return(cat(paste("ERROR: No fst estimates present for population pair ",pop_2," and ",pop_3,", even after running the runWrightFst() function. Contact the developer of SambaR.",sep=""),sep="\n"))
				}
			}
		fst2		<- as.vector(snps[myfilter,paste("Wrightfst",pop_2,pop_3,sep="_")])
		#
		meanfst1	<- mean(fst1[is.finite(fst1)],na.rm=TRUE)
		meanfst2	<- mean(fst2[is.finite(fst2)],na.rm=TRUE)
		Dfst_nsnps1[i]<- length(which(is.finite(fst1)))
		Dfst_nsnps2[i]<- length(which(is.finite(fst2)))
		Dfstvec[i]	<- (meanfst1-meanfst2)/(meanfst1+meanfst2)
		#
		# 19-04-2020: f statistics:
		# first we need to split species/population 3 in half and generate minor allele frequencies for each artificial subpop:
		myinds		<- inds$nr[inds$filter&inds$pop==pop_3]
		nind_pop3	<- length(myinds)
		nsub1		<- round(nind_pop3/2)
		inds_3a		<- myinds[1:nsub1]
		inds_3b		<- myinds[(nsub1+1):(nind_pop3)]
		p3a 		<- glMean(mygenlight[inds_3a,myfilter],alleleAsUnit=TRUE)
		p3b 		<- glMean(mygenlight[inds_3b,myfilter],alleleAsUnit=TRUE)
		p3a[!is.finite(p3a)]	<- NA
		p3b[!is.finite(p3b)]	<- NA
		mysambar$flist[[i]]		<<- cbind(p3a,p3b)
		# now we are ready to calculate f:
		ABBAnumerator[i] 	<- sum((1-p1)*p2*p3a,na.rm=TRUE)
		BABAnumerator[i] 	<- sum(p1*(1-p2)*p3a,na.rm=TRUE)
		ABBAdenominator[i] 	<- sum((1-p1)*p3b*p3a,na.rm=TRUE)
		BABAdenominator[i]	<- sum(p1*(1-p3b)*p3a,na.rm=TRUE)
		# f (admixture proportion) only sensible to calculate for ABBA excess, not for BABA excess:
		fnum[i]				<- ABBAnumerator[i]-BABAnumerator[i]
		fden[i]				<- ABBAdenominator[i]-BABAdenominator[i]
		fvec[i]				<- ifelse(dvec[i]>0,(ABBAnumerator[i]-BABAnumerator[i])/(ABBAdenominator[i]-BABAdenominator[i]),NA)
		}
	mytriplets$AAAA		<- AAAA/nsnps
	#
	mytriplets$BBAA		<- BBAA/nsnps
	mytriplets$ABBA		<- ABBA/nsnps
	mytriplets$BABA		<- BABA/nsnps
	#
	mytriplets$AABA		<- AABA/nsnps
	mytriplets$BAAA		<- BAAA/nsnps
	mytriplets$ABAA		<- ABAA/nsnps
	#
	mytriplets$BBBA		<- BBBA/nsnps
	mytriplets$all		<- as.vector(rowSums(mytriplets[,4:11]))
	#
	mytriplets$BBAAnorm	<- round(mytriplets$BBAA/(mytriplets$BBAA+mytriplets$ABBA+mytriplets$BABA),3)
	mytriplets$ABBAnorm	<- round(mytriplets$ABBA/(mytriplets$BBAA+mytriplets$ABBA+mytriplets$BABA),3)
	mytriplets$BABAnorm	<- round(mytriplets$BABA/(mytriplets$BBAA+mytriplets$ABBA+mytriplets$BABA),3)
	#
	# probability of observing deviation from equal ratio between ABBA and ABBA:
	nlow				<- ifelse(mytriplets$ABBAnorm<mytriplets$BABAnorm,round(mytriplets$ABBAnorm*nsnps),round(mytriplets$BABAnorm*nsnps))
	nboth				<- round((mytriplets$ABBAnorm+mytriplets$BABAnorm)*nsnps)
	mytriplets$rbinomp	<- round(pbinom(nlow,nboth,0.5,lower.tail=TRUE),5)
	#
	mytriplets$D		<- (mytriplets$ABBA-mytriplets$BABA)/(mytriplets$ABBA+mytriplets$BABA)
	mytriplets$D_nsnps	<- D_nsnps
	mytriplets$ABBAnum	<- ABBAnumerator/nsnps
	mytriplets$BABAnum	<- BABAnumerator/nsnps
	mytriplets$ABBAden	<- ABBAdenominator/nsnps
	mytriplets$BABAden	<- BABAdenominator/nsnps
	mytriplets$fnum		<- fnum
	mytriplets$fden		<- fden
	mytriplets$f		<- fvec
	dscores				<- mytriplets
	if(storematrix)
		{
		# note: calculation of genome wide D is based on average ABBA and average BABA. 
		# ABBA and BABA are based on multiplication of minor allele frequencies, which are almost always present, unless a SNP has no data in a particular population
		# So basically almost all data is being considered
		dscores$D_nsnps_Dpersnp	<- D_nsnps_Dpersnp
		}
	dscores$Dfst		<- Dfstvec
	dscores$Dfst_nsnps1	<- Dfst_nsnps1
	dscores$Dfst_nsnps2	<- Dfst_nsnps2
	dscores$mylabels	<- paste("(((",dscores$p1,", ",dscores$p2,"), ",dscores$p3,"), out)",sep="")
	dscores$mylabels2	<- paste("(((",dscores$p1,", ",dscores$p2,"), ",dscores$p3,"), O)",sep="")
	#
	# dividing genome in blocks needed for jackknife procedure:
	cat(paste("Dividing genome in blocks of fixed length of ",jkblocksize," bp...",sep=""),sep="\n")
	mychroms		<- snps$chr[myfilter]
	mypos			<- snps$pos[myfilter]
	block_indices 	<- get_block_indices(block_size=jkblocksize,positions=mypos,chromosomes=mychroms)
	mysambar$block_indices	<<- block_indices
	n_blocks 		<- length(block_indices)
	if(n_blocks<50)
		{
		cat(paste("WARNING: Genome divided in only", n_blocks, "blocks. This number might not allow for meaningful jackknife resampling."),sep="\n")
		}else{
		cat(paste("Genome divided into", n_blocks, "blocks."),sep="\n")
		}
	if(dojackknife&n_blocks>=minblocks)
		{
		if(!silent){cat("Starting jackknife procedure...",sep="\n")}
		D_sd			<- vector()
		D_err			<- vector()
		D_Z				<- vector()
		blockDmat		<- matrix(NA,ncol=ntriplets,nrow=n_blocks)
		blockDfstmat	<- matrix(NA,ncol=ntriplets,nrow=n_blocks)
		for(k in 1:nrow(mytriplets))
			{
			if(!silent){cat(paste(k," out of ",nrow(mytriplets),sep=""),sep="\n")}
			pop1		<- as.vector(mytriplets[k,1])
			pop2		<- as.vector(mytriplets[k,2])
			pop3		<- as.vector(mytriplets[k,3])
			p1			<- as.vector(snps[myfilter,paste("maf",pop1,sep="_")])
			p2			<- as.vector(snps[myfilter,paste("maf",pop2,sep="_")])
			p3			<- as.vector(snps[myfilter,paste("maf",pop3,sep="_")])
			#
			mypops		<- c(pop1,pop3)
			mypops		<- mypops[order(mypops)]
			pop_1		<- mypops[1]
			pop_3		<- mypops[2]
			fst1		<- as.vector(snps[myfilter,paste("Wrightfst",pop_1,pop_3,sep="_")])
			mypops		<- c(pop2,pop3)
			mypops		<- mypops[order(mypops)]
			pop_2		<- mypops[1]
			pop_3		<- mypops[2]
			fst2		<- as.vector(snps[myfilter,paste("Wrightfst",pop_2,pop_3,sep="_")])
			#
			for(blocknr in c(1:n_blocks))
				{
				myselection	<- block_indices[[blocknr]]
				blockp1		<- p1[myselection]
				blockp2		<- p2[myselection]
				blockp3		<- p3[myselection]
				blockBBAA 	<- sum(blockp1*blockp2*(1-blockp3))
				blockABBA 	<- sum((1-blockp1)*blockp2*blockp3)
				blockBABA	<- sum(blockp1*(1-blockp2)*blockp3)	
				blockDmat[blocknr,k]	<- (blockABBA-blockBABA)/(blockABBA+blockBABA)
				#
				# 13-04-2020:
				blockfst1	<- fst1[myselection]
				blockfst2	<- fst2[myselection]
				meanfst1	<- mean(blockfst1[is.finite(blockfst1)],na.rm=TRUE)
				meanfst2	<- mean(blockfst2[is.finite(blockfst2)],na.rm=TRUE)
				blockDfstmat[blocknr,k]	<- (meanfst1-meanfst2)/(meanfst1+meanfst2)
				}
			D_sd[k] 		<- get_jackknife_sd(block_indices=block_indices,FUN=D.stat,p1,p2,p3)
			# cat(paste("D standard deviation = ", round(D_sd,4)),sep="\n")
			# From this unbiased estimate of the standard deviation of D, we can compute the standard error and the Z score to test of whether D deviates significantly from zero.
			D_err[k] 		<- D_sd[k]/sqrt(n_blocks)
			D_Z[k] 			<- abs(dscores$D[k]/D_err[k])
			}
		blockdf				<- as.data.frame(blockDmat)
		colnames(blockdf)	<- paste("triplet",c(1:ntriplets),sep="")
		blockdf$nsnps		<- sapply(block_indices,FUN=length)
		# mysambar$blockdf	<<- blockdf
		#
		blockfstdf			<- as.data.frame(blockDfstmat)
		colnames(blockfstdf)<- paste("triplet",c(1:ntriplets),sep="")
		blockfstdf$nsnps	<- sapply(block_indices,FUN=length)
		# mysambar$blockfstdf <<- blockfstdf
		#
		dscores$D_sd	<- D_sd
		dscores$nblocks	<- n_blocks
		dscores$D_err	<- D_err
		dscores$D_Z		<- D_Z
		mypvalues		<- 2*pnorm(-abs(dscores$D_Z))	# this assumes the test is 2 sided (which I think it is). If not, we should not multiply by 2.
		dscores$pvalue	<- formatC(mypvalues,format="e") 
		dscores$sign2	<- ifelse(mypvalues>0.05,"NS",ifelse(mypvalues<=0.001,"**","*"))
		dscores$sign	<- ifelse(D_Z<3,"NS",ifelse(D_Z>6,"**","*"))
		dscores$excess	<- ifelse(mypvalues>0.05,"no",ifelse(mytriplets$D>0,"ABBA","BABA"))
		#
		Dtable			<- dscores[,c("p1","p2","p3","BBAA","ABBA","BABA","D","D_nsnps","D_sd","nblocks","D_err","D_Z","pvalue","sign","excess")]
		}else{
		cat(paste("Flag dojackknife has been set to FALSE or number of genome blocks is below ",minblocks," (value defined to minblocks flag). Omitting jackknife calculations and hence no identification if obtained D-values are significant.",sep=""),sep="\n")
		Dtable			<- dscores[,c("p1","p2","p3","BBAA","ABBA","BABA","D","D_nsnps")]
		}
	mysambar$dscores	<<- dscores
	write.table(Dtable,"Dstatistics.txt",col.names=TRUE,row.names=FALSE,quote=FALSE,sep="\t")	
	cat("A table with D-statistics (called 'Dstatistics.txt') has been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}

chromD<-function(n_chroms=NULL,popnames=mysambar$populations,snpfilter=snps$filter,silent=FALSE)
	{
	npops			<- length(popnames)
	if(npops<3)
		{
		return(cat("At present less than 3 population defined. ABBA-BABA tests require at least 3 populations (when not including the outgroup). Execution halted.",sep="\n"))
		}
	if(is.null(n_chroms))
		{
		return(cat("ERROR: provide a value to n_chroms flag.",sep="\n"))
		}
	if(is.null(snpfilter))
		{
		myfilter		<- rep(TRUE,nrow(snps))
		}else{
		myfilter		<- snpfilter
		}
	if(!silent){cat("Dividing genome into chromosomes...",sep="\n")}
	snpstemp			<- snps[snps$chr2<=n_chroms&myfilter,]
	chrom_names 		<- as.vector(unique(snpstemp$chr))
	chrom_indices 		<- lapply(chrom_names, function(chrom) which(snpstemp$chr == chrom))
	names(chrom_indices)<- chrom_names
	#
	# find all possible quartets:
	mytriplets				<- as.data.frame(permutations(n=npops,r=3,v=popnames,repeats.allowed=F))
	colnames(mytriplets)	<- c("p1","p2","p3")
	#
	# for our analysis no difference between (((A,B),C),D) and (((B,A),C),D). Delete (((B,A),C),D):
	mytriplets$myorder		<- as.character(mytriplets$p2)>as.character(mytriplets$p1)
	mytriplets$ingroup		<- ifelse(mytriplets$myorder,paste(mytriplets$p1,mytriplets$p2,mytriplets$p3,sep="_"),paste(mytriplets$p2,mytriplets$p1,mytriplets$p3,sep="_"))
	mytriplets				<- mytriplets[(!duplicated(mytriplets$ingroup)),c(1:3)]
	# calculate D per chromosome:
	if(!silent){cat("Calculating chromosome specific ABBA-BABA statistics for all population triplets...",sep="\n")}
	Dbychrom		<<- matrix(NA,ncol=nrow(mytriplets),nrow=n_chroms)
	for(k in 1:nrow(mytriplets))
		{
		if(!silent){cat(k,sep="\n")}
		pop1		<- mytriplets[k,1]
		pop2		<- mytriplets[k,2]
		pop3		<- mytriplets[k,3]
		P1			<- paste("maf",pop1,sep="_")
		P2			<- paste("maf",pop2,sep="_")
		P3			<- paste("maf",pop3,sep="_")
		Dbychrom[,k] <<- sapply(chrom_names,function(chrom) D.stat(snpstemp[chrom_indices[[chrom]],P1],snpstemp[chrom_indices[[chrom]],P2],snpstemp[chrom_indices[[chrom]], P3]))
		}
	if(!silent){cat("Results have been stored in a matrix object called 'Dbychrom'.",sep="\n")}
	#
	# dividing genome in blocks needed for jackknife procedure:
	if(!silent){cat("Dividing genome in blocks of fixed length...",sep="\n")}
	block_indices_chrom 	<- lapply(chrom_names,function(chrom) get_block_indices(block_size=1e6,positions=snpstemp$pos[snpstemp$chr==chrom]))
	n_blocks 				<- length(block_indices_chrom)
	if(!silent){cat(paste("Chromosomes divided into", n_blocks, "blocks."),sep="\n")}
	chrom_indices			<- chrom_indices
	#
	if(!silent){cat("Starting jackknife procedure...",sep="\n")}
	Dsd_bychrom		<- matrix(NA,ncol=nrow(mytriplets),nrow=n_chroms)
	for(k in 1:nrow(mytriplets))
		{
		if(!silent){cat(k,sep="\n")}
		for (m in c(1:n_chroms))
			{
			#cat(paste("chromosome ",m,sep=""),sep="\n")
			block_indices<- block_indices_chrom[[m]]
			pop1		<- mytriplets[k,1]
			pop2		<- mytriplets[k,2]
			pop3		<- mytriplets[k,3]
			p1			<- as.vector(snpstemp[,paste("maf",pop1,sep="_")])
			p2			<- as.vector(snpstemp[,paste("maf",pop2,sep="_")])
			p3			<- as.vector(snpstemp[,paste("maf",pop3,sep="_")])
			Dsd_bychrom[m,k] 	<- get_jackknife_sd(block_indices=block_indices,FUN=D.stat,p1,p2,p3)
			}
		}
	nblocks_chrom	<- sapply(block_indices_chrom,FUN=length)
	D_err_chrom 	<- Dsd_bychrom/sqrt(nblocks_chrom)
	D_Z_chrom 		<- Dbychrom/D_err_chrom
	D_pvalue_chrom	<- 2*pnorm(-abs(D_Z_chrom))
	D_pvalue2_chrom	<- formatC(D_pvalue_chrom,format="e") 
	D_sign			<- ifelse(D_pvalue_chrom>0.05,"NS",ifelse(D_pvalue_chrom<=0.001,"**","*"))
	Dchromlist		<<- list()
	Dchromlist[[1]]	<<- Dbychrom
	Dchromlist[[2]]	<<- Dsd_bychrom
	Dchromlist[[3]]	<<- nblocks_chrom
	Dchromlist[[4]]	<<- D_err_chrom
	Dchromlist[[5]]	<<- D_Z_chrom
	Dchromlist[[6]]	<<- D_pvalue_chrom
	Dchromlist[[7]]	<<- D_pvalue2_chrom
	Dchromlist[[8]]	<<- D_sign
	names(Dchromlist)<<-c("D","D_sd","nblocks","D_err","D_Z","pvalue","pvalue2","sign") 
	if(!silent){cat("Results have been stored in a list object called 'Dchromlist'.",sep="\n")}
	}

barplotD<-function(mydf=mysambar$dscores,export=NULL,silent=TRUE,plottitle=NULL,allcombi=FALSE,addnsnps=TRUE)
	{
	if(is.null(mydf))
		{
		return(cat("ERROR: provide a dataframe to the mydf flag.",sep="\n")) 
		}
	if(!silent){cat("Generating barplots...",sep="\n")}
	if(!is.null(export))
		{
		mywidth		<- 9.5
		myheight	<- 7
		plotlabel	<- ifelse(allcombi,"allcombi","3combi")
		plotname	<- ifelse(is.null(plottitle),paste("Dbarplot",plotlabel,sep="_"),paste("Dbarplot",plotlabel,plottitle,sep="_"))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		}
	layout(matrix(c(1:12),nrow=3,ncol=4,byrow=TRUE))
	par(mar=c(0.5,3.5,2,0.5),oma=c(6,1.5,1.5,2))
	ntriplets	<- nrow(mydf)
	totalsnps	<- mydf$D_nsnps
	#
	for(k in c(1:ntriplets))
		{
		if(!silent){cat(k,sep="\n")}
		if(allcombi)
			{
			myscores	<- as.vector(unlist(mydf[k,4:11]))
			nsnps		<- round(as.vector(unlist(mydf[k,4:11]*mydf$D_nsnps[k])))
			mymax		<- max(myscores)
			mymax		<- ifelse(mymax>0.77,1.1,0.77)
			if(k>=9)
				{
				myxlabel	<- c("AAAA","BBAA","ABBA","BABA","AABA","BAAA","ABAA","BBBA")
				}else{
				myxlabel	<- rep("",8)
				}
			xx<-barplot(myscores,las=2,names.arg=myxlabel,ylim=c(0,mymax),border=NA,cex.lab=1.25,col=c("grey70","lightsteelblue4","lightsteelblue4","lightsteelblue4","grey70","grey70","grey70","grey70"))
			mtext(mydf$mylabels2[k],side=3,line=0,cex=0.75)
			}else{
			myscores	<- as.vector(unlist(mydf[k,13:15]))
			myscores2	<- as.vector(unlist(mydf[k,5:7]))
			nsnps		<- round(myscores2*mydf$D_nsnps[k])
			mymax		<- max(myscores)
			mymax		<- ifelse(mymax>0.55,1.1,0.55)
			if(k>=9)
				{
				myxlabel	<- c("BBAA","ABBA","BABA")
				}else{
				myxlabel	<- rep("",3)
				}
			xx<-barplot(myscores,las=1,names.arg=myxlabel,ylim=c(0,mymax),border=NA,cex.lab=1.25,col=c("lightsteelblue4","lightsteelblue4","lightsteelblue4"))
			mtext(mydf$mylabels2[k],side=3,line=0.25,cex=0.75)
			mtext(paste("D = ",round(mydf$D[k],2),sep=""),side=3,line=-0.75,cex=0.75)
			}
		if(addnsnps)
			{
			text(x=xx,y=myscores-0.02,nsnps,cex=1,pos=3)
			}	
		}
	if(!is.null(plottitle))
		{
		mtext(side=3,plottitle,line=-0.5,cex=1.5,outer=TRUE)
		}
	myylab		<- ifelse(allcombi,"Proportion of sites","Relative proportion of sites")	
	mtext(side=2,myylab,line=-0.75,cex=1.5,outer=TRUE)
	xlabdistance<- ifelse(allcombi,4,3)
	mtext(side=1,"Presence of ancestral (A) and derived (B) allele",line=xlabdistance,cex=1.5,outer=TRUE)
	if(!is.null(export)){dev.off()}
	}

plotf3<-function(mydf=mysambar$f3df,plotname="f3stats",mycol="grey50",export=NULL,shortpop=FALSE,tripletlabels=NULL,silent=TRUE,mycex=3,linepos=NULL,add_Z=TRUE,ymax=0.012)
	{
	ndata	<- nrow(mydf)
	if(length(mycex)==1)
		{
		mycex	<- rep(mycex,ndata)
		}
	mycols		<- ifelse(mydf$est>0,"black","orange")
	ypos		<- seq(0,1,1/(ndata))
	if(!is.null(linepos))
		{
		linepos	<- 0.5*(ypos[linepos]+ypos[linepos+1])
		}
	mypch			<- rep(16,nrow(mydf))
	if(shortpop)
		{
		myp1		<- ifelse(nchar(as.vector(mydf$pop1))>2,substr(as.vector(mydf$pop1),1,2),as.vector(mydf$pop1))
		myp2		<- ifelse(nchar(as.vector(mydf$pop2))>2,substr(as.vector(mydf$pop2),1,2),as.vector(mydf$pop2))
		myp3		<- ifelse(nchar(as.vector(mydf$pop3))>2,substr(as.vector(mydf$pop3),1,2),as.vector(mydf$pop3))
		mylabels	<- paste("(((",myp1,",",myp2,"),",myp3,"),O)",sep="")
		}else{
		mylabels	<- mydf$mylabels
		}
	#
	if(!is.null(export))
		{
		myheight		<- ndata*0.5+2.5
		myheight2		<- ndata*50+250
		mywidth			<- ifelse(shortpop,10,15)
		mywidth2		<- ifelse(shortpop,1000,1500)
		plotname		<- ifelse(shortpop,paste(plotname,"shortpop",sep="_"),plotname)
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf")
			{
			return(cat("File type win.metafile for LD-plot not accepted.",sep="\n"))
			#if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)} # this file is too big
			}
		}
	uppermargin	<- 2
	if(shortpop)
		{
		par(mar=c(5,14.5,uppermargin,4),cex.axis=2,cex.lab=3,cex.main=3)
		}else{
		par(mar=c(5,37,uppermargin,5),cex.axis=2,cex.lab=3,cex.main=3)
		}
	mymax	<- max(abs(mydf$est))
	mymax	<- ifelse(mymax<ymax,ymax,mymax)
	plot(c(-mymax,mymax),c(0,1),col="white",xlab="",ylab="",yaxt='n')
	axis(2,at=ypos[-(ndata+1)],mylabels,las=2,cex=2)
	text(y=1,x=-0.5*mymax,"admixture",cex=2.5)
	text(y=1,x=0.5*mymax,"NO admixture",cex=2.5)
	mtext(side=1,line=3.5,"f3 score",cex=3)
	abline(v=0,col=mycol,lwd=2)
	for(k in c(1:ndata))
		{
		if(!silent){cat(k,sep="\n")}
		if(!silent){cat(mydf$est[k],sep="\n")}
		if(!silent){cat(ypos[k],sep="\n")}
		if(!silent){cat(mypch[k],sep="\n")}
		points(x=mydf$est[k],y=ypos[k],pch=mypch[k],col=mycols[k],cex=mycex[k])
		#segments(x0=x_low[k],y0=ypos[k],x1=x_up[k],y1=ypos[k],col=mycol,lwd=3.5)
		}
	if(!is.null(linepos))
		{
		abline(h=linepos,lty=2)
		}
	if(!is.null(tripletlabels))
		{
		cat("Adding tripletlabels...",sep="\n")
		for(k in c(1:ndata))
			{
			text(y=ypos[k],x=-mymax,tripletlabels[k],cex=1.5,pos=4)
			}
		}
	if(add_Z)
		{
		axis(4,at=ypos[-(ndata+1)],round(mydf$z,1),las=2,cex.axis=1.5,labels=FALSE)
		myzscores	<- abs(round(mydf$z,1))
		mycols	<- ifelse(myzscores<3,"grey60","black")
		mtext(myzscores,at=ypos[-(ndata+1)],side=4,line=1,col=mycols,las=1,cex=1.75)
		}
	if(!is.null(export)){dev.off()}
	}

plotD<-function(mydf=mysambar$dscores,plotname="Dstats",mycol="grey50",export=NULL,n_chroms=NULL,plotDfst=FALSE,shortpop=FALSE,methodname="SambaR",doboxplot=FALSE,tripletlabels=NULL,Dmax=1,silent=TRUE,add_f=FALSE,add_Z=TRUE,mycex=3,linepos=NULL)
	{
	# method name should be 'SambaR' or 'HybridCheck'
	if(doboxplot)
		{
		ndata	<- length(as.vector(unique(mydf$mylabels)))
		}else{
		ndata	<- nrow(mydf)
		}
	if(length(mycex)==1)
		{
		mycex	<- rep(mycex,ndata)
		}
	ypos		<- seq(0,1,1/(ndata))
	if(!is.null(linepos))
		{
		linepos	<- 0.5*(ypos[linepos]+ypos[linepos+1])
		}
	#yposlabel	<- 1+1/(ndata)
	yposlabel	<- 1
	x_low		<- 0-mydf$D_err
	x_up		<- 0+mydf$D_err
	if(plotDfst)
		{
		mypch	<- rep(16,nrow(mydf))
		}else{
		if("sign"%in%colnames(mydf))
			{
			mysign	<- mydf$sign
			if(all(!is.na(mydf$sign)))
				{
				mypch	<- ifelse(mysign!="NS",16,21)
				}else{
				cat("WARNING: NA-values present in 'sign'-column of D-scores dataframe. Using the x-symbol to represent D-scores with unknown significance scores.",sep="\n")
				mypch	<- ifelse(is.na(mysign),4,ifelse(mysign!="NS",16,21))
				}
			}else{
			cat("WARNING: Input dataframe does not contain a column named 'sign' for significance. Assigning all data points same pch symbol.",sep="\n")
			mypch	<- rep(16,nrow(mydf))
			}
		}
	mypch	<<- mypch
	if(shortpop)
		{
		myp1		<- ifelse(nchar(as.vector(mydf$p1))>2,substr(as.vector(mydf$p1),1,2),as.vector(mydf$p1))
		myp2		<- ifelse(nchar(as.vector(mydf$p2))>2,substr(as.vector(mydf$p2),1,2),as.vector(mydf$p2))
		myp3		<- ifelse(nchar(as.vector(mydf$p3))>2,substr(as.vector(mydf$p3),1,2),as.vector(mydf$p3))
		mylabels	<- paste("(((",myp1,",",myp2,"),",myp3,"),O)",sep="")
		}else{
		mylabels	<- mydf$mylabels
		}
	#
	if(!is.null(export))
		{
		myheight	<- ndata*0.5+2.5
		myheight2	<- ndata*50+250
		mywidth		<- ifelse(shortpop,10,15)
		mywidth2	<- ifelse(shortpop,1000,1500)
		if(plotDfst)
			{
			plotname	<- "Dfst"
			}
		if(doboxplot)
			{
			plotname	<- paste(plotname,"boxplot",sep="_")
			}
		if(!is.null(n_chroms))
			{
			plotname	<- paste(plotname,"chrom",sep="_")
			}
		if(shortpop)
			{
			plotname	<- paste(plotname,"shortpop",sep="_")
			}
		Drangelabel		<- paste("max",Dmax,sep="")
		flabel			<- ifelse(add_f,"with_prop","no_prop")
		zlabel			<- ifelse(add_Z,"with_Z","no_Zscore")
		if(export=="eps"){postscript(paste(plotname,methodname,Drangelabel,flabel,zlabel,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,methodname,Drangelabel,flabel,zlabel,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,methodname,Drangelabel,flabel,zlabel,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf")
			{
			return(cat("File type win.metafile for LD-plot not accepted.",sep="\n"))
			#if(export=="wmf"){win.metafile(paste(plotname,methodname,Drangelabel,flabel,zlabel,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)} # this file is too big
			}
		}
	uppermargin	<- ifelse(add_f,4.5,2)
	if(shortpop)
		{
		par(mar=c(5,14.5,uppermargin,4),cex.axis=2,cex.lab=3,cex.main=3)
		}else{
		par(mar=c(5,37,uppermargin,5),cex.axis=2,cex.lab=3,cex.main=3)
		}
	if(doboxplot)
		{
		boxplot(mydf$D~mydf$mylabels,las=1,horizontal=TRUE,ylim=c(-Dmax,Dmax),xlab="",ylab="",col="grey80",border="grey60",outline=FALSE)
		stripchart(D~mylabels,data=mydf,vertical=FALSE,col="black",method="jitter",pch=16,cex=1.5,bg="bisque",add=TRUE,ylab="")
		abline(v=0)
		mtext(side=1,line=3.5,"D score",cex=3)
		#text(y=ndata+0.75,x=-0.5,"BABA excess",cex=2.5)
		#text(y=ndata+0.75,x=0.5,"ABBA excess",cex=2.5)
		text(y=ndata,x=-0.5*Dmax,"BABA excess",cex=2.5,pos=3)
		text(y=ndata,x=0.5*Dmax,"ABBA excess",cex=2.5,pos=3)
		}else{
		plot(c(-Dmax,Dmax),c(0,1),col="white",xlab="",ylab="",yaxt='n')
		axis(2,at=ypos[-(ndata+1)],mylabels,las=2,cex=2)
		text(y=yposlabel,x=-0.5*Dmax,"BABA excess",cex=2.5)
		text(y=yposlabel,x=0.5*Dmax,"ABBA excess",cex=2.5)
		if(plotDfst)
			{
			mtext(side=1,line=3.5,"Dfst score",cex=3)
			}else{
			mtext(side=1,line=3.5,"D score",cex=3)
			}
		abline(v=0,col=mycol,lwd=2)
		for(k in c(1:ndata))
			{
			if(!silent){cat(k,sep="\n")}
			if(!is.null(n_chroms))
				{
				mypch2	<- ifelse(Dchromlist$sign[,k]!="NS",16,21)
				points(x=Dbychrom[,k],y=rep(ypos[k],n_chroms),pch=mypch2,col="black",cex=3)
				}else{
				if(plotDfst)
					{
					points(x=mydf$Dfst[k],y=ypos[k],pch=mypch[k],col="black",cex=3)
					}else{
					if(!silent){cat(mydf$D[k],sep="\n")}
					if(!silent){cat(ypos[k],sep="\n")}
					if(!silent){cat(mypch[k],sep="\n")}
					points(x=mydf$D[k],y=ypos[k],pch=mypch[k],col="black",cex=mycex[k])
					segments(x0=x_low[k],y0=ypos[k],x1=x_up[k],y1=ypos[k],col=mycol,lwd=3.5)
					}
				}
			}
		if(!is.null(linepos))
			{
			abline(h=linepos,lty=2)
			}
		if(!is.null(tripletlabels))
			{
			cat("Adding tripletlabels...",sep="\n")
			for(k in c(1:ndata))
				{
				text(y=ypos[k],x=-Dmax,tripletlabels[k],cex=1.5,pos=4)
				}
			}
		if(add_Z)
			{
			if("D_Z"%in%colnames(mydf))
				{
				axis(4,at=ypos[-(ndata+1)],round(mydf$D_Z,1),las=2,cex.axis=1.5,labels=FALSE)
				myzscores	<- abs(round(mydf$D_Z,1))
				mycols		<- ifelse(myzscores<3,"grey60","black")
				mtext(round(mydf$D_Z,1),at=ypos[-(ndata+1)],side=4,line=1,col=mycols,las=1,cex=1.75)
				}else{
				cat("WARNING: column 'D_Z' is missing. Not adding z-scores to plot.",sep="\n")
				}
			}
		if(add_f)
			{
			if("f"%in%colnames(mydf))
				{
				par(new=TRUE,mgp=c(3,0.25,0))
				plot(c(-1,1),c(0,1),col="white",xlab="",ylab="",yaxt='n',xaxt='n')
				for(k in c(1:ndata))
					{
					if(!is.na(mydf$sign[k])&mydf$sign[k]!="NS")
						{
						points(x=mydf$f[k],y=ypos[k],pch=18,col="orange",cex=2.5)
						}
					}
				axis(side=3,col.axis="orange",col="orange")
				mtext(side=3,line=2,"f score",cex=3,col="orange")
				}else{
				cat("WARNING: column 'f' is missing. Not adding f-scores to plot.",sep="\n")
				}
			}
		}
	if(!is.null(export)){dev.off()}
	}

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
D.stat<-function(p1,p2,p3) 
	{
	ABBA <- (1-p1)*p2*p3
    BABA <- p1*(1-p2)*p3
	# 05_11_2021: get rid of NA-values:
	# return((sum(ABBA)-sum(BABA))/(sum(ABBA)+sum(BABA)))
    # option 1:
	# return((sum(ABBA,na.rm=TRUE)-sum(BABA,na.rm=TRUE))/(sum(ABBA,na.rm=TRUE)+sum(BABA,na.rm=TRUE)))
	# option 2:
	mybool		<- (!is.na(ABBA))&(!is.na(BABA))
	nretained	<- length(mybool[mybool])
	ntotal		<- length(mybool)
	#cat(paste("Number of retained blocks (no missing values): ",nretained," out of ",ntotal,".",sep=""),sep="\n")
	return((sum(ABBA[mybool])-sum(BABA[mybool]))/(sum(ABBA[mybool])+sum(BABA[mybool])))
	}

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data'):
# The D statistic does not quantify the proportion of the genome that has been shared. 
# A related method has been developed to estimate f, the 'admixture proportion'.
# The idea behind this approach is that we compare the observed excess of ABBA over BABA sites, to that which would be expected under complete admixture. 
# To approximate the expectation under complete admixture we re-count ABBA and BABA but substituting a second population of the P3 species in the place of P2. 
# If you lack a second population for p3, you can simply split your P3 samples into two. 
f.stat <- function(p1, p2, p3a, p3b) 
	{
    # same as D.stat, except:
	ABBA_numerator <- (1-p1)*p2*p3a
    BABA_numerator <- p1*(1-p2)*p3a
	#
    ABBA_denominator <- (1-p1)*p3b*p3a
    BABA_denominator <- p1*(1-p3b)*p3a
	#
    return(sum(ABBA_numerator)-sum(BABA_numerator))/(sum(ABBA_denominator)-sum(BABA_denominator))
    }

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
get_block_indices<-function(block_size,positions,chromosomes=NULL)
	{
    if(is.null(chromosomes)) 
		{
        block_starts 	<- seq(min(positions),max(positions),block_size)
        block_ends 		<- block_starts + block_size - 1
        lapply(1:length(block_starts), function(x) which(positions>=block_starts[x] & positions<=block_ends[x]))
        }else{
        chrom_names 	<- unique(chromosomes)
        block_starts 	<- lapply(chrom_names, function(chrom_name) seq(min(positions[chromosomes==chrom_name]), max(positions[chromosomes==chrom_name]), block_size)) 
        block_chroms 	<- unlist(lapply(1:length(block_starts), function(x) rep(chrom_names[x], length(block_starts[[x]]))))
        block_starts 	<- unlist(block_starts)
        block_ends 		<- block_starts + block_size - 1
        lapply(1:length(block_starts), function(x) which(chromosomes == block_chroms[x] & positions >= block_starts[x] & positions <= block_ends[x]))
        }
    }

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
# this function runs the jackknife procedure by calculating pseudovalues by removing one block at a time
# if the arguments specified by "..." are vectors, they will be indexed as they are; if they have two dimensions, they will be indexed along the first dimension
get_jackknife_sd<-function(block_indices, FUN, ...)
	{
    n_blocks 	<- length(block_indices)
    args 		<- list(...)
    overall_mean<- FUN(...)
    if (is.null(dim(args[1])))
		{
		blockestimates	<- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]]]))*(n_blocks-1))
        return(sd(blockestimates,na.rm=TRUE))
        }else{
		blockestimates	<- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]],]))*(n_blocks-1))
        return(sd(blockestimates,na.rm=TRUE))
        }
    }

# taken from tutorial of simonhmartin on github ('ABBA BABA statistics using genome wide SNP data')
block_jackknife <- function(block_indices, FUN, ...)
	{
    n_blocks	<- length(block_indices)
    args 		<- list(...)
    overall_mean<- FUN(...)
    if (is.null(dim(args[1])))
		{
        pseudovalues <- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]]]))*(n_blocks-1))
        }else{
        pseudovalues <- sapply(1:n_blocks, function(i) overall_mean*n_blocks - do.call(FUN, lapply(args, function(a) a[-block_indices[[i]],]))*(n_blocks-1))
        }
    mean 		<- mean(pseudovalues,na.rm=TRUE)
    std_dev 	<- sd(pseudovalues,na.rm=TRUE)
    list(mean=mean,std_dev=std_dev)
    }

# Function to support Bayesass migration analyses outside of R environment:	
create_bayesass_input<-function(nind=NULL,maxlines=36000,exportname="Bayesassinput")
	{
	# bayesinput can have maximum just over 36000 lines, as far as I know.
	# each line represents a locus for a single individual
	# therefore, the total number of loci equals 36000/nind.
	if(is.null(nind))
		{
		nind	<- nrow(inds[inds$filter,])
		}
	nloci	<- floor(maxlines/nind) 
	subselectdata(nrsnps=nloci,export=exportname)
	}

# Function to support Bayesass migration analyses outside of R environment:	
plotmigration<-function(myinputmatrix="bayesassmatrix.txt",mycolours=NULL,export=NULL,addaxis=FALSE,addlabels=TRUE,use_current_dir=FALSE)
	{
	# 07-05-2020: Thomas ran into error: Error in (function (classes, fdef, mtable): unable to find an inherited method for function 'desc' for signature '"numeric"'
	# Not solved yet
	# Maybe because the function desc is masked by a particular package?
	# the function works when typing desc returns: 'standardGeneric for "desc" defined from package "IRanges"'
	if(!use_current_dir)
		{
		if(exists("mysambar"))
			{
			setwd(mysambar$inputfilesdir)
			}else{
			return(cat("ERROR: Inputfilesdir not defined. First run the importdata() function, or alternatively run the plotmigration function with the flag 'use_current_dir' set to TRUE.",sep="\n"))
			}
		}
	if(!file.exists(myinputmatrix))
		{
		cat(paste("ERROR: SambaR expects to find the file '",myinputmatrix,"' in the directory:",sep=""),sep="\n")
		mypath	<- ifelse(use_current_dir,getwd(),mysambar$inputfilesdir)
		return(cat(mypath,sep="\n"))
		}
	# this function expects to find in sambardir directory a file containing a matrix defining migration rates, like:
	# EastAnglia m[0][0]: 0.8973(0.0348) m[0][1]: 0.0066(0.0028) m[0][2]: 0.0554(0.0209)
	# Ayrshire m[1][0]: 0.0138(0.0086) m[1][1]: 0.8262(0.0610) m[1][2]: 0.1110(0.0575)
	# Wurttemberg m[2][0]: 0.0016(0.0012) m[2][1]: 0.0043(0.0031) m[2][2]: 0.9895(0.0036)
	# So the first column contains population names and the other columns comprise the matrix outputted by Bayesass.
	m 			<- read.table(myinputmatrix,stringsAsFactors=FALSE)
	populations	<- m[,1]
	m			<- m[,(2:ncol(m))]
	m2			<- m[,c(FALSE,TRUE)]
	n			<- nrow(m)
	m			<- m2
	for(i in c(1:ncol(m2)))
		{
		m[,i]<- as.numeric(substr(m2[,i],1,6))
		}
	# 29-01-2019:
	# The following commands assumes migration flow is from i to j. (i = row number, j = column number)
	# However, in the Bayesass output table, migration flow is from j to to i.
	# From the Bayesass manual:
	# "Note that m[i][j] is the fraction of individuals in population i that are migrants derived from population j (per generation)."	
	# So we have to transpose the table:
	m	<- t(m)
	# create colours:
	# define colours:
	npops	<- length(mysambar$populations)
	if(npops!=nrow(m))
		{
		cat("ERROR: Number of populations in input file does not correspond to the expected number of populations.",sep="\n")
		cat(paste("Number of populations in input file (i.e. number of rows in Bayesass output file): ",nrow(m),".",sep=""),sep="\n")
		cat(paste("Number of expected populations (i.e. length(mysambar$populations)): ",npops,".",sep=""),sep="\n")
		}
	if(is.null(mycolours))
		{
		#mycolours	<- as.vector(unique(inds$popcol))
		mycolours	<- mysambar$mycolours[1:npops]
		}
	# make df1:
	df1			<- as.data.frame(cbind(c(1:n),populations))
	names(df1)	<- c("order","region")
	df1			<- arrange(df1, order)
	df1$region 	<- factor(df1$region, levels=df1$region) 
	# install packages:
	if("migest" %in% rownames(installed.packages()) == FALSE) {install.packages("migest",repos='http://cran.us.r-project.org')}
	if("plyr" %in% rownames(installed.packages()) == FALSE) {install.packages("plyr",repos='http://cran.us.r-project.org')}
	if("circlize" %in% rownames(installed.packages()) == FALSE) {install.packages("circlize",repos='http://cran.us.r-project.org')}
	if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages("gplots",repos='http://cran.us.r-project.org')}
	library("migest")
	library("plyr")
	library("circlize")
	library("gplots")
	# edit m:
	df1			<- as.data.frame(cbind(c(1:n),populations))
	names(df1)	<- c("order","region")
	df1			<- arrange(df1, order)
	df1$region 	<- factor(df1$region, levels=df1$region) 
	# edit df1:
	df1$xmin 	<- 0
	df1$xmax 	<- rowSums(m)+colSums(m)
	myrgbs		<- t(col2rgb(mycolours, alpha = FALSE))
	df1			<- as.data.frame(cbind(df1,myrgbs))
	names(df1)[5:7]	<- c("r","g","b")
	df1$rgb		<- paste(df1$r,df1$g,df1$b,sep=",")
	df1$rcol	<- col2hex(mycolours)
	df1$lcol	<- paste(df1$rcol,"C8",sep="")			# lighter colour. If you want to use, set as option in panel.fun
	df1			<<- df1
	# create df2 (needed to add migration rates):
	df1$sum1 	<- colSums(m)
	df1$sum2 	<- numeric(n)
	rownames(m)	<- populations
	df2			<- cbind(as.data.frame(m),orig=rownames(m), stringsAsFactors=FALSE)
	df2			<- reshape(df2, idvar="orig", varying=list(1:n),direction="long",timevar="dest", time=rownames(m),v.names = "m")
	df2			<- arrange(df2,desc(m))
	df2			<<- df2
	# df2		<- subset(df2, m>quantile(m,0.5))	# optionally ignore small migration rates
	# create circos plot:
	graphics.off()
	if(!use_current_dir&!is.null(mysambar$demographydir)){setwd(mysambar$demographydir)}
	if(!is.null(export))
		{
		if(export=="eps"){postscript("Migration.circosplot.eps",family=mysambar$myfont,width=7,height=7)}
		if(export=="pdf"){pdf("Migration.circosplot.pdf",family=mysambar$myfont,width=7,height=7)}
		}
	par(mar=rep(0,4))
	circos.clear()
	circos.par(cell.padding=c(0,0,0,0),track.margin=c(0,0.15),start.degree=90,gap.degree=4,points.overflow.warning=FALSE)
	circos.initialize(factors=df1$region,xlim=cbind(df1$xmin, df1$xmax))
	circos.trackPlotRegion(ylim = c(0, 1), factors=df1$region, track.height=0.1, 
	panel.fun = function(x, y) 
		{
		name 	= get.cell.meta.data("sector.index")
		i 		= get.cell.meta.data("sector.numeric.index")
		xlim 	= get.cell.meta.data("xlim")
		ylim 	= get.cell.meta.data("ylim")
		pi 	= circlize(mean(xlim), 1.3)[1, 1] %% 360
		dd 		= ifelse(pi < 90 || pi > 270,"clockwise", "reverse.clockwise")
		aa 		= c(1,0.5)	
		if(pi < 90 || pi > 270)  aa =c(1,0.5)
		# if you want to add region labels:
		if(addlabels)
			{
			circos.text(x=max(xlim), y=1.9,labels=populations[i], facing = "bending", cex=2.5,  adj = aa)
			}
		circos.rect(xleft=xlim[1], ybottom=ylim[1],xright=xlim[2], ytop=ylim[2],col = df1$rcol[i], border=df1$rcol[i])
		circos.rect(xleft=xlim[1], ybottom=ylim[1],xright=xlim[2]-sum(df2$m)[i], ytop=ylim[1]+0.3,col = "white", border = "white")
		circos.rect(xleft=xlim[1], ybottom=0.3,	xright=xlim[2], ytop=0.32, col = "white", border = "white")
		# if you want to add region axes:
		if(addaxis)
			{
			circos.axis(labels.cex=0.6, direction="outside", major.at=seq(from=0, to=floor(df1$xmax)[i],by=5), minor.ticks=1, labels.away.percentage = 0.15)
			}
		})
	# add migration routes:
	for(k in 1:nrow(df2))
		{
		i<-match(df2$orig[k],df1$region)
		j<-match(df2$dest[k],df1$region)
		if(is.na(i)|is.na(j)){return(cat(paste("ERROR: no match between df2$orig and df1$region for k =",k,sep = " ")))}
		circos.link(
			sector.index1=df1$region[i], 
			point1=c(df1$sum1[i],df1$sum1[i] + abs(m[i,j])),
			sector.index2=df1$region[j], 
			point2=c(df1$sum2[j],df1$sum2[j] + abs(m[i,j])), 
			col = df1$lcol[i])
		df1$sum1[i] = df1$sum1[i] + abs(m[i,j])
		df1$sum2[j] = df1$sum2[j] + abs(m[i,j])
		}
	if(!is.null(export))
		{
		dev.off()
		if(!use_current_dir)
			{
			if(exists("mysambar$sambardir")){setwd(sambardir)}
			cat("Circos plot with migration rates has been exported to demography directory.",sep="\n")
			}else{
			cat("Circos plot with migration rates has been exported to working directory.",sep="\n")
			}
		}
	}	

# End of demographic analyses 
###############################################################################################################











###############################################################################################################
# Genetic diversity analyses

# This function executes all genetic distance analyses at once:
# I decided not to include calcLD, because it only calculates LD for adjacent snps (otherwise it takes too long).
# What's more, SambaR provides excellent plotting function for PLINK output. 

calcdiversity<-function(nrsites=NULL,nrsegsites=NULL,nrsnps=NULL,legend_cex=2.5,silent=TRUE,u_g=1.0*10^-8,dohwe=TRUE,do_he=TRUE,do_pi=TRUE,do_sfs=FALSE,do_continue=FALSE,redo_tajd=TRUE,do_triplot=TRUE,do_venn=TRUE,pheno_vector=NULL)
	{
	# nrsites must be a vector of length of either 1 or length of vector mysambar$populations
	# nrsegsites must be vector of length of either 1 or length of vector mysambar$populations
	# nrsnps must be a vector of length of either 1 or length of nrow(inds)
	#
	#				inds$nsites1		# number of sites retained by snps$filter						snps$filter
	#				inds$nsites2		# number of sites per individual								snps$filter&!is.na		# same as inds$nsites5 and inds$ndata
	#  				inds$nsegsites1		# number of segregating sites per population (filtered)			snps$filter&popmaf>0
	#  				inds$nsegsites2		# number of segregating sites per individual (filtered)			snps$filter&popmaf>0&!is.na
	# nrsegsites: 	inds$nsegsites3		# number of segregating sites per population (not filtered)		popmaf>0
	# nrsnps: 		inds$nsegsites4		# number of segregating sites per individual (not filtered)		popmaf>0&!is.na
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")		
	setwd(mysambar$diversitydir)
	if(do_he)
		{
		if(all(inds$hetero==0,na.rm=TRUE))
			{
			return(cat("All individuals fully homozygous. Haploid data? Not generating heterozygosity plots.",sep="\n"))
			}
		if("inbreedR" %in% rownames(installed.packages()))
			{
			# 23-09-2022: unexplained occasional error message (only observed when running calcdiversity() function, not when running MLHboxplot independently):
			# Error in boxplot.default(split(mf[[response]], mf[-response], drop = drop, : invalid first argument
			# Called from: boxplot.default(split(mf[[response]], mf[-response], drop = drop,
			# sep = sep, lex.order = lex.order), xlab = xlab, ylab = ylab,
			# add = add, ann = ann, horizontal = horizontal, ...)
			if("inbreedR" %in% (.packages()) == FALSE){library(inbreedR)}
			cat("Calculating (standardized) multilocus heterozygosity (sMLH) using inbreedR...",sep="\n")
			calcMLH()
			cat("Plotting standardized multilocus heterozygosity...",sep="\n")
			MLHboxplot(export="eps",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
			MLHboxplot(export="pdf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
			MLHboxplot(export="png",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
			if(mysambar$os=="Windows"){MLHboxplot(export="wmf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")}
			cat("Plotting multilocus heterozygosity...",sep="\n")
			MLHboxplot(export="eps",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")
			MLHboxplot(export="pdf",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")
			MLHboxplot(export="png",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")
			if(mysambar$os=="Windows"){MLHboxplot(export="wmf",sMLH=TRUE,plotname="MLHstandardized_boxplot",ylabel="sMLH")}
			}else{
			# the function will use the column 'hetero_all' rather than MLH (identical values): 
			cat("Plotting multilocus heterozygosity...",sep="\n")
			MLHboxplot(export="eps",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
			MLHboxplot(export="pdf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
			MLHboxplot(export="png",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")
			if(mysambar$os=="Windows"){MLHboxplot(export="wmf",sMLH=FALSE,plotname="MLH_boxplot",ylabel="Multi locus heterozygosity")}
			#
			# heterozygosity-fitness calculations:
			if(!is.null(pheno_vector))
				{
				calcMLH(phenovector=pheno_vector)
				}
			}
		#
		# identical to MLH:
		cat("Plotting heterozygosity for all sites (same as MLH)...",sep="\n")
		indheboxplot(export="eps",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)
		indheboxplot(export="pdf",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)
		indheboxplot(export="png",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)
		if(mysambar$os=="Windows"){indheboxplot(export="wmf",plotname="He_allsites_boxplot",heteroscore="hetero_all",ylabel="Heterozygosity (%)",yline=4.5)}
		# segregating sites only:
		cat("Plotting heterozygosity for segregating sites only...",sep="\n")
		indheboxplot(export="eps",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)
		indheboxplot(export="pdf",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)	
		indheboxplot(export="png",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)
		if(mysambar$os=="Windows"){indheboxplot(export="wmf",plotname="He_segsites_boxplot",heteroscore="hetero",ylabel="Heterozygosity (%)",yline=4.5)}
		}
	if(do_sfs)
		{
		cat("WARNING: Because the flag 'do_SFS' is set to TRUE, SambaR will attempt to extract SFS vectors from the SNP data.",sep="\n")
		cat("However, experience shows that the generated SFS-vectors can look different from expected, and/or different from SFS-vectors generated by more specialized software.",sep="\n")
		cat("You are therefore advised to construct SFS-vectors using other software (e.g., ANGSD, easySFS or Popgen Pipeline Platform).",sep="\n")
		if(!do_continue)
			{
			return(cat("To continue generating SFS-vectors, set the flag do_continue to TRUE.",sep="\n"))
			}
		}else{
		cat("Because the flag do_SFS is set to FALSE (default), SambaR will not generate SFS-vectors.",sep="\n")
		}
	if("meanpi"%in%colnames(pops2)&"d"%in%colnames(pops2))
		{
		if(!silent){cat("popscatter(score1=meanpi,score2=d)",sep="\n")}
		popscatter(export="pdf",score1="meanpi",score2="d",addlegend=FALSE,legendcex=1.5)
		popscatter(export="pdf",score1="meanpi",score2="d",addlegend=TRUE)
		}
	if("meanpi"%in%colnames(pops2)&"fst"%in%colnames(pops2))
		{
		if(!silent){cat("popscatter(score1=meanpi,score2=fst)",sep="\n")}
		popscatter(export="pdf",score1="meanpi",score2="fst",addlegend=FALSE,legendcex=1.5)
		popscatter(export="pdf",score1="meanpi",score2="fst",addlegend=TRUE)
		}
	if("meanhe"%in%colnames(pops2)&"d"%in%colnames(pops2))
		{
		if(!silent){cat("popscatter(score1=meanhe,score2=d)",sep="\n")}
		popscatter(export="pdf",score1="meanhe",score2="d",addlegend=FALSE,legendcex=1.5)
		popscatter(export="pdf",score1="meanhe",score2="d",addlegend=TRUE)
		}
	if("meanhe"%in%colnames(pops2)&"fst"%in%colnames(pops2))
		{
		if(!silent){cat("popscatter(score1=meanhe,score2=fst)",sep="\n")}
		popscatter(export="pdf",score1="meanhe",score2="fst",addlegend=FALSE,legendcex=1.5)
		popscatter(export="pdf",score1="meanhe",score2="fst",addlegend=TRUE)
		}
	if(do_triplot)
		{
		if(!silent){cat("plotgenotri",sep="\n")}
		plotgenotri(export="eps",allsites=FALSE)
		plotgenotri(export="pdf",allsites=FALSE)
		plotgenotri(export="png",allsites=FALSE)
		if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
		plotgenotri(export="eps",allsites=TRUE)
		plotgenotri(export="pdf",allsites=TRUE)
		plotgenotri(export="png",allsites=TRUE)
		if(mysambar$os=="Windows"){plotgenotri(export="wmf",allsites=TRUE)}
		cat("Hardy Weinberg calculations...",sep="\n")
		cat("If you receive an error after this line, set the flag dohwe to FALSE.",sep="\n")
		}
	if(dohwe)
		{
		hwe(export="pdf")
		}
	# plot_F(export=TRUE)				# 26-09-2019: incorrect at the moment, needs to be improved	
	if(length(mysambar$populations)==1)
		{
		cat("Currently only 1 population defined. Most plots won't be generated, as they are meant to compare diversity between populations.",sep="\n")
		}
	npops	<- length(mysambar$populations)
	if(is.null(nrsites))
		{
		cat("You didn't provide the total number of sequenced sites (i.e.: nsites=NULL).",sep="\n")
		#cat("You miss out on various interesting analyses! See SambaR manual for more details.",sep="\n")
		}else{
		if(length(nrsites)==1)
			{
			inds$allseqsites	<<- nrsites
			}else{
			if(length(nrsites)!=npops)
				{
				return(cat("ERROR: length of vector input to nrsites flag should be either 1 or equal to number of populations.",sep="\n"))
				}else{
				inds$allseqsites		<<- NA
				for(i in c(1:nrow(inds)))
					{
					inds$allseqsites[i]	<<- nrsites[which(mysambar$populations==inds$pop[i])]
					}
				}
			}
		inds$S			<<- inds$nsegsites3/inds$allseqsites
		}
	if(length(mysambar$populations)>1)
		{
		cat("Counting number of private alleles...",sep="\n")
		private_hist(snpsfilter=NULL,export="eps")
		private_hist(snpsfilter=NULL,export="pdf")
		private_hist(snpsfilter=NULL,export="png")
		if(mysambar$os=="Windows"){private_hist(snpsfilter=NULL,export="wmf")}
		private_hist(snpsfilter=snps$filter,export="eps")
		private_hist(snpsfilter=snps$filter,export="pdf")
		private_hist(snpsfilter=snps$filter,export="png")
		if(mysambar$os=="Windows"){private_hist(snpsfilter=snps$filter,export="wmf")}
		if(length(mysambar$populations)<6&do_venn)
			{
			cat("If you receive an error shortly after this line, rerun the calcdiversity function with the flag do_venn to FALSE.",sep="\n") 
			# Venn diagram showing overlap of polymorphic sites between loci
			# Works for maximum 5 populations
			markervenn(export=TRUE,doprop=FALSE,dofilter=TRUE)
			markervenn(export=TRUE,doprop=TRUE,dofilter=TRUE)
			markervenn(export=TRUE,doprop=FALSE,dofilter=FALSE)
			markervenn(export=TRUE,doprop=TRUE,dofilter=FALSE)
			}
		}else{
		cat("Only 1 population defined. Skipping count of private alleles.")
		}
	cat("Plotting genocounts...",sep="\n")
	plotgenocounts(addlabels=FALSE,export=TRUE)
	plotgenocounts(addlabels=TRUE,export=TRUE)
	#
	if(!do_sfs)
		{
		cat("Skipping site frequency spectra analyses because the flag do_sfs is set to FALSE.",sep="\n")
		}else{
		cat("Generating site frequency spectra...",sep="\n")
		cat("If you run into an error soon after this line, rerun the calcdiversity() function with the flag do_sfs set to FALSE.",sep="\n")
		multirunsfs(do_silent=silent,number_sites=nrsites,number_segsites=nrsegsites)
		}
	#
	cat("Calculating pi and tajima's D per population...",sep="\n")
	if(do_pi)
		{
		popnind <- as.vector(table(inds$pop[inds$filter]))
		popbool	<- popnind>1
		if(all(popbool))
			{
			if(!is.null(mysambar$tajd))
				{
				if(!redo_tajd)
					{
					cat("WARNING: using existing Tajima's statistics table stored at mysambar$tajd.",sep="\n")
					cat("If you want to redo the calculations, set the flag redo_tajd to TRUE.",sep="\n")
					}else{
					cat("Rerunning 'calcpi' function. To save time, set the flag redo_tajd to FALSE.",sep="\n")
					calcpi(pi_per_pop=TRUE)
					}
				}
			if(length(mysambar$populations)>1)
				{
				seqdivplot(export=TRUE)
				if(!silent){cat("plottajd",sep="\n")}
				plottajd(export=TRUE,insetbarplot=TRUE,legendcex=legend_cex)
				}
			plottajd(export=TRUE,insetbarplot=FALSE,legendcex=legend_cex)
			if(!silent){cat("plotpi_vs_he",sep="\n")}
			plotpi_vs_he(export="eps",genomewide=FALSE)
			plotpi_vs_he(export="pdf",genomewide=FALSE)
			plotpi_vs_he(export="png",genomewide=FALSE)
			if(mysambar$os=="Windows"){plotpi_vs_he(export="wmf",genomewide=FALSE)}
			if(!silent){cat("calcS",sep="\n")}
			calcS(export="eps")
			calcS(export="pdf")
			calcS(export="png")
			if(mysambar$os=="Windows"){calcS(export="wmf")}
			}else{
			cat("Skipping calculations on nucleotide diversity, Tajima's D, and number of segregation sites, because one or more populations contain only 1 retained individual.",sep="\n")
			}
		}
	if(!silent){cat("plotcompareF(genomewide=TRUE)",sep="\n")}
	plotcompareF(export="eps",genomewide=FALSE)
	plotcompareF(export="pdf",genomewide=FALSE)
	plotcompareF(export="png",genomewide=FALSE)
	if(mysambar$os=="Windows"){plotcompareF(export="wmf",genomewide=FALSE)}
	#
	if(!silent){cat("plotdispersal",sep="\n")}
	calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="eps")
	calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="pdf")
	calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="png")
	#
	if(mysambar$os=="Windows"){calcdispersal(popnames=mysambar$populations,domatrix=FALSE,export="wmf")}
	if(!is.null(nrsites))
		{
		if(any(table(inds$pop[inds$filter])==1))
			{
			cat("WARNING: One or more population(s) contain(s) one individual only (after filtering).",sep="\n")
			cat("For that reason, not generating genome wide diversity statistics. Define different population assignment or different filter settings, and then try again.",sep="\n")
			}else{
			cat("Plotting genome wide heterozygosity and pi...",sep="\n")
			getgenomepi(nsites=inds$allseqsites,nsnps=nrsnps)
			if(nrow(inds)>10)
				{
				if(!silent){cat("plotHe_perind",sep="\n")}
				plotHe_perind(export="eps",genomehe=TRUE)
				plotHe_perind(export="pdf",genomehe=TRUE)
				plotHe_perind(export="png",genomehe=TRUE)
				if(mysambar$os=="Windows"){plotHe_perind(export="wmf",genomehe=TRUE)}
				}
			if(!silent){cat("plotgenomehe",sep="\n")}
			plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="eps",do_stripchart=TRUE)
			plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="pdf",do_stripchart=TRUE)
			plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="png",do_stripchart=TRUE)
			#if(mysambar$os=="Windows"){plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="wmf",do_stripchart=TRUE)}	# this returns an error
			if("vioplot" %in% (.packages()))
				{
				plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="eps",do_stripchart=FALSE)
				plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="pdf",do_stripchart=FALSE)
				plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="png",do_stripchart=FALSE)
				}
			if(mysambar$os=="Windows"){plotgenomehe(nsites=nrsites,nsegsites=nrsegsites,export="wmf",do_stripchart=FALSE)}
			if(!silent){cat("plotpi_vs_he(genomewide=TRUE)",sep="\n")}
			plotpi_vs_he(export="eps",genomewide=TRUE)
			plotpi_vs_he(export="pdf",genomewide=TRUE)
			plotpi_vs_he(export="png",genomewide=TRUE)
			if(mysambar$os=="Windows"){plotpi_vs_he(export="wmf",genomewide=TRUE)}
			if(!silent){cat("plotcompareF(genomewide=TRUE)",sep="\n")}
			plotcompareF(genomewide=TRUE,export="pdf")
			plotcompareF(export="eps",genomewide=TRUE)	
			plotcompareF(export="pdf",genomewide=TRUE)
			plotcompareF(export="png",genomewide=TRUE)
			if(mysambar$os=="Windows"){plotcompareF(export="wmf",genomewide=TRUE)}
			if(length(mysambar$populations)>1)
				{
				if(!silent){cat("seqdivplot",sep="\n")}
				seqdivplot(nsites=nrsites,export=TRUE)
				if(!silent){cat("plottajd",sep="\n")}
				plottajd(export=TRUE,insetbarplot=TRUE,genome_wide=TRUE,legendcex=legend_cex)
				}
			if(!silent){cat("plottajd",sep="\n")}
			plottajd(export=TRUE,insetbarplot=FALSE,genome_wide=TRUE)
			cat("Plotting proportion of segregating sites vs number of individuals...",sep="\n")
			calcS(nsites=nrsites,export="eps")
			calcS(nsites=nrsites,export="pdf")
			calcS(nsites=nrsites,export="png")
			if(mysambar$os=="Windows"){calcS(nsites=nrsites,export="wmf")}
			cat("Generating summary statistics...",sep="\n")	
			popstats(nsites=nrsites,u=u_g)
			}
		}else{
		cat("Generating summary statistics...",sep="\n")
		popstats()
		}
	# plotstats()
	#if("dist" %in% colnames(snps))
	#	{
		# homorun(export="pdf")
		# if(!silent){cat("multimafdiff",sep="\n")}
		# multimafdiff(export=TRUE,do_boxplot=FALSE,do_scatterplot=TRUE,addoutliers=FALSE)
		# 08-05-2020: replace with (still to be polished):
		# rundetectROHs()
	#	}
	# reset working directory:
	setwd(mysambar$inputdatadir)
	cat("Analysis finished.",sep="\n")
	}

calcdispersal<-function(popnames=mysambar$populations,domatrix=FALSE,export=NULL)
	{
	# function to calculate directionality index:
	# Peter and Slatkin, 2013, DETECTING RANGE EXPANSIONS FROM GENETIC DATA
	npops	<- length(popnames)
	meanmaf	<<- vector()
	for (k in c(1:npops))
		{
		mypop		<- popnames[k]
		mafcolumn	<- paste("maf",mypop,sep="_")
		if(!mafcolumn%in%colnames(snps))
			{
			return(cat("ERROR: mafcolumn not present.",sep="\n"))
			}else{
			mafvec		<- as.vector(snps[,mafcolumn])
			}
		meanmaf[k]	<<- mean(mafvec[mafvec>0],na.rm=TRUE)
		}
	#
	mafdf		<- data.frame("pop"=popnames,"maf"=meanmaf)
	mafdf		<- mafdf[mysambar$popordernr,]
	mafdf$col	<- mysambar$colorder
	mafdf$nind	<- NA
	for(k in c(1:nrow(mafdf)))
		{
		mypop			<- mafdf$pop[k]
		mafdf$nind[k]	<- nrow(inds[as.character(inds$pop)==mypop,])  
		}
	#
	if(!is.null(export))
		{
		plotname	<- "Popmaf_segregatingsites"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} 
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	plot(mafdf$nind,mafdf$maf,pch=16,cex=4,xlab="Number of individuals",col=mysambar$colorder,ylab="Mean MAF (MAF>0)",ylim=c(0,1))
	legend("topright",legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=1.5)
	if(!is.null(export)){dev.off()}
	#
	#
	if(domatrix)
		{
		popnr		<- c(1:npops)
		combitable	<- combn(popnr,m=2)
		nametable	<- combn(popnames,m=2)
		dirindex	<- rep(NA,ncol(combitable))
		for (i in c(1:ncol(combitable)))
			{
			popnr1		<- combitable[1,i]	
			popnr2		<- combitable[2,i]	
			mean1		<- meanmaf[popnr1]
			mean2		<- meanmaf[popnr2]
			dirindex[i]	<- round(mean1-mean2,3)
			}
		dirindextable	<<- rbind(combitable,nametable,dirindex)
		b							<- matrix(1,nrow=npops,ncol=npops)
		b[lower.tri(b, diag=FALSE)] <- dirindex
		b							<- t(b)
		b[lower.tri(b, diag=FALSE)] <- dirindex
		colnames(b)					<- popnames
		rownames(b)					<- popnames
		dirindexmat		<<- b
		#
		plotfst(popnames=mysambar$populations,export="pdf",inputvector=dirindex,exportname="Directionaly_index",plottitle="Directionality index")
		}
	}	

calcMLH<-function(popnames=mysambar$populations2,phenovector=NULL,snpsfilter=snps$filter,add2pops=FALSE,silent=TRUE)
	{
	if("inbreedR" %in% rownames(installed.packages()) == FALSE){install.packages("inbreedR",repos=myrepos)}
	if("inbreedR" %in% (.packages()) == FALSE){library(inbreedR)}
	inds$MLH					<<- NA
	inds$sMLH					<<- NA
	if(!silent){cat("Selecting data...",sep="\n")}
	mydf						<- as.data.frame(mygenlight[,snpsfilter])
	mydf[mydf==2]				<- 0
	if(!silent){cat("Calculating heterozygosity per individual...",sep="\n")}
	inds$MLH					<<- MLH(mydf)	# multilocus heterozygosity
	inds$sMLH					<<- sMLH(mydf)	# standardized multilocus heterozygosity
	if(add2pops)
		{
		cat("Adding mean heterozygosity values to pops2 dataframe.",sep="\n")
		pops2$hetero1			<<- NA
		pops2$hetero2			<<- NA
		for(k in c(1:length(popnames)))
			{
			mypop				<- popnames[k]
			if(!silent){cat(mypop,sep="\n")}
			myhetero			<- mean(inds$MLH[inds$pop==mypop],na.rm=TRUE)
			pops2$hetero1[pops2$pop1==mypop]	<<- myhetero
			pops2$hetero2[pops2$pop2==mypop]	<<- myhetero
			}
		pops2$hetero			<<- 0.5*(pops2$hetero1+pops2$hetero2)
		}
	if(!is.null(phenovector))
		{
		cat("Performing heterozygosity-fitness correlation test...",sep="\n")
		# HETEROZYGOSITY-FITNESS CORRELATIONS (HFC)
		# inbreedR can also be used to calculate heterozygosity-fitness correlations (HFC).
		# calculate identity distribution (a proxy of inbreeding coefficient):
		myf 	<- g2_snps(try,nperm=100,nboot=10,CI=0.95,parallel=FALSE,ncores=NULL)
		# alternative to identity distribution: heterozygosity-heterozygosity correlation coefficients (HCP)
		# myhhc <- HHC(try,reps=100)
		#
		# linear model of fitness trait (mypheno) on heterozygosity
		mypheno	<- phenovector[inds$filter]		# this should be a quantitative trait, such as body size or number of offspring
		mymodel <- lm(mypheno ~ het)
		mybeta 	<- coef(mod)[2]
		#
		# r2 between fitness and heterozygosity:
		Wh 		<- cor(mypheno,predict(mymodel))^2
		# r2 between inbreeding and heterozygosity:
		hf 		<- r2_hf(genotypes=mydf,type="snps")
		# r2 between inbreeding and fitness:
		Wf 		<- r2_Wf(genotypes=mydf,trait=mypheno,family=gaussian,type="snps")
		mysambar$hfclist	<<- c(Wh,hf,Wf)
		cat("Results of heterozygosity-fitness correlation test stored in mysambar$hfclist.",sep="\n")
		}
	}

MLHboxplot<-function(export=NULL,sMLH=FALSE,plotname="MLH_boxplot",popnames=mysambar$poporder,popcolours=mysambar$colorder,ylabel="Multi locus heterozygosity (%)",yline=5.25,silent=TRUE,labelcex=2,mywidth=0.75)
	{
	if(is.null(popnames))
		{
		return(cat("ERROR: the flag 'popnames' may not be set to NULL.",sep="\n"))
		}
	if(is.null(popcolours))
		{
		return(cat("ERROR: the flag 'popcolours' may not be set to NULL.",sep="\n"))
		}
	indstemp	<- droplevels(inds[inds$filter,])
	npops		<- length(popnames)
	#
	if(!"MLH"%in%colnames(indstemp))
		{
		# SambaR's hetero_all estimate is identical to the MLH estimate of the package inbreedR
		cat("Column 'MLH' not present in inds dataframe. Setting it equal to inds$hetero_all.",sep="\n")
		if(!"hetero_all"%in%colnames(indstemp))
			{
			return(cat("ERROR: the column inds$hetero_all is also missing (?). Rerun the filterdata() function.",sep="\n"))
			}
		indstemp$MLH<- indstemp$hetero_all
		}
	#
	if(sMLH)
		{
		if(!"sMLH"%in%colnames(indstemp))
			{
			return(cat("Column 'sMLH' not present in inds dataframe. First run the calcMLH function.",sep="\n"))
			}
		ymax		<- 1.1*max(indstemp$sMLH,na.rm=TRUE)
		ymin		<- 0.9*min(indstemp$sMLH,na.rm=TRUE)
		}else{
		ymax		<- 1.1*max(indstemp$MLH,na.rm=TRUE)
		ymin		<- 0.8*min(indstemp$MLH,na.rm=TRUE)
		ymax		<- ifelse(ymax>1,1,ymax)
		ymin		<- ifelse(ymin<0,0,ymin)
		}
	if(!"poporder"%in%colnames(indstemp))
		{
		return(cat("ERROR: the column 'poporder' is missing from inds object.",sep="\n"))
		}
	#
	if(!is.null(export))
		{
		mywidth2=mywidth*100
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=npops*mywidth+2,height=10)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=npops*mywidth+2,height=10)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=npops*mywidth2+200,height=1000)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=npops*mywidth+2,height=10)}
		}
	par(oma=c(12,8,1,1),mar=c(8,0.5,0.5,0.5),cex.axis=2)
	if(sMLH)
		{
		boxplot(indstemp$sMLH~indstemp$poporder,border=popcolours,col="grey90",cex.axis=labelcex,pch=16,outline=FALSE,ylim=c(ymin,ymax),las=2,xlab="",ylab="")
		stripchart(sMLH~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=labelcex,col=popcolours,bg="bisque",add=TRUE)
		abline(h=1,lty=2)
		}else{
		boxplot(indstemp$MLH~indstemp$poporder,border=popcolours,col="grey90",cex.axis=labelcex,pch=16,outline=FALSE,ylim=c(ymin,ymax),las=2,xlab="",ylab="")
		stripchart(MLH~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=labelcex,col=popcolours,bg="bisque",add=TRUE) 
		}
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	#mtext(side=1,"Population",line=6.5,cex=2)
	if(!is.null(export))
		{
		dev.off()
		if(!silent){cat("Boxplot with per sample multi locus heterozygosity values has been exported to the directory:",sep="\n")}
		if(!silent){cat(getwd(),sep="\n")}
		}
	}


# calculate Ne from LD profile:
stratag_ne<-function(snpmissmax=NULL,write_genepop=FALSE,do_analysis=TRUE,ncores=1)
	{
	if("strataG" %in% rownames(installed.packages()) == FALSE)	
		{
		cat("Installing package strataG...",sep="\n")
		devtools::install_github('ericarcher/strataG',build_vignettes=FALSE,upgrade="never")
		}
	if("strataG"%in%(.packages()) == FALSE)	
		{
		cat("Loading package strataG...",sep="\n")
		library(strataG)
		}
	if(is.null(mysambar$genind))
		{
		cat("Converting genlight to genind...",sep="\n")
		genlight2genind()
		}
	mygenind	<- mysambar$genind
	if(is.null(snpmissmax))
		{
		mygenind2	<- mygenind
		}else{
		mygenind2	<- missingno(mygenind,type="loci",cutoff=snpmissmax)		# optionally shrink dataset
		}
	cat("Converting genind to gtypes...",sep="\n")
	snps_gtypes <- genind2gtypes(mygenind2)
	if(write_genepop)
		{
		cat("Exporting genepop file (in case you would like to run the software Ne_estimator)...",sep="\n")
		genepopWrite(snps_gtypes,"gstrata_genepop.txt")
		# alternatively:
		# genlight2genepop()
		}
	if(do_analysis)
		{
		cat("Calculating Ne...",sep="\n")
		myne 		<<- ldNe(snps_gtypes,maf.threshold=0,by.strata=TRUE,ci=0.95,drop.missing=TRUE,num.cores=ncores)
		myne		<<- round(myne,3)
		# Save the results:
		write.table(myne,"Ne_gstrata.txt",row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")	
		cat("Results are stored in 'myne'. In addition, a file called 'Ne_gstrata' has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

rundetectROHs<-function(doexample=TRUE,pernsnps=FALSE,het_run=FALSE,create_newfile=FALSE)
	{
	# if het_run is TRUE, detection of runs of heterozygosity rather than runs of homozygosity
	if(doexample)
		{
		genotypeFilePath<- system.file("extdata", "Kijas2016_Sheep_subset.ped", package="detectRUNS")
		mapFilePath 	<- system.file("extdata", "Kijas2016_Sheep_subset.map", package="detectRUNS")
		if(!pernsnps)
			{
			# sliding window:
			slidingRuns 	<- slidingRUNS.run(genotypeFile=genotypeFilePath,mapFile=mapFilePath,windowSize=15,threshold=0.05,minSNP=20,ROHet=het_run,maxOppWindow=1,maxMissWindow=1,maxGap=10^6,minLengthBps=250000,minDensity=1/10^3,maxOppRun=NULL,maxMissRun=NULL)
			# minDensity is: # SNP/kbps
			}else{
			# consecutive SNPs:
			consecutiveRuns <- consecutiveRUNS.run(genotypeFile=genotypeFilePath,mapFile=mapFilePath,minSNP=20,ROHet=het_run,maxGap=10^6,minLengthBps=250000,maxOppRun=1,maxMissRun=1)
			}
		#
		# summary statistics:
		# summaryList <- summaryRuns(runs=slidingRuns,mapFile=mapFilePath,genotypeFile=genotypeFilePath,Class=6,snpInRuns=TRUE)
		# summaryList$summary_ROH_count
		# summaryList$summary_ROH_mean_chr
		# head(summaryList$SNPinRun)		# The dataframe “SNPinRun” contains, for each SNP, the proportion of times it falls inside a run in any given population/group
		# topRuns <- tableRuns(runs=slidingRuns,genotypeFile=genotypeFilePath,mapFile=mapFilePath,threshold=0.7)
		#
		# plot (ggplot based):
		plot_Runs(runs=slidingRuns)
		plot_StackedRuns(runs=slidingRuns)
		plot_SnpsInRuns(runs=slidingRuns[slidingRuns$chrom==2,],genotypeFile=genotypeFilePath,mapFile=mapFilePath)
		plot_SnpsInRuns(runs=slidingRuns[slidingRuns$chrom==24,],genotypeFile=genotypeFilePath,mapFile=mapFilePath)
		plot_manhattanRuns(runs=slidingRuns[slidingRuns$group=="Jacobs",],genotypeFile=genotypeFilePath,mapFile=mapFilePath)
		#
		# Inbreeding statistics: Froh = Lroh/Lgenome
		# genome_wide:
		my_froh	<- Froh_inbreeding(runs=slidingRuns,mapFile=mapFilePath,genome_wide=TRUE)
		# per chromosome: genome_wide=FALSE
		my_froh	<- Froh_inbreeding(runs=slidingRuns,mapFile=mapFilePath,genome_wide=FALSE)
		}else{
		setwd(mysambar$inputfilesdir)
		if(!file.exists("allinds.filter2.ped")|create_newfile)
			{
			# Note: need to be space separated, not tab separated, otherwise you get the error:
			# Error: Number of markers differ in mapFile and genotype: are those file the same dataset?
			genlight2ped(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter2,indsfilter=rep(TRUE,nrow(inds)),exportname="allinds.filter2",pheno=NULL,genonumber=FALSE,quiet=FALSE,miss_char="N",use_tab=FALSE) 
			}
		myrohs 	<- consecutiveRUNS.run(genotypeFile="allinds.filter2.ped",mapFile="allinds.filter2.map",minSNP=200,ROHet=het_run,maxGap=10^6,minLengthBps=250000,maxOppRun=1,maxMissRun=1)
		# calculate Froh:
		myfroh				<- Froh_inbreeding(runs=myrohs,mapFile="allinds.filter2.map",genome_wide=TRUE)
		myfroh2				<- myfroh[,c("id","Froh_genome")]
		colnames(myfroh2)	<- c("name","Froh")  
		indstemp			<- merge(inds,myfroh2,by="name",all=TRUE)
		inds				<<- indstemp
		}
	}

twofactorbarplot<-function(mydf=dataallwhales,export=NULL)
	{
	mypops			<- unique(mydf$Species)
	mydf$Species	<- factor(mydf$Species,levels=as.character(mypops))	# reorder factors alphabetically
	npops			<- length(mypops)
	if(!is.null(export))
		{
		myheight	<- 0.25
		myheight2	<- 75
		plotname	<- "Froh_barplot_2factor"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=npops*myheight+2,width=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=npops*myheight+2,width=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=npops*myheight2+200,width=600)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=npops*myheight+2,width=6)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=1.5)
	barplot(mydf$Froh~mydf$Cutoffs+mydf$Species,las=2,col=colors()[c(23,89,12,11,5)],horiz=TRUE,xlab="",ylab="",border=NA)
	if(!is.null(export)){dev.off()}
	}

# If you want to do it your way, it requires a few more steps:
onefactorbarplot<-function(export=NULL)
	{
	# first define factor levels:
	allcombi 		<- expand.grid(a = unique(mydf$Cutoffs), b = unique(mydf$Species))
	allcombi$c		<- paste(allcombi$b,allcombi$b,sep="_")
	allcombi$c		<- paste(allcombi$b,allcombi$a,sep="_")
	#
	# define classes:
	mydf$class		<- paste(mydf$Species,mydf$Cutoffs,sep="_")
	mydf$classorder <- factor(mydf$class,levels=allcombi$c)
	#
	nclass			<- length(unique(mydf$classorder))
	if(!is.null(export))
		{
		myheight	<- 0.25
		myheight2	<- 75
		plotname	<- "Froh_barplot_1factor"
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=nclass*myheight+2,width=6)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=nclass*myheight+2,width=6)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=nclass*myheight2+200,width=600)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=nclass*myheight+2,width=6)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=1.25)
	barplot(mydf$Froh~mydf$Cutoffs+mydf$classorder,las=2,horiz=TRUE,xlab="",ylab="",border=NA)
	if(!is.null(export)){dev.off()}
	}

private_hist<-function(popnames=mysambar$populations,snpsfilter=NULL,export=NULL)
	{
	npops		<- length(popnames)
	snpstemp	<- snps[,paste("maf",popnames,sep="_")]
	mafsum		<- rowSums(snpstemp)
	privatevec	<- vector()
	for(j in c(1:npops))
		{
		mypop			<- popnames[j]
		mymaf			<- snps[,paste("maf",mypop,sep="_")]
		if(is.null(snpsfilter))
			{
			privatevec[j]	<- length(mymaf[mymaf==mafsum&mafsum!=0]) 
			}else{
			privatevec[j]	<- length(mymaf[mymaf==mafsum&snpsfilter&mafsum!=0]) 
			}
		#mymaf			<<- mymaf
		#mafsum			<<- mafsum
		}
	if(!is.null(export))
		{
		plotname	<- ifelse(is.null(snpsfilter),"Private_alleles_unfiltered","Private_alleles_filtered")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),height=npops*2+1,width=14)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=npops*2+1,width=14)}
		if(export=="png"){png(paste(plotname,"png",sep="."),height=npops*250+100,width=1400)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),height=npops*2+1,width=14)}
		}
	par(mar=c(6,20,3,0),cex.axis=3)
	privatevec2	<- privatevec/1000
	xx<-barplot(privatevec2,las=1,col=mysambar$mycolours,border=NA,space=0.1,names.arg=mysambar$populations,horiz=TRUE,xlim=c(0,max(privatevec2)*1.3))
	text(x=privatevec2,y=xx,privatevec2,pos=4,cex=3)
	mtext("# private alleles (k)",side=1,line=3.5,cex=3)
	snpstotal	<- ifelse(!is.null(snpsfilter),nrow(snps[snpsfilter&mafsum!=0,]),nrow(snps[mafsum!=0,]))
	mtext(paste("# SNPs:",snpstotal/1000,"k",sep=" "),side=3,line=0.75,cex=3)
	if(!is.null(export)){dev.off()}
	}

# 14-09-2021:
# Shows number of private allele as well as shared alleles
# Works for maximum 5 populations
markervenn<-function(export=FALSE,plotname="Private_and_shared_alleles_venndiagram",minmaf=0,dofilter=TRUE,popnames=mysambar$populations,popcolours=mysambar$mycolours,silent=TRUE,numbercex=2.5,labelcex=2.5,addtotal=FALSE,include_overall=FALSE,doprop=FALSE)
	{
	if(dofilter)
		{
		myfilter	<- snps$filter
		}else{
		myfilter	<- TRUE
		}
	seglist		<<- list()
	npops		<- length(popnames)
	for(k in c(1:npops))
		{
		mypop		<- as.character(popnames[k])
		mafvec		<- snps[,paste("maf",mypop,sep="_")]
		seglist[[k]]<<- snps$name[myfilter&mafvec>minmaf]
		}
	if(addtotal)
		{
		names(seglist)	<<- paste(as.vector(summary(seglist)[,1]),popnames,sep="\n")
		}else{
		names(seglist)	<<- popnames
		}
	#
	if(is.null(popcolours))
		{
		popcolours	<- vector()
		for(k in c(1:npops))
			{
			mypop			<- as.character(popnames[k])
			popcolours[k]	<- mysambar$mycolours[which(mysambar$populations==mypop)]
			}
		}
	if(include_overall)
		{
		# useless:
		seglist$overall	<<- snps$name[myfilter&snps$maf>minmaf]
		popcolours		<- c(popcolours,"grey50") 
		}
	if(!silent){cat("Plotting...",sep="\n")}
	# depends on package VennDiagram
	plotname	<- ifelse(doprop,paste(plotname,"prop",sep="."),plotname)
	plotname	<- ifelse(dofilter,paste(plotname,"filtered",sep="."),paste(plotname,"unfiltered",sep="."))
	if(export){pdf(paste(plotname,paste("minmaf",minmaf,sep=""),"pdf",sep="."),height=6,width=8)}
	#v1 <- venn.diagram(seglist,filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkorchid4"),col=c("blue","darkgreen","darkorchid4"),margin=0.1)
	v1 	<<- venn.diagram(seglist,filename=NULL,alpha=0.6,cex=numbercex,cat.cex=labelcex,fill=popcolours,col=popcolours,margin=0.1)
	if(doprop)
		{
		# 01-10-2021: has been tested on four populations:
		ngroups		<- 0
		for(j in c(1:npops))
			{
			ngroups	<- ngroups+choose(npops,j)
			}
		labelvec	<- vector()
		for(k in c(1:ngroups))
			{
			labelvec[k]	<- as.numeric(v1[[k+(npops*2)]][1]) 
			}
		mysum	<- sum(labelvec)
		for(k in c(1:ngroups))
			{
			v1[[k+(npops*2)]][1]	<- round(labelvec[k]/mysum,2) 
			}
		}
	grid.newpage()
	grid.draw(v1)
	if(export)
		{
		dev.off()
		cat("Venn diagram has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	vennlogfiles <- list.files(pattern = "\\.log$")
	unlink(vennlogfiles)
	}

snp_sim<-function(snp1=NULL,snp2=NULL)
	{
	# how similar are genotype scores of two snps?
	# expects genotype scores of two biallelic snps (e.g 0,1,2) 
	# output is stored in scalar 'snpsim'
	# The similarity roughly indicates whether snps have same distribution of a minor and a major allele. 
	nodata	<- is.na(snp1)|is.na(snp2)
	if(sum(nodata)==length(nodata))
		{
		snpsim <<- NA
		}else{
		snp1	<- snp1[!nodata]	
		snp2	<- snp2[!nodata]	
		onediff	<- sum(abs(snp2-snp1)==1)
		twodiff	<- sum(abs(snp2-snp1)==2)
		snpsim	<<- 1-((onediff+2*twodiff)/(2*length(snp1)))	
		}
	#cat(paste("Similarity score:",snpsim,sep=" "),sep="\n")
	}

gethaplo<-function()
	{
	# install.packages("C:/Users/Menno_de_Jong/Documents/software/HaploBlocker/HaploBlocker-master/HaploBlocker_1.6.06.zip",repos=NULL,type="source")
	# library(HaploBlocker)
	# Error: package 'RandomFieldsUtils' 0.5.3 is loaded, but >= 0.6.6 is required by 'HaploBlocker'
	#
	# try to solve by installing latest version from source (0.6 not available yet on CRAN) 
	# detach(package:RandomFieldsUtils,unload = TRUE)
	# install.packages("C:/Users/Menno_de_Jong/Documents/software/HaploBlocker/HaploBlocker-master/RandomFieldsUtils_0.6.6.tar.gz",repos=NULL,type="source")
	# Warning in system(cmd) : 'make' not found; ERROR: compilation failed for package 'RandomFieldsUtils'
	# 
	# after following instructions to install Rtools40 from this website:
	# https://cran.r-project.org/bin/windows/Rtools/
	# when I retry to install RandomFieldsUtils, I get the error:
	# sh: line 1: c:/Rtools/mingw_32/bin/g++: No such file or directory; make: *** [C:/PROGRA~1/R/R-3.6.2/etc/i386/Makeconf:213: RFoptions.o] Error 127
	#
	# Because I did not manage to solve this error, for now using an older version:
	# install.packages("C:/Users/Menno_de_Jong/Documents/software/HaploBlocker/HaploBlocker-master/Old_version/HaploBlocker_1.5.18.zip",repos=NULL,type="source")
	# library("HaploBlocker")
	#
	# INPUT DATA AND RUN CALCULATIONS:
	# Note: assuming phased data (for example with SHAPEIT)
	# blocklist	<- block_calculation(dhm=ex_maze)
	setwd(mysambar$inputdatadir)
	blocklist	<- block_calculation(dhm="brown121_MT_blackout.ped",bp_map=snps$pos)
	blocklist	<- block_calculation(dhm="brown121_ychrom_blackout.ped",bp_map=snps$pos)
	#
	# CREATE PLOT:
	pdf("Haploblocks.pdf")
	plot_block(blocklist,type="bp")												# type="bp" only works if bp_map flag was not set to NULL (default) when running block_calculation
	# mtext(side=2,rep(inds$pop,rep=2),at=c(1:(2*nrow(inds))),las=2,cex=0.25) 	# not ordered per pop, so does not correspond.
	dev.off()
	#
	# alternative ways to visualize:
	# block_plot(blocklist)
	# blocklist_plot(blocklist)
	# blocklist_plot_xsize(blocklist)
	#
	# OBSERVE OUTPUT:
	# which individuals per block?
	nblocks		<- length(blocklist)
	blockinds	<- list()
	for(i in c(1:nblocks))
		{
		myindex		<- ceiling(blocklist[[i]][6][[1]]/2)
		cat(paste("BLOCK:",i,sep=" "),sep="\n")
		blockinds[[i]]	<- as.character(inds$name[myindex])
		}
	# which individuals missing:
	allinds		<- unlist(blockinds,use.names=FALSE)
	as.character(inds$name[!as.character(inds$name)%in%allinds])
	}
	
# This function calculates LD only for adjacent snps.	
# 27-03-2019: To do for more than just adjacent snps takes a long time, so better to use PLINK.
calcLD<-function(mypop=NULL,add_snpsim=FALSE,doplot=FALSE)
	{
	cat("Calculating LD estimates for unphased data (squared pearson correlation coefficients)...",sep="\n")
	if(is.null(mypop))
		{
		indfilter	<- inds$filter
		}else{
		indfilter	<- inds$filter&inds$pop==mypop
		}
	# This function outputs LD values (squared pearson correlation coefficients) between adjacent snps: 
	# It generates NA if a SNP contains no variation (so only 0's, 1's or 2's (except from NA))
	mymatrix	<- as.matrix(mygenlight)[indfilter,snps$filter2]
	mysnps		<- as.vector(snps$name[snps$filter2])
	mychr		<- snps$chr[snps$filter2]
	mypos		<- snps$pos[snps$filter2]
	myld		<- vector()
	myld[1]		<- NA
	# to suppress warnings:
	op 			<- options(warn = (-1))
	ldmatrix	<- as.data.frame(matrix(NA,ncol=8,nrow=length(mysnps)))
	colnames(ldmatrix)	<- c("snp1","snp2","chr1","chr2","pos1","pos2","ld","sim")
	ldmatrix$sim<- NA
	#for (k in c(2:ncol(mymatrix)))	# replacement has 37 rows, data has 36
	for (k in c(2:nrow(ldmatrix)))	# replacement has 36 rows, data has 175
		{
		ldmatrix$snp1[k]	<- mysnps[k-1]
		ldmatrix$snp2[k]	<- mysnps[k]
		ldmatrix$chr1[k]	<- mychr[k-1]
		ldmatrix$chr2[k]	<- mychr[k]	
		ldmatrix$pos1[k]	<- mypos[k-1]
		ldmatrix$pos2[k]	<- mypos[k]	
		mypair				<- mymatrix[,c((k-1),k)]
		mycorr				<- cor(mypair,method="pearson",use="na.or.complete")
		myld[k]				<- mycorr[2,1]
		ldmatrix$ld[k]		<- mycorr[2,1]
		# Note: this has nothing to do with LD, but just to see how similar the snps are:
		if(add_snpsim)
			{
			snp_1				<- mypair[,1]
			snp_2				<- mypair[,2]
			snp_sim(snp1=snp_1,snp2=snp_2)
			ldmatrix$sim[k]		<- snpsim
			}
		}
	# ldmatrix$ld will have NA if at least one of both snps has identical genotype scores for all individuals (so all individuals are either 0,1,2)
	# this is ignoring individuals with NA scores (note: NA in either the individual itself, or NA in the other individual)
	# enable warnings again:
	ldmatrix				<<- ldmatrix
	options(op)
	snps$ldtemp				<<-	NA 				# this NA values can be discriminated from NA values mentioned above by using snps$filter
	snps$ldtemp[snps$filter]<<- round(myld^2,4)
	if(is.null(mypop))
		{
		names(snps)[names(snps)=="ldtemp"]	<<- "ld_meta"
		}else{
		names(snps)[names(snps)=="ldtemp"]	<<- paste("ld",mypop,sep="_")
		}
	snps 		<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	if(doplot)
		{
		mydf	<- as.data.frame(mypair)
		colnames(mydf)	<- c("snp1","snp2")
		plot(mydf$snp1,mydf$snp2,col="white",xlab="SNP 1",ylab="SNP 2")
		for(i in c(0,1,2))
			{
			for(j in c(0,1,2))
				{
				ngenotypes	<- nrow(mydf[mydf$snp1==i&!is.na(mydf$snp1)&mydf$snp2==j&!is.na(mydf$snp2),])
				if(ngenotypes>0)
					{
					points(i,j,cex=ngenotypes,pch=16,col="grey50")
					}
				}
			}
		}
	}	

calcpopLD<-function(popnames=mysambar$populations)
	{
	for (my_pop in popnames)
		{
		cat(my_pop,sep="\n")
		calcLD(mypop=my_pop)
		}
	snps 		<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	}
	
# depends on wintajd:	
wintajd_multiplewinsizes<-function(my_chr=25,doexport=TRUE)
	{
	if(doexport){pdf(paste("TajimaD",my_chr,"multiple_windowsizes.pdf",sep="."),height=16,width=12)}
	par(mfrow=c(4,1),oma=c(3,3,2,3))
	wintajd(my_chrom=my_chr,winsize=500000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=1000000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=1500000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	wintajd(my_chrom=my_chr,winsize=2000000,winstep=200000,do_analysis=TRUE,export=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
	mtext("Position (Mb)",side=1,line=0,outer=TRUE,cex=2)
	mtext("Tajima's D",side=2,line=-1,outer=TRUE,cex=2)
	mtext(paste("Chromosome",my_chr,sep=" "),side=3,line=-2.5,outer=TRUE,cex=2)
	mtext("Number of SNPs per window",side=4,line=-0.5,outer=TRUE,cex=2)
	if(doexport){dev.off()}
	# and separate plots:
	wintajd(my_chrom=my_chr,winsize=500000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=1000000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=1500000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	wintajd(my_chrom=my_chr,winsize=2000000,winstep=200000,do_analysis=TRUE,export=TRUE,addlab=TRUE,addxaxis=TRUE)
	}

# depends on function wintajd()	
wintajd_multiplechroms<-function(mycomparisons=NULL,popnames=mysambar$populations,ntiles=18,mychroms=NULL,windowsize=50000000,windowstep=30000000,export=NULL,addX=TRUE,myyrange=c(-3,3),my_lwd=1.5)
	{
	myxmax	<- max(snps$pos[snps$filter],na.rm=TRUE)
	my_xlim	<- c(0,myxmax/1000000)
	setwd(mysambar$selectiondir)
	# run windowfst function recursively:
	if(is.null(mycomparisons))
		{
		mycomparisons=seq(1:ncol(combn(popnames,m=2)))
		}
	if(is.null(mychroms))
		{
		mychroms<-sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
		}
	nchroms		<- length(mychroms)
	ntabs		<- ceiling(nchroms/ntiles)
	for (n in c(1:ntabs))
		{ 
		if(!is.null(export))
			{
			if(export=="eps"){postscript(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"eps",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="pdf"){pdf(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"pdf",sep="."),family=mysambar$myfont,width=6,height=8)}
			if(export=="png"){png(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"png",sep="."),family=mysambar$myfont,width=540,height=720)}
			if(export=="wmf"){win.metafile(paste("Window_TajimaD",(paste(windowsize,"snpsperwindow",sep="")),n,"wmf",sep="."),family=mysambar$myfont,width=6,height=8)}
			}
		layout(matrix(c(c(c(1:(ntiles/2)),ntiles+1),c((ntiles/2+1):(ntiles+1))),nrow=(ntiles/2+1),ncol=2,byrow=FALSE))
		#layout(matrix(c(1:ntiles),(ntiles/2),2,byrow=FALSE))
		par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))
		if(n<ntabs)
			{
			chromset	<- mychroms[((n-1)*ntiles+1):(ntiles*n)]
			}else{
			chromset	<- mychroms[((n-1)*ntiles+1):length(mychroms)]
			}
		for (chromname in chromset)
			{
			# cat(chromname,sep="\n")
			if(chromname%%(ntiles/2)==0)
				{
				wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addinfo=FALSE,addlab=FALSE,addxaxis=TRUE,subtitlepos=-2)
				#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
				}else{
				if(mychroms[nchroms]==chromname&&addX==FALSE)
					{
					wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=FALSE,subtitlepos=-2)
					#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
					}else{
					wintajd(my_chrom=chromname,winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=FALSE,subtitlepos=-2)
					#windowfst(chrom=chromname,selectcombi=mycomparisons,width=windowsize,yrange=myyrange,yby=0.05,xaxislabels=FALSE,mylwd=my_lwd)
					}
				}
			}
		if(addX&n==ntabs)
			{
			wintajd(my_chrom="X",winsize=windowsize,winstep=windowstep,do_analysis=TRUE,export=FALSE,myxlim=my_xlim,addlab=FALSE,addinfo=FALSE,addxaxis=TRUE,subtitlepos=-2)
			#windowfst(chrom="X",selectcombi=mycomparisons,width=windowsize,yrange=c(0.025,0.225),yby=0.05,xaxislabels=TRUE,mylwd=my_lwd)
			}
		mtext("Tajima's D", side=2, line=0, outer=TRUE,cex=1.5)
		mtext("Position along chromosome (Mb)", side=1, line=-3.5, outer=TRUE,cex=1.25)
		# addlegend:
		if(n==ntabs)
			{
			nempty	<- ifelse(addX,(ntabs*ntiles-length(mychroms)-1+1),(ntabs*ntiles-length(mychroms)+1))
			for(mycounter in c(1:(nempty)+1))
				{
				plot(1,type ="n",axes=FALSE,xlab="",ylab="")	
				}
			}else{
			plot(1,type= "n",axes=FALSE,xlab="",ylab="")
			}
		legend(x="bottom",legend=popnames,horiz=T,fill=mysambar$mycolours[1:length(popnames)],cex=1.25,bty="n")
		if(!is.null(export)){dev.off()}
		}
	setwd(mysambar$inputdatadir)
	}		
	
# depends on calcpi:
wintajd<-function(my_chrom=25,winsize=1000000,winstep=200000,popnames=mysambar$populations,do_analysis=TRUE,export=FALSE,addlab=TRUE,addinfo=TRUE,addxaxis=TRUE,subtitlepos=-1.5,myxlim=NULL)
	{
	if(!my_chrom%in%snps$chr)
		{
		return(cat("ERROR: specified chromosome/contig not present in snps$chr column. Aborting.",sep="\n"))
		}
	npops			<- length(popnames)
	mycols			<- mysambar$mycolours[1:npops]
	if(do_analysis)
		{
		mymax		<- max(snps$pos[snps$chr==my_chrom],na.rm=TRUE)
		mystarts	<- seq(0,winsize,winstep)
		mywindows	<- vector() 
		for(mystart in mystarts)
			{
			mywindow	<- seq(mystart,mymax,winsize)
			mywindows	<- c(mywindows,mywindow)
			}
		windowstart	<- sort(as.vector(unique(mywindows)))
		windowend	<- windowstart+winsize
		nwin		<- length(windowstart)
		cat(paste("Calculating Tajima's D for",nwin,"windows of",winsize/1000000,"Mb width on contig/chromosome",my_chrom,"...",sep=" "),sep="\n")
		for(k in c(1:nwin))
			{
			cat(k,sep="\n")
			mywindow	<- c(windowstart[k],windowend[k])
			calcpi(mychrom=my_chrom,myrange=mywindow,silent=TRUE,pi_per_pop=TRUE)
			if(k==1)
				{
				wintaj	<<- mysambar$tajd
				}else{
				wintaj	<<- rbind(wintaj,mysambar$tajd)
				}
			}
		mymean	<- round(mean(wintaj$mean_nsites,na.rm=TRUE),1) 
		cat(paste("Average number of SNPs per window:",mymean,sep=" "),sep="\n")
		cat(paste("Results have been written to a dataframe called wintaj."),sep="\n")
		mymax	<- max(wintaj$TajimaD,na.rm=TRUE)
		mymin	<- min(wintaj$TajimaD,na.rm=TRUE)
		mymax	<- ifelse(mymax< 3, 3, mymax)
		mymin	<- ifelse(mymax> -3,-3, mymin)
		}
	# plot:
	if(export){pdf(paste("TajimaD",my_chrom,"winsize",winsize/1000000,"Mb.pdf",sep="."),height=5,width=12)}
	if(addinfo)
		{
		par(mar=c(4,4.5,3,5),cex.axis=1.5)		# par(mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,2,2))		
		}
	myxaxt		<- ifelse(addxaxis,'s','n')
	mypop		<- popnames[1]
	plot(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],type='l',las=1,lwd=2,col=mycols[1],xaxt=myxaxt,ylim=c(mymin,mymax),xlim=myxlim,ylab="",xlab="",main="")
	if(npops>1)
		{
		for(i in c(2:npops))
			{	
			mypop	<- popnames[i]
			points(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],type='l',lwd=2,col=mycols[i])
			}
		}
	if(addlab)
		{
		mtext("Tajima's D",side=2,line=2.5,cex=2)
		mtext("Position (Mb)",side=1,line=2.5,cex=2)
		mytitle		<- paste("chromosome",my_chrom,sep=" ")
		mtext(mytitle,side=3,line=0,cex=2)
		}else{
		mtext(my_chrom,side=3,line=-1,cex=0.75)
		}
	if(addinfo)
		{
		mysubtitle	<- paste("window size:",winsize/1000000,"Mb",sep=" ")
		mtext(mysubtitle,side=3,line=subtitlepos,cex=1.5)
		}
	# plot number of snps per window:
	if(addinfo)
		{
		par(new=TRUE)
		mymin2	<- min(wintaj$mean_nsites,na.rm=TRUE)
		mymax2	<- max(wintaj$mean_nsites,na.rm=TRUE)
		myrange2<- mymax2-mymin2
		myrange1<- mymax-mymin
		mypop	<- popnames[1]
		plot(wintaj$mid[wintaj$pop==mypop],wintaj$mean_nsites[wintaj$pop==mypop],col="white",type='l',yaxt='n',xaxt=myxaxt,ylab="",xlab="",xaxt='n',ylim=c(mymin2,myrange1*mymax2))
		polygon(x=c(wintaj$mid[wintaj$pop==mypop],rev(wintaj$mid[wintaj$pop==mypop])),y=c(rep(0,length(wintaj$mean_nsites[wintaj$pop==mypop])),rev(wintaj$mean_nsites[wintaj$pop==mypop])),col="grey",border=NA)
		axis(side=4,las=1)
		if(addlab)
			{
			mtext("SNPs per window",side=4,cex=2,line=3.5)
			}
		par(new=TRUE)
		plot(wintaj$mid[wintaj$pop==mypop]/1000000,wintaj$TajimaD[wintaj$pop==mypop],col=mycols[1],type='l',ylim=c(mymin,mymax),xaxt=myxaxt,ylab="",xlab="",main="",yaxt='n',xaxt='n')
		# last two lines are needed to add outlier borders
		}
	# add Tajima's D outlier borders:
	abline(h=c(2,-2),lty=2)
	if(addinfo)
		{
		text(x=0,y=-2,"positive selection",adj=c(0,1.25),cex=1)
		text(x=0,y=2,"balancing selection",adj=c(0,-0.5),cex=1)
		}
	if(export){dev.off()}
	}
	
# depends on output of calcpi with flag pi_per_pop set to TRUE:
plottajd<-function(tajdtable=NULL,genome_wide=FALSE,nsites=NULL,nsegsites=NULL,popnames=mysambar$poporder,export=TRUE,insetbarplot=TRUE,legendcex=2,symbolsize=2)
	{
	# if genome_wide is set to FALSE, nucleotide diversity (pi) and Watterson theta are for snp dataset only 
	# if genome_wide is set to TRUE, nucleotide diversity (pi) and Watterson theta are genome wide (i.e. * segregating/sequenced sites)
	if(insetbarplot&length(popnames)==1)
		{
		return(cat("Only 1 population defined. No space in plot for inset. Set insetbarplot to FALSE.",sep="\n"))
		}
	popnind <- as.vector(table(inds$pop[inds$filter]))
	popbool	<- popnind>1
	if(any(!popbool))
		{
		return(cat("Populations present with only 1 individual. Not generating Tajima's D plots.",sep="\n"))
		}
	npops	<- length(popnames)
	mycols	<- mysambar$colorder
	if(!is.null(tajdtable))
		{
		if(nrow(tajdtable)!=length(popnames))
			{
			return(cat("ERROR: Number of rows in input tajdtable does not equal number of populations.",sep="\n"))
			}else{
			tajd	<- tajdtable	# else: tajd should be in environment, created by calcpi(pi_per_pop=TRUE)
			}
		}
	if(is.null(mysambar$tajd))
		{
		calcpi(pi_per_pop=TRUE)
		}
	if(nrow(mysambar$tajd)!=length(popnames))
		{
		calcpi(pi_per_pop=TRUE)
		}
	tajd	<- mysambar$tajd
	mywatt	<- tajd$Watterson_scaled		# tajd$Watterson/tajd$mean_nsites	
	mypi	<- tajd$pi_scaled				# tajd$mean_pi/tajd$mean_nsites
	mytajd	<- tajd$TajimaD_scaled			# tajd$TajimaD/tajd$mean_nsites
	if(genome_wide)
		{
		if(is.null(nsegsites))
			{
			indstemp	<- inds[,c("pop","nsegsites3")]
			aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean,na.rm=TRUE)
			myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			if(length(nsegsites)!=npops)
				{		
				return(cat("The length of vector input to nsegsites does not equal the number of populations. SambaR can not generate Tajima's D plot.",sep="\n"))
				}else{
				myseg		<- nsegsites			
				}
			}
		if(is.null(nsites))
			{
			indstemp	<- inds[,c("pop","allseqsites")]
			aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			allsites	<- nsites
			}
		mywatt	<- mywatt*myseg/allsites*100
		mypi	<- mypi*myseg/allsites*100
		mytajd	<- mytajd*myseg/allsites*100
		myscores<<- cbind(mywatt,mypi,mytajd)
		}
	mymin	<- min(mywatt,mypi)-0.02
	mymax	<- max(mywatt,mypi)+0.02
	myrange	<- c(mymin,mymax)
	if(export)
		{
		if(genome_wide)
			{
			plotname	<- ifelse(insetbarplot,"Wattersontheta_vs_pi.withTajima.genomewide.pdf","Wattersontheta_vs_pi.genomewide.pdf")
			}else{
			plotname	<- ifelse(insetbarplot,"Wattersontheta_vs_pi.withTajima.snpdata.pdf","Wattersontheta_vs_pi.snpdata.pdf")
			}
		pdf(plotname,height=8,width=8)		
		}
	par(fig = c(0,1,0,1),cex.axis=1.5,cex.lab=2,mar=c(5,6,2,1))
	plot(mywatt,mypi,xlim=myrange,ylim=myrange,las=1,col=mycols,pch=16,cex=symbolsize,ylab="",xlab="")
	lines(x=c(0,1),y=c(0,1),lty=2)
	#text(0.11,0.105,"Excess of rare alleles",srt=45,adj=c(0,1),cex=1.5) 	
	#text(0.105,0.11,"Lack of rare alleles",srt=45,adj=c(0,0),cex=1.5) 
	mymin2<-mymin+0.0075
	text(mymin2,mymin2-0.00375,"Excess of rare alleles",srt=45,adj=c(0,1),cex=1.5) 	
	text(mymin2-0.00375,mymin2,"Lack of rare alleles",srt=45,adj=c(0,0),cex=1.5) 
	mtext("Nucleotide diversity (%)",side=2,line=4,cex=2)
	mtext("Watterson's theta (%)",side=1,line=3,cex=2)
	legend("topleft",popnames,fill=mycols,cex=legendcex,bty='n')
	if(insetbarplot)
		{
		if(all(popbool))
			{
			barwidth	<- 0.3/npops 
			myx			<- 1-(npops*barwidth)-0.025
			myx			<- ifelse(myx<0.1,0.1,myx)
			par(fig=c(myx,0.975,0.025,0.425),new=TRUE)
			mymin2		<- min(mytajd)-0.002
			mymax2		<- max(mytajd)+0.002
			myrange2	<- c(mymin2,mymax2)
			barplot(mytajd,col=mycols,las=1,ylim=myrange2,border=mycols,space=0.1)
			if(npops>2)		# with less populations, the title doesn't fit
				{
				mtext(side=3,"Tajima's D",line=0.5,cex=1.5)
				}
			}else{
			cat("Not including Tajima's D barplot because at least one populations contains only 1 individual only.",sep="\n") 
			}
		}	
	if(export){dev.off()}
	#
	# separate barplot Tajima's D:
	if(!insetbarplot)
		{
		if(all(popbool))
			{	
			graphics.off()
			if(export)
				{
				if(genome_wide)
					{
					pdf("TajimaD.barplot.genomewide.pdf")
					}else{
					pdf("TajimaD.barplot.snpdata.pdf")
					}
				}
			par(mar=c(4,8,2.5,2.5))
			barplot(mytajd,col=mycols,border=mycols,space=0.1,horiz=TRUE,main="Tajima's D",names.arg=popnames,las=2)
			if(export){dev.off()}
			}else{
			cat("Not including Tajima's D barplot because at least one populations contains only 1 individual only.",sep="\n") 
			}
		}
	}


#get genome wide heterozygosity and pi:
getgenomepi<-function(nsites=NULL,nsnps=NULL)
	{
	if(is.null(nsites))
		{
		cat("Warning: you did not provide the total number of sequenced sites to the nsites argument.",sep="\n")
		cat("As a result, SambaR will not calculate genome wide estimates.",sep="\n") 
		cat("Instead, the columns 'genomehe' and 'genomepi' are set to NA.",sep="\n")
		inds$genomepi			<<- NA
		inds$genomehe			<<-	NA
		}else{
		if(is.null(inds$pi))
			{
			cat("Column inds$pi not found. Generating now using the calcpi function...",sep="\n")
			calcpi(pi_per_pop=TRUE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,corrected=TRUE,silent=TRUE)
			}
		if(is.null(nsnps))
			{
			n_snps					<- inds$nsegsites4		# 08072019: instead of: nrow(snps)
			}else{
			n_snps					<- nsnps
			}
		inds$genomepi			<<- inds$pi*n_snps/nsites
		inds$genomehe			<<-	inds$hetero_all*n_snps/nsites
		# Two possibilities:
		# genomepi				<<- (pi * length(snps[i,]))/allsites
		# genomepi2				<<- (pi * length(snps[i,snps$popmaf>0]))/allsites
		# You could argue in favour of both, but I got the impression genomepi gives me more credible estimates than genomepi2, so I went with genomepi.
		}
	}

# old version (which calculates pi based on a sample of individuals (4) rather than all individuals):	
getpi<-function(nsites=NULL,nsample=4,popnames=mysambar$populations)
	{
	# This function calculates pi: the average number of variant sites when randomly drawing 2 sequences from a population.
	# We calculate two versions:
	# pi						(hetero * length(snps[i,]))/allsites
	# pi2					(hetero * length(snps[i,snps$popmaf>0]))/allsites
	# You could argue in favour of both, but I think pi gives me more credible estimates than pi2.
	if(is.null(nsites))
		{
		return(cat("ERROR: you need to provide the total number of sequenced sites to the nsites argument.",sep="\n"))
		}
	# Create matrix
	nsnps					<- nrow(snps)
	npops					<- length(popnames)
	for(j in c(1:npops))
		{
		mypop				<- popnames[j]
		myinds				<- inds$nr[inds$pop==mypop]
		ninds				<- length(myinds)
		for (i in c(1:ninds))
			{
			myind1			<- myinds[i]
			myind2			<- rep(myind1,nsample)
			otherinds1		<- inds$nr[inds$pop==mypop&inds$filter]
			otherinds2		<- otherinds1[!(otherinds1 == myind1)]
			otherinds3		<- sample(otherinds2,nsample,replace=FALSE)
			combitabletemp	<- rbind(myind2,otherinds3)
			if(i==1&&j==1)
				{
				combitable	<- combitabletemp
				}else{
				combitable	<- cbind(combitable,combitabletemp)
				}
			}
		}
	npairs					<- ncol(combitable)
	mydiffmatrix			<<- as.data.frame(matrix(NA,nrow=npairs,ncol=9))
	colnames(mydiffmatrix)	<<- c("ind1","ind2","pop1","pop2","diff","nsites","allsites","pi","pi2")
	# to find number of clusters, maybe try the R package modes?
	# modes(data,nmore=2)[1,][rev(order(modes(data,nmore=2)[2,]))]
	for (i in c(1:npairs))
		{
		# cat(paste(i,"out of",npairs,"pairwise comparisons",sep =" "),sep="\n")
		myind1				<- combitable[1,i]
		myind2				<- combitable[2,i]
		mygeno				<- as.matrix(mygenlight[inds$nr==myind1|inds$nr==myind2,snps$filter])
		genosum				<- !is.na(colSums(mygeno))
		ngeno				<- length(genosum[genosum])
		ndiff				<- vector() 
		for (j in c(1:ncol(mygeno)))
			{
			geno1			<- mygeno[1,j]
			geno2			<- mygeno[2,j]
			ndiff[j]		<- ifelse((!genosum[j]),0,ifelse(((geno1==0&&geno2==0)||(geno1==2&&geno2==2)),0,ifelse((geno1==0&&geno2==2)||(geno1==2&&geno2==0),1,0.5)))
			}
		mymeandiff			<- round((sum(ndiff,na.rm=TRUE)/ngeno),3)
		npoly				<- inds$nsegsites1[inds$nr==myind1]
		mydiffmatrix[i,1]	<<- myind1
		mydiffmatrix[i,2]	<<- myind2
		mydiffmatrix[i,3]	<<- inds$pop[inds$nr==myind1]
		mydiffmatrix[i,4]	<<- inds$pop[inds$nr==myind2]
		mydiffmatrix[i,5]	<<- mymeandiff
		mydiffmatrix[i,6]	<<- ngeno
		mydiffmatrix[i,7]	<<- nsites
		mydiffmatrix[i,8]	<<- mymeandiff*nsnps/nsites	
		mydiffmatrix[i,9]	<<- mymeandiff*npoly/nsites	
		# you might wonder: why not multiply with ngeno rather than nsnps? 
		# ngeno is nsnps - nmissing		# with nmissing being number of missing data points
		# missing data points are not considered in calculation (as we divide by ngeno, and as non missing data points are set to 0)																
		# so meandiff is truly the probability of heterozygous site if you compare two 2 randomly drawn sequences (after all: it is an average, not a sum) 
		# this is the probability over the entire snp data set (polymorphic sites in retained reads)
		# we want to rescale to all sites (also non-polymorphic sites in retained reads)  
		# hence we multiply with nsnps (and more specifically: all polymorphic sites, also the ones which don't meet filter criteria)									 
		}
	pitemp				<- aggregate(mydiffmatrix$pi,list(mydiffmatrix$ind1),mean)
	colnames(pitemp)		<- c("nr","pi")
	pitemp2				<- aggregate(mydiffmatrix$pi2,list(mydiffmatrix$ind1),mean)
	colnames(pitemp2)	<- c("nr","pi")
	inds$pi				<<- pitemp$pi
	# inds$pi2			<<- pitemp2$pi
	inds$autozygosity2	<<- 1-inds$genomehe/inds$pi
	}
	
plotpi_vs_he<-function(export=NULL,mycolours=mysambar$mycolours,popnames=mysambar$populations,adddiscarded=FALSE,genomewide=TRUE)
	{	
	if(genomewide)
		{
		if(!"genomepi"%in%colnames(inds))
			{
			return(cat("Column 'genomepi' not present in inds dataframe. Omitting 'he_vs_pi' plot.",sep="\n"))
			}
		if(!"genomehe"%in%colnames(inds))
			{
			return(cat("Column 'genomehe' not present in inds dataframe. Omitting 'he_vs_pi' plot.",sep="\n"))
			}
		}
	graphics.off()
	if(!is.null(export))
		{
		mylabel	<- ifelse(genomewide,"genomewide","snpdata")
		if(export=="eps"){postscript(paste("he_vs_pi",mylabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("he_vs_pi",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("he_vs_pi",mylabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("he_vs_pi",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)	
	if(genomewide)
		{
		mypi				<- inds$genomepi*100
		mygenomehe			<- inds$genomehe*100
		myylab				<- "Genome wide heterozygosity (%)"
		}else{
		mypi				<- inds$pi*100
		mygenomehe			<- inds$hetero_all*100
		myylab				<- "Heterozygosity (%)"
		}
	mymin				<- 0.95*min(c(min(mypi[inds$filter],min(mygenomehe[inds$filter]))))
	mymax				<- 1.05*max(c(max(mypi[inds$filter],max(mygenomehe[inds$filter]))))
	plot(mypi[inds$filter],mygenomehe[inds$filter],xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="Nucleotide diversity (%)",ylab=myylab,cex=2,col="white")
	npops					<- length(popnames)
	mycolours				<- mycolours[1:npops]
	for (j in c(1:npops))
		{
		mypop				<- popnames[j]
		points(mypi[inds$pop==mypop&inds$filter],mygenomehe[inds$pop==mypop&inds$filter],col=mycolours[j],pch=16,cex=2)
		if(adddiscarded)
			{
			points(mypi[inds$pop==mypop&!inds$filter],mygenomehe[inds$pop==mypop&!inds$filter],col=mycolours[j],cex=2)
			}
		}
	lines(c(0,100),c(0,100))
	if(!is.null(export)){dev.off()}
	}	

plotcompareF<-function(export=NULL,mycolours=mysambar$mycolours,popnames=mysambar$populations,adddiscarded=FALSE,genomewide=TRUE)
	{	
	if(!"F"%in%colnames(inds))
		{
		return(cat("Column 'F' not present in inds dataframe (which is generated by calckinship function). Omitting 'Inbreeding_Fpi_vs_Fh' plot.",sep="\n"))	
		}
	if(genomewide)
		{
		if(!"autozygosity2"%in%colnames(inds))
			{
			return(cat("Column 'autozygosity2' not present in inds dataframe. Omitting 'Inbreeding_Fpi_vs_Fh' plot.",sep="\n"))
			}
		}else{
		if(!"autozygosity"%in%colnames(inds))
			{
			return(cat("Column 'autozygosity' not present in inds dataframe. Omitting 'Inbreeding_Fpi_vs_Fh' plot.",sep="\n"))
			}
		}
	graphics.off()
	if(!is.null(export))
		{
		mylabel	<- ifelse(genomewide,"genomewide","snpdata")
		if(export=="eps"){postscript(paste("Inbreeding_Fpi_vs_Fh",mylabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("Inbreeding_Fpi_vs_Fh",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("Inbreeding_Fpi_vs_Fh",mylabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("Inbreeding_Fpi_vs_Fh",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)	
	if(genomewide)
		{
		myauto				<- inds$autozygosity2
		}else{
		myauto				<- inds$autozygosity
		}
	myylab				<- "F_pi"
	mymin				<- 0.95*min(c(min(myauto[inds$filter],min(inds$F[inds$filter]))))
	mymax				<- 1.05*max(c(max(myauto[inds$filter],max(inds$F[inds$filter]))))
	plot(inds$F[inds$filter],myauto[inds$filter],xlim=c(mymin,mymax),ylim=c(mymin,mymax),xlab="F_h",ylab=myylab,cex=3,col="white")
	lines(c(-100,100),c(-100,100))
	npops					<- length(popnames)
	mycolours				<- mycolours[1:npops]
	for (j in c(1:npops))
		{
		mypop				<- popnames[j]
		points(inds$F[inds$pop==mypop&inds$filter],myauto[inds$pop==mypop&inds$filter],pch=16,cex=3,col=mycolours[j])
		if(adddiscarded)
			{
			points(inds$F[inds$pop==mypop&!inds$filter],myauto[inds$pop==mypop&!inds$filter],pch=16,cex=3,col=mycolours[j])
			}
		}
	if(!is.null(export)){dev.off()}
	}	

# requires package vioplot if dostripchart is set to FALSE
plotsampleHe<-function(popnames=mysambar$poporder,yrange=c(0,0.55),yrange2=c(0.0005,0.0025),mycolours=mysambar$colorder,shortpop=NULL,allsites=FALSE,dostripchart=FALSE)
	{
	if(allsites&!("genomehe"%in%colnames(inds)))
		{
		return(cat("ERROR: column 'genomehe' not present in inds dataframe. Set flag allsites to FALSE.",sep="\n"))
		}
	if(is.null(shortpop))
		{
		shortpop<-substr(popnames,1,2)
		}
	x 			<- rnorm(100)
	y 			<- rnorm(100)
	npop		<- length(popnames)
	mycolours	<- mycolours[1:npop]
	if(allsites)
		{
		#cat("You have set nsites=TRUE. Plot will show genome wide heterozygosity (inds$genomehe) which you calculated when setting nsites=TRUE with the function 'pophetero'.",sep="\n")
		#myyrange <- yrange2	# 21052019: flag 'yrange2' can probably be removed
		myyrange <- c(min(inds$genomehe[inds$filter]),max(inds$genomehe[inds$filter]))
		}else{
		#myyrange <- yrange		# 21052019: flag 'yrange' can probably be removed
		myyrange <- c(min(inds$hetero[inds$filter]),max(inds$hetero[inds$filter]))
		}	
	par(cex.axis=2.5,cex.lab=3,cex.main=3.5)
	if(dostripchart)
		{
		indstemp		<- droplevels(inds[inds$filter,])
		if(allsites)
			{
			boxplot(indstemp$genomehe~indstemp$poporder,border=mycolours,names=shortpop,col="grey90",xlab="",ylab="",cex.axis=2.5,pch=16,outline=FALSE)
			stripchart(genomehe~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2.5,col=mycolours,bg="bisque",add=TRUE) 
			}else{
			boxplot(indstemp$hetero~indstemp$poporder,border=mycolours,names=shortpop,col="grey90",xlab="",ylab="",cex.axis=2.5,pch=16,outline=FALSE,las=3)
			stripchart(hetero~poporder,data=indstemp,vertical=TRUE,method="jitter",pch=16,cex=2.5,col=mycolours,bg="bisque",add=TRUE) 
			}
		}else{
		if(allsites)
			{
			myheteroallinds	<- inds$genomehe[inds$filter]
			}else{
			myheteroallinds	<- inds$hetero[inds$filter]
			}
		plot(x, y, xlim=c(0.5,npop+0.5),ylim=c(0.975*min(myheteroallinds,na.rm=TRUE),1.025*max(myheteroallinds,na.rm=TRUE)),col="white",xaxt="n",xlab="",ylab="")
		for (i in c(1:npop))
			{
			mypop			<- popnames[i]
			if(allsites)
				{
				myhetero	<- inds$genomehe[inds$pop==mypop&inds$filter]
				}else{
				myhetero	<- inds$hetero[inds$pop==mypop&inds$filter]
				}
			vioplot(myhetero,at=i,add=TRUE,names=popnames[i],col=mycolours[i])
			}
		axis(side=1,at=seq(1,npop),labels=shortpop,lty=1,las=3)
		}
	# mtext("Population",1,line=2.5,cex=1.25)
	mtext("Proportion of heterozygote sites",2,line=3.5,cex=2.5)
	if(allsites)
		{
		mtext("For all sites",3,line=-2.5,cex=2)
		}else{
		mtext("For segregating sites only",3,line=-2.5,cex=2)
		}
	}

# This function uses the plotsampleHe function
plotgenomehe<-function(popnames=mysambar$populations,shortpop=NULL,nsites=NULL,nsegsites=NULL,mycolours=mysambar$mycolours,export=NULL,dofilter=FALSE,do_stripchart=FALSE)
	{
	npops		<- length(popnames)
	mycolours	<- mycolours[1:npops]
	if(is.null(shortpop))
		{
		shortpop<- substr(popnames,1,2)
		}
	# derive proportion of segregating sites:
	if(is.null(nsegsites))
		{
		indstemp	<- inds[,c("pop","nsegsites3")]
		aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
		}else{
		if(length(nsegsites)!=npops)
			{		
			return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
			}else{
			myseg		<- nsegsites			
			}
		}
	if(is.null(nsites))
		{
		indstemp	<- inds[,c("pop","allseqsites")]
		aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
		myseg		<- myseg/allsites
		}else{
		myseg		<- myseg/nsites
		}
	# Plot:
	if(!is.null(export))
		{
		mylabel		<- ifelse(do_stripchart,"stripchart","vioplot")
		if(export=="eps"){postscript(paste("pi.pop",mylabel,"eps",sep="."),family=mysambar$myfont,width=25,height=10)}
		if(export=="pdf"){pdf(paste("pi.pop",mylabel,"pdf",sep="."),family=mysambar$myfont,width=25,height=10)}
		if(export=="png"){png(paste("pi.pop",mylabel,"png",sep="."),family=mysambar$myfont,width=1800,height=720)}
		if(export=="wmf"){win.metafile(paste("pi.pop",mylabel,"wmf",sep="."),family=mysambar$myfont,width=25,height=10)}
		}
	par(mfrow=c(1,3),mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
	# layout(matrix(c(1,2,3),1,3))
	# Plot proportion of segregating sites:
	if(do_stripchart)
		{
		par(lwd=4)
		xx<-barplot(myseg,names.arg=shortpop,col="grey",border=mycolours,ylab=NULL,ylim=c(0,max(myseg)+1/10*max(myseg)),xpd = FALSE)
		par(lwd=1)
		}else{
		xx<-barplot(myseg,names.arg=shortpop,col=mycolours,ylab=NULL,ylim=c(0,max(myseg)+1/10*max(myseg)),xpd = FALSE)
		}
	text(x = xx, y = myseg,label=round(myseg,4),pos=3,cex=3.5,col="black")
	mtext("Proportion of segregating sites",side=2,line=3.5,cex=2.5)
	# Plot he for segregating sites:
	plotsampleHe(allsites=FALSE,dostripchart=do_stripchart)
	# Plot pi:
	plotsampleHe(allsites=TRUE,dostripchart=do_stripchart)
	mtext("Nucleotide diversity",3,line=-3.5,cex=3,outer=TRUE)
	mtext("Population",1,line=-1.5,cex=2.5,outer=TRUE)
	if(!is.null(export)){dev.off()}
	}

# summary statistics:
popstats<-function(popnames=mysambar$populations,nsites=NULL,u=1.0*10^-8)
	{
	npops				<- length(popnames)
	mystats				<- as.data.frame(matrix(NA,nrow=npops+1,ncol=13))
	colnames(mystats)	<- c("pop","n_inds","maf_all","maf_seg","MLH","sMLH","n_snps","nsequenced","S","genomehe","genomepi","Ne_he","Ne_pi")
	mystats$pop[1]		<- "Metapop"
	mystats$n_inds[1]	<- nrow(inds[inds$filter,])
	mystats$maf_all[1]	<- round(mean(inds$maf_all[inds$filter]),3)  
	mystats$maf_seg[1]	<- round(mean(inds$maf[inds$filter]),3)  
	mystats$MLH[1]		<- round(mean(inds$hetero_all[inds$filter],na.rm=TRUE),3)			# multilocus heterozygosity (same as inds$MLH and inds$hetero_all)  
	if("sMLH"%in%colnames(inds))
		{
		mystats$sMLH[1]		<- round(mean(inds$sMLH[inds$filter],na.rm=TRUE),3)					# standardized multilocus heterozygosity (same as inds$MLH and inds$hetero_all)  
		}else{
		mystats$sMLH[1]		<- NA
		}
	mystats$n_snps[1]	<- round(mean(inds$nsites_nofilter[inds$filter]))	
	myvector			<- snps$maf
	nsegsites			<- length(myvector[myvector>0])
	if(!is.null(nsites))
		{
		if(length(nsites)==1)
			{
			mystats$S[1]		<- round(nsegsites/nsites,4)
			}else{
			mystats$S[1]		<- round(nsegsites/max(nsites),4)
			}
		mystats$nsequenced[1]<- nsites
		mystats$genomehe[1]	<- round(mean(inds$genomehe[inds$filter]),4)
		mystats$genomepi[1]	<- round(mean(inds$genomepi[inds$filter]),4)
		#mystats$Watterson[1]<- round(mean(inds$Watterson_scaled[inds$filter]),4)
		#mystats$TajimaD[1]	<- round(mean(inds$TajimaD_scaled[inds$filter]),4)
		cat(paste("Ne is calculating as pi/4*u, with u (generation mutation rate) set to ",u,". You can change this value using the u flag (or u_g flag if you invoke the popstats function using the calcdiversity function).",sep=""),sep="\n") 
		mystats$Ne_he[1]		<- round(mean(inds$genomehe[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
		mystats$Ne_pi[1]		<- round(mean(inds$genomepi[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = pi/4u
		}else{
		mystats$S[1]			<- NA
		mystats$nsequenced[1]	<- NA
		mystats$genomehe[1]		<- NA
		mystats$genomepi[1]		<- NA
		#mystats$Watterson[1]	<- NA
		#mystats$TajimaD[1]		<- NA
		mystats$Ne_he[1]		<- NA
		mystats$Ne_pi[1]		<- NA
		}
	for (i in c(1:npops))
		{
		mypop				<- popnames[i]
		mystats$pop[i+1]	<- mypop
		mystats$n_inds[i+1]	<- nrow(inds[inds$filter&inds$pop==mypop,])
		mystats$maf_all[i+1]<- round(mean(inds$maf_all[inds$filter&inds$pop==mypop]),3)  
		mystats$maf_seg[i+1]<- round(mean(inds$maf[inds$filter&inds$pop==mypop]),3)  
		mystats$MLH[i+1]	<- round(mean(inds$hetero[inds$filter&inds$pop==mypop]),3) 
		if("sMLH"%in%colnames(inds))
			{
			mystats$sMLH[i+1]	<- round(mean(inds$sMLH[inds$filter&inds$pop==mypop]),3)	
			}else{
			mystats$sMLH[i+1]	<- NA
			}
		mystats$n_snps[i+1]	<- round(mean(inds$nsites_nofilter[inds$filter&inds$pop==mypop]))	
		myvector			<- snps[,names(snps) == paste("maf",mypop,sep="_")]
		nsegsites			<- length(myvector[myvector>0])
		if(!is.null(nsites))
			{
			if(length(nsites)==1)
				{
				mystats$S[i+1]			<- round(nsegsites/nsites,4)
				}else{
				mystats$S[i+1]			<- round(nsegsites/nsites[i],4)
				}
			mystats$nsequenced[i+1]	<- nsites
			mystats$genomehe[i+1]	<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop]),4) 
			mystats$genomepi[i+1]	<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop]),4) 
			#mystats$Watterson[i+1]	<- round(mean(inds$Watterson_scaled[inds$filter&inds$pop==mypop]),4)
			#mystats$TajimaD[i+1]	<- round(mean(inds$TajimaD_scaled[inds$filter&inds$pop==mypop]),4)
			mystats$Ne_he[i+1]		<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
			mystats$Ne_pi[i+1]		<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop])/(4*u))  # theta = pi = 4Neu, hence: Ne = pi/4u
			}else{
			mystats$S[i+1]			<- NA
			mystats$nsequenced[i+1]	<- NA
			mystats$genomehe[i+1]	<- NA
			mystats$genomepi[i+1]	<- NA
			#mystats$Watterson[i+1]	<- NA
			#mystats$TajimaD[i+1]	<- NA
			mystats$Ne_he[i+1]		<- NA
			mystats$Ne_pi[i+1]		<- NA
			}
		} 
	mystats	<- t(mystats)
	write.table(mystats,"SambaR.popdiversity.stats.txt",row.names=TRUE,col.names=FALSE,quote=FALSE,sep="\t")
	}


# summary statistics:
popstats_old<-function(popnames=mysambar$populations,nsites=NULL,u=1.0*10^-8)
	{
	npops				<- length(popnames)
	mystats				<- as.data.frame(matrix(NA,nrow=npops+1,ncol=16))
	colnames(mystats)	<- c("pop","n","maf_all","ho_all","he_all","perc_He_deficit","perc_He_surplus","maf_seg","ho_seg","he_seg","F_seg","S","genomehe","genomepi","Ne_he","Ne_pi")
	mystats$pop[1]		<- "Metapop"
	mystats$n[1]		<- nrow(inds[inds$filter,])
	mystats$maf_all[1]	<- round(mean(inds$maf_all[inds$filter]),3)  
	mystats$ho_all[1]	<- round(mean(inds$hetero_all[inds$filter]),3)  
	mystats$he_all[1]	<- round(mean(inds$expHe_all[inds$filter]),3)  
	mystats$perc_He_deficit[1]<-mysambar$hwetable[1,3]
	mystats$perc_He_surplus[1]<-mysambar$hwetable[1,4]
	mystats$maf_seg[1]	<- round(mean(inds$maf[inds$filter]),3)  
	mystats$ho_seg[1]	<- round(mean(inds$hetero[inds$filter]),3) 
	mystats$he_seg[1]	<- round(mean(inds$expHe[inds$filter]),3) 
	mystats$F_seg[1]	<- round(mean(inds$F[inds$filter]),3)  
	myvector			<- snps$maf
	nsegsites			<- length(myvector[myvector>0])
	if(!is.null(nsites))
		{
		if(length(nsites)==1)
			{
			mystats$S[1]		<- round(nsegsites/nsites,4)
			}else{
			mystats$S[1]		<- round(nsegsites/max(nsites),4)
			}
		mystats$genomehe[1]	<- round(mean(inds$genomehe[inds$filter]),4)
		mystats$genomepi[1]	<- round(mean(inds$genomepi[inds$filter]),4)
		cat(paste("Ne is calculating as pi/4*u, with u (generation mutation rate) set to ",u,". You can change this value using the u flag (or u_g flag if you invoke the popstats function using the calcdiversity function).",sep=""),sep="\n") 
		mystats$Ne_he[1]		<- round(mean(inds$genomehe[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
		mystats$Ne_pi[1]		<- round(mean(inds$genomepi[inds$filter])/(4*u))  # theta = he = 4Neu, hence: Ne = pi/4u
		}else{
		mystats$S[1]			<- NA
		mystats$genomehe[1]		<- NA
		mystats$genomepi[1]		<- NA
		mystats$Ne_he[1]		<- NA
		mystats$Ne_pi[i]		<- NA
		}
	for (i in c(1:npops))
		{
		mypop				<- popnames[i]
		mystats$pop[i+1]	<- mypop
		mystats$n[i+1]		<- nrow(inds[inds$filter&inds$pop==mypop,])
		mystats$maf_all[i+1]<- round(mean(inds$maf_all[inds$filter&inds$pop==mypop]),3)  
		mystats$ho_all[i+1]	<- round(mean(inds$hetero_all[inds$filter&inds$pop==mypop]),3)  
		mystats$he_all[i+1]	<- round(mean(inds$expHe_all[inds$filter&inds$pop==mypop]),3)  
		mystats$perc_He_deficit[i+1]<-mysambar$hwetable[i+1,3]
		mystats$perc_He_surplus[i+1]<-mysambar$hwetable[i+1,4]	
		mystats$maf_seg[i+1]<- round(mean(inds$maf[inds$filter&inds$pop==mypop]),3)  
		mystats$ho_seg[i+1]	<- round(mean(inds$hetero[inds$filter&inds$pop==mypop]),3) 
		mystats$he_seg[i+1]	<- round(mean(inds$expHe[inds$filter&inds$pop==mypop]),3) 
		mystats$F_seg[i+1]	<- round(mean(inds$F[inds$filter&inds$pop==mypop]),3)  
		myvector			<- snps[,names(snps) == paste("maf",mypop,sep="_")]
		nsegsites			<- length(myvector[myvector>0])
		if(!is.null(nsites))
			{
			if(length(nsites)==1)
				{
				mystats$S[i+1]			<- round(nsegsites/nsites,4)
				}else{
				mystats$S[i+1]			<- round(nsegsites/nsites[i],4)
				}
			mystats$genomehe[i+1]	<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop]),4) 
			mystats$genomepi[i+1]	<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop]),4) 
			mystats$Ne_he[i+1]		<- round(mean(inds$genomehe[inds$filter&inds$pop==mypop])/(4*u))  # theta = he = 4Neu, hence: Ne = he/4u
			mystats$Ne_pi[i+1]		<- round(mean(inds$genomepi[inds$filter&inds$pop==mypop])/(4*u))  # theta = pi = 4Neu, hence: Ne = pi/4u
			}else{
			mystats$S[i+1]			<- NA
			mystats$genomehe[i+1]	<- NA
			mystats$genomepi[i+1]	<- NA
			mystats$Ne_he[i+1]		<- NA
			mystats$Ne_pi[i+1]		<- NA
			}
		} 
	mystats	<- t(mystats)
	write.table(mystats,"SambaR.popdiversity.stats.txt",row.names=TRUE,col.names=FALSE,quote=FALSE,sep="\t")
	}

plotstats<-function(myfilter=inds$filter,popnames=mysambar$populations)
	{
	layout(matrix(c(1:8),4,2,byrow=FALSE))
	par(mar=c(2,4.0,0.5,0.5),oma=c(3,2,2,2))
	# segregating sites only:
	boxplot(maf[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="MAF",xlab="Population",main="Segregating sites only")
	boxplot(hetero[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="Ho",xlab="Population")
	boxplot(expHe[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="He",xlab="Population")
	boxplot(F[myfilter]~pop[myfilter],data=inds,frame.plot=F,notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="F (1-Ho/He)",xlab="Population",names=popnames)
	# all sites:
	boxplot(maf_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population",names=rep("",length(popnames)),main="All sites")
	boxplot(hetero_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population")
	boxplot(expHe_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,xaxt='n',notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population")
	boxplot(F_all[myfilter]~pop[myfilter],data=inds,frame.plot=F,notch=FALSE,col=c("blue","darkgreen","darkred","orange"),ylab="",xlab="Population",names=popnames)
	mtext("Population",side=1,line=1,outer=TRUE)
	}

multirunsfs<-function(do_silent=TRUE,number_sites=NULL,number_segsites=NULL)
	{
	# For more information on SFS:
	# Hudson, 2015, A new proof of the expected frequency spectrum under the standard neutral model
	myrunnames	<- c("allsnps_NOTimputed","allsnps_imputed","snpfilter_NOTimputed","snpfilter_imputed")
	for(mysfsrun in c(1:4))
		{
		if(!do_silent){cat(myrunnames[mysfsrun],sep="\n")}
		setwd(mysambar$diversitydir)
		sfsfolder	<- paste("SFS",myrunnames[mysfsrun],sep="_")
		if(file.exists(sfsfolder))
			{
			setwd(file.path(mysambar$diversitydir,sfsfolder))
			}else{
			dir.create(file.path(mysambar$diversitydir,sfsfolder))
			setwd(file.path(mysambar$diversitydir,sfsfolder))
			}
		do_snpfilter	<- ifelse(mysfsrun>2,TRUE,FALSE)
		do_imputeddata	<- ifelse(mysfsrun%%2==0,TRUE,FALSE)
		if(!do_silent){cat("Running getfoldedsfs...",sep="\n")}
		getfoldedsfs(dofilter=do_snpfilter,do_impute=do_imputeddata)
		#
		if(do_snpfilter&do_imputeddata)
			{
			sfs_table	<- mysambar$foldedsfstable_snpfilter_imputed
			sfs_heprop	<- mysambar$foldedsfs_prophe_snpfilter_imputed
			sfs_mean	<- mysambar$bootsfsmean_snpfilter_imputed
			sfs_sd		<- mysambar$bootsfssd_snpfilter_imputed
			}
		if((!do_snpfilter)&do_imputeddata)
			{
			sfs_table	<- mysambar$foldedsfstable_imputed
			sfs_heprop	<- mysambar$foldedsfs_prophe_imputed
			sfs_mean	<- mysambar$bootsfsmean_imputed
			sfs_sd		<- mysambar$bootsfssd_imputed		
			}
		if(do_snpfilter&(!do_imputeddata))
			{
			sfs_table	<- mysambar$foldedsfstable_snpfilter
			sfs_heprop	<- mysambar$foldedsfs_prophe_snpfilter
			sfs_mean	<- mysambar$bootsfsmean_snpfilter
			sfs_sd		<- mysambar$bootsfssd_snpfilter
			}
		if((!do_snpfilter)&(!do_imputeddata))
			{	
			sfs_table	<- mysambar$foldedsfstable
			sfs_heprop	<- mysambar$foldedsfs_prophe
			sfs_mean	<- mysambar$bootsfsmean
			sfs_sd		<- mysambar$bootsfssd
			}
		imputelabel		<- ifelse(do_imputeddata,"imputed","NOTimputed")
		# barplots without bootstrap:
		if(!do_silent){cat("Creating barplots withOUT bootstrap...",sep="\n")}
		#barplotsfs(export="eps",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)
		barplotsfs(export="pdf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)
		barplotsfs(export="png",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)
		if(mysambar$os=="Windows"){barplotsfs(export="wmf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=NULL,bootstrapsd=NULL)}
		#
		# barplots with bootstrap error bars:
		if(!do_silent){cat("Creating barplots with bootstrap error bars...",sep="\n")}
		#barplotsfs(export="eps",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)
		barplotsfs(export="pdf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)
		barplotsfs(export="png",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)
		if(mysambar$os=="Windows"){barplotsfs(export="wmf",foldedsfstable=sfs_table,plotlabel=imputelabel,bootstrapmean=sfs_mean,bootstrapsd=sfs_sd)}
		#
		# proportion heterozygous sites per MAC class:
		if(!do_silent){cat("He_per_SFSbin plots...",sep="\n")}
		myplotname	<- paste("He_per_SFSbin",myrunnames[mysfsrun],sep="_")
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		plotsfshe(export="pdf",plotname=myplotname,heproplist=sfs_heprop)
		#
		if(mysfsrun%%2!=0)
			{
			# not yet implemented for imputed data.
			if(length(mysambar$populations)>1)
				{
				if(!do_silent){cat("plot2Dsfs",sep="\n")}
				plot2Dsfs(export="eps",dofilter=do_snpfilter)	
				plot2Dsfs(export="pdf",dofilter=do_snpfilter)
				plot2Dsfs(export="png",dofilter=do_snpfilter)
				if(mysambar$os=="Windows"){plot2Dsfs(export="wmf",dofilter=do_snpfilter)}		
				# combine 2D-SFS plots on one page:
				# if(do_snpfilter)
				#	{
				# 	plot2Dsfs_multi(export="pdf",exportname="SFS.2D.all",mylist=mysambar$sfs2Dlist_snpfilter,inverse=FALSE)
				#	}else{
				#	plot2Dsfs_multi(export="pdf",exportname="SFS.2D.all",mylist=mysambar$sfs2Dlist_allsnps,inverse=FALSE)
				#	}
				}
			}
		if(mysfsrun==3)
			{
			# only available for not imputed, with snp filter
			# SFS binned:
			if(!do_silent){cat("plotsfs",sep="\n")}
			plotsfs(export="eps",silent=do_silent)										# without barplot showing number of segregating sites
			plotsfs(export="pdf",silent=do_silent)
			plotsfs(export="png",silent=do_silent)
			if(mysambar$os=="Windows"){plotsfs(export="wmf",silent=do_silent)}
			plotsfs(export="eps",silent=do_silent,addlegend=FALSE)										
			plotsfs(export="pdf",silent=do_silent,addlegend=FALSE)
			plotsfs(export="png",silent=do_silent,addlegend=FALSE)
			if(mysambar$os=="Windows"){plotsfs(export="wmf",silent=do_silent,addlegend=FALSE)}
			#
			if(!is.null(number_sites))
				{
				cat("Plotting proportion of segregating sites...",sep="\n")
				plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="eps",silent=TRUE)	# with barplot with number of segregating sites is included
				plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="pdf",silent=TRUE)
				plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="png",silent=TRUE)
				if(mysambar$os=="Windows"){plotsfs(nsites=number_sites,addbarplot=TRUE,nsegsites=number_segsites,export="wmf",silent=TRUE)}
				}
			}
		}
	setwd(mysambar$diversitydir)
	}

getfoldedsfs<-function(popnames=mysambar$populations,histo=FALSE,yrange=c(0,nrow(snps)/4),dofilter=FALSE,do_impute=FALSE,nbootstrap=100,silent=TRUE)
	{
	if(do_impute)
		{
		if(is.null(mysambar$imputedmatrix_persnp))
			{
			sambarimpute(per_snp=TRUE)
			}
		inputgenlight	<- as.genlight(mysambar$imputedmatrix_persnp)
		cat("Because the flag do_impute is set to TRUE, SFS vectors are being calculated using imputed dataset.",sep="\n")
		}else{
		inputgenlight	<- mygenlight
		}
	foldedsfs			<- list()
	foldedsfs_prophe	<- list()
	bootsfsmean			<- list()
	bootsfssd			<- list()
	#
	# BACKGROUND INFO: CALCULATION OF MINOR ALLELE COUNTS PER SNP
	# how many (non-)missing data points per SNP?
	# misscount				<- glNA(inputgenlight[inds$filter,],alleleAsUnit=FALSE)
	# nonmissallelecount 	<- 2*(nInd(inputgenlight[inds$filter,])-misscount)
	#
	# glSum: computes the mean number of second allele in each SNP.
	# the second allele is represented twice in genotype 2, and once in genotype 1
	#
	# When considering all individuals, the second allele is always the minor allele
	# However, after filtering out individuals, this could have changed.
	# Imagine you have a dataset of six diploid individuals, with for a certain site the genotypes 2,2,0,0,1,0
	# If individuals 3 and 4 are filtered out, then the remaining genotypes are 2,2,1,0. The second allele has become the major allele.
	# We need to correct for that, and to make sure that we have exclusively counts of the minor allele, and not of the major allele.
	# mymac				<- as.vector(glSum(inputgenlight[inds$filter,]))
	# mymac				<- ifelse(mymac>0.5*nonmissallelecount,nonmissallelecount-mymac,mymac)
	# However, no need to generate this vectors here again, because already generated during importdata() and filterdata() functions, or sambarimpute() function
	#
	nind					<- nrow(inds[inds$filter,])
	if(!do_impute)
		{
		nonmissallelecount	<- snps$nonmissallelecount
		mymac				<- snps$minorcount
		myhecount			<- snps$Aa
		}else{
		#nonmissallelecount	<- rep(2*nind,nrow(snps))			# no missing data in imputed dataset
		nonmissallelecount	<- snps$nonmissallelecount
		mymac				<- snps$imputed_minorcount
		myhecount			<- snps$imputed_Aa
		}
	if(length(mymac)!=length(nonmissallelecount))
		{
		return(cat("ERROR: length of mymac vector (metapopulation) does not correspond with length of nonmissallelecount vector (1).",sep="\n"))
		}
	#mymac					<- ifelse(any(mymac>(0.5*nonmissallelecount)),nonmissallelecount-mymac,mymac)
	mymac					<- ifelse(mymac>(0.5*nonmissallelecount),nonmissallelecount-mymac,mymac)
	#
	if(histo)
		{
		graphics.off()
		par(mfrow=c(1,length(popnames)+1))
		hist(mymac[mymac!=0],ylim=yrange,main="Metapop",xlab=NULL,breaks=seq(0,nrow(inds[inds$filter,]),1))
		}
	#
	# We consider only individuals which passed filter settings:
	nind			<- nrow(inds[inds$filter,])
	if(dofilter)
		{
		# If flag dofilter is set to TRUE, we consider only snps which passed filter settings:
		nonmissallelecount	<- nonmissallelecount[snps$filter]
		mymac				<- mymac[snps$filter]
		myhecount			<- myhecount[snps$filter]
		}
	if(length(mymac)!=length(nonmissallelecount))
		{
		return(cat("ERROR: length of mymac vector (metapopulation) does not correspond with length of nonmissallelecount vector (2).",sep="\n"))
		}
	#mymac				<- ifelse(any(mymac>(0.5*nonmissallelecount)),nonmissallelecount-mymac,mymac)
	mymac				<- ifelse(mymac>(0.5*nonmissallelecount),nonmissallelecount-mymac,mymac)
	if(any(mymac<0,na.rm=TRUE))
		{
		return(cat("ERROR: negative minor allele counts (for metapopulation data). Please contact the developer of SambaR.",sep="\n"))
		}
	#
	# SFS VECTOR METAPOPULATION:
	# the minor allele, being the minor allele, can be represented by maximum 50% of all allele copies
	# in a diploid population, the total number of allele copies is 2*nind
	# hence, the maximum number of allele copies of the minor allele is 2*nind/2 = nind.
	# the sfs-vector is simply a histogram which shows how many SNPs (y-axis: minorclassesfreq) have a certain number of copies of the minor allele (x-axis: minorclasses)
	# In other words, the sfs-vector shows the number of SNPs in which the minor allele is present once, twice, three times, four times, etc.
	minorclasses		<- c(1:nind)	# Note: not c(0:nind), because we ignore monomorphic sites
	minorclassesfreq	<- vector()
	minorclassesheprop	<- vector()
	for (j in minorclasses)
		{
		class_indices		<- which(mymac==j)
		minorclassesfreq[j]	<- length(class_indices)
		# total number heterozygote sites divided by potential number of heterozygote sites (if all minor alleles occur in heterozygote individuals only):
		minorclassesheprop[j]<- sum(myhecount[class_indices],na.rm=TRUE)/(j*minorclassesfreq[j])
		}
	foldedsfs[[1]]			<- minorclassesfreq
	foldedsfs_prophe[[1]]	<- minorclassesheprop
	#
	if(length(minorclassesfreq)!=nind)
		{
		cat("WARNING: Length of the SFS-vector does not equal the number of retained individuals in the overall dataset. Contact developer of SambaR.",sep="\n")
		}
	#
	if(nbootstrap!=0)
		{
		btmatrix		<- matrix(NA,nrow=nbootstrap,ncol=nind)
		for(k in c(1:nbootstrap))
			{
			btmac		<- sample(x=mymac,replace=TRUE,size=length(mymac))
			for (j in minorclasses)
				{
				btmatrix[k,j]	<- length(which(btmac==j))
				}
			}
		bootsfsmean[[1]]	<- round(apply(btmatrix,2,mean,na.rm=TRUE))
		bootsfssd[[1]]		<- round(apply(btmatrix,2,sd,na.rm=TRUE))
		}
	#
	# SFS VECTOR PER POPULATION:
	for (i in (1:length(popnames)))
		{
		if(!silent){cat(popnames[i],sep="\n")}
		mypop				<- as.character(popnames[i])
		nind				<- nrow(inds[inds$filter&as.character(inds$pop)==mypop,])
		#misscount			<- glNA(inputgenlight[inds$filter&inds$pop==popnames[i],],alleleAsUnit=FALSE)
		#nonmissallelecount <- 2*(nInd(inputgenlight[inds$filter&inds$pop==popnames[i],])-misscount)
		#snps$mactemp		<<- as.vector(glSum(inputgenlight[inds$filter&inds$pop==popnames[i],]))
		#snps$mactemp		<<- ifelse(snps$mactemp>0.5*nonmissallelecount,nonmissallelecount-snps$mactemp,snps$mactemp)
		if(!do_impute)
			{
			nonmissallelecount	<- 2*as.vector(snps[,paste("n",popnames[i],sep="_")])
			mymac				<- as.vector(snps[,paste("mac",popnames[i],sep="_")])
			myhecount			<- as.vector(snps[,paste("Aa",popnames[i],sep="_")])
			}else{
			nonmissallelecount	<- rep(2*nind,nrow(snps))						# no missing data in imputed dataset
			if(!silent){cat(nonmissallelecount,sep="\n")}
			mymac				<- as.vector(snps[,paste("imputed_mac",popnames[i],sep="_")])
			myhecount			<- as.vector(snps[,paste("imputed_Aa",popnames[i],sep="_")])
			}
		if(histo)
			{
			#hist(snps$mactemp[snps$mactemp!=0],ylim=yrange,main = popnames[i],xlab=NULL,breaks=seq(0,nrow(inds[inds$filter&as.character(inds$pop)==popnames[i],]),1))
			hist(mymac[mymac!=0],ylim=yrange,main = popnames[i],xlab=NULL,breaks=seq(0,nrow(inds[inds$filter&as.character(inds$pop)==popnames[i],]),1))
			}
		minorclasses			<- c(1:nind)
		if(dofilter)
			{
			nonmissallelecount	<- nonmissallelecount[snps$filter]
			mymac				<- mymac[snps$filter]
			myhecount			<- myhecount[snps$filter]
			}
		if(length(mymac)!=length(nonmissallelecount))
			{
			return(cat("ERROR: length of mymac vector does not correspond with length of nonmissallelecount vector.",sep="\n"))
			}
		mymac					<- ifelse(mymac>0.5*nonmissallelecount,nonmissallelecount-mymac,mymac)
		if(any(mymac<0,na.rm=TRUE))
			{
			return(cat("Negative minor allele counts. Please contact the developer of SambaR.",sep="\n"))
			}
		#
		minorclassesfreq	<- vector()
		minorclassesheprop	<- vector()
		for (j in minorclasses)
			{
			class_indices			<- which(mymac==j)
			minorclassesfreq[j]		<- length(class_indices)
			minorclassesheprop[j]	<- sum(myhecount[class_indices])/(j*minorclassesfreq[j])
			}
		foldedsfs[[i+1]]		<- minorclassesfreq
		foldedsfs_prophe[[i+1]]	<- minorclassesheprop
		#
		#write.table(minorclassesfreq,file=paste("SFSvector",popnames[i],"txt",sep="."),sep="\n",quote=FALSE,col.names=FALSE,row.names=FALSE)
		cat(minorclassesfreq,file=paste("SFSvector",popnames[i],"txt",sep="."),sep=" ")
		#names(snps)[names(snps) == "mactemp"] <<- paste("mac",popnames[i],sep = "_")
		if(length(minorclassesfreq)!=nind)
			{
			cat(paste("WARNING: Length of the SFS-vector does not equal the number of retained individuals in ",popnames[i],". Contact developer of SambaR.",sep=""),sep="\n")
			}
		#
		if(nbootstrap!=0)
			{
			btmatrix		<- matrix(NA,nrow=nbootstrap,ncol=nind)
			for(k in c(1:nbootstrap))
				{
				btmac		<- sample(x=mymac,replace=TRUE,size=length(mymac))
				for (j in minorclasses)
					{
					btmatrix[k,j]	<- length(which(btmac==j))
					}
				}
			bootsfsmean[[i+1]]	<- round(apply(btmatrix,2,mean,na.rm=TRUE))
			bootsfssd[[i+1]]	<- round(apply(btmatrix,2,sd,na.rm=TRUE))
			}
		}
	snps 						<<- snps[, !duplicated(colnames(snps),fromlast=TRUE)]
	names(foldedsfs)			<- c("Metapop",popnames)
	if(nbootstrap!=0)
		{
		names(bootsfsmean)		<- c("Metapop",popnames)
		names(bootsfssd)		<- c("Metapop",popnames)
		}
	#
	if(do_impute)
		{
		if(dofilter)
			{
			mysambar$foldedsfstable_snpfilter_imputed	<<- foldedsfs
			mysambar$foldedsfs_prophe_snpfilter_imputed	<<- foldedsfs_prophe
			mysambar$bootsfsmean_snpfilter_imputed		<<- bootsfsmean
			mysambar$bootsfssd_snpfilter_imputed		<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable_snpfilter_imputed'.",sep="\n")
			}else{
			mysambar$foldedsfstable_imputed				<<- foldedsfs
			mysambar$foldedsfs_prophe_imputed			<<- foldedsfs_prophe
			mysambar$bootsfsmean_imputed				<<- bootsfsmean
			mysambar$bootsfssd_imputed					<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable_imputed'.",sep="\n")
			}
		}else{
		if(dofilter)
			{
			mysambar$foldedsfstable_snpfilter			<<- foldedsfs
			mysambar$foldedsfs_prophe_snpfilter			<<- foldedsfs_prophe
			mysambar$bootsfsmean_snpfilter				<<- bootsfsmean
			mysambar$bootsfssd_snpfilter				<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable_snpfilter'.",sep="\n")
			}else{
			mysambar$foldedsfstable						<<- foldedsfs
			mysambar$foldedsfs_prophe					<<- foldedsfs_prophe
			mysambar$bootsfsmean						<<- bootsfsmean
			mysambar$bootsfssd							<<- bootsfssd
			cat("A list with SFS-vectors (for the metapopulation as well as for each population individually) has been stored at 'mysambar$foldedsfstable'.",sep="\n")
			}
		}
	}

plotsfshe<-function(export=NULL,plotname="He_per_SFSbin",popnames=mysambar$populations,mycolours=mysambar$mycolours,heproplist=mysambar$foldedsfs_prophe_imputed,yline=4,legendpos="bottomleft")
	{
	popnames	<- c("metapop",popnames) 
	npops		<- length(popnames)
	mycolours	<- c("black",mycolours)
	#
	xlabel	<- "Minor allele count (MAC) class"
	ylabel	<- "(sum(#He))/(MAC*nsites)"
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=8,height=8)}
		}
	par(mar=c(4.5,6.5,1.5,0.5),cex.axis=2,cex.lab=2.5,cex.main=2.5)
	for(k in c(1:npops))
		{
		heprop	<- heproplist[[k]]
		if(k==1)
			{
			plot(heprop,col=mycolours[k],pch=16,cex=2,ylim=c(0,1),las=1,xlab=xlabel,ylab="")
			}else{
			points(heprop,col=mycolours[k],pch=16,cex=2)
			}
		}
	mtext(side=2,line=yline,ylabel,cex=3)
	legend(legendpos,legend=popnames,fill=mycolours,cex=2.5,bty='n')
	if(!is.null(export)){dev.off()}
	}

barplotsfs<-function(popnames=mysambar$populations,silent=TRUE,export=NULL,plotlabel="NOTimputed",foldedsfstable=mysambar$foldedsfstable,bootstrapmean=mysambar$bootsfsmean,bootstrapsd=mysambar$bootsfssd)
	{
	npops	<- length(popnames)
	if(is.null(foldedsfstable))
		{
		return(cat("ERROR: Object 'foldedsfstable' is missing. Please first (re)run getfoldedsfs() function.",sep="\n"))
		}
	if(npops+1!=length(foldedsfstable))
		{
		return(cat("ERROR: Unexpected number of populations in 'foldedsfstable' object. Please first (re)run getfoldedsfs() function.",sep="\n"))
		}
	if(is.null(bootstrapsd)|is.null(bootstrapmean))
		{
		if(!silent){cat("WARNING: Object 'bootstrapsd' is missing. Not adding error bars.",sep="\n")}
		}else{
		if((npops+1)!=length(bootstrapmean)|(npops+1)!=length(bootstrapsd))
			{
			return(cat("ERROR: Unexpected number of populations in 'bootstrapsd' and/or 'bootstrapmean' object.",sep="\n"))
			}
		}
	maxn	<- lengths(foldedsfstable[-1])[which(lengths(foldedsfstable[-1])==max(lengths(foldedsfstable[-1])))]
	#
	# POPULATIONS:
	graphics.off()
	if(!is.null(export))
		{
		myheight	<- 8
		myheight2	<- 1000
		mywidth		<- 7
		mywidth2	<- 700
		plotname	<- ifelse(!is.null(bootstrapsd)&!is.null(bootstrapmean),paste("SFSbarplot",plotlabel,"withbootstrap",sep="."),paste("SFSbarplot",plotlabel,sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2*npops+200,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth*npops+2,height=myheight)}
		}
	nindsperpop	<- as.vector(table(inds$pop[inds$filter]))
	mycex		<- ifelse(any(nindsperpop>30),0.25,0.5)
	par(mfrow=c(1,npops),mar=c(2,4.0,0.5,0.5),oma=c(5,7,2,2),cex.axis=mycex)
	mymax		<- max(unlist(foldedsfstable[-1]))*1.15
	for (i in (1:npops))
		{
		mypop	<- popnames[i]
		mysfs	<- unlist(foldedsfstable[names(foldedsfstable)==mypop])
		ninds	<- length(mysfs)
		barcenters	<- barplot(mysfs,col=mysambar$mycolours[i],border=NA,names.arg=c(1:ninds),las=2,ylim=c(0,mymax),yaxt='n')
		axis(side=2,cex.axis=2.5,las=1)
		mtext(mypop,side=3,line=-3.5,cex=3.5)
		if(i==1){mtext("Number of sites",side=2,line=6.75,cex=3.5)}
		#
		if(!is.null(bootstrapsd)&!is.null(bootstrapmean))
			{
			mymean	<- unlist(bootstrapmean[names(bootstrapmean)==mypop])
			mysd	<- unlist(bootstrapsd[names(bootstrapsd)==mypop])
			#segments(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5)
			arrows(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5,angle=90,code=3,length=0.03)
			}
		}
	mtext("Number of minor allele copies",side=1,line=2,cex=3.5,outer=TRUE)
	if(!is.null(export)){dev.off()}	
	#
	# META-POPULATION:
	mysfs	<- foldedsfstable[[1]]
	mymax	<- max(mysfs,na.rm=TRUE)*1.05
	ninds	<- length(mysfs)
	mycex	<- ifelse(ninds>30,0.5,1)
	graphics.off()
	if(!is.null(export))
		{
		myheight	<- 8
		myheight2	<- 800
		mywidth		<- 12
		mywidth2	<- 1200
		plotname	<- ifelse(!is.null(bootstrapsd)&!is.null(bootstrapmean),paste("SFSbarplot_metapopulation",plotlabel,"withbootstrap",sep="."),paste("SFSbarplot_metapopulation",plotlabel,sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=myheight2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=myheight)}
		}
	par(oma=c(1,5,1,1),cex.axis=mycex)
	barcenters	<- barplot(mysfs,col="grey50",border=NA,names.arg=c(1:ninds),las=2,ylim=c(0,mymax),yaxt='n')
	axis(side=2,cex.axis=2.5,las=1)
	mtext("Metapopulation",side=3,line=0,cex=3)
	mtext("Number of sites",side=2,line=7,cex=3)
	#
	if(!is.null(bootstrapsd)&!is.null(bootstrapmean))
		{
		mymean	<- unlist(bootstrapmean[[1]])
		mysd	<- unlist(bootstrapsd[[1]])
		#segments(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5)
		arrows(barcenters,mymean-mysd*2,barcenters,mymean+mysd*2,lwd=0.5,angle=90,code=3,length=0.03)
		}
	mtext("Number of minor allele copies",side=1,line=-1,cex=3,outer=TRUE)
	if(!is.null(export))
		{
		dev.off()
		if(!silent)
			{
			cat("Barplots have been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}	
	}

extractmafdata<-function(mypops=mysambar$populations)
	{
	npops		<- length(mypops)
	for(j in c(1:npops))
		{
		mypop			<- mypops[j]
		maftemp			<- snps[,c(paste("maf2",mypop,sep="_"),"filter")]
		colnames(maftemp)<- c("maf","filter")
		maftemp$species	<- mypop
		if(j==1)
			{
			mymaf		<- maftemp
			}else{
			mymaf		<- rbind(mymaf,maftemp) 
			}
		}
	return(mymaf)
	}

# this function expects maf2 column, generated by getpopmaf-function.
plotsfs<-function(nbins=5,mafbincounts=NULL,addbarplot=FALSE,mylwd=4,labelsize=2.5,mypops=mysambar$populations,nsites=NULL,nsegsites=NULL,export=NULL,shortpop=NULL,mycolours=mysambar$mycolours,silent=FALSE,legendcex=2.5,addlegend=TRUE)
	{
	# You can choose to provide to the mafbincounts argument, a table from which SFS plot will be drawn.
	# This should be a matrix with npop rows and 5 columns with percentages of number of snps in maf bins 0-0.1,0.1-0.2,0.2-0.3,0.3-0.4,0.4-0.5
	# If not provided (default), this function will generate this table.  
	#
	if(addbarplot&is.null(nsites)&!"allseqsites"%in%colnames(inds))
		{
		return(cat("ERROR: addbarplot is TRUE, but nsites is NULL and column 'inds$allseqsites' does not exist either.",sep="\n"))
		}
	# addbarplot can only be set to TRUE if nsites is not
	#
	if(is.null(shortpop))
		{
		shortpop<-substr(mypops,1,2)
		}
	npops		<- length(mypops)
	mycolours	<- mysambar$mycolours[1:npops]
	### SFS ###
	if(is.null(mafbincounts))
		{
		mymaf			<- extractmafdata()
		temp1			<- mymaf
		colnames(mymaf)	<- c("maf","filter","species")
		mymaf			<- mymaf[mymaf$maf!=0,]
		if(nbins==5)
			{
			mylabels		<- seq(0.05,0.45,0.1)
			mymaf$binned	<- cut(mymaf$maf,5, include.lowest=TRUE,labels=mylabels)
			}
		if(nbins==10)
			{
			mylabels		<- seq(0.025,0.475,0.05)
			mymaf$binned	<- cut(mymaf$maf,10, include.lowest=TRUE,labels=mylabels)
			}
		mymafcounts 	<- table(mymaf$species,mymaf$binned)
		# restore order (to order of populations vector):
		temp1			<- rownames(mymafcounts)
		temp2			<- match(temp1,mypops)
		mymafcounts		<- mymafcounts[order(temp1),] 
		write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE)
		mypops			<- mypops[temp2]	
		mycolours		<- mycolours[temp2]	
		if(npops==1)
			{
			write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE,col.names=FALSE)
			mymafcounts		<-  mymafcounts/sum(mymafcounts)*100
			write.table(mymafcounts,"SFS.binned.percentages.txt",sep="\t",quote=FALSE,col.names=FALSE)
			}else{
			write.table(mymafcounts,"SFS.binned.counts.txt",sep="\t",quote=FALSE)
			for(j in c(1:length(mypops)))
				{
				mymafcounts[j,]	<- mymafcounts[j,]/sum(mymafcounts[j,])*100
				}
			write.table(mymafcounts,"SFS.binned.percentages.txt",sep="\t",quote=FALSE)
			}
		}else{
		mymafcounts		<- mafbincounts
		mylabels		<- seq(0.05,0.45,0.1)
		}
	# mymafcounts	<<- mymafcounts
	### SEGREGATING SITES ###
	if(addbarplot)
		{
		if(is.null(nsegsites))
			{
			if(!"nsegsites3"%in%colnames(inds))
				{
				if(!is.null(export)){dev.off()}
				return(cat("ERROR: column 'nsegsites3' is missing from inds dataframe. First run the function: ind_maf(allsites=TRUE)",sep="\n"))
				}
			indstemp	<- inds[,c("pop","nsegsites3")]
			aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
			}else{
			if(length(nsegsites)!=npops)
				{		
				return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
				}else{
				myseg		<- nsegsites			
				}
			}
		if(is.null(nsites))
			{
			indstemp	<- inds[,c("pop","allseqsites")]
			aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
			allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
			myseg		<- myseg/allsites
			}else{
			myseg		<- 100*myseg/nsites
			}
		}
	#
	### PLOT ###
	if(!is.null(export))
		{
		graphics.off()
		mywidth		<- ifelse(addbarplot,12,10)
		mystring	<- ifelse(addbarplot,ifelse(addlegend,"with_barplot","with_barplot.no_legend"),ifelse(addlegend,"no_barplot","no_barplot.no_legend"))
		if(export=="eps"){postscript(paste("SFS.binned",mystring,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="pdf"){pdf(paste("SFS.binned",mystring,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		if(export=="png"){png(paste("SFS.binned",mystring,"png",sep="."),family=mysambar$myfont,width=864,height=720)}
		if(export=="wmf"){win.metafile(paste("SFS.binned",mystring,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=10)}
		}
	if(addbarplot)
		{
		layout(matrix(c(1,1,1,1,1,2,2,2),1,8))
		par(mar=c(4,7,5,2),oma=c(5,4,2,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}else{
		par(mar=c(4,6,5,2),oma=c(5,4,2,2),cex.axis=2.5,cex.lab=3,cex.main=3.5)
		}
	# SFS:
	if(npops>1)
		{
		plot(as.vector(unlist(mymafcounts[1,])),type="b",log="x",col="white",lwd=4,ann=FALSE,xaxt="n",xlab=NULL,ylab=NULL,ylim=c(0,max(mymafcounts)),las=1)
		for(j in c(1:length(mypops)))
			{
			mypop	<- mypops[j]
			npopinds<- nrow(inds[inds$filter&inds$pop==mypop,])
			#cat(mypop,sep="\n")
			#cat(npopinds,sep="\n")
			if(npopinds<5)
				{
				cat(paste("Less than 5 individuals in",mypop,"population. Excluded from plot, because snps with maf<0.1 will be underrepresented."),sep="\n")
				}else{
				points(as.vector(unlist(mymafcounts[j,])),type="b",col=mycolours[j],lwd=mylwd)
				}
			}
		if(addlegend)
			{
			legend("topright",legend=mypops,fill=mycolours,box.lty=0,cex=legendcex)
			}
		}else{
		plot(as.vector(mymafcounts),log="x",type="b",col=mycolours[1],lwd=4,ann=FALSE,xaxt="n",xlab=NULL,ylab=NULL,ylim=c(0,max(mymafcounts)),las=1)
		}
	axis(side=1, at=seq(1,length(mylabels),1), labels=mylabels,las=2)
	mtext("MAF class midpoint",side=1,line=7.5,cex=labelsize)
	mtext("Polymorphic sites (%)",side=2,line=4.5,cex=labelsize)
	#mtext("Folded SFS",side=3,line=0.5,cex=labelsize)
	# SEGREGATING SITES:
	if(addbarplot)
		{
		# Segregating sites:
		xx<-barplot(myseg,names.arg=shortpop,col=mycolours,las=2,ylab=NULL,ylim=c(0,max(myseg)+0.05),cex.names=3)
		text(x = xx, y = myseg,label=round(myseg,2),pos=3,cex=2.5,col="black")
		mtext("Segregating sites (%)",side=2,line=5.75,cex=2.5)
		}else{
		if(!silent)
			{
			cat("The flag 'addbarplot' is set to FALSE. Therefore, barplot with number of segregating sites not included.",sep="\n")
			}
		}
	if(!is.null(export)){dev.off()}	
	}

Sbarplot<-function(shortpop=NULL,mypops=mysambar$populations,labelsize=3,barlabelsize=2.5,nsites=NULL,nsegsites=NULL,mycolours=mysambar$mycolours)
	{
	if(is.null(shortpop))
		{
		shortpop<-substr(mypops,1,2)
		}
	npops		<- length(mypops)
	mycolours	<- mysambar$mycolours[1:npops]
	### SEGREGATING SITES ###
	if(is.null(nsegsites))
		{
		indstemp	<- inds[,c("pop","nsegsites3")]
		aggdata 	<- aggregate(indstemp$nsegsites3,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		myseg		<- aggdata$x[order(as.character(aggdata$Group.1))]
		}else{
		if(length(nsegsites)!=npops)
			{		
			return(cat("The length of vector input to nsegsites does not equal the number of populations",sep="\n"))
			}else{
			myseg		<- nsegsites			
			}
		}
	if(is.null(nsites))
		{
		indstemp	<- inds[,c("pop","allseqsites")]
		aggdata 	<- aggregate(indstemp$allseqsites,by=list(indstemp$pop),FUN=mean, na.rm=TRUE)
		allsites	<- aggdata$x[order(as.character(aggdata$Group.1))]
		myseg		<- myseg/allsites
		}else{
		myseg		<- 100*myseg/nsites
		}
	# plot:
	xx<-barplot(myseg,names.arg=shortpop,col=mycolours,las=2,ylab=NULL,ylim=c(0,max(myseg)+0.05),cex.names=labelsize)
	text(x = xx, y = myseg,label=round(myseg,2),pos=3,cex=barlabelsize,col="black")
	mtext("Segregating sites (%)",side=2,line=5.75,cex=labelsize)
	}

plot2Dsfs_multi<-function(export=NULL,exportname="SFS.2D.all",mylist=mysambar$sfslist,inverse=FALSE)
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	# library(grid)
	# install.packages("gridGraphics")
	# library(gridGraphics)
	# library(gridExtra)
	gl <- lapply(1:length(mylist), function(i){
		pop1		<- mysambar$sfscombitable[1,i]
		pop2		<- mysambar$sfscombitable[2,i]
		mymatrix	<- unclass(mylist[[i]])
		myBreaks	<- mysambar$sfsbreaks[[i]]
		myColours	<- mysambar$sfscolours[[i]]
		mytitle		<- names(sfsmatrix)[i]
		my_margins=c(2.5,2.5)	# under/above,right/left
		heatmap.2(mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=90,key=FALSE,margins=my_margins,adjCol=c(1,0.5),adjRow=c(0,NA),offsetRow = -0.5,offsetCol=-0.5)
		#mtext(myylab, side = 4, line = 1, cex = 2, las=2)
		#mtext(myxlab, side = 1, line = 3.25, cex = 2)
		mtext(pop1, side=2, line = 0.5, cex = 3)
		mtext(pop2, side = 3, line = 0.5, cex = 3)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		#if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=8,width=24,onefile=FALSE)}	# 3 columns
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=24,width=8,onefile=FALSE)}		# 1 column
		if(export=="png"){png(paste(exportname,"png",sep="."),height=1325,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=1325,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=1, clip=TRUE, as.table = FALSE)	
	if(!is.null(export)){dev.off()}
	}

plot2Dsfs<-function(popnames=mysambar$populations,mycolours=mysambar$mycolours,ndecimals=3,export=NULL,dofilter=TRUE)
	{
	# this function generates pairwise 2D-SFS plots
	# this function expects mac columns in snp datasets, produced by 'getfoldedsfs'-function
	#
	# which pairwise comparisons?
	combitable					<- combn(popnames,m=2)
	combicoltable				<- combn(mycolours,m=2)
	multilocusweirfstvector		<- vector()
	npops						<- length(popnames)
	mysambar$sfslist			<<- list()
	mysambar$sfscolours			<<- list()
	mysambar$sfsbreaks			<<- list()
	mysambar$sfscombitable		<<- combitable
	# Do the actual calculation:
	for (i in (1:(ncol(combitable))))
		{
		# cat(i,sep="\n")
		pop1		<- combitable[1,i]
		pop2		<- combitable[2,i]
		if(dofilter)
			{
			mac1		<- snps[snps$filter,paste("mac",pop1,sep="_")]
			mac2		<- snps[snps$filter,paste("mac",pop2,sep="_")]
			}else{
			mac1		<- snps[,paste("mac",pop1,sep="_")]
			mac2		<- snps[,paste("mac",pop2,sep="_")]
			}
		nsamples1	<- length(mac1)
		nsamples2	<- length(mac2)
		nsamples	<- max(c(nsamples1,nsamples2))
		mymatrix	<- table(mac1,mac2)
		mymatrix	<- mymatrix/(sum(mymatrix))*100
		if(nrow(mymatrix)>1&ncol(mymatrix)>1)
			{
			# as colour we are going to use a blend of the two population colours:
			mycol1		<- combicoltable[1,i]
			mycol2		<- combicoltable[2,i]
			mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
			mycol		<- mycolfunc3(3)[2]
			# define colour scale
			mycolfunc1 	<- colorRampPalette(c("grey85",mycol))
			myBreaks1	<- seq(0,0.99,0.01)
			myCol1		<- c(mycolfunc1(length(myBreaks1)-1))
			mycolfunc2 	<- colorRampPalette(c(mycol,"black"))
			mymax		<- ceiling(max(mymatrix))
			myBreaks2	<- seq(1,mymax,1)
			myCol2		<- c(mycolfunc2(length(myBreaks2)-1))
			# combine:
			myBreaks	<- c(myBreaks1,myBreaks2)
			myColours	<- c(myCol1,mycol,myCol2)
			# create plot:
			if(!is.null(export))
				{
				filterlabel	<- ifelse(dofilter,"snpfilter","allsnps")
				myprefix	<- paste("SFS.2D",pop1,pop2,filterlabel,sep="_")
				if(export=="eps"){postscript(paste(myprefix,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="pdf"){pdf(paste(myprefix,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
				if(export=="png"){png(paste(myprefix,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
				if(export=="wmf"){win.metafile(paste(myprefix,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
				}
			mycex<-ifelse(nsamples>35,0.75,1.5)
			heatmap.2(mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=mycex,cexRow=mycex,
			ylab="",xlab="",srtRow=0,srtCol=90,key=FALSE)
			myylab	<- paste("# allele copies in",pop1,sep=" ")
			myxlab	<- paste("# allele copies in",pop2,sep=" ")
			mtext(myylab, side = 4, line = 1, cex = 2)
			mtext(myxlab, side = 1, line = 3.5, cex = 2)
			mtext(paste(pop1,"vs",pop2,sep=" "), side = 3, line = 1, cex = 2.5)
			if(!is.null(export)){dev.off()}
			#
			if(dofilter)
				{
				mysambar$sfs2Dlist_snpfilter[[i]]		<<- mymatrix
				names(mysambar$sfs2Dlist_snpfilter)[i]	<<- paste(pop1,"vs",pop2,sep=" ")
				}else{
				mysambar$sfs2Dlist_allsnps[[i]]			<<- mymatrix
				names(mysambar$sfs2Dlist_allsnps)[i]	<<- paste(pop1,"vs",pop2,sep=" ")
				}
			mysambar$sfscolours[[i]]	<<- myColours
			mysambar$sfsbreaks[[i]]		<<- myBreaks
			}else{
			mypoppair<-paste(pop1,"_",pop2,sep="")
			cat(paste("SFS vector of length 1 for pairwise population comparison:",mypoppair,sep=" "),sep="\n")
			cat("Outputting a table rather than a plot.",sep="\n")
			write.table(mymatrix,paste("SFS.2D",mypoppair,"txt",sep="."),quote=FALSE,row.names=TRUE,col.names=TRUE)
			}
		}
	}

wattersonplot<-function(export=NULL,do_expected=FALSE)
	{
	if(!"pop_ninds"%in%colnames(inds))
		{
		mynind			<- as.data.frame(table(inds$pop[inds$filter]))
		inds$pop_ninds	<- NA
		for (i in c(1:nrow(inds)))
			{
			mypop				<- inds$pop[i]
			mypop2				<- which(mynind$Var1==mypop)
			inds$pop_ninds[i]	<- mynind$Freq[mypop2]
			}
		}
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Watterson.numbers.pdf",height=6,width=6)}
		}
	par(cex.lab=1.5,cex.lab=1.5)
	plot(inds$pop_ninds,inds$nsegsites1,col=inds$popcol,pch=16,cex=1.5,xlab="# individuals",ylab="# segregating sites")
	legend("bottomright",legend=mysambar$populations,fill=mysambar$mycolours,bty='n',cex=1.25)
	#
	# expected S, based on harmonic (unfortunately results don't add up, so I don't include it):
	if(do_expected)
		{
		mymax 	<- max(inds$pop_ninds,na.rm=TRUE)+5
		myrange	<- c(1:mymax)
		myexp	<- vector()
		for(j in myrange)
			{
			myexp[j]	<- sum(1/c(1:(myrange[j]*2))) 
			}
		mypi	<- mean(inds$genomepi,na.rm=TRUE)
		expS	<- mypi*myexp
		}
	if(!is.null(export)){dev.off()}
	if(!"S"%in%colnames(inds))
		{
		cat("No column called 'S' in inds dataframe. Not generating 'Watterson.proportions' plot.",sep="\n")
		cat("The 'S' column is generated by calcdiversity() function if an input is provided to nsites argument.",sep="\n")
		}else{
		inds$harmonic			<<- NA
		for(j in c(1:nrow(inds)))
			{
			inds$harmonic[j]	<<- sum(1/c(1:(inds$pop_ninds[j]*2)))
			}
		if(!"genomepi_pop"%in%colnames(inds))
			{
			mynind					<- as.data.frame(table(inds$genomepi[inds$filter]))
			inds$genomepi_pop	<<- NA
			for (i in c(1:nrow(inds)))
				{
				mypop				<- inds$pop[i]
				mypivector		<- inds$genomepi[inds$pop==mypop]
				inds$genomepi_pop[i]	<<- mean(mypivector,na.rm=TRUE)
				}
			}
		if(!is.null(export))
			{
			if(export=="pdf"){pdf("Watterson.proportions.pdf",height=6,width=6)}
			}
		par(cex.lab=1.5,cex.lab=1.5)
		plot(inds$pop_ninds,inds$S,col=inds$popcol,pch=16,cex=1.5,xlab="# individuals",ylab="Proportion segregating sites")
		legend("bottomright",legend=mysambar$populations,fill=mysambar$mycolours,bty='n',cex=1.25)
		if(do_expected)
			{
			lines(myrange,expS)
			}
		if(!is.null(export)){dev.off()}
		}	
	}	

calcS<-function(popnames=mysambar$populations,export=NULL,plotexpected=FALSE,nsites=NULL,dofilter=FALSE,plotretainedinds=FALSE)
	{
	npops			<- length(popnames)
	ninds			<- nrow(inds[inds$filter,])
	if(dofilter)
		{
		myfilter	<- snps$filter
		}else{
		myfilter	<- rep(TRUE,nrow(snps))
		}
	nsnps			<- nrow(snps[myfilter,])
	polylist		<- list() 
	mymax			<- 1
	for (p in c(1:npops))
		{
		mypop		<- popnames[p]
		#cat(mypop,sep="\n")
		myinds		<- inds$nr[inds$pop==mypop&inds$filter]
		npopinds	<- length(myinds)
		npolyvec	<- rep(NA,npopinds)
		if(npopinds<2)
			{
			cat("Only one retained individual for population:",sep="\n")
			cat(mypop,sep="\n")
			return(cat("Exiting.",sep="\n"))
			}
		svec		<- rep(FALSE,nsnps)
		for (i in c(1:npopinds))
			{
			myind		<- myinds[i]
			mygeno		<- as.matrix(mygenlight[myind,myfilter])
			mygeno[is.na(mygeno)]	<- 3
			svec		<- svec|(mygeno==1|mygeno==2)
			npolyvec[i]	<- length(svec[svec])
			}
		mymax			<- ifelse(max(npolyvec)>mymax,max(npolyvec),mymax)
		polylist[[p]]	<- npolyvec
		}
	xmax	<- max(table(inds$pop[inds$filter]))
	if(!is.null(nsites))
		{
		maxnsites<- max(nsites)	# 01052020: in case of a vector, not sure if it makes sense
		mymax	<- mymax/maxnsites*100
		mysteps	<- ifelse(mymax>1,0.5,ifelse(mymax<0.2,0.05,0.1))
		y_lab	<- "segregating sites (%)"
		}else{
		mysteps	<- ifelse(mymax>20000,10000,ifelse(mymax<10000,1000,2000)) 
		y_lab	<- "# segregating sites (k)"
		}
	if(!is.null(export))
		{
		mylabel		<- ifelse(!is.null(nsites),"genomewide","snpsonly")
		if(export=="eps"){postscript(paste("S_vs_nind",mylabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("S_vs_nind",mylabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("S_vs_nind",mylabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile(paste("S_vs_nind",mylabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
		}
	par(mar=c(5,6,5,2),cex.axis=2,cex.lab=3,cex.main=2.5)
	#par(cex.axis=1.5,cex.lab=2,mar=c(5,6,2,1))
	plot(c(0,xmax),c(0,mymax),col="white",xlab="# individuals",ylab=y_lab,yaxt='n')
	myaxis	<- seq(0,mymax,mysteps)
	if(!is.null(nsites))
		{
		axis(2,at=myaxis,labels=myaxis)
		}else{
		axis(2,at=myaxis,labels=myaxis/1000)
		}
	#mtext("# segregating sites (k)",side=2,line=4,cex=2)
	#mtext("# individuals",side=1,line=3,cex=2)
	for (p in c(1:npops))
		{
		# observed:
		mypop		<- popnames[p]
		mypopcol	<- mysambar$mycolours[p]
		if(is.null(nsites))
			{
			lines(polylist[[p]],col=mypopcol,lwd=4)
			}else{
			maxnsites	<- max(nsites)
			lines(polylist[[p]]/maxnsites*100,col=mypopcol,lwd=4)
			}
		if(plotexpected)
			{
			mypi		<- inds$pi2[inds$pop==mypop][1]
			nind		<- length(polylist[[p]]) 
			an			<- cumsum(1/(seq(2,ninds,2)))	# harmonic number: 2 sequences per individual
			mywat		<- 2*mypi*an	# why times 2? no idea if it makes sense
			lines(mywat,col=mypopcol,lty=2,lwd=3.5)
			}
		if(plotretainedinds)
			{
			abline(v=nrow(inds[inds$pop==mypop&inds$filter,]),col=mypopcol,lty=2,lwd=0.5)
			}
		}
	# legend:
	legend("bottom",legend=popnames,cex=3,fill=mysambar$mycolours,bty="n")
	if(!is.null(export)){dev.off()}
	}

# 19-01-2023:
# Plot output from PopLDdecay: 
plotpoplddecay<-function(myxlim=c(0,250),myylim=c(0,0.4),export=NULL,mylwd=3.5,legendcex=1.75)
	{
	setwd(mysambar$diversitydir)
	cat("Searching for inputfiles in the directory:",sep="\n")
	cat(getwd(),sep="\n")
	filenames 	<- list.files(mysambar$diversitydir,pattern="pop.all.LDdecay")
	if(length(filenames)==0)
		{
		return(cat("ERROR: no PopLDdecay output files found.",sep="\n"))
		}
	popnames	<- sub("pop.all.LDdecay.","",filenames)
	poporder	<- mysambar$poporder2[mysambar$poporder2%in%popnames]
	colorder	<- mysambar$colorder2[mysambar$poporder2%in%popnames]
	npops		<- length(poporder)
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript("PopLDdecay.eps",family=mysambar$myfont,width=8,height=8)}
		if(export=="pdf"){pdf("PopLDdecay.pdf",family=mysambar$myfont,width=8,height=8)}
		if(export=="png"){png("PopLDdecay.png",family=mysambar$myfont,width=720,height=720)}
		if(export=="wmf"){win.metafile("PopLDdecay.wmf",family=mysambar$myfont,width=8,height=8)}
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	lddf		<- read.table(paste("pop.all.LDdecay",poporder[1],sep="."))
	plot(lddf[,1]/1000,lddf[,2],type="l",col="white",xlab="Distance(Kb)",xlim=myxlim,ylim=myylim,ylab=expression(r^{2}),bty="n",lwd=mylwd)
	for(k in c(1:npops))
		{
		lddf		<- read.table(paste("pop.all.LDdecay",poporder[k],sep="."))
		lines(lddf[,1]/1000,lddf[,2],col=colorder[k],lwd=mylwd)
		}
	legend("topright",legend=poporder,fill=colorder,bty="n",cex=legendcex)
	if(!is.null(export))
		{
		dev.off()
		cat("File has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")	
		}
	setwd(mysambar$inputdatadir)
	}
	
# Plot output from PLINK (linkage disequilibrium):
LD_plot<-function(export=NULL,doimport=TRUE,silent=FALSE,doboxplot=TRUE,addstripchart=FALSE,dopopboxplot=FALSE,doscatter=TRUE,plotmeans=TRUE,popnames=mysambar$populations,maxr2filter=TRUE,inverse=FALSE,xrange=c(0,1000000),stepsize=100000,cols=NULL,myxmax=1,xloc=0.6,yloc=0.9,legendsize=2.5,symbolsize=2.5,yaxismax=1,axiscex=1,axislabelcex=3.5,xlabdistance=5.5,ylabdistance=4,symboltype=c(17,20,18,15),nsequences=100,showmedian=FALSE)
	{
	cat("REMINDER: Use xrange (default is c(0,1000000) and stepsize (default is 100000) to set distance bins.",sep="\n")
	# This function expects to find inputfiles files generated by plink R2 command called after the names of the populations.
	npops				<- length(popnames)
	if(is.null(cols))
		{
		cols	<- mysambar$mycolours[1:npops]
		}
	# set distance bins and their labels (midpoints):
	br					<- seq(xrange[1],xrange[2],stepsize)
	mids				<- vector() 
	for(i in c(1:length(br)-1))
		{
		mids[i]			<- sum(br[i],br[i+1])/2
		}
	if(doimport)
		{
		# read data from plink output (ld files created by plink R2 command) and divide into distance bins:
		setwd(mysambar$inputfilesdir)
		cat("Importing files from directory:",sep="\n")
		cat(getwd(),sep="\n")
		mylist				<- list()
		for (i in c(1:npops))
			{
			myinputfile				<- paste(popnames[i],"ld",sep=".")
			if(!myinputfile%in%list.files())
				{
				return(cat(paste("ERROR: Could not find file called ",myinputfile,".",sep=""),sep="\n"))
				}
			mylist[[i]]				<- read.table(paste(popnames[i],"ld",sep="."),header=TRUE)
			colnames(mylist[[i]])	<- c("CHR_A","BP_A","SNP_A","CHR_B","BP_B","SNP_B","R2")  	# not really necessary, but just in case spaces in input files causes problems
			mylist[[i]]$dist		<- (mylist[[i]]$BP_B-mylist[[i]]$BP_A)
			mylist[[i]]$below1		<- ifelse(!(mylist[[i]]$R2==1&maxr2filter==TRUE),TRUE,FALSE)
			mylist[[i]]$distclass	<- cut(mylist[[i]]$dist,breaks=br,labels=mids) 
			mylist[[i]]$pop			<- as.factor(popnames[i])
			}
		names(mylist)				<- popnames
		mylist						<<- mylist
		x							<- do.call(rbind,mylist)
		LDtable						<<- x
		cat("Plink LD estimates stored in a dataframe called 'LDtable'.",sep="\n")
		}else{
		x	<- LDtable
		}
	# 
	if(dopopboxplot)
		{
		for (i in c(1:length(popnames)))
			{
			popdata		<- mylist[[i]]
			myyaxt		<- ifelse(i==1,'s','n')
			boxplot(popdata$R2~popdata$distclass,outline=FALSE,col=cols[i],ylim=c(0,1),xaxt='n',yaxt=myyaxt)
			axis(side=1,labels=mids/100000,at=mids)
			axis(side=1)
			mtext(side=3,popnames[i],line=0,cex=2)
			}
		}
	# scatter plot:	
	setwd(mysambar$diversitydir)
	if(doscatter)
		{
		if(!silent){cat("LDscatter",sep="\n")}
		if(!is.null(export))
			{
			if(export=="eps"){postscript("LDscatter.eps",family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf("LDscatter.pdf",family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png("LDscatter.png",family=mysambar$myfont,width=720,height=720)}
			#if(export=="wmf"){win.metafile("LDscatter.wmf",family=mysambar$myfont,width=10,height=10)} # this file is too big
			}
		par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
		if(nrow(LDtable)>10000)
			{
			mysample	<- sample(c(1:nrow(LDtable)),10000,replace = FALSE)
			xsample		<- LDtable[mysample,]
			}else{
			xsample		<- LDtable 
			}
		plot(xsample$dist,xsample$R2,col="white",xlab="Distance (bp)",ylab="R2")
		for (j in c(1:npops))
			{
			mypop	<- popnames[j]
			mycol	<- cols[j]
			points(xsample$dist[xsample$pop==mypop],xsample$R2[xsample$pop==mypop],col=mycol,xlab="Distance (bp)",pch=16,cex=0.5)
			}
		legend("topright",popnames,fill=cols[1:npops],bty='n',cex=legendsize)
		if(!is.null(export))
			{
			dev.off()
			cat("A file called  has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	# boxplot:
	if(doboxplot)
		{
		if(!silent){cat("LD.boxplot",sep="\n")}
		cat("If you receive an error, try again without the boxplot by typing: LD_plot(doboxplot=FALSE).",sep="\n")
		graphics.off()
		if(!is.null(export))
			{
			plotname	<- ifelse(addstripchart,"LD.boxplot.stripchart","LD.boxplot")
			stepsize2	<- stepsize/1000
			if(export=="eps"){postscript(paste(plotname,paste(stepsize2,"K",sep=""),"eps",sep="."),family=mysambar$myfont,width=8,height=8)}
			if(export=="pdf"){pdf(paste(plotname,paste(stepsize2,"K",sep=""),"pdf",sep="."),family=mysambar$myfont,width=8,height=8)}
			if(export=="png"){png(paste(plotname,paste(stepsize2,"K",sep=""),"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotname,paste(stepsize2,"K",sep=""),"wmf",sep="."),family=mysambar$myfont,width=8,height=8)}
			}
		par(mar=c(6,5,1,1),cex.axis=1.5,cex.main=2.5)
		mydistclass	<- as.vector(x$distclass)
		mydistclass	<- mydistclass[!is.na(mydistclass)]
		mybins	<- as.vector(unique(mydistclass))
		#nclass	<- length(mybins)-1
		nclass	<- length(mybins)
		myloc	<- c(1:(nclass*(npops+1)-1))
		myloc2	<- myloc[myloc%%(npops+1)!=0]	
		boxplot(x$R2~as.vector(x$distclass)*as.vector(x$pop),outline=FALSE,col=mysambar$mycolours[1:npops],ylim=c(0,1),xaxt='n',at=myloc2,las=1,xlab="",ylab="")
		if(addstripchart)
			{
			cat("If you receive an error, try again without the boxplot by typing: LD_plot(addstripchart=FALSE).",sep="\n")
			mysample<-sample(c(1:nrow(x)),5000,replace = FALSE)
			xsample	<- x[mysample,]
			stripchart(R2~as.vector(distclass)*as.vector(pop),data=xsample,vertical=TRUE,method="jitter",pch=16,cex=0.5,col="grey50",bg="bisque",las=2,at=myloc2,xlab="",ylab="",add=TRUE) 
			}
		legend("topright",popnames,fill=cols[1:npops],bty='n',cex=2)
		if(plotmeans)
			{
			# 14-04-2020: This seems to give strange results (probably because sorting a factor complicates the analysis), so I excluded it for now:
			# add means:
			mymeans <- aggregate(R2 ~ pop*distclass, x, mean)
			points(myloc2,mymeans$R2,pch=21,col="black",cex=1.5,bg="white")
			#
			}
		# add xaxis:
		labelloc1<- round(mean(1:npops))
		labelloc2<- seq(labelloc1,nclass*(npops+1),(npops+1))
		#
		axis(side=1,at=labelloc2,label=(mids/100000)[1:nclass],las=2)
		mtext(side=1,"Physical distance (100 kB)",line=4.5,cex=2.5)
		mtext(side=2,"LD (r2)",line=3,cex=2.5)
		if(!is.null(export))
			{
			dev.off()
			cat("A file called LD.boxplot has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	#
	# 14-04-2020: This seems to give strange results (probably because sorting a factor complicates the analysis), so I excluded it for now:
	if(plotmeans)
		{
		if(!silent){cat("LDmean",sep="\n")}
		# calculate mean per dataclass:
		r2matrix				<<- matrix(nrow=(length(popnames)+1),ncol=(length(br)-1))
		r2matrix[1,]			<<- mids
		r2medianmat				<<- r2matrix
		for(i in c(1:length(br)-1))
			{ 
			temp				<- mids[i]
			for (j in c(1:npops))
				{
				#cat(j,sep="\n")
				#cat((names(mylist)[j]),sep="\n")
				r2matrix[j+1,i]		<<- ifelse(inverse,1/(mean(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE)),mean(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE))
				r2medianmat[j+1,i]	<<- ifelse(inverse,1/(median(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE)),median(mylist[[j]]$R2[mylist[[j]]$distclass==temp],na.rm=TRUE))
				}
			}
		# Plot means only:
		if(!is.null(export))
			{
			setwd(mysambar$diversitydir)
			graphics.off()
			plotlabel	<- ifelse(is.null(nsequences),"LDmean","LDmean_expected")
			if(export=="eps"){postscript(paste(plotlabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="pdf"){pdf(paste(plotlabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
			if(export=="png"){png(paste(plotlabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotlabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)}
			}
		par(mar=c(5,7,5,2),oma=c(2,0,2,0),cex.axis=2,cex.lab=axislabelcex,cex.main=3.5)
		xaxismax			<<- myxmax*xrange[2]
		if(is.null(yaxismax))
			{
			yaxismax			<<- max(r2matrix[2:length(popnames),],na.rm=TRUE)
			}
		#plot(r2matrix[1,],r2matrix[2,],pch=symboltype[1],col=cols[1],xaxt="n",xlab="Physical distance (100 kb)",ylab="",cex=2.5,ylim=c(0,yaxismax),xlim=c(0,xaxismax),bty="n")
		plot(r2matrix[1,],r2matrix[2,],pch=16,col=cols[1],xlab="",ylab="",xaxt='n',cex=2.5,ylim=c(0,yaxismax),xlim=c(0,xaxismax),bty="n",las=1)
		if(showmedian)
			{
			points(r2medianmat[1,],r2medianmat[2,],pch=17,col=cols[1],cex=1)
			}
		axis(side=1,at=seq(0,xaxismax,100000),labels=(seq(0,xaxismax,100000)/100000),lty=1,las=1,mgp=c(3,2,0))
		mtext("Physical distance (100 kb)",side=1,cex=axislabelcex,line=xlabdistance)
		#ylabel			<- ifelse(inverse,"1/(mean R2)","mean R2")
		mtext("LD (mean R2)",side=2,cex=axislabelcex,line=ylabdistance)
		for (i in c(2:length(popnames)))
			{
			#if(length(popnames)<=4)
			#	{
			#	points(r2matrix[1,],r2matrix[i+1,],pch=symboltype[i],col=cols[i],cex=2.5,xlim=c(0,xaxismax))
			#	}else{
				points(r2matrix[1,],r2matrix[i+1,],pch=16,col=cols[i],cex=symbolsize,xlim=c(0,xaxismax))
				if(showmedian)
					{
					points(r2medianmat[1,],r2medianmat[i+1,],pch=17,col=cols[i],cex=1)
					}
			#	}
			}
		if(!is.null(nsequences))
			{
			expld(Ne=50,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="black",xmax=max(xrange))
			expld(Ne=100,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey20",xmax=max(xrange))
			expld(Ne=500,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey40",xmax=max(xrange))
			expld(Ne=1000,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey60",xmax=max(xrange))
			expld(Ne=5000,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey80",xmax=max(xrange))
			expld(Ne=10000,n=nsequences,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=TRUE,mycol="grey90",xmax=max(xrange))
			legend("topleft",legend=c("50","100","500","1000","5000","10000"),fill=c("black","grey20","grey40","grey60","grey80","grey90"),cex=2,bty='n')
			}	
		#if(length(popnames)<=4)
		#	{
		#	legend(x=xloc*xaxismax,y=yloc*yaxismax,legend=popnames,pch=symboltype,fill=cols,cex=legendsize,bty="n")
		#	}else{
			#legend(x=xloc*xaxismax,y=yloc*yaxismax,legend=popnames,fill=cols,cex=legendsize,bty="n")
			legend("topright",legend=popnames,fill=cols,cex=legendsize,bty='n')
		#	}
		if(!is.null(export))
			{
			dev.off()
			cat("A file called LDmean has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	setwd(mysambar$inputdatadir)
	}

expld<-function(Ne=50,n=60,stepsize=0.05,maxdistance=1,doplot=FALSE,addline=FALSE,mycol="black",xmax=1000000)
	{
	# It is assumed that for the recombination rate per generation (r) is 0.01 per 1Mb
	# Hence, the population mutation rate (4*Ne*r) equals 0.04*Ne*d, in which d is the distance between two loci in Mb (so 1 means 1 Mb)
	#
	d		<- seq(stepsize,maxdistance,stepsize)
	r		<- d*0.01
	p		<- 4*Ne*r
	# probability no crossing-over:
	pr0		<- (18+p)/(18+13*p+p^2)
	# expected r2:
	x1		<- (10+p)/((2+p)*(11+p))
	x2		<- (3+p)*(12+12*p+p^2)
	x3		<- n*(2+p)*(11+p)
	ld		<- x1*(1+x2/x3)  
	if(doplot)
		{
		plot(d,ld,ylim=c(0,1),type='l',col=mycol,xlab="Physical distance (Mb)",ylab="LD (r2)")
		abline(h=1/n,lty=2)
		}
	if(addline)
		{
		d<-d*1000000*(xmax/1000000)
		lines(d,ld,ylim=c(0,1),type='l',col=mycol)
		abline(h=1/n,lty=2)
		}
	}

LDperchrom<-function(addX=FALSE,popnames=mysambar$populations,export=NULL,maxr2filter=TRUE,cols=as.vector(unique(inds$popcol)))
	{
	# This function expects to find inputfiles subdirectory files generated by plink R2 command called after the names of the populations.
	setwd(mysambar$inputfilesdir)
	# read data from plink output (ld files created by plink R2 command) and add columns: 
	mylist	<- list()
	for (i in c(1:length(popnames)))
		{
		mylist[[i]]				<- read.table(paste(popnames[i],"ld",sep="."),header=TRUE)
		colnames(mylist[[i]])	<- c("CHR_A","BP_A","SNP_A","CHR_B","BP_B","SNP_B","R2")  	# not really necessary, but just in case spaces in input files causes problems
		mylist[[i]]$dist		<- mylist[[i]]$BP_B-mylist[[i]]$BP_A
		mylist[[i]]$below1		<- ifelse(!(mylist[[i]]$R2==1&maxr2filter==TRUE),TRUE,FALSE)
		mylist[[i]]$distclass	<- cut(mylist[[i]]$dist,breaks=br,labels=mids) 
		}
	names(mylist)				<- popnames
	# Calculate LD per chrom:
	mychroms					<- sort(as.numeric(as.vector(unique(snps$chr[as.vector(snps$autosomal)]))))
	if(addX){mychroms			<- c(mychroms,"X")}
	LDmatrix					<<- matrix(ncol=length(popnames),nrow=length(mychroms))
	rownames(LDmatrix)			<<- mychroms
	colnames(LDmatrix)			<<- popnames
	for (i in c(1:length(popnames)))
		{
		for (i in mychroms)
			{
			temp				<- mylist[[j]]$R2[mylist[[j]]$CHR_A==i&mylist[[j]]$below1]
			LDmatrix[i,j]		<<- round(mean(temp,na.rm=TRUE),3)
			}
		}
	setwd(mysambar$diversitydir)
	write.table(LDmatrix,file="LDperchrom.txt",na="NA",row.names=TRUE,col.names=TRUE,sep="\n",quote=FALSE)
	setwd(mysambar$inputdatadir)
	}

# Boxplots of differences in maf between adjacent snps.
# Not entirely sure how this relates to LD. 
multimafdiff<-function(export=FALSE,popnames=mysambar$populations,mymaxdistances=c(500,10000,500000),my_log="",do_boxplot=TRUE,do_scatterplot=TRUE,addoutliers=FALSE)
	{
	if(!"dist" %in% colnames(snps))
		{
		return(cat("ERROR: no column called dist in snps dataframe.",sep="\n"))
		}
	npop	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npop]
	if(do_boxplot)
		{
		if(export){pdf("DeltaMAF_vs_spacing.pdf",width=9,height=npop*3)}
		par(mfrow=c(3,npop),oma=c(2,5,2.5,1),mar=c(4,0.5,0.5,0.5),cex.axis=1.5)
		for (k in c(1:3))
			{
			mydistance	<- mymaxdistances[k]
			mystepsize	<- mydistance/10
			for(p in c(1:npop))
				{
				mypop	<- popnames[p]
				mypopcol<- mycols[p]
				mypopmaf<- snps[,paste("maf",mypop,sep="_")]
				add_y	<- ifelse(p==1,TRUE,FALSE)
				mytitle	<- ifelse(k==1,mypop,"")
				if(k==1)
					{
					mafdiff(mypopmaf,mycol=mypopcol,plottitle=mytitle,addyaxis=add_y,addylabel=FALSE,stepsize=mystepsize,distrange=c(0,mydistance),mylog=my_log,addtosnps=TRUE)
					names(snps)[names(snps)=="mafdiff"]	<<- paste("mafdiff",mypop,sep="_")
					}else{
					mafdiff(mypopmaf,mycol=mypopcol,plottitle=mytitle,addyaxis=add_y,addylabel=FALSE,stepsize=mystepsize,distrange=c(0,mydistance),mylog=my_log,addtosnps=FALSE)
					}
				}
			}
		mtext("SNP spacing (kb)",side=1,cex=2,line=0.5,outer=TRUE)
		mtext(side=2,line=2.5,"MAF difference",cex=2,outer=TRUE)
		if(export){dev.off()}
		}
	snps 	<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	if(do_scatterplot&npop>1)
		{
		if(export)
			{
			n_pair	<- ncol(combitable)
			mywidth	<- ifelse(n_pair==2,10,15)
			myheight<- ifelse(n_pair==2,5,ifelse(n_pair==3,15,ifelse(n_pair>3&n_pair<7,10,ifelse(n_pair>6&n_pair<10,15,20))))
			pdf("DeltaMAF_interpopulation.pdf",height=myheight,width=mywidth)
			}
		par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5),mar=c(5,6,2.5,2))
		combitable		<<- combn(popnames,m=2)
		for (j in c(1:ncol(combitable)))
			{
			mypop1	<- combitable[1,j]
			mypop2	<- combitable[2,j]
			mylabel	<- paste(mypop1,mypop2,sep="_")
			mydiff1	<- snps[,paste("mafdiff",mypop1,sep="_")]
			mydiff2	<- snps[,paste("mafdiff",mypop2,sep="_")]
			diffmat	<- as.data.frame(cbind(mydiff1,mydiff2))
			colnames(diffmat)	<- c("pop1","pop2")
			if(addoutliers)
				{
				diffmat$out<-snps$rfisherout_pheno
				}
			diffmat	<- as.data.frame(unique(diffmat))
			plot(diffmat$pop2[snps$filter2],diffmat$pop1[snps$filter2],xlim=c(0,1),ylim=c(0,1),pch=16,cex=0.75,las=1,cex.axis=1.5,ylab="",xlab="")
			if(addoutliers)
				{
				outmat	<- diffmat[diffmat$out,]
				points(outmat$pop2[2],outmat$pop1[2],col="red",pch=16,cex=2)
				points(outmat$pop2[3],outmat$pop1[3],col="red",cex=2)
				}
			mtext(paste(mypop2,"Delta_MAF",sep=" "),side=1,line=3.5,cex=2.5)
			mtext(paste(mypop1,"Delta_MAF",sep=" "),side=2,line=3.5,cex=2.5)
			}
		if(export){dev.off()}
		
		}
	}

mafdiff<-function(mymaf=snps$maf,stepsize=500,doboxplot=TRUE,distrange=c(0,10000),mycol="grey",addylabel=TRUE,addyaxis=TRUE,plottitle=NULL,mylog="",addtosnps=FALSE)
	{
	if(!"dist" %in% colnames(snps))
		{
		return(cat("ERROR: no column called dist in snps dataframe.",sep="\n"))
		}
	# calculate difference in maf between adjacent snps:
	new_chr			<- (as.vector(snps$chr))!=c(as.vector(snps$chr[2:length(snps$chr)]),as.factor("dummy"))
	new_chr			<- c(TRUE,new_chr[1:(length(new_chr)-1)])
	mymaf1			<- mymaf
	mymaf2			<- c(as.vector(mymaf[2:length(mymaf)]),NA)
	mydiff			<- mymaf2-mymaf1
	mydiff			<- abs(c(NA,mydiff[1:(length(mydiff)-1)]))
	mydiff[new_chr]	<- NA
	# set distance bins and their labels (midpoints):
	br					<- seq(distrange[1],distrange[2],stepsize)
	mids				<- vector() 
	for(i in c(1:length(br)-1))
		{
  		mids[i]			<- sum(br[i],br[i+1])/2
		}	
	mids				<- mids/1000
	mydistclass			<- cut(snps$dist,breaks=br,labels=mids) 
	#meanperdistclass	<<- aggregate(mydiff,list(mydistclass),mean)
	myyaxt				<- ifelse(addyaxis,'s','n')
	if(doboxplot)
		{
		if(mylog=="y")
			{
			boxplot(mydiff[snps$filter2&mydiff!=0]~mydistclass[snps$filter2&mydiff!=0],las=2,col=mycol,ylim=c(0.0001,1),yaxt=myyaxt,log=mylog)
			}else{
			boxplot(mydiff[snps$filter2&!is.na(mydiff)]~mydistclass[snps$filter2&!is.na(mydiff)],las=2,col=mycol,ylim=c(0,1),yaxt=myyaxt,log=mylog)
			}
		if(addylabel)
			{
			mtext(side=2,line=2.5,"MAF difference",cex=2)
			}
		if(!is.null(plottitle))
			{
			mtext(plottitle,side=3,line=0.5,cex=1.5)
			}
		}
	if(addtosnps)
		{
		snps$mafdiff		<<- mydiff
		}
	mydiff	<<- as.data.frame(cbind(mymaf1,mymaf2,mydiff)) 
	}

# 21-01-2023: depreciated and replaced with find_roh().
homorun<-function(export=NULL,sims=FALSE,input=mygenlight,popnames=mysambar$populations,indselection=inds$filter,snpselection=snps$filter,maxrohlength=100,lowmaf=TRUE,colourcode=inds$popcol)
	{
	# 19032019: I removed simulations because I run into ERROR after changing from line plot to boxplot
	npops	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npops]
	if(!(any(names(snps)=="dist")))
		{
		return(cat("ERROR: snps$dist column missing. This function can only be executed if you know the location of your snps.",sep="\n"))
		}
	nindsperpop			<- as.vector(table(inds$pop[inds$filter]))
	if(any(nindsperpop<5))
		{
		return(cat("Some populations contain less than 5 retained individuals. SambaR will not generate ROH plot.",sep="\n"))
		}
	# First we need to calculate mean spacing:
	if(any(snps$autosomal))
		{
		meanspacing			<- mean(snps$dist[snps$autosomal],na.rm=TRUE)	
		medianspacing		<- median(snps$dist[snps$autosomal],na.rm=TRUE)
		}else{
		meanspacing			<- mean(snps$dist,na.rm=TRUE)	
		medianspacing		<- median(snps$dist,na.rm=TRUE)
		}
	# Now create dataframe in which these values are multiplied with various numbers of snps:
	rohlength			<- c(1:maxrohlength)
	meanbp				<- rohlength*meanspacing
	medianbp			<- rohlength*medianspacing
	roh					<- data.frame(rohlength,meanbp,medianbp)
	# Select snps:
	if(lowmaf==TRUE)
		{
		if(any(snps$autosomal))
			{
			snpselect		<- snps$filter&snps$autosomal&snps$maf<0.1  
			}else{
			snpselect		<- snps$filter&snps$maf<0.1 
			}
		}else{
		if(any(snps&autosomal))
			{
			snpselect		<- snps$filter&snps$autosomal&snps$maf>0.1
			}else{
			snpselect		<- snps$filter&snps$maf>0.1
			}
		}
	mymatrix			<- as.matrix(input[,snpselect])
	if(length(mymatrix[is.na(mymatrix)])/(nrow(mymatrix)*ncol(mymatrix))>0.2)
		{
		return(cat("More than 20 percent missing data points. SambaR will not generate ROH-plot.",sep="\n"))
		}
	# Do the actual calculation:
	for (j in (1:npops))
		{
		mypop			<- popnames[j]
		mycol			<- mycols[j]
		# Select individuals:
		indnr			<- inds$nr[indselection&inds$pop==popnames[j]] 
		# Now calculate for each selected individual roh-lengths:
		for (i in indnr)
			{ 
			sample				<- mymatrix[inds$nr==i,]
			sample				<- sample[!is.na(sample)]
			# Give minor homozygotes and major homozygotes the same code (0):
			for (k in (1:(length(sample))))
				{
				sample[k]		<-ifelse(sample[k]==1,1,0)
				}
			# Now we are ready to apply the rle-function:
			temp				<- rle(sample)
			temp2				<- cbind(as.data.frame(temp$values),as.data.frame(temp$length))
			colnames(temp2)		<- c("values","length")
			# select runs of homozygosity:
			temp2				<- temp2[temp2$values==0,]
			# Count the occurences of each rohlength:
			results				<- as.data.frame(table(temp2$length))
			colnames(results)	<- c("rohlength","count")
			results$rohlength	<- as.numeric(results$rohlength)
			# What is the frequency?
			results$count		<- as.numeric(results$count)
			results$freq		<- results$count/(sum(results$count))
			results$freqsum		<- cumsum(results$freq)
			results$p		<- ifelse(results$rohlength==1,1,NA)
			for (l in (2:(nrow(results))))
				{
				results$p[l]	<- 1-results$freqsum[l-1]
				}
			results$count		<- NULL
			results$freq		<- NULL
			results$freqsum		<- NULL
			roh					<- merge(x=roh, y=results, by="rohlength", all=TRUE)
			#lines(roh$rohlength[1:125],roh[1:125,ncol(roh)],col=mycol,ann=FALSE,xlim=c(0,100))
			names(roh)[ncol(roh)] 	<- paste0("sample", i)
			} # end of ind loop 
		} # end of population loop 
	# Plot:
	graphics.off()
	if(!is.null(export))
		{
		if(export=="wmf"){win.metafile("ROH.wmf",height=6,width=12)}
		if(export=="pdf"){pdf("ROH.pdf",height=6,width=12)}
		}
	#plot(rohlength,rep(0.5,100),ylim=c(0,1),col="white",ann=FALSE,xlim=c(0,100))
	for(j in c(1:npops))
		{
		mypop	<- popnames[j]
		mycol	<- mycols[j]
		roh2	<- t(roh)
		temp	<- roh2[4:nrow(roh2),]
		my_pops	<- inds$pop[inds$filter]
		my_inds	<- my_pops==mypop 
		temp2	<- temp[my_inds,]
		addplot	<- ifelse(j==1,FALSE,TRUE)
		myaxt	<- ifelse(j==1,'s','n')
		boxplot(temp2,use.cols=TRUE,col=mycol,outline=FALSE,las=2,add=addplot,xaxt=myaxt,yaxt='n',cex.axis=0.75)
		}
	axis(side=2,cex=1.5,las=1)
	mtext("ROH length (number of snps)",side=1,line=3,cex=2)
	mtext("Probability",side=2,line=2.5,cex=2)
	mtext("Runs of homozygosity",side=3,line=0.5,cex=2)
	legend("topright",legend=popnames,fill=mycols,cex = 1,bty='n')
	if(!is.null(export)){dev.off()}
	}		

# careful: heavy plot!
genoheatmap<-function(export=FALSE,dofilter=TRUE,maxsites=2000,mychrom="1",genocolours=c("black","blue","yellow"),rohdf=NULL,snpsfilter=rep(TRUE,nrow=snps))
	{
	if(!mychrom%in%snps$chr)
		{
		return(cat("ERROR: chromosome specified to mychrom flag not found.",sep="\n"))  
		}
	#snpsfilter		<- snps$filter&snps$chr==mychrom
	snpsfilter		<- snps$chr==mychrom&snpsfilter
	plotlabel		<- paste("chrom",mychrom,sep="")
	#
	genlighttemp	<- mygenlight[order(as.character(inds$pop)),]
	indstemp		<- inds[order(as.character(inds$pop)),]
	if(dofilter)
		{
		mysamples		<- indstemp$name[indstemp$filter]
		mypopvec		<- indstemp$pop[indstemp$filter]
		}else{
		return(cat("ERROR: set dofilter to TRUE.",sep="\n"))
		mysamples		<- indstemp$name
		mypopvec		<- indstemp$pop		
		}
	nretainedsites		<- nrow(snps[snpsfilter,])
	if(nretainedsites>maxsites)
		{
		return(cat(paste("ERROR: ",nretainedsites," SNPs, while maxsites flag is set to ",maxsites,". Specify a higher value to the maxsites flag (resulting in large file size), or zoom in to a specific region using a command like this: 'genoheatmap(snpsfilter=snps$pos>30000000&snps$pos<50000000)'.",sep=""),sep="\n"))
		}
	nsamples		<- length(mysamples)
	#
	if(export)
		{
		plotname	<- ifelse(dofilter,paste("Genotypes.filtered",plotlabel,sep="."),paste("Genotypes",plotlabel,sep="."))
		plotname	<- ifelse(is.null(rohdf),paste(plotname,"unmarked",sep="."),paste(plotname,"marked",sep="."))
		pdf(paste(plotname,"pdf",sep="."),height=nsamples*0.14+5,width=30)
		}
	par(mar=c(5,5,3,13))
	if(dofilter)
		{
		glPlot(genlighttemp[indstemp$filter,snpsfilter],col=genocolours,legend=TRUE,posi="bottomleft",yaxt='n',mar=c(3,3,3,6))
		}else{
		glPlot(genlighttemp,col=genocolours,legend=TRUE,posi="bottomleft",yaxt='n',mar=c(3,3,3,6))
		}
	#axis(side=4,at=seq(1,nsamples,1),label=rev(mysamples),cex=0.25,las=1)
	axis(side=4,at=seq(1,nsamples,1),label=rev(paste(mypopvec,mysamples,sep=": ")),cex=0.25,las=1)
	if(!is.null(rohdf))
		{
		for(k in c(1:nsamples))
			{
			myind		<- rev(mysamples)[k]
			myrohdf		<- rohdf[rohdf$ind==myind&rohdf$chrom==mychrom,]
			tempdf		<<- myrohdf
			if(nrow(myrohdf)!=0)
				{
				for(j in c(1:nrow(myrohdf)))
					{
					startnr		<- myrohdf$snpstart[j]
					endnr		<- myrohdf$snpstart[j]+myrohdf$nsnps[j]-1
					segments(x0=startnr,y0=k,x1=endnr,y1=k,col="red")
					}
				}
			}
		}
	
	if(export){dev.off()}
	}

# Function to create Mondriaan plot:
multiglPlots<-function(popnames=mysambar$populations,chromosome=1,mycols=as.vector(unique(inds$popcol)),export=NULL)
	{
	setwd(mysambar$diversitydir)
	graphics.off()
	if(!is.null(export))
		{
		if(export=="eps"){postscript("ROH.eps",family=mysambar$myfont,width=6,height=8)}
		if(export=="pdf"){pdf("ROH.pdf",family=mysambar$myfont,width=6,height=8)}
		if(export=="png"){png("ROH.png",family=mysambar$myfont,width=540,height=720)}
		if(export=="wmf"){win.metafile("ROH.wmf",family=mysambar$myfont,width=6,height=8)}
		}
	if(any(names(snps) == "chr"))
		{
		par(mfrow=c(length(popnames),1),mai=c(0.05,0.05,0.05,0.05),oma=c(3.5,3.5,2,0))
		for (i in (1:(length(popnames))))
			{ 
			mycol<-c("black",mycols[i],"grey20")
			glPlot(mygenlight[inds$filter&inds$pop==popnames[i],snps$filter&snps$chr==chromosome],col=mycol,legend=FALSE,main="") 
			mtext(popnames[i],side=2,line=2.5)
			}
		}else{
		print("Snps-dataset should contains a vector called 'chr' with information about the location of the snp")
		}
	mtext("SNP ID",side=1,line=2,outer=TRUE)
	mtext(paste("Chromosome",chromosome,sep=" "),side=3,line=0.3,outer=TRUE,font=2)
	if(!is.null(export)){dev.off()}
	setwd(mysambar$inputdatadir)
	}
   
# End of genetic diversity analyses 
###############################################################################################################






###############################################################################################################
# Calculations per population pair

batcheffectmat<-function(missdf=inds2[inds$bool,])
	{
	missdf$reldiff	<- missdf$diff/(missdf$pairmiss_exp)
	popnames		<- unique(c(as.vector(missdf$subpop1),as.vector(missdf$subpop2)))
	combitable		<- combn(popnames,m=2)
	#
	missdf$subpop1	<- as.character(missdf$subpop1)
	missdf$subpop2	<- as.character(missdf$subpop2)
	#
	# between pop comparisons:
	betweenvec		<- rep(NA,ncol(combitable))
	for (i in c(1:ncol(combitable)))
		{
		pop1		<- combitable[1,i]	
		pop2		<- combitable[2,i]	
		mytempdf	<- missdf[(missdf$subpop1==pop1&missdf$subpop2==pop2)|(missdf$subpop2==pop1&missdf$subpop1==pop2),]
		#betweenvec[i]<- mean(abs(mytempdf$diff),na.rm=TRUE) 
		betweenvec[i]<- mean(abs(mytempdf$reldiff),na.rm=TRUE) 
		}
	# within pop comparisons:
	withinvec		<- rep(NA,length(popnames))
	for (i in c(1:length(popnames)))
		{
		mypop		<- popnames[i]
		mytempdf	<- missdf[(missdf$subpop1==mypop&missdf$subpop2==mypop),]
		#withinvec[i]<- mean(abs(mytempdf$diff),na.rm=TRUE)
		withinvec[i]<- mean(abs(mytempdf$reldiff),na.rm=TRUE)
		}
	b							<<- matrix(1,nrow=length(popnames),ncol=length(popnames))
	b[lower.tri(b, diag=FALSE)] <<- betweenvec
	b							<<- t(b)
	b[lower.tri(b, diag=FALSE)] <<- 0
	diag(b)						<<- withinvec
	colnames(b)					<<- popnames
	rownames(b)					<<- popnames
	}

# 27-04-2021:
# depends on calcpi and plotfst 
popmeandxy<-function(do_overwrite=FALSE,nrsites=NULL,popvec=mysambar$poporder,my_Breaks=NULL,value_cex=4,addpi=FALSE)
	{
	if(is.null(mysambar$pidf_metalist)|do_overwrite)
		{
		cat("Generating pairwise distance scores...",sep="\n")
		calcpi(pi_per_pop=FALSE)
		}
	pidf				<- mysambar$pidf_metalist[[1]]
	pidf$poppair		<- ifelse(pidf$pop1<pidf$pop2,paste(pidf$pop1,pidf$pop2,sep="_"),paste(pidf$pop2,pidf$pop1,sep="_"))
	pidf				<- pidf[(!pidf$name1%in%inds$name[!inds$filter])&(!pidf$name2%in%inds$name[!inds$filter]),]
	pidf2				<- pidf[pidf$pop1!=pidf$pop2,]
	pidf3				<- pidf[pidf$pop1==pidf$pop2,]	
	#
	meandxy 			<- aggregate(pidf2$ndiffpersite,by=list(pidf2$poppair),FUN=mean,na.rm=TRUE)
	colnames(meandxy)	<- c("poppair","dxy")
	poppi				<- aggregate(pidf3$ndiffpersite,by=list(pidf3$poppair),FUN=mean,na.rm=TRUE)
	for(k in c(1:nrow(poppi))){poppi$Group.1[k]	<- strsplit(poppi$Group.1[k], "_")[[1]][1]}
	colnames(poppi)		<- c("pop","pi")
	meandxy$pop1		<- sapply(strsplit(meandxy$poppair,"_"),"[",1)
	meandxy$pop2		<- sapply(strsplit(meandxy$poppair,"_"),"[",2)
	if(!is.null(nrsites))
		{
		meandxy$dxy_allsites	<- meandxy$dxy*nrow(snps)/nrsites
		dxyvec					<- meandxy$dxy_allsites
		}else{
		dxyvec					<- meandxy$dxy
		}
	mysambar$meandxy	<<- meandxy
	#
	npop				<- length(popvec)
	dxymat				<- matrix(NA,nrow=npop,ncol=npop)
	colnames(dxymat)	<- popvec
	rownames(dxymat)	<- popvec
	damat				<- dxymat
	fstmat				<- dxymat
	for(popnr1 in c(1:npop))
		{
		for(popnr2 in c(1:npop))
			{
			mypop1	<- popvec[popnr1]
			mypop2	<- popvec[popnr2]
			if(popnr1!=popnr2)
				{
				poppairdxy				<- meandxy$dxy[(meandxy$pop1==mypop1&meandxy$pop2==mypop2)|(meandxy$pop1==mypop2&meandxy$pop2==mypop1)]
				poppairpixy				<- mean(poppi$pi[poppi$pop==mypop1|poppi$pop==mypop2])				
				dxymat[popnr1,popnr2]	<- poppairdxy
				damat[popnr1,popnr2]	<- poppairdxy-poppairpixy 
				fstmat[popnr1,popnr2]	<- (poppairdxy-poppairpixy)/poppairdxy
				}
			}
		}
	if(addpi)
		{
		for(popnr1 in c(1:npop))
			{
			mypop1					<- popvec[popnr1]
			dxymat[popnr1,popnr1]	<- mean(pidf$ndiffpersite[pidf$pop1==mypop1&pidf$pop2==mypop1],na.rm=TRUE)
			}
		}
	mysambar$snpdxymat	<<- dxymat 
	mysambar$snpdamat	<<- damat
	mysambar$snpfstmat	<<- fstmat	
	# 
	plotpopmatrix(exportname="Dxy_snps",addlabels=TRUE,showvalues=TRUE,popnames=popvec,mymatrix=dxymat,nrbreaks=5,addlegend=FALSE,plotlabelcex=8,export="pdf",myBreaks=my_Breaks,valuecex=value_cex)
	getpoptree(mymatrix=mysambar$snpdxy,exportlabel="snp_dxy",donj=TRUE,edgecolors=TRUE,mytype="unrooted",labelcex=1.5,popnames=mysambar$poporder,popcolours=mysambar$colorder)
	#
	cat("Exporting matrices with mean Dxy values...",sep="\n")
	plotfst(popnames=mysambar$populations,export="eps",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	plotfst(popnames=mysambar$populations,export="png",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	plotfst(popnames=mysambar$populations,export="pdf",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")
	if(mysambar$os=="Windows"){plotfst(popnames=mysambar$populations,export="wmf",inputvector=dxyvec,exportname="Dxy_pop",plottitle="Mean Dxy")}
	}

# End of calculations per population pair
###############################################################################################################






###############################################################################################################
# Calculations per sample pair

getinds2<-function()
	{
	cat("Creating inds2 dataframe...",sep="\n")
	if(any(!c("name","nr","pop","popcol","pop2")%in%colnames(inds)))
		{
		return(cat("ERROR: inds dataframe should contain at least the columns 'name', 'pop', 'popcol', 'pop2', and 'nr'.",sep="\n"))
		}
	combitable	<- combn(as.character(inds$name),m=2)
	combitable2	<- combn(inds$nr,m=2)
	if(ncol(combitable)!=ncol(combitable2))
		{
		return(cat("ERROR: number of columns of combitable and combitable2 do not correspond. Contact developer of SambaR.",sep="\n"))
		}
	ninds		<- nrow(inds)
	ncombitable	<- ncol(combitable)
	cat(paste("Number of individuals: ",ninds,".",sep=""),sep="\n")
	cat(paste("Number of pairwise comparisons: ",ncol(combitable),", as given by: (",ninds,"*(",ninds,"-1))/2.",sep=""),sep="\n") 
	if(ncombitable!=((ninds*(ninds-1))/2))
		{
		return(cat("ERROR: combitable has unexpected number of columns. Contact developer of SambaR.",sep="\n"))
		}
	#inds2		<- data.frame("name1"=c(inds$name,combitable[1,]),"name2"=c(inds$name,combitable[2,]),"indpair"=NA,"ind1"=c(inds$nr,combitable2[1,]),"ind2"=c(inds$nr,combitable2[2,]),"sameind"=TRUE,"filter1"=TRUE,"filter2"=TRUE,"filter"=TRUE,"pop1"=NA,"pop2"=NA,"samepop"=TRUE,"poppair"=NA,"popcol1"=NA,"popcol2"=NA,"subpop1"=NA,"subpop2"=NA,"long1"=NA,"lat1"=NA,"long2"=NA,"lat2"=NA,"chorddist"=NA,"geodist"=NA)
	inds2		<- data.frame("name1"=c(as.character(inds$name),as.character(combitable[1,])),"name2"=c(as.character(inds$name),as.character(combitable[2,])),"indpair"=NA,"ind1"=c(inds$nr,combitable2[1,]),"ind2"=c(inds$nr,combitable2[2,]),"sameind"=TRUE,"filter1"=TRUE,"filter2"=TRUE,"filter"=TRUE,"chorddist"=NA,"geodist"=NA)
	if(nrow(inds2)!=ncombitable+ninds)
		{
		return(cat("ERROR: unexpected number of rows of inds2 dataframe. Contact developer of SambaR.",sep="\n"))
		}
	if(!any(inds$name%in%inds2$name1))
		{
		return(cat("ERROR: sample names in inds dataframe do not correspond to sample names in inds2$name1 column. Contact developer of SambaR.",sep="\n"))
		}
	if(!any(inds$name%in%inds2$name2))
		{
		return(cat("ERROR: sample names in inds dataframe do not correspond to sample names in inds2$name2 column. Contact developer of SambaR.",sep="\n"))
		}	
	if("longitude"%in%colnames(inds)&!("longitude3"%in%colnames(inds)))
		{
		cat("Settings inds$longitude3 equal to inds$longitude.",sep="\n")
		inds$longitude3		<<- inds$longitude
		}
	geobool		<- "longitude3"%in%colnames(inds)
	if(geobool)
		{
		cat("Adding population information to inds2 dataframe, including geographical coordinates.",sep="\n")
		indstemp1			<- inds[,c("name","pop","popcol","pop2","longitude3","latitude")]	
		colnames(indstemp1)	<- c("name1","pop1","popcol1","subpop1","long1","lat1")
		indstemp2			<- inds[,c("name","pop","popcol","pop2","longitude3","latitude")]	
		colnames(indstemp2)	<- c("name2","pop2","popcol2","subpop2","long2","lat2")
		}else{
		cat("Adding population information to inds2 dataframe, without geographical coordinates.",sep="\n")
		indstemp1			<- inds[,c("name","pop","popcol","pop2")]	
		colnames(indstemp1)	<- c("name1","pop1","popcol1","subpop1")
		indstemp2			<- inds[,c("name","pop","popcol","pop2")]	
		colnames(indstemp2)	<- c("name2","pop2","popcol2","subpop2")
		}
	inds2merged			<- merge(inds2,indstemp1,by="name1")	
	if(nrow(inds2merged)!=nrow(inds2))
		{
		#indstemp1		<<- indstemp1
		write.table(indstemp1,"indstemp1.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		#inds2			<<- inds2
		write.table(inds2,"inds2.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		#inds2merged		<<- inds2merged
		write.table(inds2merged,"inds2merged.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		nrows			<- nrow(inds2merged)
		return(cat(paste("ERROR: unexpected number of rows of inds2 dataframe (",nrows,") after merging with indstemp1. Contact developer of SambaR.",sep=""),sep="\n"))
		}
	inds2merged2		<- merge(inds2merged,indstemp2,by="name2")	
	if(nrow(inds2merged2)!=nrow(inds2))
		{
		#indstemp2		<<- indstemp2
		write.table(indstemp2,"indstemp2.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		#inds2			<<- inds2
		write.table(inds2,"inds2.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		#inds2merged		<<- inds2merged
		write.table(inds2merged,"inds2merged.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		#inds2merged2	<<- inds2merged2
		write.table(inds2merged2,"inds2merged2.txt",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)
		nrows			<- nrow(inds2merged2)
		return(cat(paste("ERROR: unexpected number of rows of inds2 dataframe (",nrows,") after merging with indstemp2. Contact developer of SambaR.",sep=""),sep="\n"))
		}
	inds2				<- inds2merged2
	inds2$indpair		<- ifelse(as.character(inds2$name1)<as.character(inds2$name2),paste(inds2$name1,inds2$name2,sep="_"),paste(inds2$name1,inds2$name2,sep="_"))
	inds2$poppair		<- ifelse(as.character(inds2$pop1)<as.character(inds2$pop2),paste(inds2$pop1,inds2$pop2,sep="_"),paste(inds2$pop1,inds2$pop2,sep="_"))
	inds2$sameind		<- inds2$name1==inds2$name2
	inds2$samepop		<- inds2$pop1==inds2$pop2
	if(exists("mysambar"))
		{
		inds2$poporder1	<- factor(inds2$pop1,levels=mysambar$poporder)
		inds2$poporder2	<- factor(inds2$pop2,levels=mysambar$poporder)
		}else{
		inds2$poporder1	<- inds2$pop1
		inds2$poporder2	<- inds2$pop2
		}
	if(geobool)
		{
		cat("Adding geographical distances to inds2 dataframe...",sep="\n")
		# chord distance (in degrees):
		long			<- abs(inds2$long2-inds2$long1)
		lat				<- abs(inds2$lat2-inds2$lat1)
		inds2$chorddist	<- sqrt(long^2+lat^2)
		#
		# great circle distance (in km):
		lat1			<- inds2$lat1*pi/180
		lat2			<- inds2$lat2*pi/180
		long1			<- inds2$long1*pi/180
		long2			<- inds2$long2*pi/180
		inds2$geodist 	<- acos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2) * cos(long2-long1)) * 6371	# 6371 is estimate of earth mean radius in km
		inds2$geodist[!is.finite(inds2$geodist)]	<- NA
		inds2$geodist	<- inds2$geodist/100		# unit: 100 km
		}else{
		cat("WARNING: not calculating geographic distance (because no geographical position information present). This means you cannot generate a Mantel plot using the pops2scatter function.",sep="\n") 
		}
	inds2		<<- inds2
	}

getpops2<-function()
	{
	cat("Creating pops2 dataframe...",sep="\n")
	popnames		<- unique(inds$pop)
	npops			<- length(popnames)
	if(npops>1)
		{
		combitable		<- combn(popnames,m=2)
		pops2			<- data.frame("pop1"=c(popnames,combitable[1,]),"pop2"=c(popnames,combitable[2,]),"samepop"=TRUE,"filter1"=TRUE,"filter2"=TRUE,"filter"=TRUE,"poppair"=NA,"popcol1"=NA,"popcol2"=NA,"ninds1"=NA,"ninds2"=NA,"long1"=NA,"lat1"=NA,"long2"=NA,"lat2"=NA,"chorddist"=NA,"geodist"=NA)
		}else{
		pops2			<- data.frame("pop1"=popnames,"pop2"=popnames,"samepop"=TRUE,"filter1"=TRUE,"filter2"=TRUE,"filter"=TRUE,"poppair"=NA,"popcol1"=NA,"popcol2"=NA,"ninds1"=NA,"ninds2"=NA,"long1"=NA,"lat1"=NA,"long2"=NA,"lat2"=NA,"chorddist"=NA,"geodist"=NA)
		}
	pops2$poppair	<- ifelse(as.character(pops2$pop1)<as.character(pops2$pop2),paste(pops2$pop1,pops2$pop2,sep="_"),paste(pops2$pop1,pops2$pop2,sep="_"))
	geobool			<- "longitude3"%in%colnames(inds)
	#
	for(i in c(1:nrow(pops2)))
		{
		pop1				<- as.character(pops2$pop1[i])
		pop2				<- as.character(pops2$pop2[i])
		pops2$popcol1[i]	<- inds$popcol[as.character(inds$pop)==pop1][1]
		pops2$popcol2[i]	<- inds$popcol[as.character(inds$pop)==pop2][1]
		pops2$samepop[i]	<- pop1==pop2
		pops2$ninds1[i]		<- nrow(inds[as.character(inds$pop)==pop1,])
		pops2$ninds2[i]		<- nrow(inds[as.character(inds$pop)==pop2,])
		#
		if(geobool)
			{
			if("filter"%in%colnames(inds))
				{
				pops2$long1[i]	<- mean(inds$longitude3[as.character(inds$pop)==pop1&inds$filter],na.rm=TRUE)
				pops2$long2[i]	<- mean(inds$longitude3[as.character(inds$pop)==pop2&inds$filter],na.rm=TRUE)
				pops2$lat1[i]	<- mean(inds$latitude[as.character(inds$pop)==pop1&inds$filter],na.rm=TRUE)
				pops2$lat2[i]	<- mean(inds$latitude[as.character(inds$pop)==pop2&inds$filter],na.rm=TRUE)
				}else{
				pops2$long1[i]	<- mean(inds$longitude3[as.character(inds$pop)==pop1],na.rm=TRUE)
				pops2$long2[i]	<- mean(inds$longitude3[as.character(inds$pop)==pop2],na.rm=TRUE)
				pops2$lat1[i]	<- mean(inds$latitude[as.character(inds$pop)==pop1],na.rm=TRUE)
				pops2$lat2[i]	<- mean(inds$latitude[as.character(inds$pop)==pop2],na.rm=TRUE)
				}
			}
		}
	if(geobool)
		{
		# chord distance (in degrees):
		long			<- abs(pops2$long2-pops2$long1)
		lat				<- abs(pops2$lat2-pops2$lat1)
		pops2$chorddist	<- sqrt(long^2+lat^2)
		# great circle distance (in km):
		lat1			<- pops2$lat1*pi/180
		lat2			<- pops2$lat2*pi/180
		long1			<- pops2$long1*pi/180
		long2			<- pops2$long2*pi/180
		pops2$geodist 	<- acos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2) * cos(long2-long1)) * 6371	# 6371 is estimate of earth mean radius in km
		pops2$geodist[!is.finite(pops2$geodist)]	<- NA
		pops2$geodist	<- pops2$geodist/100		# unit: 100 km
		}
	pops2	<<- pops2
	}

# 22-06-2022: adding information from inds2 dataframe into pops2 dataframe:
inds2pops<-function(missfilter=NULL)
	{
	cat("Summarizing information in inds2 dataframe in pops2 dataframe.",sep="\n")
	if(is.null(missfilter))
		{
		cat("Including all individual pairs...",sep="\n")
		missfilter	<- rep(TRUE,nrow(inds2))
		}else{
		cat("Filtering inds2 dataframe based on filter specified to missfilter flag...",sep="\n")
		}
	# aggregate:
	num_cols 			<- unlist(lapply(inds2,is.numeric))        
	mydf 				<- inds2[missfilter,num_cols]                        
	mydf$ind1			<- NULL
	mydf$ind2			<- NULL
	mydf$poppair		<- inds2$poppair[missfilter]
	mydf2				<- aggregate(mydf[,c(1:ncol(mydf)-1)], by = list(mydf$poppair),FUN=mean,na.rm=TRUE)
	# merge:
	newcolnames			<- colnames(mydf2)
	if(length(newcolnames)==0)
		{
		return(cat("ERROR: no columns to merge.",sep="\n"))
		}
	oldcolnames			<- colnames(pops2)
	mybool				<- oldcolnames%in%newcolnames
	pops2temp			<- pops2[,!mybool]
	colnames(mydf2)[1]	<- "poppair" 
	pops2temp			<- merge(pops2temp,mydf2,by="poppair",all.x=TRUE)
	if(nrow(pops2)!=nrow(pops2temp))
		{
		mydf2			<<- mydf2
		pops2temp		<<- pops2temp
		return(cat("ERROR: after merging unexpected number of nrows for pops2 dataframe.",sep="\n"))
		}
	pops2				<<- pops2temp
	cat("Dataframe 'pops2' has been updated.",sep="\n")
	}

# 20-06-2022: add results to inds2 dataframe. For example, output from VCF_calcdist.sh.
add2inds2<-function(myfile=NULL,mutrate=NULL,errorrate=0,gentime=NULL,miss_filter=NULL,ntotalsites=NULL)
	{
	if(is.null(myfile))
		{
		cat("ERROR: specify a file name to the myfile flag.",sep="\n")
		}
	if(!file.exists(myfile))
		{
		cat("ERROR: specified file not found in directory:",sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	# following lines are needed to process output from old VCF_calcdist script: 
	inds2$h0	<<- NULL
	inds2$h1	<<- NULL
	inds2$d0	<<- NULL
	inds2$d1	<<- NULL
	inds2$d2he	<<- NULL
	inds2$d2ho	<<- NULL
	inds2$hd0	<<- NULL
	inds2$hd1	<<- NULL
	inds2$hd2	<<- NULL
	cat("Adding information to inds2 (NOT inds!) dataframe...",sep="\n")
	x		<- read.table(myfile,header=TRUE)
	npairs	<- nrow(inds2)
	if(any(!c("name1","name2")%in%colnames(x)))
		{
		return(cat("ERROR: input dataframe should contain the columns 'name1' and 'name2'.",sep="\n"))
		}
	if(nrow(inds2)!=nrow(x))
		{
		cat(paste("WARNING: number of rows in input dataframe (",nrow(x),") does not correspond to number of rows in inds2 dataframe (",nrow(inds2),").",sep=""),sep="\n")
		}
	mycolnames	<- colnames(x)
	mycolnames	<- mycolnames[!mycolnames%in%c("name1","name2")]
	if(any(mycolnames%in%colnames(inds2)))
		{
		cat("WARNING: replacing existing columns in inds2 dataframe.",sep="\n")
		inds2	<<- inds2[,!(colnames(inds2)%in%mycolnames)]	
		}
	indpairvec	<- ifelse(as.character(x$name1)<as.character(x$name2),paste(x$name1,x$name2,sep="_"),paste(x$name2,x$name1,sep="_"))
	x$indpair	<- indpairvec
	x			<- x[!duplicated(x$indpair),]
	x$name1		<- NULL
	x$name2		<- NULL
	if(nrow(inds2)<nrow(x))
		{
		# 11-01-2023: replace all=FALSE with all=TRUE
		inds2temp	<- merge(inds2,x,all=FALSE,by="indpair")
		if(nrow(inds2temp)!=npairs)
			{
			inputdf	<<- x
			return(cat("ERROR: merging 'merge(all=FALSE)' resulted in unexpected number of rows.",sep="\n"))
			}
		inds2		<<- inds2temp
		}else{
		inds2temp	<- merge(inds2,x,all=TRUE,by="indpair")
		if(nrow(inds2temp)!=npairs)
			{
			inputdf	<<- x
			return(cat("ERROR: merging 'merge(all=TRUE)' resulted in unexpected number of rows.",sep="\n"))
			}
		inds2		<<- inds2temp
		}
	cat("Information added to inds2 dataframe.",sep="\n")
	if("n0"%in%colnames(inds2)|"hd0"%in%colnames(inds2))
		{
		# following lines are needed to process output from old VCF_calcdist script: 
		inds2		<- inds2temp
		calc_rawdistance(error_rate=errorrate,mut_rate=mutrate,gen_time=gentime,missfilter=miss_filter)
		}
	if(!is.null(ntotalsites))
		{
		if(!"d_snps"%in%colnames(inds2))
			{
			return(cat("ERROR: column 'd_snps' not present in inds2 dataframe.",sep="\n"))
			}
		inds2$d		<<- inds2$d_snps*inds2$nsites/ntotalsites	
		inds2$dperc	<<- inds2$d*100
		inds2$dperc2<<- inds2$dperc
		inds2$dperc2[inds2$pop1==inds2$pop2]<<- 0
		}
	inds2pops(missfilter=miss_filter)
	}
	
calc_rawdistance<-function(error_rate=0,mut_rate=1*10^-8,gen_time=NULL,missfilter=0.25)
	{
	cat("Calculating raw genetic distance...",sep="\n")
	# optionally calculate raw genetic distance (if input data is generated by VCF_calcdist.sh
	# For haploid data, input file contains counts for two scenarios:
	# n0	=	A	A
	# n1	= 	A 	T	
	# For diploid data, input file contains counts for four scenarios: 
	# n0	=	AA	AA					
	# n1	=	AT	AA			
	# n2he	=	AT	AT			
	# n2ho	=	AA	TT	
	# For haplodiploid data, input file contains counts for three scenarios:
	# hd0	=	A	AA
	# hd1	= 	A	AT
	# hd2	= 	A	TT
	#
	# Raw genetic distance is calculated as:
	# for haploid data:
	# d		<- h1/(h0+h1)*100
	# for diploid data:
	# d		<- (n1*0.5+n2he*0.5+n2ho)/(n0+n1+n2he+n2ho)*100
	# for haplodiploid data:
	# 	- if both individuals are both haploid or both diploid: see previous lines
	#	- if one individual haploid (e.g. male, X-chromosome), one diploid (e.g., female, X-chromosome):
	# d	<- (hd1*0.5+hd2)/(hd0+hd1+hd2)
	#
	# mut_rate and gen_time are used only if flag haploid is set to TRUE.
	# Expects to find in the working directory the file 'vcfdist.txt' file generated with the 'VCF_calcdist.sh' script.
	# Error rate for y chromosome: 1*10^-4
	# Error rate for autosomes (diploid): 0.7*10^-5
	#
	hadi_data	<-	all(c("h0","h1","d0","d1","d2he","d2ho","hd0","hd1","hd2")%in%colnames(inds2))	# haplodiploid data
	didi_data	<- all(c("n0","n1","n2he","n2ho")%in%colnames(inds2))								# diplodiploid data
	#	
	if(hadi_data)
		{
		cat("Haplodiploid data.",sep="\n")
		inds2$ploidy	<- ifelse(inds2$h0>0|inds2$h1>0,"HA_HA",ifelse(inds2$hd0>0|inds2$hd1>0|inds2$hd2>0,"HA_DI","DI_DI"))
		inds2$d			<- NA
		inds2$meanhe	<- NA
		inds2$d_miss	<- NA
		# both haploid:
		inds2$d			<- ifelse(inds2$h0>0|inds2$h1>0,ifelse(inds2$name1!=inds2$name2,ifelse(inds2$h0+inds2$h1!=0,inds2$h1/(inds2$h0+inds2$h1)*100,NA),0),inds2$d)
		inds2$meanhe	<- ifelse(inds2$h0>0|inds2$h1>0,0,inds2$meanhe)
		inds2$d_miss	<- ifelse(inds2$h0>0|inds2$h1>0,inds2$nmiss/(inds2$nmiss+inds2$h0+inds2$h1),inds2$d_miss)
		# both diploid:
		inds2$d			<- ifelse(inds2$d0>0|inds2$d1>0|inds2$d2he>0|inds2$d2ho>0,(inds2$d1*0.5+inds2$d2he*0.5+inds2$d2ho)/(inds2$d0+inds2$d1+inds2$d2he+inds2$d2ho)*100,inds2$d)
		inds2$d			<- ifelse(inds2$d0>0|inds2$d1>0|inds2$d2he>0|inds2$d2ho>0,ifelse(inds2$name1==inds2$name2,2*inds2$d,inds2$d),inds2$d)	# 12-02-2024: otherwise, half of heterozygosity
		inds2$meanhe	<- ifelse(inds2$d0>0|inds2$d1>0|inds2$d2he>0|inds2$d2ho>0,(inds2$d1*0.5+inds2$d2he)/(inds2$d0+inds2$d1+inds2$d2he+inds2$d2ho)*100,inds2$meanhe)
		inds2$d_miss	<- ifelse(inds2$d0>0|inds2$d1>0|inds2$d2he>0|inds2$d2ho>0,inds2$nmiss/(inds2$nmiss+inds2$d0+inds2$d1+inds2$d2he+inds2$d2ho),inds2$d_miss)
		# one haploid, one diploid:
		inds2$d			<- ifelse(inds2$hd0>0|inds2$hd1>0|inds2$hd2>0,(inds2$hd1*0.5+inds2$hd2)/(inds2$hd0+inds2$hd1+inds2$hd2)*100,inds2$d)
		inds2$meanhe	<- ifelse(inds2$hd0>0|inds2$hd1>0|inds2$hd2>0,(inds2$hd1)/(inds2$hd0+inds2$hd1+inds2$hd2)*100,inds2$meanhe)
		inds2$d_miss	<- ifelse(inds2$hd0>0|inds2$hd1>0|inds2$hd2>0,inds2$nmiss/(inds2$nmiss+inds2$hd0+inds2$hd1+inds2$hd2),inds2$d_miss)
		}else{
		if(didi_data)
			{
			cat("Diploid data.",sep="\n")
			inds2$ploidy	<- "DI_DI"
			inds2$ho2		<- (inds2$n2ho)/(inds2$n0+inds2$n1+inds2$n2he+inds2$n2ho)*100
			inds2$d			<- (inds2$n1*0.5+inds2$n2he*0.5+inds2$n2ho)/(inds2$n0+inds2$n1+inds2$n2he+inds2$n2ho)*100
			inds2$d			<- ifelse(inds2$name1==inds2$name2,2*inds2$d,inds2$d)		# 12-02-2024: otherwise, half of heterozygosity
			inds2$meanhe	<- (inds2$n1*0.5+inds2$n2he)/(inds2$n0+inds2$n1+inds2$n2he+inds2$n2ho)*100
			#inds2$he		<- inds2$n2he/(inds2$n2he+inds2$n0)*100
			inds2$d_miss	<- inds2$nmiss/(inds2$nmiss+inds2$n0+inds2$n1+inds2$n2he+inds2$n2ho)
			}else{
			cat("Haploid data.",sep="\n")
			inds2$ploidy		<- "HA_HA"
			inds2$d				<- ifelse(inds2$name1!=inds2$name2,ifelse(inds2$n0+inds2$n1!=0,inds2$n1/(inds2$n0+inds2$n1)*100,NA),0)
			#inds2$meanhe		<- 0
			inds2$exp_nerror 	<- ifelse(inds2$name1!=inds2$name2,ifelse(inds2$n0+inds2$n1!=0,round((inds2$n0+inds2$n1)*error_rate),NA),0)
			inds2$d_corrected	<- ifelse(inds2$name1!=inds2$name2,ifelse(inds2$n0+inds2$n1!=0,(inds2$n1-inds2$exp_nerror)/(inds2$n0+inds2$n1)*100,NA),0)
			inds2$d_miss		<- inds2$nmiss/(inds2$nmiss+inds2$n0+inds2$n1)
			if(!is.null(gen_time)&!is.null(mut_rate))
				{
				cat("Assuming specified mutation rate is per site per generation.",sep="\n") 
				inds2$tmrca_g	<- (1/100*inds2$d_corrected)/(2*mut_rate)
				inds2$tmrca_y	<- inds2$tmrca_g*gen_time
				}
			if(is.null(gen_time)&!is.null(mut_rate))
				{
				cat("Assuming specified mutation rate is per site per year.",sep="\n") 
				inds2$tmrca_y	<- (1/100*inds2$d_corrected)/(2*mut_rate)
				inds2$tmrca_g	<- NA
				}
			}
		}
	inds2$d2	<- inds2$d
	inds2$d3	<- inds2$d
	inds2		<<- inds2
	#
	if(hadi_data)
		{
		pdf("Distance_versus_ploidy.boxplot.pdf")
		boxplot(inds2$d3~inds2$ploidy,xlab="Ploidy",ylab="Genetic distance (%)")
		#stripchart(d3~ploidy,data=inds2,vertical=TRUE,method="jitter",pch=16,cex=1,bg="bisque",las=2,xlab="",ylab="",add=TRUE)
		dev.off()
		}
	cat("Raw genetic distances added to inds2 dataframe.",sep="\n")
	}

# 22-06-2022: renamed from 'dxystripchart' to 'plot_rawdistance'
plot_rawdistance<-function(export=NULL,addylabel=TRUE,logy=FALSE,mycex=1.75,mytitle=NULL,plotlabel=NULL,ymax=NULL,plotwidth=6,plot_tmrca=FALSE)
	{
	popcols			<- mysambar$colorder
	popnames		<- mysambar$poporder
	npops			<- length(popnames)
	mydf			<- droplevels(inds2[inds2$filter&!inds2$sameind,])
	if(plot_tmrca)
		{
		if(!"tmrca_y"%in%colnames(mydf))
			{
			return(cat("Column 'tmrca_y' not present in inds2 dataframe.",sep="\n"))
			}
		mydf$myscore	<- mydf$tmrca_y
		}else{
		if(!"d3"%in%colnames(mydf))
			{
			return(cat("Column 'd3' not present in inds2 dataframe.",sep="\n"))
			}
		mydf$myscore	<- mydf$d3
		}
	if(!is.null(export))
		{
		myheight=0.25
		myheight2=75
		plotname	<- ifelse(plot_tmrca,"Dxy_pop_tmrca","Dxy_pop")
		plotname	<- ifelse(is.null(ymax),plotname,paste(plotname,ymax,sep="."))
		mylabel		<- ifelse(is.null(plotlabel),"boxplot",paste("boxplot",plotlabel,sep="."))
		if(export=="eps"){postscript(paste(plotname,mylabel,"eps",sep="."),family=mysambar$myfont,height=npops*myheight+2,width=plotwidth)}
		if(export=="pdf"){pdf(paste(plotname,mylabel,"pdf",sep="."),family=mysambar$myfont,height=npops*myheight+2,width=plotwidth)}
		if(export=="png"){png(paste(plotname,mylabel,"png",sep="."),family=mysambar$myfont,height=npops*myheight2+200,width=plotwidth*100)}
		if(export=="wmf")
			{
			if(mysambar$os=="Windows")
				{
				win.metafile(paste(plotname,mylabel,"wmf",sep="."),family=mysambar$myfont,height=npops*myheight+2,width=plotwidth)
				}else{
				return(cat("Can not create a windows metafile.",sep="\n"))
				}
			}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=3)
	if(is.null(ymax))
		{
		y_lim	<- c(0,1.025*max(mydf$myscore,na.rm=TRUE))
		}else{
		y_lim	<- c(0,ymax)
		}
	boxplot(mydf$myscore~mydf$poporder1,border="white",col="white",las=1,xlab="",ylab="",horizontal=TRUE,cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim,yaxt='n')
	#axis(2); axis(1, labels = NA); box()
	mtext(popnames,at=1:npops,side=2,line=0.5,col=popcols,las=1,cex=1.75)
	for(j in c(1:npops))
		{
		mypop		<- as.character(popnames[j])
		popdxy		<- mydf[as.character(mydf$pop2)==mypop,]
		mycolour	<- popcols[j]
		stripchart(myscore~poporder1,data=popdxy,vertical=FALSE,method="jitter",pch=16,cex=mycex,col=mycolour,bg="bisque",add=TRUE)
		}
	if(addylabel)
		{	
		ylabel	<- ifelse(plot_tmrca,"TMRCA (y)","Raw genetic distance (%)")
		mtext(side=1,ylabel,line=0.75,cex=2.25,outer=TRUE,las=0)
		}
	if(!is.null(mytitle))
		{
		mtext(side=3,mytitle,cex=2,line=0.25)
		}
	#mtext(side=1,"Population",line=2.75,cex=1.5)
	if(!is.null(export)){dev.off()}
	}

# 20-06-2022: originally called 'importdxydata'. Depreciated. Use instead 'add2inds2()' function.
getpairscores<-function(myfile="allvcfdist.noheaders.txt",haploid=FALSE,error_rate=0.0001,mut_rate=1.2*10^-8,gen_time=NULL)
	{
	cat("Importing data...",sep="\n")
	if(!file.exists(myfile))
		{
		return(cat("ERROR: file specified to the 'myfile' flag does not exist.",sep="\n"))
		}
	x			<- read.table(myfile,header=TRUE)
	x			<- x[order(x$ind1,x$ind2),]
	if(haploid)
		{
		cat("Haploid data.",sep="\n")
		x$dxy			<- ifelse(x$name1!=x$name2,ifelse(x$n0+x$n1!=0,x$n1/(x$n0+x$n1)*100,NA),0)
		x$he		 	<- 0
		x$exp_nerror 	<- ifelse(x$name1!=x$name2,ifelse(x$n0+x$n1!=0,round((x$n0+x$n1)*error_rate),NA),0)
		x$dxy_corrected	<- ifelse(x$name1!=x$name2,ifelse(x$n0+x$n1!=0,(x$n1-x$exp_nerror)/(x$n0+x$n1)*100,NA),0)
		if(!is.null(gen_time)&!is.null(mut_rate))
			{
			cat("Assuming specified mutation rate is per site per generation.",sep="\n") 
			x$tmrca_g		<- (1/100*x$dxy_corrected)/(2*mut_rate)
			x$tmrca_y		<- x$tmrca_g*gen_time
			}
		if(is.null(gen_time)&!is.null(mut_rate))
			{
			cat("Assuming specified mutation rate is per site per year.",sep="\n") 
			x$tmrca_y		<- (1/100*x$dxy_corrected)/(2*mut_rate)
			x$tmrca_g		<- NA
			}
		}else{
		cat("Diploid data.",sep="\n")
		x$dxy	<- (x$n1*0.5+x$n2he*0.5+x$n2ho)/(x$n0+x$n1+x$n2he+x$n2ho)*100
		x$he	<- x$n2he/(x$n2he+x$n0)
		}
	x$dxy2		<- x$dxy
	x$dxy3		<- x$dxy
	cat("Extracting information from inds dataframe...",sep="\n")
	mycolnames	<- c("name","pop","clade","popcol","cladecol","filter","longitude3","latitude")
	if(any(!mycolnames%in%colnames(inds)))
		{
		if("longitude3"%in%colnames(inds))
			{
			cat("Not adding clade information.",sep="\n")
			y			<- inds[,c("name","pop","popcol","filter","longitude3","latitude")]
			colnames(y)	<- c("name1","pop1","popcol1","bool1","long1","lat1")
			x			<- merge(x,y,by="name1")
			colnames(y)	<- c("name2","pop2","popcol2","bool2","long2","lat2")
			x			<- merge(x,y,by="name2")
			x			<- x[order(x$ind1,x$ind2),]
			}else{
			cat("Extracting information on population, population colour and filter pass.",sep="\n")
			y			<- inds[,c("name","pop","popcol","filter")]
			colnames(y)	<- c("name1","pop1","popcol1","bool1")
			x			<- merge(x,y,by="name1")
			colnames(y)	<- c("name2","pop2","popcol2","bool2")
			x			<- merge(x,y,by="name2")
			x			<- x[order(x$ind1,x$ind2),]
			}
		}else{
		cat("Extracting information on population, population colour and filter pass.",sep="\n")
		cat("In addition, extracting information on clade and geographical position.",sep="\n")  
		y			<- inds[,c("name","pop","clade","popcol","cladecol","filter","longitude3","latitude")]
		colnames(y)	<- c("name1","pop1","clade1","popcol1","cladecol1","bool1","long1","lat1")
		x			<- merge(x,y,by="name1")
		colnames(y)	<- c("name2","pop2","clade2","popcol2","cladecol2","bool2","long2","lat2")
		x			<- merge(x,y,by="name2")
		x			<- x[order(x$ind1,x$ind2),]
		}
	x$poppair	<- ifelse(as.character(x$pop1)<as.character(x$pop2),paste(x$pop1,x$pop2,sep="_"),paste(x$pop1,x$pop2,sep="_"))
	if("long2"%in%colnames(x))
		{
		cat("Adding geographical distances...",sep="\n")
		# chord distance (in degrees):
		x$long		<- abs(x$long2-x$long1)
		x$lat		<- abs(x$lat2-x$lat1)
		x$chorddist	<- sqrt(x$long^2+x$lat^2)
		#
		# great circle distance (in km):
		lat1		<- x$lat1*pi/180
		lat2		<- x$lat2*pi/180
		long1		<- x$long1*pi/180
		long2		<- x$long2*pi/180
		x$geodist 	<- acos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2) * cos(long2-long1)) * 6371	# 6371 is estimate of earth mean radius in km
		x$geodist[!is.finite(x$geodist)]	<- NA
		x$geodist	<- x$geodist/100		# unit: 100 km
		}else{
		cat("WARNING: not calculating geographic distance (because no geographical position information present). This means you cannot generate a Mantel plot.",sep="\n") 
		}
	mydistdf	<<- x
	cat("Results saved in dataframe object called 'mydistdf'.",sep="\n")
	}

plottwisst<-function(doexport=TRUE,myfile=NULL,mycolours=c("grey70","mediumpurple1","darkorchid4"))
	{
	if(is.null(myfile))
		{
		return(cat("ERROR: provide the name of the Twiss output file (ending on weights.csv.gz) to the myfile flag.",sep="\n"))
		}
	#mycolours	<- c("grey90","grey50","grey10")
	if(doexport)
		{
		pdf("Twiss_barplot.pdf",width=16,height=4)
		}
	mytopos		<- read.table(myfile,as.is=T,header=F,comment="",nrows=3)
	mytopos		<- mytopos$V2
	mytopos		<- gsub("),","),(",mytopos)
	mytopos		<- gsub(");","))",mytopos)
	mytopos		<- mytopos
	library(data.table)
	w 			<- as.data.frame(fread(myfile))
	w 			<- w/rowSums(w)
	myperc		<- round(as.vector(colSums(w)/sum(colSums(w))),3)
	mytopos		<- paste(mytopos,myperc,sep=": ")
	barplot(as.matrix(t(w)),col=mycolours,border="white",las=1)
	legend("top",fill=mycolours,border=NA,legend=mytopos,horiz=TRUE,inset=c(0,-0.3),xpd=TRUE,bty="n",cex=1.25)
	if(doexport)
		{
		dev.off()
		cat("The file 'Twiss_barplot.pdf' has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 21-11-2023: histogram of genetic distances
haplohisto<-function(bool1=NULL,bool2=NULL,plotlabel=NULL,plottitle="",doexport=TRUE,mybreaks=NULL,nbreaks=100,y_lim=NULL,x_lim=NULL,dofreq=TRUE,dolog,uline=0,nline=-1,textcex=1,returnobject=FALSE)
	{	
	if(is.null(bool1)|is.null(bool2))
		{
		return(cat("ERROR: provide boolean vector to bool1 and bool2 flag.",sep="\n"))
		}
	if(!is.logical(bool1)|!is.logical(bool2))
		{
		return(cat("ERROR: vectors provided to bool1 and bool2 flag should be logical (boolean) vectors.",sep="\n"))
		}
	if(is.null(alldistdf))
		{
		return(cat("ERROR: dataframe 'alldistdf' not found. First run: haplodistmat(dohisto=TRUE).",sep="\n"))
		}
	mypairs1	<- paste(inds$name[bool1],inds$name[bool2],sep="_")
	mypairs2	<- paste(inds$name[bool2],inds$name[bool1],sep="_")
	mypairs		<<- c(mypairs1,mypairs2)
	#
	dvec		<- alldistdf$d[alldistdf$pair%in%mypairs]
	if(dolog)
		{
		dvec[dvec==0]	<- min(dvec[dvec!=0],na.rm=TRUE)
		dvec			<- log10(dvec)
		}
	if(is.null(x_lim))
		{
		x_lim	<- c(min(dvec,na.rm=TRUE),max(dvec,na.rm=TRUE))
		x_lim	<<- x_lim
		}
	plotname	<- "Histogram_distances"
	plotname	<- ifelse(is.null(plotlabel),paste(plotname,"pdf",sep="."),paste(plotname,plotlabel,"pdf",sep="."))
	if(doexport){pdf(plotname)}
	if(is.null(mybreaks))
		{
		myhisto<-hist(dvec,freq=dofreq,xlab="Genetic distance",ylab="Proportion",main=plottitle,border=NA,breaks=nbreaks,ylim=y_lim,xlim=x_lim,las=1)
		}else{
		myhisto<-hist(dvec,freq=dofreq,xlab="Genetic distance",ylab="Proportion",main=plottitle,border=NA,breaks=mybreaks,ylim=y_lim,xlim=x_lim,las=1)
		}
	mtext(side=3,line=uline,paste("u = ",round(mean(alldistdf$d[alldistdf$pair%in%mypairs]),5),", sd = ",round(sd(alldistdf$d[alldistdf$pair%in%mypairs]),5),sep=""),cex=textcex)
	mtext(side=3,line=nline,paste("n = ",length(alldistdf$d[alldistdf$pair%in%mypairs])/2,sep=""),cex=textcex)
	if(doexport){dev.off()}
	if(returnobject)
		{
		return(myhisto)
		}
	}

# 27-10-2023: create evidence board ('Anacapa chart') or histogram of genetic distances:
haplodistmat<-function(mychroms=NULL,exporttype=NULL,myinds=inds$name[inds$filter],dropvec=inds$name[!inds$filter],do_overwrite=FALSE,getdata=TRUE,dohisto=FALSE,correctdist=TRUE,plothisto=FALSE,histopop="Black",docombine=TRUE,doplot=TRUE,dmin=0,dmax=0.01,plotbin=4,mysd=0.02,mybreaks=c(-0.01,0.05,0.1,0.15,0.2,0.25,1),mycolours=c("white","grey90","grey50","yellow","orange","red"),legendpos="topright",legendcex=1.25)
	{
	if(is.null(mychroms))
		{
		return(cat("ERROR: provide a vector with scaffold names to the mychroms flag.",sep="\n"))
		}
	nbins			<- length(mybreaks)-1
	if(length(mycolours)!=nbins)
		{
		return(cat("ERROR: length of colours vector should be length of mybreaks vector minus 1.",sep="\n"))
		}
	ninds			<- length(myinds)			# Note: does this refer to haploid data or to diploid data? In case SambaR snpdataset is loaded for diploid data (needed for evidence board), then different compared to when create locus trees
	npairs			<- (ninds*(ninds-1))/2
	nchroms			<- length(mychroms)
	ntotalloci		<- 0
	#
	pairdf			<- as.data.frame(t(combn(myinds,m=2)))
	colnames(pairdf)<- c("name1","name2") 
	pairdf			<- rbind(pairdf,data.frame("name1"=myinds,"name2"=myinds))
	pairdf$pair		<- ifelse(pairdf$name1<pairdf$name2,paste(pairdf$name1,pairdf$name2,sep="_"),paste(pairdf$name2,pairdf$name1,sep="_"))
	#
	if(getdata)
		{
		if("data.table"%in%(.packages()) == FALSE){library("data.table")}
		if(file.exists(paste("haploblockcounts",paste(dmin,"_",dmax,sep=""),mychroms[1],"txt",sep="."))&!do_overwrite&!dohisto)
			{
			cat("Files already seem to exist. Do you really want to rerun the analyses? If yes, set the flag 'do_overwrite' to TRUE. If not, set the flag 'getdata' to FALSE.",sep="\n") 
			}
		if(correctdist)
			{
			if(length(list.files(pattern = "mychrom.*.haploblocks.txt"))>0)
				{
				cat("Found files ending on 'haploblocks.txt'. Assuming these files are present for all chromosomes, so that genetic distances can be calculated for the entire haploblocks (not just variable sites).",sep="\n")
				}else{
				cat("WARNING: not correcting distances (i.e. not considering monomorphic sites), because no files found ending on 'haploblocks.txt'.",sep="\n")
				correctdist	<- FALSE
				}
			}else{
			cat("WARNING: not correcting distances (i.e. not considering monomorphic sites), because flag 'correctdist' is set to FALSE.",sep="\n")
			}
		for (chromnr in c(1:nchroms))
			{
			mychrom		<- mychroms[chromnr]
			cat(" ",sep="\n")
			cat(paste("Reading data for ",mychrom,"...",sep=""),sep="\n")
			x				<- fread(paste("vcfdist",mychrom,"txt",sep="."),header=FALSE)
			colnames(x)		<- c("ind1","ind2","name1","name2","nmiss","n0","n1","chrom","startbp")
			x$indpair		<- paste(x$ind1,x$ind2,sep="_")
			npairs2			<- length(unique(x$indpair))		# this is preferred, because insensitive to whether sambar dummy dataset is loaded for haploid/diploid data, and for removal of individuals by dropvec
			omitloci		<- vector()
			if(any(is.na(x$startbp)))
				{
				cat("WARNING: NA-values detected. Omitting locus/loci...",sep="\n")
				omitloci	<- which(is.na(x$startbp))
				omitloci	<- omitloci[omitloci%%npairs2==0]/npairs2
				x			<- x[!is.na(x$startbp),]
				}
			x$block			<- paste(x$chrom,x$startbp,sep="_")
			x$indname1		<- gsub("-2","",(gsub("-1","",x$name1)))
			x$indname2		<- gsub("-2","",(gsub("-1","",x$name2)))
			x$pair			<- ifelse(x$indname1<x$indname2,paste(x$indname1,x$indname2,sep="_"),paste(x$indname2,x$indname1,sep="_"))
			#			
			if(!is.null(dropvec))
				{
				if(length(dropvec)>0)
					{
					cat("Removing individuals...",sep="\n")
					x			<- x[!(x$indname1%in%dropvec|x$indname2%in%dropvec),]
					}
				}
			x$d					<- x$n1/(x$n0+x$n1)
			x$miss				<- x$nmiss/(x$n0+x$n1+x$nmiss)			# should be zero because of imputation
			if(correctdist)
				{
				if(file.exists(paste("mychrom",mychrom,"haploblocks.txt",sep=".")))
					{
					z			<- fread(paste("mychrom",mychrom,"haploblocks.txt",sep="."),header=FALSE)
					}else{
					return(cat("ERROR: file ending on 'haploblocks.txt' not found.",sep="\n"))
					}
				colnames(z)		<- c("chrom","startbp","endbp","length","nsnps")
				z$block			<- paste(z$chrom,z$startbp,sep="_")
				z$length2		<- z$endbp-z$startbp
				z$meanspacing	<- z$length2/z$nsnps
				#x				<<- x
				#z				<<- z
				if(length(omitloci)>0)
					{
					cat("Omitting loci from haploblocks.txt dataframe...",sep="\n")
					z			<- z[-omitloci,]
					}
				if(nrow(z)!=length(unique(x$block)))
					{
					return(cat("ERROR: number of haploblocks in distance 'vcfdist.txt' does not correspond with number of haploblocks in 'haploblocks.txt' file.",sep="\n"))
					}
				z				<- z[rep(seq_len(nrow(z)),each=npairs2), ]
				x$length		<- z$length2
				x$prop			<- (x$n0+x$n1)/x$length
				x$d				<- x$d*x$prop
				}
			#
			# for(k in c(1:nrow(x)))
			#	{
			#	myind1		<- x$name1[k]
			#	myind2		<- x$name2[k]
			#	x$pop1[k]	<- inds$pop[inds$name==myind1]
			#	x$pop2[k]	<- inds$pop[inds$name==myind2]
			#	}
			# x$poppair		<- ifelse(x$pop1<x$pop2,paste(x$pop1,x$pop2,sep="_"),paste(x$pop2,x$pop1,sep="_"))
			#
			myloci			<- unique(x$startbp)
			nloci			<- length(myloci)
			cat(paste("Total number of loci: ",nloci,".",sep=""),sep="\n")
			#
			# Count for each pair of individuals how many haplotypes they share (as defined by a certain maximum genetic distance):
			if(dohisto)
				{
				indsvec			<- inds$name[inds$pop==histopop]
				if(any(!indsvec%in%inds$name))
					{
					return(cat("ERROR: one or more specified individuals not present in inds dataframe.",sep="\n"))
					}
				my_ind			<- indsvec[1]
				cat(paste("Extracting data for (subset including) individual: ",my_ind,".",sep=""),sep="\n")
				y				<- x[(x$indname1%in%indsvec)|(x$indname2%in%indsvec),c("d","pair")]
				write.table(y,paste("vcfdist_subset",mychrom,my_ind,"txt",sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
				}else{
				cat(paste("Aggregating using minimum and maximum threshold: ",dmin," and ",dmax,".",sep=""),sep="\n")
				y				<- x[x$d>=dmin&x$d<dmax,c("d","pair")]
				mydistvec		<- y$d
				mypairs			<- y$pair
				aggdf			<- aggregate(mydistvec,by=list(mypairs),FUN=length)
				colnames(aggdf)	<- c("pair","n")
				if(nrow(aggdf)!=nrow(pairdf))
					{
					topupdf		<- data.frame("pair"=pairdf$pair[!pairdf$pair%in%aggdf$pair],"n"=0)
					aggdf2		<- rbind(aggdf,topupdf)
					}else{
					aggdf2		<- aggdf
					}
				# because we have 2 haplotypes per individual, there are 4 comparisons per individual
				# furthermore, each pairwise comparison is represented twice (1 vs 2, 2 vs 1)
				# hence we have to multiple number of loci with (4x2) 8
				#
				if(nrow(aggdf2)!=(npairs+ninds))
					{
					x			<<- x
					pairdf		<<- pairdf
					topupdf		<<- topupdf
					aggdf		<<- aggdf
					aggdf2		<<- aggdf2
					return(cat("ERROR: number of rows do not correspond (see objects 'pairdf', 'topupdf', 'aggdf' and 'aggdf2'). Are certain individuals not present in inds dataframe? You can drop them from input data using the dropvec flag.",sep="\n"))
					}
				for(k in c(1:nrow(aggdf2))){aggdf2$name1[k]	<- strsplit(aggdf2$pair[k],split="_")[[1]][1]}
				for(k in c(1:nrow(aggdf2))){aggdf2$name2[k]	<- strsplit(aggdf2$pair[k],split="_")[[1]][2]}
				#
				distdf				<- aggdf2[aggdf2$name1!=aggdf2$name2,] 
				distdf$chromnr		<- chromnr
				distdf$nloci		<- nloci
				distdf$dmin			<- dmin
				distdf$dmax			<- dmax
				write.table(distdf,paste("haploblockcounts",paste(dmin,"_",dmax,sep=""),mychrom,"txt",sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
				}
			}
		}
	if(docombine)
		{
		cat("Searching for file names starting with 'haploblockcounts' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		if(dohisto)
			{
			indsvec			<- inds$name[inds$pop==histopop]
			if(any(!indsvec%in%inds$name))
				{
				return(cat("ERROR: one or more specified individuals not present in inds dataframe.",sep="\n"))
				}
			my_ind			<- indsvec[1]
			cat(paste("Aggregating data for (subset including) individual: ",my_ind,".",sep=""),sep="\n")
			filenames 		<- list.files(pattern = paste("vcfdist_subset",".*.",my_ind,".txt",sep=""))
			nfiles			<- length(filenames)
			if(nfiles==0)
				{
				return(cat("ERROR: the directory does not contain files starting with 'haploblockcounts' and the specified threshold.",sep="\n"))
				}
			haplolist 		<- lapply(filenames,function(x)read.table(x,header=TRUE)) 
			alldistdf 		<<- do.call("rbind",haplolist)
			if(plothisto)
				{
				mypairs1	<- paste(inds$name[inds$pop==histopop],inds$name[inds$pop!=histopop],sep="_")
				mypairs2	<- paste(inds$name[inds$pop!=histopop],inds$name[inds$pop==histopop],sep="_")
				mypairs		<- c(mypairs1,mypairs2)
				pdf(paste("Histogram_distances",histopop,"pdf",sep="."))
				hist(alldistdf$d[alldistdf$pair%in%mypairs],freq=FALSE,breaks=100,xlab="Genetic distance",ylab="Proportion (%)",main=histopop)
				#distdf		<<- alldistdf[alldistdf$pair%in%mypairs,]
				dev.off()
				}
			}else{
			filenames 		<- list.files(pattern = paste("haploblockcounts.",paste(dmin,"_",dmax,sep=""),".*.txt",sep=""))
			#filenames 		<- list.files(pattern = paste("haploblockcounts.",dmax,".*.txt",sep=""))[1:33]
			if(length(filenames)==0)
				{
				return(cat("ERROR: the directory does not contain files starting with 'haploblockcounts' and the specified threshold.",sep="\n"))
				}
			haplolist 			<- lapply(filenames,function(x)read.table(x,header=TRUE)) 
			alldistdf 			<- do.call("rbind",haplolist)
			distdf				<- haplolist[[1]]
			distdf				<- distdf[order(distdf$pair),]
			for(k in c(1:npairs))
				{
				if(k%%1000==0){cat(k,sep="\n")}
				mypair			<- distdf$pair[k]
				distdf$n[k]		<- sum(alldistdf$n[alldistdf$pair==mypair])
				distdf$nloci[k]	<- sum(alldistdf$nloci[alldistdf$pair==mypair])
				}
			cat("Done",sep="\n")
			# distdf$dmin		<- dmin
			# distdf$dmax		<- dmax
			distdf				<<- distdf
			}
		}
	if(doplot)
		{
		mylabels			<- c(0:(nbins-1))
		mylwds				<- c(c(0,0.25),seq(1,(nbins-2)))
		distdf$prop			<- distdf$n/(distdf$nloci*8)
		distdf$bin			<- as.vector(cut(distdf$prop,mybreaks,labels=mylabels))
		distdf$col			<- as.vector(cut(distdf$prop,mybreaks,labels=mycolours))
		distdf$lwd			<- as.vector(cut(distdf$prop,mybreaks,labels=mylwds))
		for(k in c(1:npairs))
			{
			myind1			<- distdf$name1[k]
			myind2			<- distdf$name2[k]
			distdf$pop1[k]	<- inds$pop[inds$name==myind1]
			distdf$pop2[k]	<- inds$pop[inds$name==myind2]
			}
		distdf$poppair		<- ifelse(distdf$pop1<distdf$pop2,paste(distdf$pop1,distdf$pop2,sep="_"),paste(distdf$pop2,distdf$pop1,sep="_"))	
		distdf				<<- distdf
		#
		geocoord			<- inds[inds$filter,c("name","longitude","latitude")]
		geocoord$longitude	<- geocoord$longitude*rnorm(nrow(geocoord),mean=1,sd=mysd)
		geocoord$latitude	<- geocoord$latitude*rnorm(nrow(geocoord),mean=1,sd=mysd)
		#
		cat("Plotting...",sep="\n")
		plot(geocoord$longitude,geocoord$latitude,pch=16,col="grey20",cex=0.5)
		mybins					<- mylabels[mylabels>=plotbin]
		for(mybin in mybins)
			{
			distdf2				<- distdf[distdf$bin==mybin,]
			distdf2				<- distdf2[distdf2$pop1%in%mysambar$populations&distdf2$pop2%in%mysambar$populations,]
			if(nrow(distdf2)>0)
				{
				cat("Plotting segments...",sep="\n")
				for(k in c(1:nrow(distdf2)))
					{
					ind1		<- distdf2$name1[k]
					ind2		<- distdf2$name2[k]
					ind1x		<- geocoord$longitude[geocoord$name==ind1]
					ind2x		<- geocoord$longitude[geocoord$name==ind2]
					ind1y		<- geocoord$latitude[geocoord$name==ind1]
					ind2y		<- geocoord$latitude[geocoord$name==ind2]
					segments(x0=ind1x,y0=ind1y,x1=ind2x,y1=ind2y,lwd=0.5,col=distdf2$col[k])
					}
				}
			}
		points(geocoord$longitude,geocoord$latitude,pch=16,col="grey20",cex=0.5)
		mtext(side=3,paste(dmin," <= d < ",dmax,sep=""),line=0.5,cex=1.25)
		legend(legendpos,legend=paste(">",rev(mybreaks[(plotbin+1):nbins]),sep=""),bty="n",fill=rev(mycolours[(plotbin+1):nbins]),cex=legendcex,title="frequency:")
		}
	}

haplodist<-function(mychroms=NULL,mutrate=1.2*10^-9,exporttype=NULL,maketrees=TRUE,exporttrees=FALSE,treeroot=NULL,dotmrca=FALSE,refpop="polar")
	{
	if(maketrees)
		{
		if(is.null(mychroms))
			{
			return(cat("ERROR: provide a vector with scaffold names to the mychroms flag.",sep="\n"))
			}
		nchroms			<- length(mychroms)
		chromstreelist	<<- list()
		ntotalloci		<- 0
		for (chromnr in c(1:nchroms))
			{
			mychrom		<- mychroms[chromnr]
			cat(" ",sep="\n")
			cat(paste("Starting analyses on ",mychrom,"...",sep=""),sep="\n")
			cat("NOTE: if R crashes, restart the analyses, but no need to redo the analyses for the chromosomes for which the trees have already been stored in the output file.",sep="\n") 
			#
			treefilename			<- paste("alltrees.astralinput",mychrom,"newick.txt",sep=".")
			if(file.exists(treefilename))
				{
				return(cat("ERROR: output file 'alltrees.astralinput.chromname.newick.txt' already exists. First delete, rename or replace this file, because trees will be appended.",sep="\n")) 
				}
			#
			# read dataframe with pairwise distances:
			if("data.table"%in%(.packages()) == FALSE){library("data.table")}
			cat("Reading data...",sep="\n")
			x			<- fread(paste("vcfdist",mychrom,"txt",sep="."),header=FALSE)
			colnames(x)	<- c("ind1","ind2","name1","name2","nmiss","n0","n1","chrom","startbp")
			if(any(is.na(x$startbp)))
				{
				cat("WARNING: NA-values detected. Omitting locus/loci...",sep="\n")
				x		<- x[!is.na(x$startbp),]
				}
			x$d			<- x$n1/(x$n0+x$n1)						# 18-11-2023: This is only for variable sites, and hence not really informative. Still to be included: information on length of haplotype block. 
			x$block		<- paste(x$chrom,x$startbp,sep="_")
			x$miss		<- x$nmiss/(x$n0+x$n1+x$nmiss)			# should be zero because of imputation
			myloci		<- unique(x$startbp)
			nloci		<- length(myloci)
			treelist	<- list()
			for(locusnr in c(1:nloci))
				{
				cat(" ",sep="\n")
				cat(paste("Locus ",locusnr," out of ",nloci, " loci in total.",sep=""),sep="\n") 
				mylocus				<- myloci[locusnr]
				y					<- as.data.frame(x[x$startbp==mylocus,])
				y					<- y[order(y$name1,y$name2),]
				mysambar$plottree	<<- NULL
				locusmat			<<- NULL
				locusmat			<- NULL
				locusmat			<- df2mat(mydf=y,myinds=inds$nr,indnames=inds$name,mypops=inds$pop,myscore="d",doheatmap=TRUE,twosided=TRUE,above_diagonal=FALSE,exportprefix="Rawdistance_matrix.ind",plot_title="Raw genetic distance (%)")
				if(is.null(locusmat))
					{
					return(cat("ERROR: locusmat is NULL.",sep="\n"))
					}
				getindtree(export=exporttype,inputdistmat=locusmat,mymethod="bionj",mytype="unrooted",do_analysis=TRUE,fullplotname=FALSE,plotname=paste("LocusTree",mylocus,sep="_"),labelangle="axial",legendpos=NULL,dopathlength=FALSE,maxnodelabel=0,do_append=TRUE,calc_parsimony=FALSE,calc_likelihood=FALSE)
				treelist[[locusnr]]	<- mysambar$plottree
				}
			names(treelist)				<- paste("gt",c((1+ntotalloci):(nloci+ntotalloci)),sep="")
			ntotalloci					<- ntotalloci+nloci 
			chromstreelist[[chromnr]]	<<- treelist
			# input for Astral:
			cat(" ",sep="\n")
			cat("Outputting trees in Newick-format to be used as input for Astral...",sep="\n") 
			for(treenr in c(1:length(treelist)))
				{
				mytree	<- treelist[[treenr]] 
				write.tree(mytree,file=treefilename,append=TRUE,digits=0,tree.names=FALSE)
				}
			cat(paste("Trees stored in file '",treefilename,"'.",sep=""),sep="\n")
			}
		genometreelist					<<- unlist(chromstreelist,recursive=FALSE)
		names(chromstreelist)			<<- mychroms
		cat(" ",sep="\n")
		cat("DONE.",sep="\n")
		cat("All haploblocks trees stored in list object called 'chromstreelist' (per chrom) and 'genometreelist' (all chroms combined).",sep="\n") 
		}
	if(exporttrees)
		{
		# INPUT FOR ASTRAL:
		if(file.exists("alltrees.astralinput.newick.txt"))
			{
			cat("WARNING: output file 'alltrees.astralinput.newick.txt' already exists. Not outputting tree file. If wanted, first delete, rename or replace this file.",sep="\n") 
			}else{
			cat("Outputting trees in Newick-format to be used as input for Astral...",sep="\n") 
			for(treenr in c(1:length(genometreelist)))
				{
				mytree	<- genometreelist[[treenr]] 
				write.tree(mytree,file="alltrees.astralinput.newick.txt",append=TRUE,digits=0,tree.names=FALSE)
				}
			cat("All trees stored in file 'alltrees.astralinput.newick.txt'.",sep="\n")
			}
		#
		# INPUT FOR TWISST:
		if(!maketrees)
			{
			for(chromnr in c(1:length(chromstreelist)))
				{
				mychrom					<- mychroms[chromnr]
				cat(mychrom,sep="\n")
				mychromlist				<- chromstreelist[[chromnr]]
				treefilename			<- paste("alltrees.astralinput",mychrom,"newick.txt",sep=".")
				if(file.exists(treefilename))
					{
					cat("WARNING: output file 'alltrees.astralinput.chromname.newick.txt' already exists. Not outputting tree file for this chromosome.",sep="\n") 
					}else{
					for(treenr in c(1:length(mychromlist)))
						{
						mytree	<- mychromlist[[treenr]] 
						write.tree(mytree,file=treefilename,append=TRUE,digits=0,tree.names=FALSE)
						}
					}
				}
			cat("All trees stored in file 'alltrees.astralinput.chromname.newick.txt'.",sep="\n")
			}
		#
		# INPUT FOR PHYLONET:
		cat("Outputting trees in Nexus-format to be used as input for Phylonet...",sep="\n") 
		write.nexus(genometreelist,file="alltrees.phylonetinput.nexus.txt",translate=FALSE)
		#
		if(!is.null(treeroot))
			{
			# input for Densitree: translated and optionally no branchlenghts
			cat("Outputting trees in Nexus-format to be used as input for Densitree...",sep="\n")
			treelist2	<- genometreelist
			for(locusnr in c(1:nloci))
				{
				mytree				<- treelist2[[locusnr]]
				mytree				<- root(mytree,outgroup=treeroot,resolve.root=TRUE)
				#mytree$edge.length	<- NULL
				treelist2[[locusnr]]<- mytree
				}
			write.nexus(treelist,file="alltrees.densitreeinput.nexus.txt",translate=TRUE)							
			#write.nexus(treelist2,file="mytrees.labels.translated.nobranchlengths.nexus.txt",translate=TRUE)		# not useful
			}
		}
	if(dotmrca)
		{
		nchroms			<- length(mychroms)
		difflist		<- list()
		tmrcavec		<- c(100000,200000,300000,400000,500000,600000)
		ninds			<- nrow(inds)
		diffmat			<<- matrix(NA,nrow=ninds,ncol=nchroms)
		rownames(diffmat)<<- inds$name
		tmrcalist		<<- list()
		for(tmrcanr in c(1:length(tmrcavec)))
			{
			mytmrca		<- tmrcavec[tmrcanr]
			cat(" ",sep="\n")
			cat(paste("TMRCA: ",mytmrca,sep=""),sep="\n")
			for (chromnr in c(1:nchroms))
				{
				mychrom		<- mychroms[chromnr]
				cat(" ",sep="\n")
				cat(paste("Starting analyses on ",mychrom,"...",sep=""),sep="\n")
				#
				# read dataframe with pairwise distances:
				if("data.table"%in%(.packages()) == FALSE){library("data.table")}
				x			<- fread(paste("vcfdist",mychrom,"txt",sep="."),header=FALSE)
				colnames(x)	<- c("ind1","ind2","name1","name2","nmiss","n0","n1","chrom","startbp")
				x$d			<- x$n1/(x$n0+x$n1)
				x$block		<- paste(x$chrom,x$startbp,sep="_")
				x$miss		<- x$nmiss/(x$n0+x$n1+x$nmiss)			# should be zero because of imputation
				#
				# calculate TMRCA:
				k			<- read.table(paste("mychrom",mychrom,"haploblocks.txt",sep="."),header=FALSE)
				colnames(k)	<- c("chrom","startbp","endbp","size","nsnps")
				k$block		<- paste(k$chrom,k$startbp,sep="_")
				k			<- k[!duplicated(k$block),]
				k$nsites	<- k$endbp-k$startbp+1
				k2			<- k[,c("block","nsites")]
				x			<- merge(x,k2,by="block")
				x$d2		<- x$n1/x$nsites
				x$t			<- x$d2/(2*mutrate)
				#
				# add population data:
				indstemp			<- inds[,c("name","pop")]
				colnames(indstemp)	<- c("name1","pop1")
				x					<- merge(x,indstemp,by="name1")
				colnames(indstemp)	<- c("name2","pop2")
				x					<- merge(x,indstemp,by="name2")
				x$poppair			<- ifelse(x$pop1<x$pop2,paste(x$pop1,x$pop2,sep="_"),paste(x$pop2,x$pop1,sep="_"))
				#
				for(indnr in c(1:ninds))
					{
					myind					<- inds$name[indnr]
					y						<- x[x$name1==myind&x$pop2==refpop,]
					diffmat[indnr,chromnr]	<<- nrow(y[t<mytmrca,])/nrow(y)
					}
				}
			tmrcalist[[tmrcanr]]	<<- diffmat 
			indmean					<- rowMeans(diffmat)
			indsd					<- apply(diffmat,1,sd,na.rm = TRUE)
			meanmax					<- max(indmean[inds$pop!=refpop])
			popboxplot(export="pdf",exportname=paste("TMRCA",mytmrca,refpop,sep=""),ylabel="Proportion of loci",logy=FALSE,myscore=indmean,popvector=inds$poporder,addstripchart=TRUE,y_lim=c(0,meanmax),yline=NULL,mycex=2,plottitle=paste("TMRCA < ",mytmrca/1000," Kya",sep=""))
			}
		}
	}

# October 2020: calculat RobinsinFould distances for a list of tres relative to reference tree
calcrf<-function(doplot=FALSE,myreftree=NULL,myoutgroup=NULL,mytrees=NULL)
	{
	mttree			<- ape::read.tree(myreftree)
	mttree$tip.label<- paste(mttree$tip.label,"1",sep="-")
	mttree			<- root(mttree,myoutgroup,resolve.root=TRUE)
	#
	treelist		<- ape::read.tree(mytrees)
	ntrees			<- length(treelist)
	alltips			<- treelist[[1]]$tip.label
	selecttips		<- alltips[grepl("-1",alltips,fixed = TRUE)]
	rfvec			<- vector()
	reftree			<- mttree
	for(i in c(1:ntrees))
		{
		cat(paste(i," out of ",ntrees,".",sep=""),sep="\n")
		subtree		<- keep.tip(phy=treelist[[i]],tip=selecttips)
		genetree	<- root(subtree,myoutgroup,resolve.root=TRUE)
		rfvec[i]	<- RF.dist(tree1=reftree,tree2=genetree,check.labels=TRUE,rooted=TRUE)
		}
	if(doplot)
		{
		treenrvec	<- which(rfvec<=240)
		for(k in c(1:length(treenrvec)))
			{
			treenr		<- treenrvec[k]
			cat(treenr,sep="\n")
			besttree	<- keep.tip(phy=treelist[[treenr]],tip=selecttips)
			besttree	<- root(besttree,"Americanblack1-1",resolve.root=TRUE)
			besttree$tip.label	<- gsub("-1","",besttree$tip.label)
			getindtree(nshorten=3,do_analysis=FALSE,plotname=paste("GeneTree_likeMTdna_scaffold",treenr,sep="_"),mydistance="euclidean",mymethod="bionj",makelinear=FALSE,inputtree=besttree,mytype="unrooted",edgecolors=TRUE,labelangle="axial",export="pdf",dopathlength=FALSE,fullplotname=FALSE,calc_parsimony=FALSE,calc_likelihood=FALSE)
			#getindtree(nshorten=3,do_analysis=FALSE,inputtree=besttree,mytype="unrooted",edgecolors=TRUE,labelangle="axial",dopathlength=FALSE,fullplotname=FALSE,calc_parsimony=FALSE,calc_likelihood=FALSE)
			}
		}
	}

rfmat<-function(doplot=FALSE)
	{
	treelist		<- ape::read.tree("alltrees.astralinput.HiC_scaffold_20.newick.txt")
	ntrees			<- length(treelist)
	mymat			<- matrix(NA,nrow=ntrees,ncol=ntrees)
	colnames(mymat)	<- paste("g",c(1:ntrees),sep="")
	rownames(mymat)	<- paste("g",c(1:ntrees),sep="")
	for(i in c(1:ntrees))
		{
		cat(paste(i," out of ",ntrees,".",sep=""),sep="\n")
		mytree1		<- root(treelist[[i]],"Americanblack1-1",resolve.root=TRUE)
		for(j in c(1:ntrees))
			{
			mytree2		<- root(treelist[[j]],"Americanblack1-1",resolve.root=TRUE)
			mymat[i,j]	<- RF.dist(tree1=mytree1,tree2=mytree2,check.labels=TRUE,rooted=TRUE)
			}
		}
	if(doplot)
		{
		p 		<- ape::pcoa(mymat, correction="none", rn=NULL)
		mycols 	<- rep(rainbow(2),each=ceiling(length(treelist)/2))
		plot(myp1,myp2,col=mycols,pch=16,cex=2)
		}
	}

plothist<-function(p1="ABCbc",p2="polar",p3="Black",binsize=250000,xmax=3500000,addhisto=FALSE,dobarplot=FALSE,myxlim=NULL)
	{
	mybreaks	<- seq(0,10000000,binsize)
	#
	y1			<- x[(x$pop1==p1&x$pop2==p3)|(x$pop1==p3&x$pop2==p1),]
	y2			<- x[(x$pop1==p2&x$pop2==p3)|(x$pop1==p3&x$pop2==p2),]
	y3			<- x[(x$pop1==p1&x$pop2==p2)|(x$pop1==p2&x$pop2==p1),]
	#
	h1			<<- hist(y1$t,breaks=mybreaks,plot=FALSE)
	h2			<<- hist(y2$t,breaks=mybreaks,plot=FALSE)
	h3			<<- hist(y3$t,breaks=mybreaks,plot=FALSE)
	ymax		<- max(c(h1$density,h2$density,h3$density))
	#
	if(addhisto)
		{
		hist(y1$t,xlim=c(1,xmax),freq=FALSE,col=rgb(0,0,1,1/4),breaks=mybreaks,ylim=c(0,ymax),xlab="TMRCA (y)",ylab="Proportion of loci",main="")
		hist(y2$t,xlim=c(1,xmax),freq=FALSE,col=rgb(1,0,0,1/4),breaks=mybreaks,add=TRUE)
		hist(y3$t,xlim=c(1,xmax),freq=FALSE,col=rgb(0,1,0,1/4),breaks=mybreaks,add=TRUE)
		legend("topright",legend=c(paste(p1,"-",p3),paste(p2,"-",p3)),fill=c(rgb(0,0,1,1/4),rgb(1,0,0,1/4)),bty="n",cex=1.5)
		}else{
		par(mfrow=c(3,1))
		if(is.null(myxlim)){myxlim<- c(0,xmax)}
		hist(y1$t,xlim=myxlim,freq=FALSE,col="grey",border="grey",breaks=mybreaks,ylim=c(0,ymax),xlab="",ylab="",main="",las=2,yaxt="n")
		mtext(side=3,line=-1,text=paste(p1,"-",p3),cex=1)
		hist(y2$t,xlim=myxlim,freq=FALSE,col="grey",border="grey",breaks=mybreaks,ylim=c(0,ymax),xlab="",ylab="",main="",las=2,yaxt="n")
		mtext(side=3,line=-1,text=paste(p2,"-",p3),cex=1)
		hist(y3$t,xlim=myxlim,freq=FALSE,col="grey",border="grey",breaks=mybreaks,ylim=c(0,ymax),xlab="",ylab="",main="",las=2,yaxt="n")
		mtext(side=3,line=-1,text=paste(p1,"-",p2),cex=1)
		}
	if(dobarplot)
		{
		mycuts		<- c(0,50000,100000,200000,400000,800000,1200000,1600000,3200000,6400000)
		par(mfrow=c(3,1))
		cuts	<- cut(y1$t,breaks=mycuts)
		barplot(table(cuts)+1,las=2,log="y")
		cuts	<- cut(y2$t,breaks=mycuts)
		barplot(table(cuts)+1,las=2,log="y")
		cuts	<- cut(y3$t,breaks=mycuts)
		barplot(table(cuts)+1,las=2,log="y")
		}
	}

# pairwise missingness:
calcpairmiss<-function(popnames=mysambar$populations,exporttype=NULL,use_currentdir=TRUE,silent=TRUE,snpsfilter=FALSE,legendcex=2.5,nrbins=20,definebreaks=FALSE,addmiss=TRUE,plotexpected=FALSE,my_Breaks=NULL,include_allsites=FALSE,plotperpop=FALSE)
	{
	if(max(inds$miss,na.rm=TRUE)==0)
		{
		return(cat("No missing data points. Omitting pairwise_missingness plots.",sep="\t"))
		}
	my_wd		<- getwd()
	myinds		<- inds$nr
	combitable	<- combn(myinds,m=2)
	npairs		<- ncol(combitable)
	if(!snpsfilter)
		{
		plotlabel	<- "allsnps"
		snpsfilter	<- rep(TRUE,nrow(snps))
		}else{
		plotlabel	<- "snpsfilter"
		snpsfilter	<- snps$filter
		}
	if(is.null(inds2$pairmiss_obs))
		{
		setwd(mysambar$inputdatadir)
		if(file.exists("pairwise_missingness.txt"))
			{
			mydftemp	<- read.table("pairwise_missingness.txt",header=TRUE)
			}else{
			# create a dummy dataframe which will never meet the next condition:
			mydftemp	<- data.frame("col1"=c(1:2),"col2"=c(1:2)) 
			}
		if(nrow(mydftemp)==npairs)
			{
			missdf			<- mydftemp
			if(!"indpair"%in%colnames(missdf))
				{
				missdf$name1	<- NA
				missdf$name2	<- NA
				for(i in c(1:nrow(missdf)))
					{
					ind1			<- missdf$ind1[i]
					ind2			<- missdf$ind2[i]
					missdf$name1[i]	<- inds$name[inds$nr==ind1]
					missdf$name2[i]	<- inds$name[inds$nr==ind2]
					}
				missdf$indpair	<- ifelse(as.character(missdf$name1)<as.character(missdf$name2),paste(missdf$name1,missdf$name2,sep="_"),paste(inds2$name1,inds2$name2,sep="_"))
				}
			mydf			<- missdf[,c("ind1_miss","ind2_miss","pairmiss_exp","pairmiss_obs","diff","outlier","indpair")]
			inds2			<<- merge(inds2,mydf,by="indpair",all=TRUE)
			}else{
			cat("Pairwise_missingness.txt file is not present or does not have the expected number of rows. Creating datafile now.",sep="\n")  
			cat("This will take some time, but the next time you run the filterdata() function this step will be automatically omitted and then it will be much faster.",sep="\n") 
			mymatrix	<- as.matrix(mygenlight[,snpsfilter])
			mymatrix2	<- as.matrix(mygenlight)
			ind1vec		<- vector()
			ind2vec		<- vector()
			ind1name	<- vector()
			ind2name	<- vector()
			ind1miss	<- vector()
			ind2miss	<- vector()
			ind1pop		<- vector()
			ind2pop		<- vector()
			ind1subpop	<- vector()
			ind2subpop	<- vector()
			missvec		<<- vector()
			missvec_all	<<- vector()	# when analysing all sites
			expvec		<- vector()
			for (i in c(1:npairs))
				{
				if(i%%1000==0&!silent)
					{
					cat(paste(i," in ",ncol(combitable)," pairwise comparisons.",sep=""),sep="\n") 
					}
				ind1		<- combitable[1,i]
				ind2		<- combitable[2,i]
				ind1vec[i]	<- ind1
				ind2vec[i]	<- ind2
				ind1name[i]	<- inds$name[ind1]
				ind2name[i]	<- inds$name[ind2]
				ind1miss[i]	<- inds$miss[ind1]
				ind2miss[i]	<- inds$miss[ind2]
				ind1pop[i]	<- as.vector(inds$pop[ind1])
				ind2pop[i]	<- as.vector(inds$pop[ind2])
				ind1subpop[i]<- as.vector(inds$pop2[ind1])
				ind2subpop[i]<- as.vector(inds$pop2[ind2])
				expvec[i]	<- 1-((1-ind1miss[i])*(1-ind2miss[i]))
				geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[ind2,]
				#
				geno1_all	<- mymatrix[ind1,]
				geno2_all	<- mymatrix[ind2,]
				# Count number of SNPs with NA's in either or both individuals:
				missvec[i]		<- length(geno1[is.na(geno1)|is.na(geno2)])/length(geno1)
				missvec_all[i]	<- length(geno1_all[is.na(geno1_all)|is.na(geno2_all)])/length(geno1_all)
				}
			if(!include_allsites)
				{
				missdf			<- data.frame("ind1"=ind1vec,"ind2"=ind2vec,"name1"=ind1name,"name2"=ind2name,"pop1"=ind1pop,"pop2"=ind2pop,"subpop1"=ind1subpop,"subpop2"=ind2subpop,"ind1_miss"=ind1miss,"ind2_miss"=ind2miss,"pairmiss_exp"=expvec,"pairmiss_obs"=missvec)
				}else{
				missdf			<- data.frame("ind1"=ind1vec,"ind2"=ind2vec,"name1"=ind2name,"name2"=ind2name,"pop1"=ind1pop,"pop2"=ind2pop,"subpop1"=ind1subpop,"subpop2"=ind2subpop,"ind1_miss"=ind1miss,"ind2_miss"=ind2miss,"pairmiss_exp"=expvec,"pairmiss_obs"=missvec,"pairmiss_obs_all"=missvec_all)
				}
			missdf$diff			<- abs(missdf$pairmiss_exp-missdf$pairmiss_obs)
			missdf$outlier		<- missdf$diff>(8*sd(missdf$diff))		# 09-03-2020: 8 is random, should come up with something better 
			#
			# as of 21-06-2021, all sample pair results in inds2 dataframe: 
			mysambar$missdf		<<- missdf
			missdf$indpair		<- ifelse(as.character(missdf$name1)<as.character(missdf$name2),paste(missdf$name1,missdf$name2,sep="_"),paste(missdf$name1,missdf$name2,sep="_"))
			mydf				<- missdf[,c("ind1_miss","ind2_miss","pairmiss_exp","pairmiss_obs","diff","outlier","indpair")]
			inds2				<<- merge(inds2,mydf,by="indpair",all=TRUE)
			setwd(mysambar$inputdatadir)
			write.table(missdf,"pairwise_missingness.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
			}
		setwd(my_wd)
		}
	# PLOTTING
	mymin		<- min(inds$miss,na.rm=TRUE)
	if(definebreaks)
		{
		my_Breaks	<- c(0.02,0.05,0.1,0.15,0.2,0.3,0.4,0.5,0.75,1)
		my_Breaks	<- c(0,my_Breaks[my_Breaks>mymin])
		}else{
		my_Breaks	<- NULL
		}
	if(!use_currentdir)
		{
		setwd(mysambar$QCdir)
		}
	# matrix missingness:
	# Note: indsfilter=TRUE will create plots for both filtered and unfiltered data.
	if(!silent){cat("Plotting indmatrix...",sep="\n")}
	plot_indmatrix(export=exporttype,indsfilter=TRUE,plottitle="Observed missing data",inputvalues=inds2$pairmiss_obs[!inds2$sameind],miss_labels=addmiss,popnames=mysambar$populations,mybreaks=my_Breaks,n_bins=nrbins,legpos_x=0.1,legpos_y=0.55,leg_cex=legendcex,matcol="orange",plotprefix=paste("Pairwise_miss_obs",plotlabel,sep="."),currentdir=TRUE,perpop=FALSE,sub_title="per sample pair")
	if(plotexpected)
		{
		if(!silent){cat("Plotting expected 1...",sep="\n")}
		plot_indmatrix(export=exporttype,indsfilter=TRUE,plottitle="Expected missing data",inputvalues=inds2$pairmiss_exp[!inds2$sameind],miss_labels=addmiss,popnames=mysambar$populations,mybreaks=my_Breaks,n_bins=nrbins,legpos_x=0.1,legpos_y=0.7,leg_cex=legendcex,matcol="orange",plotprefix=paste("Pairwise_miss_exp",plotlabel,sep="."),currentdir=TRUE,perpop=plotperpop)
		if(!silent){cat("Plotting expected 2...",sep="\n")}
		plot_indmatrix(export=exporttype,indsfilter=TRUE,plottitle="Missing data deviation",inputvalues=inds2$diff[!inds2$sameind],miss_labels=addmiss,popnames=mysambar$populations,mybreaks=my_Breaks,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plotprefix=paste("Pairwise_miss_deviation",plotlabel,sep="."),currentdir=TRUE,perpop=plotperpop)
		}
	# scatterplot pairwise miss:
	if(!silent){cat("Plotting batcheffect...",sep="\n")}
	plotbatcheffects(export=exporttype,dothin=TRUE,mydf=inds2[!inds2$sameind,],usepopcol=FALSE)
	plotbatcheffects(export=exporttype,dothin=TRUE,mydf=inds2[!inds2$sameind,],usepopcol=TRUE)
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	#if(!silent){cat("Generation batch effect matrix...",sep="\n")}
	#batcheffectmat()
	}

plotbatcheffects<-function(export=NULL,dothin=TRUE,mydf=inds2[inds2$ind1!=inds2$ind2,],usepopcol=FALSE,legendcex=1.25,dolog=FALSE,mymin=NULL,mymax=NULL)
	{
	if(any(!c("pairmiss_exp","pairmiss_obs","outlier","popcol1","popcol2")%in%colnames(inds2)))
		{
		return(cat("ERROR: Not all expected columns present in inds2 dataframe. Did you run the calcpairmiss function?",sep="\t"))
		}
	if(!is.logical(mydf$outlier)&(!usepopcol))
		{
		return(cat("ERROR: inds2$outlier should be logical.",sep="\t"))
		}
	mybool		<- mydf$outlier
	graphics.off()
	if(dothin)
		{
		# This is to make plot lighter: no need to plot overlapping points.
		mydf2		<- mydf[,c("pairmiss_exp","pairmiss_obs","outlier","popcol1","popcol2")]
		mydf		<- unique(mydf2)
		}
	if(!is.null(export))
		{
		collabel	<- ifelse(usepopcol,"popcol","black")
		loglabel	<- ifelse(dolog,"log","linear")
		rangelabel	<- ifelse(is.null(mymin)|is.null(mymax),"fullrange","limitedrange")
		if(export=="eps"){postscript(paste("Pairwise_miss_deviation.scatter",collabel,loglabel,rangelabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste("Pairwise_miss_deviation.scatter",collabel,loglabel,rangelabel,"pdf",sep="."),,family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste("Pairwise_miss_deviation.scatter",collabel,loglabel,rangelabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile(paste("Pairwise_miss_deviation.scatter",collabel,loglabel,rangelabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(is.null(mymin)|is.null(mymax))
		{
		mymax	<- max(c(mydf$pairmiss_exp,mydf$pairmiss_obs),na.rm=TRUE)
		mymin	<- ifelse(dolog,0.0001,0)
		}		
	mylog	<- ifelse(dolog,"xy","")
	if(usepopcol)
		{
		plot(mydf$pairmiss_exp,mydf$pairmiss_obs,log=mylog,pch=21,col=mydf$popcol1,bg=mydf$popcol2,cex=1.5,lwd=3,xlab="Expected missingness per sample pair",ylab="Observed missingness per sample pair",ylim=c(mymin,mymax),xlim=c(mymin,mymax),main="Identification of batch effects")
		legend("topleft",legend=mysambar$poporder2,fill=mysambar$colorder2,bty='n',cex=legendcex)
		}else{
		plot(mydf$pairmiss_exp,mydf$pairmiss_obs,log=mylog,pch=16,cex=1,lwd=2,xlab="Expected missingness per sample pair",ylab="Observed missingness per sample pair",ylim=c(mymin,mymax),xlim=c(mymin,mymax),main="Identification of batch effects")
		points(mydf$pairmiss_exp[mybool],mydf$pairmiss_obs[mybool],log=mylog,pch=16,cex=1,col="red")
		legend("topleft",legend=c("TRUE","FALSE"),title="Batch effect",bty='n',fill=c("red","black"),cex=legendcex)
		}
	if(!is.null(export)){dev.off()}
	}

getcladecol<-function(cladevec=inds$Yclade,subcladevec=NULL,lightby=0.4,darkby=0.2)
	{
	if(is.null(cladevec))
		{
		return(cat("ERROR: please specify a vector with clade assignment."))
		}
	if(!is.null(subcladevec))
		{
		cat("WARNING: assuming subcladevec is a subhierarchy of cladevec.",sep="\n")
		}
	inds$cladecol	<<- NA
	inds$subcladecol<<- NA
	myclades		<- unique(cladevec)
	for(myclade in myclades)
		{
		cat(myclade,sep="\n")
		popcols			<- inds$popcol[cladevec==myclade]
		ncols			<- length(popcols)
		cladecols		<- vector(length=ncols)
		cladecols[1]	<- popcols[1]
		if(ncols>1)
			{
			for(i in c(2:ncols))
				{
				if(i==2)
					{
					mycol1	<- popcols[i-1]
					}else{
					mycol1	<- cladecols[i-1]
					}
				mycol2		<- popcols[i]
				if(mycol1==mycol2)
					{
					cladecols[i]<- cladecols[i-1]
					}else{
					mycolfunc3 	<- colorRampPalette(c(mycol1,mycol2))
					k			<- ifelse(i%%2!=0,i,i+1)
					#m			<- ifelse(i%%2!=0,(i+1)/2,i/2+1)
					#cladecols[i]<- mycolfunc3(k)[m]
					cladecols[i]<- mycolfunc3(k)[2]
					}
				}
			}
		mycladecol							<- cladecols[ncols]
		inds$cladecol[cladevec==myclade]	<<- mycladecol
		#
		if(!is.null(subcladevec))
			{
			mysubclades		<- unique(subcladevec[cladevec==myclade])
			nsub			<- length(mysubclades)
			if(nsub>5)
				{
				return(cat("ERROR: only 5 subclades allowed.",sep="\n"))
				}
			if(nsub==1)
				{
				cat("Only 1 subclade. No need to define colour variants for subclades.",sep="\n")
				mysubclade	<- mysubclades[1]
				inds$subcladecol[subcladevec==mysubclade]			<<- mycladecol
				}else{
				cat("Lightening and darkening clade colour to denote subclades.",sep="\n")
				if("colorspace" %in% (.packages()) == FALSE){library("colorspace")}
				for(k in c(1:nsub))
					{
					mysubclade	<- mysubclades[k]
					cat(mysubclade,sep="\n")
					if(k==1)
						{
						inds$subcladecol[subcladevec==mysubclade]	<<- lighten(mycladecol,amount=lightby)
						}
					if(k==2)
						{
						inds$subcladecol[subcladevec==mysubclade]	<<- mycladecol
						}
					if(k==3)
						{
						inds$subcladecol[subcladevec==mysubclade]	<<- darken(mycladecol,amount=darkby)
						}
					if(k==4)
						{
						#mycolfunc 		<- colorRampPalette(c("grey80",mycladecol))
						#mysubcladecol	<- mycolfunc3(k)[2]
						#inds$subcladecol[subcladevec==mysubclade]	<<- mysubcladecol
						inds$subcladecol[subcladevec==mysubclade]	<<- lighten(mycladecol,amount=lightby*2)
						}
					if(k==5)
						{
						#mycolfunc 		<- colorRampPalette(c("grey20",mycladecol))
						#mysubcladecol	<- mycolfunc3(k)[2]
						#inds$subcladecol[subcladevec==mysubclade]	<<- mysubcladecol
						inds$subcladecol[subcladevec==mysubclade]	<<- darken(mycladecol,amount=darkby*2)
						}
					}
				}
			}
		}
	}

# 22-06-2022: depreciated?
# cladedxy(excludepops=c("polar","Black","Himalaya","Syrian","Amur"))
cladedxy<-function(export=NULL,excludepops=NULL,plotlabel=NULL,ymax=NULL,pairorder=NULL,dxy=mysambar$dxy)
	{
	if(!"clade1"%in%colnames(dxy)|!"clade2"%in%colnames(dxy))
		{
		return(cat("ERROR: columns 'clade1' and/or 'clade2' are missing. Rerun the nrmismatch() function with the flag addclade set to TRUE.",sep="\n"))
		}
	dxy$cladepair	<- ifelse(dxy$clade1<dxy$clade2,paste(dxy$clade1,dxy$clade2,sep="_"),paste(dxy$clade2,dxy$clade1,sep="_"))
	dxy$sameclade	<- dxy$clade1==dxy$clade2
	if(!is.null(excludepops))
		{
		dxy2		<- dxy[!(dxy$pop1%in%excludepops)&!(dxy$pop2%in%excludepops),]
		}else{
		dxy2		<- dxy
		}
	#
	dxy2$cladepair[dxy2$sameclade]	<- "within"
	dxy2							<- droplevels(dxy2)	
	if(!is.null(pairorder))
		{
		dxy2$pairorder				<- factor(dxydf$cladepair,levels=pairorder)
		}else{
		dxy2$pairorder				<- dxy2$cladepair
		}
	mypairs							<- unique(dxy2$cladepair)
	npairs							<- length(mypairs)
	#
	#tempdxy				<- dxy1[!duplicated(dxy1$poppair),]
	#tempdxy				<- tempdxy[order(tempdxy$poppair),]
	#between$cladecol1	<- tempdxy$cladecol1
	#between$cladecol2	<- tempdxy$cladecol2
	#
	if(!is.null(export))
		{
		myheight=0.25
		myheight2=75
		mylabel	<- ifelse(is.null(plotlabel),"between",paste("between",plotlabel,sep="."))
		if(export=="eps"){postscript(paste("Dxy_clade",mylabel,"eps",sep="."),family=mysambar$myfont,height=npairs*myheight+2,width=6)}
		if(export=="pdf"){pdf(paste("Dxy_clade",mylabel,"pdf",sep="."),family=mysambar$myfont,height=npairs*myheight+2,width=6)}
		if(export=="png"){png(paste("Dxy_clade",mylabel,"png",sep="."),family=mysambar$myfont,height=npairs*myheight2+200,width=600)}
		if(export=="wmf"){win.metafile(paste("Dxy_clade",mylabel,"wmf",sep="."),family=mysambar$myfont,height=npairs*myheight+2,width=6)}
		}
	par(oma=c(2,8,1,1),mar=c(2,5,1,0.5),cex.axis=3)
	if(is.null(ymax))
		{
		y_lim	<- c(0.975*min(dxy2$dxy2[!dxy2$sameclade],na.rm=TRUE),1.025*max(dxy2$dxy2,na.rm=TRUE))
		}else{
		y_lim	<- c(0,ymax)
		}
	boxplot(dxy2$dxy2~dxy2$pairorder,border="grey50",col="grey80",las=1,xlab="",ylab="",horizontal=TRUE,cex.axis=1.5,pch=16,outline=FALSE,ylim=y_lim,yaxt='n')
	mtext(mypairs,at=1:npairs,side=2,line=0.5,col="black",las=1,cex=1.75)
	}

runmaf2hudsonfst<-function(maf1=0)
	{
	mafdiff	<- vector()
	fstvec	<- vector()
	maf2	<- seq(maf1,1,0.05)
	for(i in c(1:length(maf2)))
		{
		mafdiff[i]	<- abs(maf2[i]-maf1)  
		fstvec[i]	<- hudsonfst(q1=maf1,q2=maf2[i])
		}
	plot(mafdiff,fstvec,xlim=c(0,1),ylim=c(0,1),type='b')
	}

# Hudson Fst
# Hudson, RR.; Slatkin, M.; Maddison, WP. (Oct 1992). "Estimation of Levels of Gene Flow from DNA Sequence Data"
maf2hudsonfst<-function(q1=0.1,q2=0.15)
	{
	# q1: maf pop1
	# q2: maf pop2
	#
	# within pop1:
	pi1		<- q1*(1-q1)*2
	# within pop2:
	pi2		<- q2*(1-q2)*2
	# mean within:
	pi_w	<- (pi1+pi2)/2
	# between:
	pi_b	<- q1*(1-q2)+(1-q1)*q2
	# fst:
	myfst	<- (pi_b-pi_w)/pi_b
	return(myfst)
	}

# 07-11-2024: admixture proportions:
# more complicated formula:
# pianc=0.00185
# inds$admixprop[j]	<- (dmax-max(inddf$d,na.rm=TRUE))/(dmax-pianc)
calcadmix<-function(refpop1=NULL,refpop2=NULL)
	{
	if(is.null(refpop1)|is.null(refpop2))
		{
		cat("WARNING: refpop1 and refpop2 not defined. Selecting pair with highest Dxy-estimate.",sep="\n")
		refpop1	<- pops2$pop1[pops2$filter&pops2$d==max(pops2$d[pops2$filter])]
		refpop2	<- pops2$pop2[pops2$filter&pops2$d==max(pops2$d[pops2$filter])]
		cat(paste("Selected: ", refpop1," versus ",refpop2,sep=""),sep="\n")
		}
	poppair			<- paste(refpop1,refpop2,sep="_")
	dmax			<- mean(inds2$d[inds2$filter&inds2$poppair==poppair])
	#
	ninds			<- nrow(inds)
	inds$admixprop	<<- NA
	for(j in c(1:ninds))
		{
		myind				<- inds$name[j]
		inddf				<- inds2[(inds2$pop1%in%c(refpop1,refpop2)&inds2$name2==myind)|(inds2$pop2%in%c(refpop1,refpop2)&inds2$name1==myind),]
		inds$admixprop[j]	<<- (dmax-max(inddf$d,na.rm=TRUE))/dmax
		}
	if("longitude"%in%colnames(inds))
		{
		pdf("Admixprop_vs_longitude.pdf",height=6,width=8)
		plot(inds$longitude[inds$filter],inds$admixprop[inds$filter],bg=inds$popcol[inds$filter],col=inds$popcol[inds$filter],pch=21,cex=3,xlab="Longitude",ylab="(d_max - max(d1,d2))/(dmax)")
		abline(h=0,lty=2)
		dev.off()
		}
	popboxplot(myscore=inds$admixprop[inds$filter],popvector=inds$pop[inds$filter],addstripchart=TRUE,yline=0,ylabel="Admixture proportion",export="pdf",exportname="AdmixtureProportion",mycex=3,labcex=2.5,y_lim=NULL)
	}

# 25-11-2024:
# excludepop(c("polar","Black","Europe","Magadan"))
# removeinds	<- c("ABC11","Kamtschatka3")
mylegend2	<- rev(c("2a","3a","3b","4"))
legend2pch	<- rev(c(8,21,23,22))
legend2pch	<- rev(c(8,21,23,22))
mypchdf		<- data.frame("name"=mylegend2,"pch"=legend2pch)

# plotibd(removeinds=NULL,refpop="Kamtchatka",reflat=65,reflong=195)
plotibd<-function(removeinds=NULL,refpop=NULL,reflat=NULL,reflong=NULL,x_lab=NULL,y_lab=NULL,y_lines=NULL,usesymbols=FALSE,pchdf=NULL,mytitle=NULL,legendpos="topleft")
	{
	x_lab	<- ifelse(is.null(x_lab),"Geographical distance (100 km)",x_lab)
	y_lab	<- ifelse(is.null(y_lab),"Genetic distance (d)",y_lab)
	if(!is.null(removeinds))
		{
		inds$filter[inds$name%in%removeinds] 	<- FALSE
		inds2$filter[inds2$name1%in%removeinds|inds2$name2%in%removeinds] 	<- FALSE
		}
	mydf			<- inds2[((inds2$pop1==refpop&inds2$pop2!=refpop)|(inds2$pop2==refpop&inds2$pop1!=refpop))&inds2$filter,]
	mydf$mypop		<- ifelse(mydf$pop1==refpop,mydf$pop2,mydf$pop1)
	mydf$mypopcol	<- ifelse(mydf$pop1==refpop,mydf$popcol2,mydf$popcol1)
	mydf$mylong		<- ifelse(mydf$pop1==refpop,mydf$long2,mydf$long1)
	mydf$mylat		<- ifelse(mydf$pop1==refpop,mydf$lat2,mydf$lat1)
	mydf$mypch		<- 21
	if(usesymbols)
		{
		mydf$mypch[mydf$mypop%in%c("WestcoastC","WestcoastS")]	<- 22
		mydf$mypch[mydf$mypop%in%c("Yukon","Nunavut","HudsonBay","ABCcoastN","ABCcoastS","WestcoastN","AlaskaSE1","AlaskaSE2")]	<- 23
		mydf$mypch[mydf$mypop%in%c("ABCbc","ABCa")]	<- 8
		}
	if(!is.null(reflat)&!is.null(reflong))
		{
		reflat									<- reflat*pi/180
		reflong									<- reflong*pi/180
		mydf$mylat								<- mydf$mylat*pi/180
		mydf$mylong								<- mydf$mylong*pi/180
		mydf$geodist							<- acos(sin(reflat)*sin(mydf$mylat) + cos(reflat)*cos(mydf$mylat) * cos(reflong-mydf$mylong)) * 6371	# 6371 is estimate of earth mean radius in km
		mydf$geodist[!is.finite(mydf$geodist)]	<- NA
		mydf$geodist							<- mydf$geodist/100		# unit: 100 km
		pdf("ILS.pdf",height=6,width=5.5)
		plot(mydf$geodist,mydf$dperc,pch=mydf$mypch,bg=mydf$mypopcol,col="grey50",cex=3,lwd=0.5,xlab=x_lab,ylab="",cex.lab=1.75,cex.axis=1.5)
		if(any(mydf$mypch<21))
			{
			points(mydf$geodist[mydf$mypch==8],mydf$dperc[mydf$mypch==8],pch=8,col=mydf$mypopcol[mydf$mypch==8],cex=3)
			points(mydf$geodist[!mydf$mypch<21],mydf$dperc[!mydf$mypch<21],pch=mydf$mypch[!mydf$mypch<21],bg=mydf$mypopcol[!mydf$mypch<21],col="grey50",cex=3)
			}
		mtext(y_lab,side=2,line=2.5,cex=1.75)
		if(!is.null(mytitle)){mtext(mytitle,line=0.5,side=3,cex=1.5)}
		if(!is.null(pchdf)){legend(legendpos,legend=pchdf$name,pch=pchdf$pch,bty="n",cex=1.5,col="black")}
		if(!is.null(y_lines)){abline(h=y_lines,lty=2)}
		dev.off()
		}else{
		pdf("ILS.pdf")
		plot(mydf$mylong,mydf$dperc,pch=21,bg=mydf$mypopcol,col="grey50",cex=3,lwd=1,xlab=x_lab,ylab="Genetic distance (d)")
		dev.off()
		}
	}


# 27_10_2024: rewrite and rename hudsonfst function, to process output of new VCF_calcdist script.
calcdxy<-function(silent=TRUE,my_root=NULL,do_nj=TRUE,doindtree=TRUE,doindpcoa=TRUE,dopoptree=TRUE,dopoppcoa=TRUE,domatrix=TRUE,do_sd=TRUE,indtreeangle=0,n_shorten=0,calcd3=TRUE,Ttest=TRUE,donetwork=TRUE,distplots=TRUE,dxybreaks=NULL,fstbreaks=NULL,legpos="topleft",legcex=1.25,pop_legcex=4.5,bin_legcex=8,pop_legposy=5,treelabelcex=1,treelwd=0.5,n_decimals=3,docoalunits=TRUE,pcoamirror=c(TRUE,TRUE))
	{
	if(!"d"%in%colnames(inds2))
		{
		return(cat("ERROR: column 'd' absent from inds2 dataframe. Did you already add the data generated by VCF_calcdist script to inds2 dataframe using add2inds function?",sep="\n"))
		}
	mymat		<- df2mat(mydf=inds2,myinds=inds$nr,indnames=inds$name,mypops=inds$pop,myscore="d",doheatmap=TRUE)
	mymat2		<- as.dist(t(mymat[inds$filter,inds$filter]))
	#
	if(doindpcoa)
		{
		cat("PCoA analyses for individuals...",sep="\n")
		mysambar$p	<<- ape_pcoa(return_object=TRUE,method="pi",inputdistmat=mymat2,addlegend=TRUE,legendpos=legpos,legendcex=legcex,do_mirror=pcoamirror,axis1=1,axis2=2,export="pdf",mypch=21,symbolsize=4.5,use_current_dir=TRUE,addtitle=NULL)			
		mysambar$p	<<- ape_pcoa(return_object=TRUE,method="pi",inputdistmat=mymat2,addlegend=TRUE,legendpos=legpos,legendcex=legcex,do_mirror=pcoamirror,axis1=1,axis2=3,export="pdf",mypch=21,symbolsize=4.5,use_current_dir=TRUE,addtitle=NULL)	
		mysambar$p	<<- ape_pcoa(return_object=TRUE,method="pi",inputdistmat=mymat2,addlegend=TRUE,legendpos=legpos,legendcex=legcex,do_mirror=pcoamirror,axis1=2,axis2=3,export="pdf",mypch=21,symbolsize=4.5,use_current_dir=TRUE,addtitle=NULL)	
		plotloadings(exporttype="pdf",myloadings=mysambar$p$vectors,myperc=mysambar$pcoaperc,plotname="PCoA_pi")	
		}
	if(doindtree)
		{
		cat("Hierarchical structure analyses for individuals...",sep="\n")
		dropvec		<- inds$name[!inds$filter]
		getindtree(plotname="Tree_bioNJ",inputdistmat=mymat2,mymethod="bionj",drop_ind=dropvec,mytype="unrooted",labelangle="axial",labelcex=1,tiplabels=FALSE,dopathlength=FALSE,edgecolors=FALSE,tipdots=TRUE,nshorten=n_shorten,export="pdf",dotcex=3,legendpos=NULL,fullplotname=FALSE,tree_angle=indtreeangle)
		getindtree(plotname="Tree_bioNJ",inputdistmat=mymat2,mymethod="bionj",drop_ind=dropvec,mytype="unrooted",labelangle="axial",labelcex=1,tiplabels=TRUE,dopathlength=TRUE,edgecolors=TRUE,tipdots=FALSE,nshorten=n_shorten,export="pdf",dotcex=3,legendpos=NULL,fullplotname=FALSE,tree_angle=indtreeangle)
		getindtree(plotname="Tree_OLS",inputdistmat=mymat2,mymethod="OLS",drop_ind=dropvec,mytype="unrooted",labelangle="axial",labelcex=1,tiplabels=FALSE,dopathlength=FALSE,edgecolors=FALSE,tipdots=TRUE,nshorten=n_shorten,export="pdf",dotcex=3,legendpos=NULL,fullplotname=FALSE,tree_angle=indtreeangle)
		getindtree(plotname="Tree_OLS",inputdistmat=mymat2,mymethod="OLS",drop_ind=dropvec,mytype="unrooted",labelangle="axial",labelcex=1,tiplabels=TRUE,dopathlength=TRUE,edgecolors=TRUE,tipdots=FALSE,nshorten=n_shorten,export="pdf",dotcex=3,legendpos=NULL,fullplotname=FALSE,tree_angle=indtreeangle)
		}
	# Hudson Fst: (pi_between - pi_within)/pi_between
	popnames			<- mysambar$populations2
	npops				<- length(popnames)
	# PI:
	# derive nucleotide diversity per population:
	pophe				<- rep(NA,npops)
	names(pophe)		<- popnames
	poppi				<- pophe
	poppi2				<- pophe
	cat("Calculating nucleotide diversity per population...",sep="\n")
	for (j in c(1:npops))
		{
		mypop			<- as.character(popnames[j])
		cat(mypop,sep="\n")
		#hevec			<- inds2$meanhe[as.character(inds2$pop1)==mypop&(inds2$name1==inds2$name2)&inds2$filter]
		hevec			<- inds2$d[as.character(inds2$pop1)==mypop&(inds2$name1==inds2$name2)&inds2$filter]
		if(length(hevec)>0)
			{
			hevec			<- hevec[is.finite(hevec)]
			pophe[j]		<- mean(hevec,na.rm=TRUE)
			}else{
			cat("WARNING: Zero retained individuals. Not possible to calculate heterozygosity.",sep="\n")
			pophe[j]		<- NA
			}
		if(!silent){cat(paste("he: ",round(pophe[j],3),sep=""),sep="\n")}
		#
		pibool			<- as.character(inds2$pop1)==mypop&as.character(inds2$pop2)==mypop&(inds2$name1!=inds2$name2)&inds2$filter
		if(length(pibool[pibool])==0)
			{
			poppi2[j]	<- NA
			if(is.na(pophe[j]))
				{
				cat("WARNING: Zero retained individuals, and thus impossible to estimate nucleotide diversity. This will result in NA-values for pairwise comparisons involving this population.",sep="\n")
				}
			poppi[j]	<- pophe[j]
			}else{
			if(length(pibool[pibool])>0)
				{
				if(!silent){cat("At least one pairwise comparison (so at least two retained individuals).",sep="\n")}
				pivec		<- inds2$d[pibool]
				pivec		<- pivec[is.finite(pivec)]
				poppi2[j]	<- mean(pivec,na.rm=TRUE)
				poppi[j]	<- mean(c(hevec,pivec),na.rm=TRUE)
				}else{
				cat("WARNING: No pairwise comparison, which suggests only 1 individual for this population. Nucleotide diversity is set equal to heterozygosity.",sep="\n")
				poppi2[j]	<- NA
				if(is.na(pophe[j]))
					{
					cat("WARNING: heterozygosity is NA. (Haploid data?) Impossible to estimate nucleotide diversity. This will result in NA-values for pairwise comparisons involving this population.",sep="\n")
					}
				poppi[j]	<- pophe[j]
				}
			}
		if(!silent){cat(paste("pi: ",round(poppi[j],3),sep=""),sep="\n")}
		}
	# DXY AND FST:
	# fstdf		<<- data.frame("pop1"=mysambar$pairpop1,"pop2"=mysambar$pairpop2,"popcol1"=mysambar$pairpopcol1,"popcol2"=mysambar$pairpopcol2,"pi1"=NA,"pi2"=NA,"dxy"=NA,"geodist"=NA)
	cat("Calculating Dxy per population pair...",sep="\n")
	pops2$npairs		<<- NA
	pops2$pi1			<<- NA
	pops2$pi2			<<- NA
	pops2$dxy			<<- NA
	pops2$Dsd			<<- NA
	pops2$Dsdnorm		<<- NA
	pops2$Z				<<- NA
	pops2$pvalue1		<<- NA
	pops2$pvalue2		<<- NA
	for(j in c(1:nrow(pops2)))
		{
		pop1			<- as.character(pops2$pop1[j])
		pop2			<- as.character(pops2$pop2[j])
		pops2$pi1[j]	<<- poppi[names(poppi)==pop1]
		pops2$pi2[j]	<<- poppi[names(poppi)==pop2]
		if(pop1!=pop2)
			{
			dxyvec			<- inds2$d[inds2$filter&((as.character(inds2$pop1)==pop1&as.character(inds2$pop2)==pop2)|(as.character(inds2$pop1)==pop2&as.character(inds2$pop2)==pop1))]
			pops2$npairs[j]	<<- length(dxyvec)
			pops2$dxy[j]	<<- mean(dxyvec,na.rm=TRUE)
			pops2$Dsd[j]	<<- sd(dxyvec,na.rm=TRUE)
			pops2$Dsdnorm[j]<<- sd(dxyvec,na.rm=TRUE)/mean(dxyvec,na.rm=TRUE)
			pops2$Z[j]		<<- mean(dxyvec,na.rm=TRUE)/sd(dxyvec,na.rm=TRUE)
			# poppivec		<-  inds2$d[inds2$filter&(((!inds2$sameind)&(inds2$samepop)&(as.character(inds2$pop1)==pop1))|((!inds2$sameind)&(inds2$samepop)&(as.character(inds2$pop1)==pop2)))]
			# if(length(poppivec)>1)
			#	{
			#	pops2$Dsd[j]	<<- (sd(dxyvec,na.rm=TRUE)-sd(poppivec,na.rm=TRUE))/mean(dxyvec,na.rm=TRUE)
			#	}else{
			#	pops2$Dsd[j]	<<- sd(dxyvec,na.rm=TRUE)/mean(dxyvec,na.rm=TRUE)
			#	}
			}else{
			pops2$dxy[j]	<<- pops2$pi1[j]
			#poppivec		<-  inds2$d[inds2$filter&(inds2$name1!=inds2$name2)&((as.character(inds2$pop1)==pop1&as.character(inds2$pop2)==pop2)|(as.character(inds2$pop1)==pop2&as.character(inds2$pop2)==pop1))]
			#pops2$Dsd[j]	<<- sd(poppivec,na.rm=TRUE)/
			}
		}
	pops2$meanpi		<<- (pops2$pi1+pops2$pi2)/2
	pops2$fst			<<- (pops2$dxy - pops2$meanpi)/pops2$dxy
	# pops2$perc1		<<- (pops2$dxy-pops2$pi1)/pops2$dxy*100
	# pops2$perc2		<<- (pops2$dxy-pops2$pi2)/pops2$dxy*100
	#
	# 03-12-2023:
	if(calcd3)
		{
		cat("If you receive an error shortly after this line, set the flag 'calcd3' to FALSE.",sep="\n")
		dxytrio(mypops=mysambar$poporder,doplot=TRUE,p_thres=0.05,add_legend=TRUE)
		}
	if(Ttest)
		{
		cat("If you receive an error shortly after this line, set the flag 'Ttest' to FALSE.",sep="\n")
		for(myrefpop in mysambar$poporder)
			{
			comparedxy(refpop=myrefpop,popvec=mysambar$poporder,doplot=TRUE,returnobject=FALSE)
			}
		}
	# 23-03-2023:
	# net divergence (Da): 
	# Dxy - (pi_x + pi_y)/2	# Nei & Li (1979), as calculated by DnaSP, and also defined in Presa et al. 2022, Genetic Divergence and Connectivity among Gene Pools of Polyprion americanus
	pops2$da			<<- (pops2$dxy - pops2$meanpi)				# Note: in percentage	
	#
	# 20-09-2024:
	# Nei's D:
	cat("Calculating Nei's genetic distance...",sep="\n")
	pops2$neiD			<<- -log((1-pops2$dxy)/sqrt((1-pops2$pi1)*(1-pops2$pi2)))		
	#
	# Jukes-Cantor correction:
	pops2$pi1_jk 		<<- -3/4*log(1-4/3*pops2$pi1/100)*100		# formula does not work on percentages, so therefore divided by 100 and then multiplied by 100 again
	pops2$pi2_jk 		<<- -3/4*log(1-4/3*pops2$pi2/100)*100
	pops2$dxy_jk		<<- -3/4*log(1-4/3*pops2$dxy/100)*100
	pops2$da_jk			<<- (pops2$dxy_jk - (pops2$pi1_jk+pops2$pi2_jk)/2)	
	cat("Results stored in pops2 dataframe.",sep="\n")
	cat("Generating population distance matrices...",sep="\n")
	m			<-matrix(NA,nrow=length(mysambar$populations),ncol=length(mysambar$populations))
	colnames(m)	<- mysambar$populations
	rownames(m)	<- mysambar$populations
	n			<- m
	f			<- m
	g			<- m
	h			<- m
	d			<- m
	for(i in c(1:nrow(m)))
		{
		pop1	<- mysambar$populations[i]
		for(j in c(1:ncol(m)))
			{
			pop2	<- mysambar$populations[j]
			m[i,j]	<- pops2$dxy[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			n[i,j]	<- pops2$da[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			f[i,j]	<- pops2$fst[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			g[i,j]	<- pops2$Dsd[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			h[i,j]	<- pops2$Dsdnorm[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			d[i,j]	<- pops2$neiD[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			}
		}
	diag(g)	<- 0
	diag(h)	<- 0
	# Note (01-09-2024): fst measures the mean proportion of drift in either population.
	# That is: the distance of each population to the population split.
	# Hence, in order to obtain the distance between the two populations, we need to multiply by 2:
	k	<- 1/10000*(log(1-f)/log(0.9999))
	mysambar$dxymatrix				<<- m*100
	mysambar$damatrix				<<- n
	mysambar$hudsonfstmatrix		<<- f
	mysambar$Dsdmatrix				<<- g
	mysambar$Dsdnormmatrix			<<- h
	mysambar$driftcoalunitsmatrix	<<- k
	mysambar$neiDmatrix				<<- d
	#
	if(domatrix)
		{
		cat("Plotting distance matrices...",sep="\n")
		cat("If you receive the 'must have one more break than colour', rerun with a higher value specified to n_decimals (by default 3).",sep="\n")
		cat("If you receive another error shortly after this line, set the flag 'domatrix' to FALSE.",sep="\n")
		# with values:
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dxy",popnames=mysambar$populations,mymatrix=mysambar$dxymatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=dxybreaks,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Hudsonfst",popnames=mysambar$populations,mymatrix=mysambar$hudsonfstmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=fstbreaks,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NetDivergence",popnames=mysambar$populations,mymatrix=mysambar$damatrix,export="pdf",ndecimals=n_decimals+2,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Coalescentunits_drift",popnames=mysambar$populations,mymatrix=mysambar$driftcoalunitsmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NeiD",popnames=mysambar$populations,mymatrix=mysambar$neiDmatrix,export="pdf",ndecimals=n_decimals+2,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		#
		# without values:
		cat("values",sep="\n")
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dxy",popnames=mysambar$populations,mymatrix=mysambar$dxymatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=dxybreaks,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Hudsonfst",popnames=mysambar$populations,mymatrix=mysambar$hudsonfstmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=fstbreaks,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NetDivergence",popnames=mysambar$populations,mymatrix=mysambar$damatrix,export="pdf",ndecimals=n_decimals+2,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=fstbreaks,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Coalescentunits_drift",popnames=mysambar$populations,mymatrix=mysambar$driftcoalunitsmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NeiD",popnames=mysambar$populations,mymatrix=mysambar$neiDmatrix,export="pdf",ndecimals=n_decimals+2,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
		}
	if(do_sd)
		{
		cat("Plotting distance matrices with standard deviations...",sep="\n")
		cat("If you receive another error shortly after this line, set the flag 'do_sd' to FALSE.",sep="\n")
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dsd",popnames=mysambar$populations,mymatrix=mysambar$Dsdmatrix,export="pdf",ndecimals=8,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_DsdNorm",popnames=mysambar$populations,mymatrix=mysambar$Dsdnormmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
		plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_DsdNorm",popnames=mysambar$populations,mymatrix=mysambar$Dsdnormmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
		}
	#	
	cat("Creating boxplot depicting within versus between populations...",sep="\n")
	pops2$type	<<- ifelse(pops2$samepop,"within","between")
	pops2$dperc	<<- pops2$d*100
	grouppopboxplot(export="pdf",yscore="dperc",plotlabel="dxy_vs_pi",groupvector="type",grouplevels=c("within","between"),popfilter=pops2$filter,symbolcex=2,yrange=NULL,ylabel="Absolute distance (%)",mywidth=1.25,plottitle="  pi       Dxy",mybg="orange",axiscex=2.5,myline=4.5)
	#
	if(dopoptree)
		{
		cat("Generating population dendrograms...",sep="\n")
		cat("Net nucleotide divergence...",sep="\n")
		getpoptree(mymatrix=n,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=treelabelcex,exportlabel="NetNucleotideDivergence",donj=do_nj)	
		write.tree(mysambar$poptree,file=paste("Poptree.NetNucleotideDivergence.newick.txt",sep="."),digits=0,tree.names=FALSE)
		if(!is.null(my_root))
			{
			myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
			getpoptree(mytree=myrootedtree,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="NetNucleotideDivergence",donj=do_nj)
			write.tree(mysambar$poptree,file=paste("Poptree.NetNucleotideDivergence.rooted.newick.txt",sep="."),digits=0,tree.names=FALSE)
			}
		
		#
		cat("Hudson Fst...",sep="\n")
		getpoptree(mymatrix=f,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Hudsonfst",donj=do_nj)	
		write.tree(mysambar$poptree,file=paste("Poptree.HudsonFst.newick.txt",sep="."),digits=0,tree.names=FALSE)
		if(!is.null(my_root))
			{
			myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
			getpoptree(mytree=myrootedtree,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Hudsonfst",donj=do_nj)
			write.tree(mysambar$poptree,file=paste("Poptree.HudsonFst.rooted.newick.txt",sep="."),digits=0,tree.names=FALSE)
			}
		#
		if(docoalunits)
			{
			cat("Coalescent units estimated using drift...",sep="\n")
			getpoptree(mymatrix=h,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=treelabelcex,exportlabel="CoalescentUnitsDrift",donj=do_nj)	
			write.tree(mysambar$poptree,file=paste("Poptree.CoalescentUnits.newick.txt",sep="."),digits=0,tree.names=FALSE)
			if(!is.null(my_root))
				{
				myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
				getpoptree(mytree=myrootedtree,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="CoalescentUnitsDrift",donj=do_nj)
				write.tree(mysambar$poptree,file=paste("Poptree.CoalescentUnitsDrift.rooted.newick.txt",sep="."),digits=0,tree.names=FALSE)
				}
			}
		#
		cat("Dxy...",sep="\n")
		getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=1.0,exportlabel="Dxy",donj=TRUE)
		getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=1.0,exportlabel="Dxy",donj=FALSE)
		getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="phylogram",mylwd=treelwd,labelcex=1.0,exportlabel="Dxy",donj=TRUE)
		write.tree(mysambar$poptree,file=paste("Poptree.Dxy.NJ.newick.txt",sep="."),digits=0,tree.names=FALSE)
		getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="phylogram",mylwd=treelwd,labelcex=1.0,exportlabel="Dxy",donj=FALSE)
		write.tree(mysambar$poptree,file=paste("Poptree.Dxy.UPGMA.newick.txt",sep="."),digits=0,tree.names=FALSE)
		if(is.null(my_root))
			{
			getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Dxy",donj=do_nj)
			write.tree(mysambar$poptree,file=paste("Poptree.Dxy.newick.txt",sep="."),digits=0,tree.names=FALSE)
			}else{
			getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Dxy",myroot=my_root,donj=do_nj)
			myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
			write.tree(myrootedtree,file=paste("Poptree.Dxy.newick.rooted.txt",sep="."),digits=0,tree.names=FALSE)
			}
		}
	if(dopoppcoa)
		{
		cat("Generating pcoa-plots...",sep="\n")
		poppcoa(popmat=mysambar$dxymatrix,method="dxy",export="pdf",axis1=1,axis2=2,legendpos=legpos)
		poppcoa(popmat=mysambar$dxymatrix,method="dxy",export="pdf",axis1=1,axis2=3,legendpos=legpos)
		poppcoa(popmat=mysambar$dxymatrix,method="dxy",export="pdf",axis1=2,axis2=3,legendpos=legpos)
		#
		poppcoa(popmat=mysambar$damatrix,method="da",export="pdf",axis1=1,axis2=2,legendpos=legpos)
		poppcoa(popmat=mysambar$damatrix,method="da",export="pdf",axis1=1,axis2=3,legendpos=legpos)
		poppcoa(popmat=mysambar$damatrix,method="da",export="pdf",axis1=2,axis2=3,legendpos=legpos)
		#
		poppcoa(popmat=mysambar$hudsonfstmatrix,method="fst",export="pdf",axis1=1,axis2=2,legendpos=legpos)
		poppcoa(popmat=mysambar$hudsonfstmatrix,method="fst",export="pdf",axis1=1,axis2=3,legendpos=legpos)
		poppcoa(popmat=mysambar$hudsonfstmatrix,method="fst",export="pdf",axis1=2,axis2=3,legendpos=legpos)
		}
	if(distplots)
		{
		# boxplot depicting within and between-population genetic distances:
		grouppopboxplot(export="pdf",yscore="d",groupvector="samepop",grouplevels=c(TRUE,FALSE),popfilter=pops2$filter,symbolcex=2)
		#
		cat("Generating scatter plots...",sep="\n")
		# pi versus nucleotide divergence:
		popscatter(hline=c(0.4,2),export="pdf",plottitle=NULL,score1="meanpi",score2="da",legendpos="right",ylabel="Net nucleotide divergence (%)",xlabel="Mean nucleotide diversity (%)",addregression=FALSE,yline=2.5)
		# pi versus nucleotide divergence (with Jukes Cantor correction):
		popscatter(hline=c(0.4,2),export="pdf",plottitle=NULL,score1="meanpi",score2="da_jk",legendpos="top",ylabel="Net nucleotide divergence (%)",xlabel="Mean nucleotide diversity (%)",addregression=FALSE,yline=2.5)
		#
		# Dxy vs Fst:
		popscatter(addlegend=FALSE,export="pdf",plottitle=NULL,score1="fst",score2="d",legendpos="bottomright",legendcex=1.1,ylabel="Dxy (%)",xlabel="Hudson Fst",addregression=FALSE)
		}
	if(donetwork)
		{
		cat("Generating neighbour network...",sep="\n")
		popnetwork(mydistmat=mysambar$dxymatrix,do_analysis=TRUE,plotname="Phylonetwork_neighbornet_pop_dxy",mylwd=0.25,doexport=TRUE,mynetwork=NULL,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1.5)
		#
		cat("Population dendrograms and pcoa plot have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

dxytrio<-function(mypops=mysambar$poporder,doplot=TRUE,p_thres=0.05,add_legend=TRUE)
	{
	#if(!any(mysambar$poporder%in%mysambar$poporder2))
	#	{
	#	return(cat("Resetting population filter in order to allow t-test calculations.",sep="\n"))
	#	excludepop()
	#	}
	mytriplets			<- as.data.frame(t(combn(mypops,3)))
	colnames(mytriplets)<- c("p1","p2","p3")
	ntriplets			<- nrow(mytriplets)
	triodf				<- data.frame("admixpop"=rep(NA,ntriplets),"inpop"=NA,"outpop"=NA,"diff"=NA,"prop"=NA,"p"=NA,"sign"=NA,"bonferroni"=NA)
	for(i in c(1:ntriplets))
		{
		if(i%%500==0){cat(paste(i, " out of ",ntriplets," triplets.",sep=""),sep="\n")}
		p1		<- mytriplets$p1[i]
		p2		<- mytriplets$p2[i]
		p3		<- mytriplets$p3[i] 
		pvec	<- c(p1,p2,p3)	
		#
		# distances:
		distvec		<- rep(NA,3)
		distvec[1]	<- pops2$dperc[(pops2$pop1==p1&pops2$pop2==p2)|(pops2$pop1==p2&pops2$pop2==p1)] # 1 vs 2 
		distvec[2]	<- pops2$dperc[(pops2$pop1==p1&pops2$pop2==p3)|(pops2$pop1==p3&pops2$pop2==p1)] # 1 vs 3 
		distvec[3]	<- pops2$dperc[(pops2$pop1==p2&pops2$pop2==p3)|(pops2$pop1==p3&pops2$pop2==p2)] # 2 vs 3
		#
		# which population is putatively admixed?
		maxdist		<- max(distvec)
		k			<- which(distvec==maxdist)
		admixnr		<- ifelse(k==1,3,ifelse(k==2,2,1))
		admixpop	<- pvec[admixnr]
		#
		# which population is outgroup?
		mindist		<- min(distvec)
		j			<- which(distvec==mindist)
		outnr		<- ifelse(j==1,3,ifelse(j==2,2,1))
		outpop		<- pvec[outnr]
		#
		# which population is the ingroup?
		mediumdist	<- distvec[-c(j,k)]
		m			<- which(distvec==mediumdist)
		inpop		<- pvec[-c(admixnr,outnr)]
		#
		# how unbalanced are the differences?
		diffvec		<- rep(NA,3)
		diffvec[1]	<- distvec[1]-distvec[2]		# compare against p1 (Kodiak):		Kodiak-HudsonBay vs Kodiak-Westcoast
		diffvec[2]	<- distvec[1]-distvec[3]		# compare against p2 (HudsonBay):	Kodiak-HudsonBay vs HudsonBay-Westcoast
		diffvec[3]	<- distvec[2]-distvec[3]		# compare against p3 (Westcoast):	Kodiak-Westcoast vs HudsonBay-Westcoast
		#
		triodf$admixpop[i]	<- admixpop
		triodf$inpop[i]		<- inpop
		triodf$outpop[i]	<- outpop
		triodf$diff[i]		<- abs(diffvec[outnr])
		triodf$prop[i]		<- abs(diffvec[outnr])/distvec[k]
		triodf$d3[i]		<- (maxdist-mediumdist)/(maxdist-mindist)
		#
		# t-test p-values:
		dxyvec1				<- inds2$d[inds2$filter&((as.character(inds2$pop1)==outpop&as.character(inds2$pop2)==admixpop)|(as.character(inds2$pop1)==admixpop&as.character(inds2$pop2)==outpop))]
		dxyvec2				<- inds2$d[inds2$filter&((as.character(inds2$pop1)==outpop&as.character(inds2$pop2)==inpop)|(as.character(inds2$pop1)==inpop&as.character(inds2$pop2)==outpop))]
		if(length(dxyvec1>1)&length(dxyvec2>1))
			{
			triodf$p[i]			<- round(t.test(x=dxyvec1,y=dxyvec2)$p.value,6)
			triodf$sign[i]		<- ifelse(triodf$p[i]<0.05,ifelse(triodf$p[i]<0.01,ifelse(triodf$p[i]<0.001,"***","**"),"*"),"NS")
			triodf$bonferroni[i]<- ifelse(triodf$p[i]<0.05/nrow(triodf),TRUE,FALSE)
			}
		}
	if(all(is.na(triodf$p)))
		{
		cat("WARNING: adding dummy p-values because not enough individuals per population.",sep="\n") 
		triodf$p		<- 0.01
		}
	mysambar$d3df			<<- triodf[order(triodf$prop),]
	cat("Results have been stored in mysambar$d3df.",sep="\n")
	#
	if(doplot)
		{
		d3df				<- mysambar$d3df
		colnames(d3df)[1:3]	<- c("pop1","pop2","pop3")
		colnames(d3df)[5]	<- "est"
		mysambar$d3df2		<<- d3df 		
		cat("Plotting...",sep="\n")
		for(d3thres in seq(0.02,0.12,0.02))
			{
			f3heatmap(creatematrix=TRUE,pthres=p_thres,f3thres=d3thres,export="pdf",exportname="d3heatmap",f3df=mysambar$d3df2,addlabels=TRUE,plottitle="d3-score",mybg="white",subtitle=paste("d3 threshold = ",d3thres,"; pvalue threshold = ",p_thres,sep=""),NAcolour=NULL,addlegend=add_legend,fillsquare=TRUE,legendcex=1.25,oldmethod=FALSE,checkpops=FALSE,minthres=TRUE)
			}
		}
	}
	
comparedxy<-function(refpop=NULL,popvec=mysambar$poporder,doplot=TRUE,returnobject=FALSE,plotlabel=NULL)
	{
	if(is.null(refpop)){return(cat("ERROR: Specify a population to the refpop flag.",sep="\n"))}
	if(!refpop%in%mysambar$poporder2){return(cat("ERROR: Specify an existing population to the refpop flag.",sep="\n"))}
	#
	npops				<- length(popvec)
	pmatrix				<- matrix(NA,nrow=npops,ncol=npops)
	colnames(pmatrix)	<- popvec
	rownames(pmatrix)	<- popvec
	for(i in c(1:npops))
		{
		for(j in c(1:npops))
			{
			if(i<j)
				{
				p1a				<- refpop
				p1b				<- mysambar$poporder[i]
				p2a				<- refpop
				p2b				<- mysambar$poporder[j]
				if(p1b==refpop|p2b==refpop)
					{
					myp			<- 0
					}else{
					dxyvec1		<- inds2$d[inds2$filter&((as.character(inds2$pop1)==p1a&as.character(inds2$pop2)==p1b)|(as.character(inds2$pop1)==p1b&as.character(inds2$pop2)==p1a))]
					dxyvec2		<- inds2$d[inds2$filter&((as.character(inds2$pop1)==p2a&as.character(inds2$pop2)==p2b)|(as.character(inds2$pop1)==p2b&as.character(inds2$pop2)==p2a))]
					myp			<- round(t.test(x=dxyvec1,y=dxyvec2)$p.value,5)
					}
				pmatrix[i,j]	<- myp
				pmatrix[j,i]	<- myp
				}
			}
		}
	diag(pmatrix)	<- 0
	if(doplot)
		{
		myplotname		<- paste("Dxy_Ttest_matrix",refpop,sep=".")
		plotpopmatrix(exportname=myplotname,addlabels=TRUE,showvalues=TRUE,labelline=-2,plotlabel=paste("t-test p-values\nAre genetic distances relative to ",refpop," significantly different?",sep=""),popnames=popvec,mymatrix=pmatrix,nrbreaks=4,addlegend=FALSE,plotlabelcex=2,export="pdf",myBreaks=c(0,0.001,0.01,0.05,1),valuecex=3.5,addsidebars=TRUE)
		}
	if(returnobject)
		{
		return(pmatrix)
		}
	}

# 22-06-2022:
hudsonfst<-function(silent=TRUE,my_root=NULL,do_nj=TRUE,dotree=TRUE,dopcoa=TRUE,donetwork=TRUE,distplots=TRUE,pop_legcex=4.5,bin_legcex=8,pop_legposy=5,treelabelcex=1,treelwd=0.5,n_decimals=3,docoalunits=TRUE)
	{
	if(!"meanhe"%in%colnames(inds2)|!"d3"%in%colnames(inds2))
		{
		return(cat("ERROR: columns 'meanhe' and/or 'd3' absent from inds2 dataframe. Did you already add the data generated by VCF_calcdist script to inds2 dataframe using add2inds function?",sep="\n"))
		}
	# Hudson Fst: (pi_between - pi_within)/pi_between
	popnames			<- mysambar$populations2
	npops				<- length(popnames)
	# PI:
	# derive nucleotide diversity per population:
	pophe				<- rep(NA,npops)
	names(pophe)		<- popnames
	poppi				<- pophe
	poppi2				<- pophe
	cat("Calculating nucleotide diversity per population...",sep="\n")
	for (j in c(1:npops))
		{
		mypop			<- as.character(popnames[j])
		cat(mypop,sep="\n")
		hevec			<- inds2$meanhe[as.character(inds2$pop1)==mypop&(inds2$name1==inds2$name2)&inds2$filter]
		if(length(hevec)>0)
			{
			hevec			<- hevec[is.finite(hevec)]
			pophe[j]		<- mean(hevec,na.rm=TRUE)
			}else{
			cat("WARNING: Zero retained individuals. Not possible to calculate heterozygosity.",sep="\n")
			pophe[j]		<- NA
			}
		if(!silent){cat(paste("he: ",round(pophe[j],3),sep=""),sep="\n")}
		#
		pibool			<- as.character(inds2$pop1)==mypop&as.character(inds2$pop2)==mypop&(inds2$name1!=inds2$name2)&inds2$filter
		if(length(pibool[pibool])==0)
			{
			poppi2[j]	<- NA
			if(is.na(pophe[j]))
				{
				cat("WARNING: Zero retained individuals, and thus impossible to estimate nucleotide diversity. This will result in NA-values for pairwise comparisons involving this population.",sep="\n")
				}
			poppi[j]	<- pophe[j]
			}else{
			if(length(pibool[pibool])>1)
				{
				if(!silent){cat("More than 1 individual.",sep="\n")}
				pivec		<- inds2$d3[pibool]
				pivec		<- pivec[is.finite(pivec)]
				poppi2[j]	<- mean(pivec,na.rm=TRUE)
				poppi[j]	<- mean(c(hevec,pivec),na.rm=TRUE)
				}else{
				cat("WARNING: Only 1 individual. Nucleotide diversity is set equal to heterozygosity.",sep="\n")
				poppi2[j]	<- NA
				if(is.na(pophe[j]))
					{
					cat("WARNING: heterozygosity is NA. (Haploid data?) Impossible to estimate nucleotide diversity. This will result in NA-values for pairwise comparisons involving this population.",sep="\n")
					}
				poppi[j]	<- pophe[j]
				}
			}
		if(!silent){cat(paste("pi: ",round(poppi[j],3),sep=""),sep="\n")}
		}
	# DXY AND FST:
	# fstdf		<<- data.frame("pop1"=mysambar$pairpop1,"pop2"=mysambar$pairpop2,"popcol1"=mysambar$pairpopcol1,"popcol2"=mysambar$pairpopcol2,"pi1"=NA,"pi2"=NA,"dxy"=NA,"geodist"=NA)
	cat("Calculating Dxy per population pair...",sep="\n")
	pops2$pi1			<<- NA
	pops2$pi2			<<- NA
	pops2$dxy			<<- NA
	pops2$Dsd			<<- NA
	pops2$pvalue1		<<- NA
	pops2$pvalue2		<<- NA
	for(j in c(1:nrow(pops2)))
		{
		pop1			<- as.character(pops2$pop1[j])
		pop2			<- as.character(pops2$pop2[j])
		pops2$pi1[j]	<<- poppi[names(poppi)==pop1]
		pops2$pi2[j]	<<- poppi[names(poppi)==pop2]
		if(pop1!=pop2)
			{
			dxyvec			<- inds2$d3[inds2$filter&((as.character(inds2$pop1)==pop1&as.character(inds2$pop2)==pop2)|(as.character(inds2$pop1)==pop2&as.character(inds2$pop2)==pop1))]
			pops2$dxy[j]	<<- mean(dxyvec,na.rm=TRUE)
			pops2$Dsd[j]	<<- sd(dxyvec,na.rm=TRUE)/mean(dxyvec,na.rm=TRUE)
			# poppivec		<-  inds2$d3[inds2$filter&(((!inds2$sameind)&(inds2$samepop)&(as.character(inds2$pop1)==pop1))|((!inds2$sameind)&(inds2$samepop)&(as.character(inds2$pop1)==pop2)))]
			# if(length(poppivec)>1)
			#	{
			#	pops2$Dsd[j]	<<- (sd(dxyvec,na.rm=TRUE)-sd(poppivec,na.rm=TRUE))/mean(dxyvec,na.rm=TRUE)
			#	}else{
			#	pops2$Dsd[j]	<<- sd(dxyvec,na.rm=TRUE)/mean(dxyvec,na.rm=TRUE)
			#	}
			}else{
			pops2$dxy[j]	<<- pops2$pi1[j]
			#poppivec		<-  inds2$d3[inds2$filter&(inds2$name1!=inds2$name2)&((as.character(inds2$pop1)==pop1&as.character(inds2$pop2)==pop2)|(as.character(inds2$pop1)==pop2&as.character(inds2$pop2)==pop1))]
			#pops2$Dsd[j]	<<- sd(poppivec,na.rm=TRUE)/
			pops2$Dsd[j]	<<- 0
			}
		}
	pops2$meanpi		<<- (pops2$pi1+pops2$pi2)/2
	pops2$fst			<<- (pops2$dxy - pops2$meanpi)/pops2$dxy
	# pops2$perc1		<<- (pops2$dxy-pops2$pi1)/pops2$dxy*100
	# pops2$perc2		<<- (pops2$dxy-pops2$pi2)/pops2$dxy*100
	#
	# 23-03-2023:
	# net divergence (Da): 
	# Dxy - (pi_x + pi_y)/2	# Nei & Li (1979), as calculated by DnaSP, and also defined in Presa et al. 2022, Genetic Divergence and Connectivity among Gene Pools of Polyprion americanus
	pops2$da			<<- (pops2$dxy - pops2$meanpi)				# Note: in percentage	
	#
	# 20-09-2024:
	# Nei's D:
	cat("Calculating Nei's genetic distance...",sep="\n")
	pops2$neiD			<<- -log((1-pops2$dxy)/sqrt((1-pops2$pi1)*(1-pops2$pi2)))		
	#
	# Jukes-Cantor correction:
	pops2$pi1_jk 		<<- -3/4*log(1-4/3*pops2$pi1/100)*100		# formula does not work on percentages, so therefore divided by 100 and then multiplied by 100 again
	pops2$pi2_jk 		<<- -3/4*log(1-4/3*pops2$pi2/100)*100
	pops2$dxy_jk		<<- -3/4*log(1-4/3*pops2$dxy/100)*100
	pops2$da_jk			<<- (pops2$dxy_jk - (pops2$pi1_jk+pops2$pi2_jk)/2)	
	cat("Results stored in pops2 dataframe.",sep="\n")
	#
	cat("Generating population distance matrices...",sep="\n")
	m			<-matrix(NA,nrow=length(mysambar$populations),ncol=length(mysambar$populations))
	colnames(m)	<- mysambar$populations
	rownames(m)	<- mysambar$populations
	n			<- m
	f			<- m
	g			<- m
	d			<- m
	for(i in c(1:nrow(m)))
		{
		pop1	<- mysambar$populations[i]
		for(j in c(1:ncol(m)))
			{
			pop2	<- mysambar$populations[j]
			m[i,j]	<- pops2$dxy[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			n[i,j]	<- pops2$da[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			f[i,j]	<- pops2$fst[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			g[i,j]	<- pops2$Dsd[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			d[i,j]	<- pops2$neiD[(pops2$pop1==pop1&pops2$pop2==pop2)|(pops2$pop1==pop2&pops2$pop2==pop1)]
			}
		}
	# Note (01-09-2024): fst measures the mean proportion of drift in either population.
	# That is: the distance of each population to the population split.
	# Hence, in order to obtain the distance between the two populations, we need to multiply by 2:
	h	<- 1/10000*(log(1-f)/log(0.9999))
	mysambar$dxymatrix				<<- m
	mysambar$damatrix				<<- n
	mysambar$hudsonfstmatrix		<<- f
	mysambar$Dsdmatrix				<<- g
	mysambar$driftcoalunitsmatrix	<<- h
	mysambar$neiDmatrix				<<- d
	#
	cat("Plotting distance matrices...",sep="\n")
	# with values:
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dxy",popnames=mysambar$populations,mymatrix=mysambar$dxymatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NetDivergence",popnames=mysambar$populations,mymatrix=mysambar$damatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Hudsonfst",popnames=mysambar$populations,mymatrix=mysambar$hudsonfstmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Coalescentunits_drift",popnames=mysambar$populations,mymatrix=mysambar$driftcoalunitsmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dsd",popnames=mysambar$populations,mymatrix=mysambar$Dsdmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NeiD",popnames=mysambar$populations,mymatrix=mysambar$neiDmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=TRUE,addlegend=FALSE,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=TRUE,addlabels=FALSE,poplegposx=0.15,poplegposy=pop_legposy,poplegcex=pop_legcex)
	# without values:
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dxy",popnames=mysambar$populations,mymatrix=mysambar$dxymatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NetDivergence",popnames=mysambar$populations,mymatrix=mysambar$damatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Hudsonfst",popnames=mysambar$populations,mymatrix=mysambar$hudsonfstmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Coalescentunits_drift",popnames=mysambar$populations,mymatrix=mysambar$driftcoalunitsmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_Dsd",popnames=mysambar$populations,mymatrix=mysambar$Dsdmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
	plotpopmatrix(addsidebars=TRUE,exportname="Popmatrix_NeiD",popnames=mysambar$populations,mymatrix=mysambar$neiDmatrix,export="pdf",ndecimals=n_decimals,plotlabel=NULL,labelline=-6,plotlabelcex=10,showvalues=FALSE,addlegend=TRUE,legcex=bin_legcex,legendtitle=NULL,myBreaks=NULL,nrbreaks=5,addpoplegend=FALSE,addlabels=FALSE,poplegposx=0.15,poplegposy=0.675,poplegcex=5.75)
	#
	if(dotree)
		{
		cat("Generating population dendrograms...",sep="\n")
		cat("Net nucleotide divergence...",sep="\n")
		getpoptree(mymatrix=n,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=treelabelcex,exportlabel="NetNucleotideDivergence",donj=do_nj)	
		write.tree(mysambar$poptree,file=paste("Poptree.NetNucleotideDivergence.newick.txt",sep="."),digits=0,tree.names=FALSE)
		if(!is.null(my_root))
			{
			myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
			getpoptree(mytree=myrootedtree,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="NetNucleotideDivergence",donj=do_nj)
			write.tree(mysambar$poptree,file=paste("Poptree.NetNucleotideDivergence.rooted.newick.txt",sep="."),digits=0,tree.names=FALSE)
			}
		
		#
		cat("Hudson Fst...",sep="\n")
		getpoptree(mymatrix=f,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Hudsonfst",donj=do_nj)	
		write.tree(mysambar$poptree,file=paste("Poptree.HudsonFst.newick.txt",sep="."),digits=0,tree.names=FALSE)
		if(!is.null(my_root))
			{
			myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
			getpoptree(mytree=myrootedtree,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Hudsonfst",donj=do_nj)
			write.tree(mysambar$poptree,file=paste("Poptree.HudsonFst.rooted.newick.txt",sep="."),digits=0,tree.names=FALSE)
			}
		#
		if(docoalunits)
			{
			cat("Coalescent units estimated using drift...",sep="\n")
			getpoptree(mymatrix=h,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=treelabelcex,exportlabel="CoalescentUnitsDrift",donj=do_nj)	
			write.tree(mysambar$poptree,file=paste("Poptree.CoalescentUnits.newick.txt",sep="."),digits=0,tree.names=FALSE)
			if(!is.null(my_root))
				{
				myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
				getpoptree(mytree=myrootedtree,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="CoalescentUnitsDrift",donj=do_nj)
				write.tree(mysambar$poptree,file=paste("Poptree.CoalescentUnitsDrift.rooted.newick.txt",sep="."),digits=0,tree.names=FALSE)
				}
			}
		#
		cat("Dxy...",sep="\n")
		getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=1.0,exportlabel="Dxy",donj=FALSE)
		getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="unrooted",mylwd=treelwd,labelcex=1.0,exportlabel="Dxy",donj=TRUE)
		if(is.null(my_root))
			{
			getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Dxy",donj=do_nj)
			write.tree(mysambar$poptree,file=paste("Poptree.Dxy.newick.txt",sep="."),digits=0,tree.names=FALSE)
			}else{
			getpoptree(mymatrix=m,popnames=mysambar$populations,mytype="phylogram",mylwd=treelwd,labelcex=treelabelcex,exportlabel="Dxy",myroot=my_root,donj=do_nj)
			myrootedtree	<- root(mysambar$poptree,outgroup=my_root,resolve.root=TRUE)
			write.tree(myrootedtree,file=paste("Poptree.Dxy.newick.rooted.txt",sep="."),digits=0,tree.names=FALSE)
			}
		}
	if(dopcoa)
		{
		cat("Generating pcoa-plots...",sep="\n")
		poppcoa(popmat=mysambar$dxymatrix,method="dxy",export="pdf",axis1=1,axis2=2)
		poppcoa(popmat=mysambar$dxymatrix,method="dxy",export="pdf",axis1=1,axis2=3)
		poppcoa(popmat=mysambar$dxymatrix,method="dxy",export="pdf",axis1=2,axis2=3)
		}
	#
	if(distplots)
		{
		# boxplot depicting within and between-population genetic distances:
		grouppopboxplot(export="pdf",yscore="d3",groupvector="samepop",grouplevels=c(TRUE,FALSE),popfilter=pops2$filter,symbolcex=2)
		#
		cat("Generating scatter plots...",sep="\n")
		# pi versus nucleotide divergence:
		popscatter(hline=c(0.4,2),export="pdf",plottitle=NULL,score1="meanpi",score2="da",legendpos="right",ylabel="Net nucleotide divergence (%)",xlabel="Mean nucleotide diversity (%)",addregression=FALSE,yline=2.5)
		# pi versus nucleotide divergence (with Jukes Cantor correction):
		popscatter(hline=c(0.4,2),export="pdf",plottitle=NULL,score1="meanpi",score2="da_jk",legendpos="top",ylabel="Net nucleotide divergence (%)",xlabel="Mean nucleotide diversity (%)",addregression=FALSE,yline=2.5)
		#
		# Dxy vs Fst:
		popscatter(addlegend=FALSE,export="pdf",plottitle=NULL,score1="fst",score2="d3",legendpos="bottomright",legendcex=1.1,ylabel="Dxy (%)",xlabel="Hudson Fst",addregression=FALSE)
		}
	if(donetwork)
		{
		cat("Generating neighbour network...",sep="\n")
		popnetwork(mydistmat=mysambar$dxymatrix,do_analysis=TRUE,plotname="Phylonetwork_neighbornet_pop_dxy",mylwd=0.25,doexport=TRUE,mynetwork=NULL,edgecolors=TRUE,silent=TRUE,dolabels=TRUE,mybg="white",labelcex=1.5)
		#
		cat("Population dendrograms and pcoa plot have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 25-06-2022: negative correlation between he and fst is a fingerprint of genetic drift
# integrate with function 'pops2scatter'?
#
popscatter<-function(logaxis="",indmin=1,export=NULL,plottitle=NULL,plotwidth=8,plotlabel=NULL,ylabel=NULL,ref_pop=NULL,refpop2=NULL,mylas=2,xlabel=NULL,score1="meanhe",score2="fst",mycex=3,mylwd=4,myxlim=NULL,myylim=NULL,axiscex=1.5,labcex=2,maincex=2,xline=4,yline=4.75,addlegend=TRUE,legendpos="bottomleft",legend2pos="topright",legendcex=0.9,hline=NULL,vline=NULL,addregression=TRUE,addrleg=TRUE,addlm=FALSE,add_diag=FALSE,predictdf=NULL,predictdf2=NULL)
	{
	if(!(logaxis==""|logaxis=="xy"|logaxis=="x"|logaxis=="y"))
		{
		return(cat("ERROR: unvalid value for logaxis.",sep="\n"))
		}
	nindfilter	<- pops2$ninds1>=indmin&pops2$ninds2>=indmin
	mydf		<- pops2[pops2$filter&!pops2$samepop&nindfilter,]
	cat("Plotting...",sep="\n")
	if(!is.null(export))
		{
		plotname	<- paste("Pop",paste(score1,"VS",score2,sep=""),sep="_")
		if(is.null(plotlabel))
			{
			plotname	<- paste(plotname,paste("min",indmin,"ind",sep=""),sep="_")
			}else{
			plotname	<- paste(plotname,plotlabel,sep="_")
			}
		plotname	<- ifelse(logaxis=="",plotname,paste(plotname,paste("log",logaxis,sep=""),sep="."))
		legendlabel	<- ifelse(addlegend,"WITHlegend","NOlegend")
		if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=plotwidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=plotwidth,height=8)}
		if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=plotwidth*100,height=plotwidth*100)}
		if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=plotwidth,height=8)} 
		}
	par(mar=c(5.5,6.25,3,0.5),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex)	
	mydf	<- mydf[,c(score1,score2,"pop1","pop2","popcol1","popcol2")]
	colnames(mydf)	<- c("score1","score2","pop1","pop2","popcol1","popcol2")
	if(!is.null(ref_pop))
		{
		# give all population pairs the background colours of a certain population:
		refcol			<- mysambar$colorder2[mysambar$poporder2==ref_pop]
		colnames(mydf)	<- c("score1","score2","col1","col2")
		mydf$popcol2	<- refcol
		mydf$popcol1	<- ifelse(mydf$col1==refcol,mydf$col2,mydf$col1) 
		}
	if(!is.null(refpop2))
		{
		# give some population pairs the background colours of a certain population (doesn't work properly):
		for(myrefpop in refpop2)
			{
			cat(myrefpop,sep="\n")
			colnames(mydf)	<- c("score1","score2","pop1","pop2","col1","col2")
			mydf$popcol2	<- ifelse(mydf$pop1==myrefpop|mydf$pop2==myrefpop,ifelse(mydf$pop1==myrefpop,mydf$col1,mydf$col2),mydf$col2) 
			mydf$popcol1	<- ifelse(mydf$pop1==myrefpop|mydf$pop2==myrefpop,ifelse(mydf$pop1==myrefpop,mydf$col2,mydf$col1),mydf$col1) 
			mydf$col1		<- NULL
			mydf$col2		<- NULL
			}
		}
	if(is.null(ylabel))
		{
		ylabel	<- ifelse(score2=="d","Dxy (%)","Hudson Fst")
		}
	if(is.null(xlabel))
		{
		xlabel	<- ifelse(score1=="meanhe","Heterozygosity (%)","Nucleotide diversity (%)")
		}
	if(is.null(myylim))
		{
		myylim	<- c(min(mydf$score2),max(mydf$score2))
		}
	if(is.null(myxlim))
		{
		plot(mydf$score1,mydf$score2,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=mycex,lwd=mylwd,log=logaxis,xlab="",ylab="",las=mylas,ylim=myylim,main=plottitle)
		}else{
		plot(mydf$score1,mydf$score2,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=mycex,lwd=mylwd,log=logaxis,xlab="",ylab="",las=mylas,xlim=myxlim,ylim=myylim,main=plottitle)
		}
	if(addlegend){legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)}
	mtext(side=1,line=xline,xlabel,cex=labcex)
	mtext(side=2,line=yline,ylabel,cex=labcex)
	if(addregression)
		{
		if(logaxis=="")
			{
			myfit		<<- lm(score2 ~ score1,data=mydf)
			}else{
			if(logaxis=="xy")
				{
				myfit		<<- lm(log10(score2) ~ log10(score1),data=mydf)
				}else{
				if(logaxis=="x")
					{
					myfit		<<- lm(score2 ~ log10(score1),data=mydf)
					}else{
					myfit		<<- lm(log10(score2) ~ score1,data=mydf)
					}
				}
			}
		abline(myfit,lty=2,lwd=3)
		myfit2		<<- summary(myfit)
		# significance:
		myp			<<- round(myfit2$coefficients[2,4],4)
		# explained variance:
		myr			<<- round(myfit2$r.squared,3)
		# correlation coefficient (pearson or spearman):
		mycorr		<<- cor.test(mydf$score2,mydf$score1,method=c("pearson"))
		if(addrleg&!addlm){legend(legend2pos,legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)}
		if(addrleg&addlm)
			{
			myintercept	<- round(summary(myfit)$coefficients[1,1],2)
			myslope		<- round(summary(myfit)$coefficients[2,1],2)
			legend(legend2pos,legend=c(paste("intercept = ",myintercept,sep=""),paste("slope = ",myslope,sep=""),paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
			}
		}
	if(!is.null(hline))
		{
		abline(h=hline,lty=2,lwd=2,col="grey50")
		}
	if(!is.null(vline))
		{
		abline(v=vline,lty=2,lwd=2,col="grey50")
		}
	if(add_diag)
		{
		lines(x=c(-10000,10000),y=c(-10000,10000),col="grey80",lwd=1)
		}
	if(!is.null(predictdf))
		{
		lines(predictdf[,1],predictdf[,2],lwd=3.5,lty=2)
		}
	if(!is.null(predictdf2))
		{
		lines(predictdf2[,1],predictdf2[,2],lwd=3.5,lty=2,col="grey50")
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# added on 22-06-2022. 03-02-2023: this should be merged with pops2scatter
popfstmantel<-function(logaxis="",export=NULL,plottitle=NULL,plotname="Mantelplot_Fst",yscore="fst",mycex=3,mylwd=4,myxlim=NULL,axiscex=1.5,labcex=2,maincex=2,xline=4,yline=4.75,addlegend=TRUE,legendpos="topleft",legend2pos="bottomright",legendcex=1,vline=NULL,xlabel="Distance (100 km)",ylabel="Fst",addregression=FALSE)
	{
	if(!yscore%in%colnames(pops2))
		{
		return(cat("Specified y-score column not present in pops2 dataframe.",sep="\n"))
		}
	mydf			<- pops2[pops2$filter&!pops2$samepop,c("geodist","popcol1","popcol2",yscore)]
	colnames(mydf)	<- c("geodist","popcol1","popcol2","fst")
	cat("Plotting...",sep="\n")
	if(!is.null(export))
		{
		plotname	<- paste(plotname,"popcol",sep="_")
		legendlabel	<- ifelse(addlegend,"WITHlegend","NOlegend")
		if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,6.5,3,0.25),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex)	
	if(is.null(myxlim))
		{
		plot(mydf$geodist,mydf$fst,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=mycex,lwd=mylwd,log=logaxis,xlab="",ylab="",las=2,main=plottitle)
		}else{
		plot(mydf$geodist,mydf$fst,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=mycex,lwd=mylwd,log=logaxis,xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
		}
	if(addlegend){legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)}
	mtext(side=1,line=xline,xlabel,cex=labcex)
	mtext(side=2,line=yline,ylabel,cex=labcex)
	if(addregression)
		{
		mydata		<- mydf[,c("geodist","fst")] 
		myfit		<<- lm(fst ~ log10(geodist),data=mydata)
		abline(myfit,lty=2,lwd=3)
		myfit2		<<- summary(myfit)
		myr			<<- round(myfit2$r.squared,3)
		myp			<<- round(myfit2$coefficients[2,4],4)
		if(myp<0.001)
			{
			legend(legend2pos,legend=c(paste("r = ",myr,sep=""),"p < 0.001"),cex=legendcex,bty='n',col=NA,lty=2)
			}else{
			legend(legend2pos,legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
			}
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}
	
# 22-06-2022: rewritten to hudsonfst (for calculation) and popfstmantel (for plotting), which input and output to inds2 
hudsonfst_old<-function(popnames=mysambar$populations2,mydf=mydistdf,excludepops=NULL,runanalysis=TRUE,doplot=TRUE,logaxis="",export=NULL,plottitle=NULL,usecladecol=FALSE,plotname="HudsonFst",mycex=3,myxlim=NULL,axiscex=1.5,labcex=2,maincex=2,xline=4,yline=4.75,addlegend=TRUE,legendpos="topleft",legend2pos="bottomright",legendcex=1,vline=NULL,xlabel="Distance (100 km)",ylabel="Hudson Fst",addregression=FALSE)
	{
	# Hudson Fst: (pi_between - pi_within)/pi_between
	npops				<- length(popnames)
	if(runanalysis)
		{
		if(is.null(mysambar$pairpopcol1))
			{
			cat("Generating mysambar$pairpop1 and mysambar$pairpop2.",sep="\n")
			popnames				<- mysambar$populations2
			popcols					<- mysambar$mycolours2
			combitable				<- combn(popnames,m=2)
			mysambar$pairpop1		<<- combitable[1,]
			mysambar$pairpop2		<<- combitable[2,]
			mysambar$pairpopcol1	<<- vector()
			mysambar$pairpopcol2	<<- vector()
			for(k in c(1:ncol(combitable)))
				{
				mysambar$pairpopcol1[k]	<<- popcols[which(popnames==mysambar$pairpop1[k])]
				mysambar$pairpopcol2[k]	<<- popcols[which(popnames==mysambar$pairpop2[k])]
				}
			}
		# PI:
		# derive nucleotide diversity per population:
		pophe			<<- rep(NA,npops)
		names(pophe)	<<- popnames
		poppi			<<- pophe
		poppi2			<<- pophe
		cat("Calculating nucleotide diversity per population...",sep="\n")
		for (j in c(1:npops))
			{
			mypop		<- as.character(popnames[j])
			#cat(mypop,sep="\n")
			hevec		<- mydf$he[as.character(mydf$pop1)==mypop&mydf$name1==mydf$name2]
			pivec		<- mydf$dxy2[as.character(mydf$pop1)==mypop&as.character(mydf$pop2)==mypop&mydf$name1!=mydf$name2]
			hevec		<- hevec[is.finite(hevec)]
			pivec		<- pivec[is.finite(pivec)]
			pophe[j]	<<- mean(hevec,na.rm=TRUE)
			poppi2[j]	<<- mean(pivec,na.rm=TRUE)
			poppi[j]	<<- mean(c(hevec,pivec),na.rm=TRUE)
			}
		# DXY AND FST:
		fstdf		<<- data.frame("pop1"=mysambar$pairpop1,"pop2"=mysambar$pairpop2,"popcol1"=mysambar$pairpopcol1,"popcol2"=mysambar$pairpopcol2,"pi1"=NA,"pi2"=NA,"dxy"=NA,"geodist"=NA)
		npairs		<- nrow(fstdf)
		cat("Calculating Dxy per population pair...",sep="\n")
		if("geodist"%in%colnames(mydistdf))
			{
			cat("In addition, calculating mean geographic distance...",sep="\n")
			}
		for(j in c(1:npairs))
			{
			pop1			<- as.character(fstdf$pop1[j])
			pop2			<- as.character(fstdf$pop2[j])
			fstdf$pi1[j]	<<- poppi[names(poppi)==pop1]
			fstdf$pi2[j]	<<- poppi[names(poppi)==pop2]
			dxyvec			<- mydf$dxy2[(as.character(mydf$pop1)==pop1&as.character(mydf$pop2)==pop2)|(as.character(mydf$pop1)==pop2&as.character(mydf$pop2)==pop1)]
			fstdf$dxy[j]	<<- mean(dxyvec,na.rm=TRUE)
			#
			geovec			<- mydf$geodist[(as.character(mydf$pop1)==pop1&as.character(mydf$pop2)==pop2)|(as.character(mydf$pop1)==pop2&as.character(mydf$pop2)==pop1)]
			fstdf$geodist[j]<<- mean(geovec,na.rm=TRUE)
			}
		fstdf$meanpi		<<- (fstdf$pi1+fstdf$pi2)/2
		fstdf$fst			<<- (fstdf$dxy - fstdf$meanpi)/fstdf$dxy
		}
	cat("Results stored in fstdf.",sep="\n")
	#
	if(!is.null(excludepops))
		{
		mybool		<- !(fstdf$pop1%in%excludepops)&!(fstdf$pop2%in%excludepops)
		fstdf		<-fstdf[mybool,]
		}
	#
	if(doplot)
		{
		cat("Plotting...",sep="\n")
		if(!is.null(export))
			{
			plotname	<- ifelse(usecladecol,paste(plotname,"cladecol",sep="_"),paste(plotname,"popcol",sep="_"))
			legendlabel	<- ifelse(addlegend,"WITHlegend","NOlegend")
			if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
			if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
			if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
			}
		par(mar=c(5.5,6.5,3,0.25),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex)	
		if(!usecladecol)
			{
			if(is.null(myxlim))
				{
				plot(fstdf$geodist,fstdf$fst,pch=21,bg=as.character(fstdf$popcol1),col=as.character(fstdf$popcol2),cex=mycex,lwd=4,log=logaxis,xlab="",ylab="",las=2,main=plottitle)
				}else{
				plot(fstdf$geodist,fstdf$fst,pch=21,bg=as.character(fstdf$popcol1),col=as.character(fstdf$popcol2),cex=mycex,lwd=4,log=logaxis,xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
				}
			if(addlegend){legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)}
			}else{
			if(is.null(myxlim))
				{
				plot(fstdf$geodist,fstdf$dxy,pch=21,bg=as.character(fstdf$cladecol1),col=as.character(fstdf$cladecol2),cex=mycex,lwd=4,log=logaxis,xlab="",ylab="",las=2,main=plottitle)
				}else{
				plot(fstdf$geodist,fstdf$dxy,pch=21,bg=as.character(fstdf$cladecol1),col=as.character(fstdf$cladecol2),cex=mycex,lwd=4,log=logaxis,xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
				}
			if(addlegend){legend(legendpos,legend=unique(as.character(fstdf$clade1)),bty='n',fill=unique(as.character(fstdf$cladecol1)),border=unique(as.character(fstdf$cladecol1)),cex=legendcex)}
			}
		mtext(side=1,line=xline,xlabel,cex=labcex)
		mtext(side=2,line=yline,ylabel,cex=labcex)
		if(addregression)
			{
			mydata		<- fstdf[,c("geodist","fst")] 
			myfit		<<- lm(fst ~ log10(geodist),data=mydata)
			abline(myfit,lty=2,lwd=3)
			myfit2		<<- summary(myfit)
			myr			<<- round(myfit2$r.squared,3)
			myp			<<- round(myfit2$coefficients[2,4],4)
			legend(legend2pos,legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
			}
		if(!is.null(export))
			{
			dev.off()
			cat("Scatterplot has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	}


# function to create a histogram with rough tmrca estimate:
dxyhisto<-function(mydf=mydistdf,pairdf=NULL,export=NULL,mybreaks=seq(-1,10000,500),xmax=70000,plotwidth=8,ymax=0.15,legendpos="topright",plotname="Dxy_histo",silent=TRUE,per_year=TRUE,mycolours=NULL)
	{
	if(is.null(mycolours))
		{
		mycolours	<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
		}
	if(is.null(pairdf))
		{
		return(cat("ERROR: provide a dataframe with the columns pop1 and pop2, listing the population pairs you want to plot.",sep="\n"))
		}
	npairs		<- nrow(pairdf)
	myscore		<- ifelse(per_year,mydf$tmrca_y/1000,mydf$tmrca_g/1000)
	if(max(myscore,na.rm=TRUE)>max(mybreaks))
		{
		return(cat("ERROR: mybreaks do not span entire range.",sep="\n"))
		}
	#
	if(!is.null(export))
		{
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=plotwidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=plotwidth,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=plotwidth*90,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=plotwidth,height=8)} 
		}
	# outline of plot:
	par(mar=c(6,7,2,2),cex.axis=2,cex.lab=2.5)
	hist(myscore,breaks=mybreaks/1000,xlim=c(0,xmax/1000),freq=TRUE,col="white",border=NA,ylim=c(0,ymax),xlab="",ylab="",main="",las=2)
	mtext(side=1,"Y-chrom TMRCA (kya)",line=4.5,cex=2.5)
	mtext(side=2,"Sample pair frequency",line=4.75,cex=2.5)
	# add LGM:
	if(per_year)
		{
		rect(xleft=18000/1000,ybottom=0,xright=32000/1000,ytop=1,border="grey70",col="grey70")
		text(x=25000/1000,y=ymax*0.975,"LGM",cex=2.25)
		}
	#
	allsubdf	<- list()
	for(k in c(1:npairs))
		{
		cat(k,sep="\n")
		pop1		<- as.character(pairdf[k,1])
		pop2		<- as.character(pairdf[k,2])
		if(!silent){cat(pop1,sep="\n")}
		if(!silent){cat(pop2,sep="\n")}
		subdf		<- droplevels(mydf[(as.character(mydf$pop1)==pop1&as.character(mydf$pop2)==pop2)|(as.character(mydf$pop2)==pop1&as.character(mydf$pop1)==pop2),])
		subdf		<- subdf[subdf$bool1&subdf$bool2,]
		allsubdf[[k]]	<- subdf
		popcol1		<- as.character(subdf$popcol1[1])
		popcol2		<- as.character(subdf$popcol2[2])
		if(per_year)
			{
			myscore		<- subdf$tmrca_y/1000
			}else{
			myscore		<- subdf$tmrca_g/1000
			}
		mydensity	<- density(myscore,na.rm=TRUE)
		lines(mydensity$x,mydensity$y,col=popcol1,lwd=7)
		lines(mydensity$x,mydensity$y,col=popcol2,lwd=7,lty=2)
		}
	# mask negative:
	rect(-50000,-ymax/1000,0,ymax/1000,col="white",border="white")	
	# legend:
	alldf 	<- do.call("rbind",allsubdf)
	mypops	<- data.frame("pop"=c(as.character(alldf$pop1),as.character(alldf$pop2)),"popcol"=c(as.character(alldf$popcol1),as.character(alldf$popcol2)))
	mypops	<- mypops[order(mypops$pop),]
	mypops	<- mypops[!duplicated(mypops$pop),]
	legend(legendpos,legend=mypops$pop,bty='n',fill=as.character(mypops$popcol),cex=2.5,border=as.character(mypops$popcol))
	if(!is.null(export))
		{
		dev.off()
		cat("Histograms showing genome wide scores per sample has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 21-08-2022: renamed from popdxymantel to pops2scatter, to make it generally useful to create scatter plots for pops2 dataframe.
# 21-06-2022: rebuilt from dxyfac() function, and renamed to popdxymantel:
# 23-03-2023: can this replace popscatter function?
pops2scatter<-function(dobetween=TRUE,dowithin=FALSE,export=NULL,xscore="geodist",yscore="d",mybg="white",mylas=2,plotname="Mantelplot_rawdistance",addlines=NULL,plottitle=NULL,mylinemat=NULL,mycex=3,myxlim=NULL,axiscex=2.5,labcex=3,maincex=3,xline=4.5,yline=5.5,addlegend=TRUE,legendpos="topleft",legend2pos="bottomright",legendcex=1.5,vline=NULL,xlabel="Distance (100 km)",ylabel="Dxy (%)",addregression=TRUE)
	{
	if((!"filter1"%in%colnames(pops2))|(!"filter2"%in%colnames(pops2)))
		{
		return(cat("ERROR: columns 'filter1' and/or 'filter2' are missing in pops2 dataframe.",sep="\n"))
		}
	if(!any(colnames(pops2)%in%xscore))
		{
		return(cat("ERROR: xscore (default: 'geodist') missing in pops2 dataframe.",sep="\n"))
		}
	if(!any(colnames(pops2)%in%yscore))
		{
		return(cat("ERROR: yscore (default: 'd') missing in pops2 dataframe.",sep="\n"))
		}
	cat("Selecting data...",sep="\n")
	mydf			<- pops2[pops2$filter&!pops2$samepop,colnames(pops2)%in%c(xscore,yscore,"popcol1","popcol2","pop1","pop2")]
	colnames(mydf)[colnames(mydf)%in%xscore]	<- "x"
	colnames(mydf)[colnames(mydf)%in%yscore]	<- "y"
	#mydf2			<- pops2[pops2$filter&!pops2$samepop,c("popcol1","popcol2")]
	#mydf			<- cbind(mydf,mydf2)
	if(any(!is.finite(mydf$x)|!is.finite(mydf$y)))
		{
		return(cat("ERROR: selected column(s) contain infinite values.",sep="\n"))
		}
	if(any(is.na(mydf$x)))
		{
		cat("WARNING: NA-values in mydf$x.",sep="\n")
		}
	if(any(is.na(mydf$y)))
		{
		cat("WARNING: NA-values in mydf$y.",sep="\n")
		}
	cat("Plotting...",sep="\n")
	if(!is.null(export))
		{
		plotname	<- paste(plotname,"popcol",sep="_")
		plotname	<- ifelse(mybg=="white",plotname,paste(plotname,mybg,sep="."))
		legendlabel	<- ifelse(addlegend,"WITHlegend","NOlegend")
		if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,7.5,3,0.25),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex,bg=mybg)	
	mydf			<<- mydf
	if(is.null(myxlim))
		{
		plot(mydf$x,mydf$y,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=mylas,main=plottitle)
		}else{
		plot(mydf$x,mydf$y,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=mylas,xlim=myxlim,main=plottitle)
		}
	if(!is.null(addlines)){abline(h=addlines,lty=2,col="grey50")}
	if(addlegend){legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)}
	if(!is.null(mylinemat))
		{
		cat("Adding lines...",sep="\n")
		for (k in c(1:nrow(mylinemat)))
			{
			lines(c(mylinemat[k,1],mylinemat[k,2]),c(mylinemat[k,3],mylinemat[k,4]),lwd=3)
			}
		}
	mtext(side=1,line=xline,xlabel,cex=labcex)
	mtext(side=2,line=yline,ylabel,cex=labcex)
	if(addregression)
		{
		mydata			<- mydf
		mydata$x[mydata$x==0]	<- 0.1	
		myfit			<- lm(y ~ log10(x),data=mydata)
		abline(myfit,lty=2,lwd=3)
		myfit2			<- summary(myfit)
		myr				<- round(myfit2$r.squared,3)
		myp				<- round(myfit2$coefficients[2,4],4)
		legend(legend2pos,legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
		}
	if(!is.null(vline))
		{
		abline(v=vline,lty=2,col="grey80")	
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 21-06-2022: depreciated, and replaced by dxymantel function
dxyfac_old<-function(dxy=mysambar$dxy,doclades=FALSE,excludepops=NULL,dobetween=TRUE,dowithin=FALSE,export=NULL,plotname="Dxy_vs_dist",addlines=NULL,usecladecol=FALSE,plottitle=NULL,mylinemat=NULL,mycex=3,myxlim=NULL,axiscex=1.5,labcex=2,maincex=2,xline=4,yline=4.75,addlegend=TRUE,legendpos="topleft",legend2pos="bottomright",legendcex=2,vline=NULL,xlabel="Distance (100 km)",ylabel="Dxy (%)",addregression=TRUE)
	{
	if(usecladecol&(!"clade1"%in%colnames(dxy)|!"clade2"%in%colnames(dxy)))
		{
		return(cat("ERROR: columns 'clade1' and/or 'clade2' are missing. Rerun the nrmismatch() function with the flag addclade set to TRUE, or alternatively rerun the dxyfac function with the flag usecladecol set to FALSE.",sep="\n"))
		}
	if((!"bool1"%in%colnames(dxy))|(!"bool2"%in%colnames(dxy)))
		{
		return(cat("ERROR: columns 'bool1' and/or 'bool2' are missing.",sep="\n"))
		}
	if(!"geodist"%in%colnames(dxy))
		{
		return(cat("ERROR: column 'geodist' missing. Essential for Mantel plot.",sep="\n"))
		}
	cat("Selecting data...",sep="\n")
	dxy				<- dxy[dxy$bool1&dxy$bool2,]
	if(!"clade1"%in%colnames(dxy))
		{
		cat("Adding dummy clade information...",sep="\n")
		dxy$clade1		<- "clade1"
		dxy$clade2		<- "clade1"
		dxy$cladecol1	<- "darkred"
		dxy$cladecol2	<- "darkred"
		}
	dxy$cladepair	<- paste(dxy$clade1,dxy$clade2,sep="_")
	dxy$sameclade	<- dxy$clade1==dxy$clade2
	dxy$poppair		<- paste(dxy$pop1,dxy$pop2,sep="_")
	dxy$samepop		<- dxy$pop1==dxy$pop2	
	if(!is.null(excludepops))
		{
		mybool		<- !(dxy$pop1%in%excludepops)&!(dxy$pop2%in%excludepops)
		dxy2		<- dxy[mybool,]
		}else{
		mybool		<- TRUE
		dxy2		<- dxy
		}
	#
	cat("Aggregating data...",sep="\n")
	if(dowithin&!dobetween)
		{
		cat("Within only...",sep="\n")
		# within:
		dxy1			<- dxy[mybool&dxy$samepop,c("geodist","dxy3","pop1","pop2","popcol1","popcol2")]
		agg1 			<- aggregate(dxy1$dxy3,by=list(dxy1$pop1),FUN=mean,na.rm=TRUE)
		colnames(agg1)	<- c("pop","dxy")
		agg2 			<- aggregate(dxy1$geodist,by=list(dxy1$pop1),FUN=mean,na.rm=TRUE)
		colnames(agg2)	<- c("pop","dist")
		agg3 			<- aggregate(dxy1$popcol1,by=list(dxy1$pop1),FUN=unique)
		colnames(agg3)	<- c("pop","popcol")
		#
		within			<- data.frame("pop"=agg1$pop,"dxy"=agg1$dxy,"dist"=agg2$dist,"popcol"=agg3$popcol)
		plot(within$dist,within$dxy,cex=3,pch=16,col=as.character(within$popcol),log="x")
		}
	if(dobetween)
		{
		if(dowithin)
			{
			cat("Within and between...",sep="\n")
			dxy1		<- dxy[mybool,c("geodist","dxy3","poppair","pop1","pop2","popcol1","popcol2","clade1","clade2","cladecol1","cladecol2")]
			}else{
			cat("Between only...",sep="\n")
			mydxy		<<- dxy
			dxy1		<- dxy[mybool&(!dxy$samepop),c("geodist","dxy3","poppair","pop1","pop2","popcol1","popcol2","clade1","clade2","cladecol1","cladecol2")]
			}
		agg1 			<- aggregate(dxy1$dxy3,by=list(dxy1$poppair),FUN=mean,na.rm=TRUE)
		colnames(agg1)	<- c("poppair","dxy")
		agg2 			<- aggregate(dxy1$geodist,by=list(dxy1$poppair),FUN=mean,na.rm=TRUE)
		colnames(agg2)	<- c("poppair","dist")
		agg3 			<- aggregate(dxy1$popcol1,by=list(dxy1$poppair),FUN=unique)
		colnames(agg3)	<- c("poppair","popcol1")
		agg4 			<- aggregate(dxy1$popcol2,by=list(dxy1$poppair),FUN=unique)
		colnames(agg4)	<- c("poppair","popcol2")
		between			<- data.frame("pop"=agg1$poppair,"dxy"=agg1$dxy,"dist"=agg2$dist,"popcol1"=agg3$popcol,"popcol2"=agg4$popcol2)
		#
		tempdxy				<- dxy1[!duplicated(dxy1$poppair),]
		tempdxy				<- tempdxy[order(tempdxy$poppair),]
		between$cladecol1	<- tempdxy$cladecol1
		between$cladecol2	<- tempdxy$cladecol2
		dxybetween			<<- between
		#
		cat("Plotting...",sep="\n")
		if(!is.null(export))
			{
			plotname	<- ifelse(usecladecol,paste(plotname,"cladecol",sep="_"),paste(plotname,"popcol",sep="_"))
			legendlabel	<- ifelse(addlegend,"WITHlegend","NOlegend")
			if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
			if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
			if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
			if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
			}
		par(mar=c(5.5,6.5,3,0.25),cex.axis=axiscex,cex.lab=labcex,cex.main=maincex)	
		if(!usecladecol)
			{
			if(is.null(myxlim))
				{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$popcol1),col=as.character(between$popcol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,main=plottitle)
				}else{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$popcol1),col=as.character(between$popcol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
				}
			if(!is.null(addlines)){abline(h=addlines,lty=2,col="grey50")}
			#if(length(mysambar$populations)==19)
			#	{
			#	legend("top",legend=mysambar$populations[c(14:17,19,18)],bty='n',fill=mysambar$mycolours[c(14:17,19,18)],cex=1.5)
			#	legend("topleft",legend=mysambar$populations[1:13],bty='n',fill=mysambar$mycolours[1:13],cex=1.5)
			#	}else{
				if(addlegend){legend(legendpos,legend=mysambar$poporder,bty='n',fill=mysambar$colorder,border=mysambar$colorder,cex=legendcex)}
				#legend(legendpos,legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=1.5)
				#legend(legendpos,legend=unique(c(as.character(mydf$pop1),as.character(mydf$pop2))),bty='n',fill=unique(c(as.character(mydf$popcol1),as.character(mydf$popcol2))),cex=2)
			#	}
			}else{
			if(is.null(myxlim))
				{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$cladecol1),col=as.character(between$cladecol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,main=plottitle)
				}else{
				plot(between$dist,between$dxy,pch=21,bg=as.character(between$cladecol1),col=as.character(between$cladecol2),cex=mycex,lwd=4,log="x",xlab="",ylab="",las=2,xlim=myxlim,main=plottitle)
				}
			if(!is.null(addlines)){abline(h=addlines,lty=2,col="grey50")}
			#legend(legendpos,legend=c("Syrian","Himalaya","Eurasia-west","Eurasia-east","Amur","Alaska","Westcoast"),bty='n',fill=c("indianred1","orangered1","darkred","midnightblue","mediumpurple1","darkgreen","greenyellow"),cex=2)
			if(addlegend){legend(legendpos,legend=unique(as.character(dxy$clade1)),bty='n',fill=unique(as.character(dxy$cladecol1)),border=unique(as.character(dxy$cladecol1)),cex=legendcex)}
			}
		if(!is.null(mylinemat))
			{
			cat("Adding lines...",sep="\n")
			for (k in c(1:nrow(mylinemat)))
				{
				lines(c(mylinemat[k,1],mylinemat[k,2]),c(mylinemat[k,3],mylinemat[k,4]),lwd=3)
				}
			}
		mtext(side=1,line=xline,xlabel,cex=labcex)
		mtext(side=2,line=yline,ylabel,cex=labcex)
		#if(!is.null(plottitle))
		#	{
		#	mtext(side=3,line=0.5,plottitle,cex=3.5)
		#	}
		#
		# regression:
		if(addregression)
			{
			mydata		<- between[,c("dist","dxy")] 
			myfit		<<- lm(dxy ~ log10(dist),data=mydata)
			abline(myfit,lty=2,lwd=3)
			myfit2		<<- summary(myfit)
			myr			<<- round(myfit2$r.squared,3)
			myp			<<- round(myfit2$coefficients[2,4],4)
			legend(legend2pos,legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
			}
		#wdata		<- between[between$cladecol1==between$cladecol2&between$dist>5,c("dist","dxy")] 
		#wfit		<<- lm(dxy ~ log10(dist),data=wdata)
		#abline(wfit,lty=2,lwd=3)
		#
		#bdata		<- between[between$cladecol1!=between$cladecol2&between$dist>5,c("dist","dxy")] 
		#bfit		<<- lm(dxy ~ log10(dist),data=bdata)
		#abline(bfit,lty=2,lwd=3)
		#
		if(!is.null(vline))
			{
			abline(v=vline,lty=2,col="grey80")	
			}
		#
		if(!is.null(export))
			{
			dev.off()
			cat("Scatterplot has been exported to the directory:",sep="\n")
			cat(getwd(),sep="\n")
			}
		}
	#
	if(doclades)
		{
		# between clades:
		dxy1			<- dxy[mybool&(!dxy$sameclade),c("geodist","dxy3","clade1","clade2","cladecol1","cladecol2")]
		dxy1$cladepair	<- paste(dxy1$clade1,dxy1$clade2,sep="_")
		agg1 			<- aggregate(dxy1$dxy3,by=list(dxy1$cladepair),FUN=mean,na.rm=TRUE)
		colnames(agg1)	<- c("cladepair","dxy")
		agg2 			<- aggregate(dxy1$geodist,by=list(dxy1$cladepair),FUN=mean,na.rm=TRUE)
		colnames(agg2)	<- c("cladepair","dist")
		agg3 			<- aggregate(dxy1$cladecol1,by=list(dxy1$cladepair),FUN=unique)
		colnames(agg3)	<- c("cladepair","cladecol1")
		agg4 			<- aggregate(dxy1$cladecol2,by=list(dxy1$cladepair),FUN=unique)
		colnames(agg4)	<- c("cladepair","cladecol2")
		clade			<- data.frame("cladepair"=agg1$cladepair,"dxy"=agg1$dxy,"dist"=agg2$dist,"cladecol1"=agg3$cladecol1,"cladecol2"=agg4$cladecol2)
		plot(clade$dist,clade$dxy,pch=21,bg=as.character(clade$cladecol1),col=as.character(clade$cladecol2),cex=mycex,lwd=3,log="x")
		legend("topleft",mysambar$populations,fill=mysambar$mycolours,bty='n',cex=2.5)
		}
	}

makemanteldf<-function(addclade=TRUE,docalc=TRUE,onlybetween=FALSE,onlywithin=FALSE,dofst=TRUE)
	{
	if(docalc&dofst)
		{
		cat("Running Fst calculations...",sep="\n")
		runWrightFst()
		}
	if(docalc&!dofst)
		{
		cat("Running Nei's D calculations...",sep="\n")
		pop_neimatrix()
		}
	if(dofst)
		{
		myscore		<- mysambar$Wrightfstvector
		}else{
		myscore		<- mysambar$popneivector
		}
	if(is.null(myscore))
		{
		return(cat("ERROR: myscore is NULL.",sep="\n"))
		}
	mydf				<- data.frame("pop1"=mysambar$pairpop1,"pop2"=mysambar$pairpop2,"popdist"=myscore,"long"=NA,"lat"=NA,"cladecol1"=NA,"cladecol2"=NA,"popcol1"=NA,"popcol2"=NA)
	npairs				<- nrow(mydf)
	for(i in c(1:npairs))
		{
		pop1			<- as.character(mydf$pop1[i])
		pop2			<- as.character(mydf$pop2[i])
		#
		# geographical distance:
		long1			<- mean(inds$longitude3[as.character(inds$pop)==pop1],na.rm=TRUE)
		long2			<- mean(inds$longitude3[as.character(inds$pop)==pop2],na.rm=TRUE)
		lat1			<- mean(inds$latitude[as.character(inds$pop)==pop1],na.rm=TRUE)
		lat2			<- mean(inds$latitude[as.character(inds$pop)==pop2],na.rm=TRUE)
		mydf$long[i]	<- abs(long2-long1)
		mydf$lat[i]	<- abs(lat2-lat1)
		if(addclade)
			{
			mydf$clade1[i]		<- unique(inds$clade[as.character(inds$pop)==pop1])[1]
			if(length(unique(inds$clade[as.character(inds$pop)==pop1]))>1){cat(paste("WARNING: more than 1 clade defined for population ",pop1,".",sep=""),sep="\n")}
			mydf$clade2[i]		<- unique(inds$clade[as.character(inds$pop)==pop2])[1]
			if(length(unique(inds$clade[as.character(inds$pop)==pop2]))>1){cat(paste("WARNING: more than 1 clade defined for population ",pop2,".",sep=""),sep="\n")}
			mydf$cladecol1[i]	<- unique(inds$cladecol[as.character(inds$pop)==pop1])[1]
			if(length(unique(inds$cladecol[as.character(inds$pop)==pop1]))>1){cat(paste("WARNING: more than 1 cladecol defined for population ",pop1,".",sep=""),sep="\n")}
			mydf$cladecol2[i]	<- unique(inds$cladecol[as.character(inds$pop)==pop2])[1]
			if(length(unique(inds$cladecol[as.character(inds$pop)==pop2]))>1){cat(paste("WARNING: more than 1 clade defined for population ",pop2,".",sep=""),sep="\n")}
			mydf$popcol1[i]		<- unique(inds$popcol[as.character(inds$pop)==pop1])[1]
			if(length(unique(inds$popcol[as.character(inds$pop)==pop1]))>1){cat(paste("WARNING: more than 1 popcol defined for population ",pop1,".",sep=""),sep="\n")}
			mydf$popcol2[i]		<- unique(inds$popcol[as.character(inds$pop)==pop2])[1]
			if(length(unique(inds$popcol[as.character(inds$pop)==pop2]))>1){cat(paste("WARNING: more than 1 popcol defined for population ",pop2,".",sep=""),sep="\n")}
			}
		}
	mydf$geodist		<- sqrt(mydf$long^2+mydf$lat^2) 
	if(dofst)
		{
		mydf$popdist	<- mydf$popdist/(1-mydf$popdist)
		}
	mydf$cladepair		<- ifelse(mydf$clade1<mydf$clade2,paste(mydf$clade1,mydf$clade2,sep="_"),paste(mydf$clade2,mydf$clade1,sep="_"))
	if(onlybetween)
		{
		mydf			<- mydf[mydf$clade1!=mydf$clade2,]
		}
	if(onlywithin)
		{
		mydf			<- mydf[mydf$clade1==mydf$clade2,]
		}
	#mydf				<- mydf[mydf$cladepair=="Eastern_NewWorld",]
	#mydf				<- mydf[mydf$cladepair=="Eastern_Western"|mydf$cladepair=="Eastern_Eastern"|mydf$cladepair=="Western_Western"|mydf$cladepair=="Central_Western"|mydf$cladepair=="Central_Eastern",]
	mydf				<- mydf[mydf$cladepair=="NewWorld_NewWorld"|mydf$cladepair=="Eastern_Western"|mydf$cladepair=="Alaska_Eastern"|mydf$cladepair=="Alaska_Western"|mydf$cladepair=="Eastern_Eastern"|mydf$cladepair=="Western_Western",]
	popdistdf			<<- mydf
	}

plotmantel<-function(mydf=popdistdf,export=NULL,usecladecol=FALSE,myxlim=NULL,legendpos="bottomright",plotname="Fst_vs_dist",xlabel="Distance (degrees)",ylabel="Fst/(1-Fst)",legendcex=2)
	{
	if(!is.null(export))
		{
		plotname	<- ifelse(usecladecol,paste(plotname,"cladecol",sep="_"),paste(plotname,"popcol",sep=""))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(7,6.5,2.5,0.25),cex.axis=2,cex.lab=2.5,cex.main=3)	
	if(!usecladecol)
		{
		if(is.null(myxlim))
			{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=3,lwd=4,xlab="",ylab="",las=2)
			}else{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=as.character(mydf$popcol1),col=as.character(mydf$popcol2),cex=3,lwd=4,xlab="",ylab="",las=2,xlim=myxlim)
			}
		#legend(legendpos,legend=mysambar$populations,bty='n',fill=mysambar$mycolours,cex=1.5)
		legend(legendpos,legend=unique(c(as.character(mydf$pop1),as.character(mydf$pop2))),bty='n',fill=unique(c(as.character(mydf$popcol1),as.character(mydf$popcol2))),cex=2)
		}else{
		mybg		<- ifelse(mydf$clade1<mydf$clade2,mydf$cladecol1,mydf$cladecol2)
		mycol		<- ifelse(mydf$clade1<mydf$clade2,mydf$cladecol2,mydf$cladecol1)
		if(is.null(myxlim))
			{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=mybg,col=mycol,cex=3,lwd=4,xlab="",ylab="",las=2)
			}else{
			plot(mydf$geodist,mydf$popdist,pch=21,bg=mybg,col=mycol,cex=3,lwd=4,xlab="",ylab="",las=2,xlim=myxlim)
			}
		#legend(legendpos,legend=c("Syrian","Himalaya","Eurasia-west","Eurasia-east","Amur","Alaska","Westcoast"),bty='n',fill=c("indianred1","orangered1","darkred","midnightblue","mediumpurple1","darkgreen","greenyellow"),cex=2)
		legend(legendpos,legend=unique(as.character(mydf$clade1)),bty='n',fill=unique(as.character(mydf$cladecol1)),cex=2)
		}
	mtext(side=1,line=4.5,xlabel,cex=2.75)
	mtext(side=2,line=4.5,ylabel,cex=2.75)
	#
	# regression:
	mydata		<- mydf[,c("geodist","popdist")] 
	myfit		<<- lm(popdist ~ geodist,data=mydata)
	abline(myfit,lty=2,lwd=2)
	myfit2		<<- summary(myfit)
	myr			<<- round(myfit2$r.squared,2)
	myp			<<- round(myfit2$coefficients[2,4],4)
	legend("topleft",legend=c(paste("r = ",myr,sep=""),paste("p = ",myp,sep="")),cex=legendcex,bty='n',col=NA,lty=2)
	#
	if(!is.null(export))
		{
		dev.off()
		cat("Scatterplot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

nrmismatch<-function(nrsites=NULL,haploid=FALSE,addclade=FALSE)
	{
	ninds		<- nrow(inds)
	myinds		<- as.character(inds$name)
	mypops		<- as.character(inds$pop)
	mynr		<- as.character(inds$nr)
	mybool		<- inds$filter
	mycol		<- inds$popcol
	mydf		<- data.frame("ind1"=rep(myinds,each=ninds),"ind2"=rep(myinds,times=ninds),"nr1"=rep(mynr,each=ninds),"nr2"=rep(mynr,times=ninds),"pop1"=rep(mypops,each=ninds),"pop2"=rep(mypops,times=ninds),"bool1"=rep(mybool,each=ninds),"bool2"=rep(mybool,times=ninds),"popcol1"=rep(mycol,each=ninds),"popcol2"=rep(mycol,times=ninds))
	mydf$nsites	<- NA
	mydf$ndiff	<- NA
	mydf$long	<- NA
	mydf$lat	<- NA
	if(addclade)
		{
		mydf$clade1		<- NA
		mydf$clade2		<- NA
		mydf$cladecol1	<- NA
		mydf$cladecol2	<- NA
		}
	#
	npairs	<- nrow(mydf)
	for(i in c(1:npairs))
		{
		ind1			<- as.integer(as.character(mydf$nr1[i]))
		ind2			<- as.integer(as.character(mydf$nr2[i]))
		geno1			<- as.matrix(mygenlight[ind1,])
		geno2			<- as.matrix(mygenlight[ind2,])
		long1			<- inds$longitude3[ind1]
		long2			<- inds$longitude3[ind2]
		lat1			<- inds$latitude[ind1]
		lat2			<- inds$latitude[ind2]
		if(addclade)
			{
			mydf$clade1[i]		<- as.character(inds$clade[ind1])
			mydf$clade2[i]		<- as.character(inds$clade[ind2])
			mydf$cladecol1[i]	<- as.character(inds$cladecol[ind1])
			mydf$cladecol2[i]	<- as.character(inds$cladecol[ind2])
			}
		mybool			<- !is.na(geno1)&!is.na(geno2)
		geno1			<- geno1[mybool]
		geno2			<- geno2[mybool]
		mydf$nsites[i]	<- length(mybool[mybool])
		if(haploid)
			{
			mydf$ndiff[i]	<- length(geno1[geno1!=geno2])
			}else{
			# To avoid that NA is included when stating geno==1, we change NA to 3:
			geno1[is.na(geno1)]	<- 3
			geno2[is.na(geno2)]	<- 3
			## we have 4 combinations of haplotypes between individuals: 
			## If both individuals are homozygous, but for different allele:
			mybool		<- (geno1==0&geno2==2)|(geno1==2&geno2==0)
			ndiff1		<- 4*length(mybool[mybool])
			# If one individual is homozygous and the other heterozygous:
			mybool		<- (geno1==0&geno2==1)|(geno1==2&geno2==1)|(geno1==1&geno2==0)|(geno1==1&geno2==2)
			ndiff2		<- 2*length(mybool[mybool])		
			# If both individuals are heterozygous: 
			mybool		<- geno1==1&geno2==1
			ndiff3		<- 2*length(mybool[mybool])
			## combine:
			mydf$ndiff[i]<- ndiff1+ndiff2+ndiff3
			}
		mydf$long[i]	<- abs(long2-long1)
		mydf$lat[i]		<- abs(lat2-lat1)
		}
	mydf$dxy			<- mydf$ndiff/mydf$nsites
	mydf$geodist		<- sqrt(mydf$long^2+mydf$lat^2) 
	if(!is.null(nrsites))
		{
		mydf$dxy2	<- mydf$ndiff/nrsites*100
		}else{
		mydf$dxy2	<- mydf$dxy*100 
		}
	mydf$dxy3		<- mydf$nsites/max(mydf$nsites,na.rm=TRUE)*mydf$dxy2		# correct for differences in levels of missing data
	mysambar$dxy	<<- mydf
	}

# 15-03-19: new version to calculate pi: 
calcpi<-function(pi_per_pop=FALSE,myinput=mygenlight,indselection=inds$filter,snpselection=snps$filter,popnames=mysambar$populations,samplesize=NULL,mychrom=NULL,myrange=NULL,corrected=FALSE,silent=TRUE)
	{
	# This function calculates pi: the average sequence dissimilarity when randomly drawing 2 sequences from a population.
	# Comparison between Hamming, allele sharing distance (ASD) and pi:
	# 		ind1	ind2	ind1	ind2	Hamming	ASD		pi	
	# snp1	AA		AA		0		0		0		0		0	
	# snp2	AA		Aa		0		1		1		1		0.25
	# snp3	AA		aa		0		2		1		2		1
	# snp4	Aa		Aa		1		1		0		0		0.5	
	# snp5	Aa		aa		1		2		1		1		0.25
	# snp6	aa		aa		2		2		0		0		0
	#
	## pi is calculated as follows:
	# Consider the following genlight object of 3 individuals and 2 snps:
	#		snp1	snp2
	# ind1	0 		1
	# ind2	2 		NA
	# ind3	1 		0
	# First NA is converted into 3, to avoid counting NA as 1.
	#
	# Second we calculate the number of differences between and within individuals, and take into account that each pairwise (diploid) individual comparison entails 4 haplotype comparisons (AB,Ab,aB,ab)
	# comparison	snp1	snp2	snp1	snp2	total			meanpairwise
	# ind1-ind2: 	0/2		1/NA	4 + 	NA = 	4		/4 =	1	
	# ind1-ind3: 	0/1		1/0		2 + 	2 = 	4		/4 =	1
	# ind2-ind3: 	2/1		NA/0	2 + 	NA = 	2		/4 =	0.5
	# ind1: 		0		1		0 + 	1 = 	1				1
	# ind2: 		2		NA		0 + 	NA = 	0				0
	# ind3: 		1		0		1 + 	0 = 	1				1
	# total:										12				4.5
	# average:														0.75		
	# So we find that on average 0.75 sites differ between two haplotypes. This is the observed pi. 
	#
	# Third we calculate the number of missing data:
	# comparison	snp1	snp2	total			meanpairwise	meannonmissing
	# ind1-ind2: 	0 + 	4 = 	4		/4 =	1				1
	# ind1-ind3: 	0 + 	0 = 	0		/4 =	0				2
	# ind2-ind3: 	0 + 	4 = 	4		/4 =	1				1
	# ind1: 		0 + 	0 = 	0				0				2
	# ind2: 		0 + 	1 = 	1				1				1
	# ind3: 		0 + 	0 = 	0				0				2
	# total:						9				3				9
	# average:										0.5				1.5		
	# So we find that on average we have data for 1.5 sites per haplotype, rather than for 2 sites.
	# The corrected pi therefore equals: 0.75/2*1.5 = 0.5625 differences per haplotype (of 2 bp length). 
	# The default is to use the corrected pi. Set corrected to FALSE, to use uncorrected pi. 
	#
	# 18-03-2019: I don't understand why the following reasoning doesn't give the same outcomes as above for uncorrected and corrected pi:
	# Total number of differences: 				12
	# Total snp comparisons: 					4*(choose(nind,2))+nind)*nsnp 	= 	15*2 = 30
	# Total number of missing datapoints: 		9
	# Total number of non-missing datapoints:	30-9 = 21
	# Uncorrected pi:							12/30 = 0.4
	# Corrected pi: 							12/21 = 0.5714
	# Just to avoid confusion: this is just a consideration. Not used for actual calculations. 
	#
	# 15-5-2020: Looking again at this, I realize that 0.5714 is the right value, not 0.5625.
	# We have the following differences for within individual comparisons:.
	# SNP1: 0 0 1 
	# SNP2: 1 N 0
	# and for between individual comparisons:
	# SNP1: 1 1 1 1 0 0 1 1 0 0 1 1 
	# SNP2: N N N N 0 0 1 1 N N N N
	# This is 12/21 = 0.5714
	# The reason that the calculation leads to 0.5622 is because it is not correct to give a single 'within-comparison' the same weight as 4 'between-comparisons' 
	## 04-08-2021: NOTE THAT WHEN FLAG CORRECTED IS SET TO TRUE, THE CALCULATION AND THE OUTPUT VALUES ARE SLIGHTLY DIFFERENT; IT ATTEMPTS TO CORRECT FOR MISSING DATA
	#
	## Watterson's estimate of theta is calculated as follows (corrected for missing data):
	# The per snp average number of inds with data:	(3 + 2)/2 = 2.5
	# The average number of haplotypes: 			nind*2 = 2.5*2 = 5 			# 6 haplotypes for first SNP, 4 haplotypes for second SNP
	# n-1: 											5-1 = 4  
	# Number of snps with maf>0 (S):				2 
	# Corrected Watterson's estimate of theta:		S/(sum(1/(1/1+...+1/(n-1))) = 2/(1/1+1/2+1/3+1/4) = 2/2.083 = 0.96
	# This number is telling us that for each pairwise comparison of haplotypes (of 2 bp length) we expect 0.96 sites to differ between both haplotypes.  
	# Uncorrected Watterson's estimate of theta:	2/(1/1+1/2+1/3+1/4+1/5) = 2/2.28 = 0.87  
	#
	## Tajima's D is calculated as follows:
	# Observed uncorrected pi minus corrected Watterson's estimate:
	# Tajima's D: 0.75 - 0.96 = -0.21 
	#
	# I first tried to calculate sliding window with snpR, using the following steps, but that resulted in an ERROR: 
	# options(repos=c(CRAN='http://cran.us.r-project.org'))
	# install_github("hemstrow/snpR")
	# library(snpR)
	# mymatrix		<- as.matrix(mygenlight[inds$filter,snps$filter2])
	# mymatrix		<- cbind(inds$nr[inds$filter],inds$pop[inds$filter],mymatrix)
	# newmat		<- format_snps(mymatrix, ecs=2, output = 1, input_form = "0_geno") 
	# but then I got an ERROR it couldn't find 'm'
	#
	# define which snps to be included in analysis:
	if(is.null(mychrom)&!is.null(myrange))	{return(cat("ERROR: not allowed to define a range (myrange flag) without defining chromosome/contig (mychrom flag)",sep="\n"))}
	if(!is.null(mychrom)&!is.null(myrange))	{snpselection	<- snpselection&snps$chr==mychrom&snps$pos>=myrange[1]&snps$pos<=myrange[2]}
	if(!is.null(mychrom)&is.null(myrange))	{snpselection	<- snpselection&snps$chr==mychrom}
	if(!is.null(mychrom)&!is.null(myrange))
		{
		# cat(paste("chrom =",mychrom,sep=" "),sep="\n")
		# cat(paste("range =",myrange,sep=" "),sep="\n")
		nsnps	<- nrow(snps[snps$chr==mychrom&snps$pos>myrange[1]&snps$pos<myrange[2]&snps$filter,])
		if(nsnps<1){return(cat("No snps in specified range.",sep="\n"))}
		}
	# Prepare output table:
	if(pi_per_pop)
		{
		popnames		<- popnames
		}else{
		popnames		<- "metapop"
		}
	npops				<- length(popnames)
	ninds				<- nrow(inds[inds$filter,])
	popdf				<- as.data.frame(matrix(NA,ncol=14,nrow=npops))		# 22-03-2022: previously called outmat
	colnames(popdf)		<- c("pop","chrom","start","end","mid","mean_nsites","mean_pi","mean_maf","expected_pi","S","harmonic_number","Watterson","TajimaD","sd_pi")
	popdf$pop			<- popnames
	pidf_list			<- list()
	if(!is.null(mychrom)&!is.null(myrange))
		{
		popdf$chrom		<- mychrom
		popdf$start		<- myrange[1]
		popdf$end		<- myrange[2]
		popdf$mid		<- round(mean(myrange))
		}
	if(!is.null(mychrom)&is.null(myrange))	{popdf$chrom<- mychrom}
	#
	cat("Calculating sequencing divergence for all sample pairs...",sep="\n")
	if(!any(snpselection))
		{
		popdf$mean_nsites	<- 0
		}else{
		##### GENERATE INPUT DATA #####
		mymatrix			<- as.matrix(myinput[,snpselection]) 
		for (p in c(1:npops))
			{
			mypop			<- popnames[p]
			#mypopcol		<- mysambar$mycolours[p]
			# cat(mypop,sep="\n")
			if(!pi_per_pop)
				{
				myinds		<- inds$nr[indselection]
				mymaf		<- snps$maf[snpselection]
				}else{
				myinds		<- inds$nr[inds$pop==mypop&indselection]
				mymaf		<- snps[snpselection,paste("maf",mypop,sep="_")]
				}
			if(!is.null(samplesize))
				{
				myinds		<- sample(myinds,samplesize,replace=FALSE)
				}
			## compare haplotypes between individuals (4 possible combinations per pair):
			if(length(myinds)<2)
				{
				cat("Only one retained individual for population:",sep="\n")
				cat(mypop,sep="\n")
				return(cat("Exiting.",sep="\n"))
				}
			indpairtable	<- combn(myinds,m=2)	
			ndiffvec		<- vector()
			asd1vec			<- vector()
			asd2vec			<- vector()
			ndatavec		<- vector()
			nnavec			<- vector()
			for (i in c(1:ncol(indpairtable)))
				{
				if(i%%10000==0)
					{
					cat(paste(i," out of ",ncol(indpairtable)," comparisons in total.",sep=""),sep="\n") 
					}
				ind1		<- indpairtable[1,i]
				ind2		<- indpairtable[2,i]
				geno1		<- mymatrix[inds$nr==ind1,]		#24-05-2023: corrected: geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[inds$nr==ind2,]		#24-05-2023: corrected: geno2		<- mymatrix[ind2,]
				# To avoid that NA is included when stating geno==1, we change NA to 3:
				geno1[is.na(geno1)]	<- 3
				geno2[is.na(geno2)]	<- 3
				## we have 4 combinations of haplotypes between individuals: 
				## If both individuals are homozygous, but for different allele:
				mybool		<- (geno1==0&geno2==2)|(geno1==2&geno2==0)
				ndiff1		<- 4*length(mybool[mybool])
				asd2vec[i]	<- length(mybool[mybool])	
				# If one individual is homozygous and the other heterozygous:
				mybool		<- (geno1==0&geno2==1)|(geno1==2&geno2==1)|(geno1==1&geno2==0)|(geno1==1&geno2==2)
				ndiff2		<- 2*length(mybool[mybool])
				asd1vec[i]	<- length(mybool[mybool])
				# If both individuals are heterozygous: 
				mybool		<- geno1==1&geno2==1
				ndiff3		<- 2*length(mybool[mybool])
				## sequence dissimilarity:
				ndiffvec[i]	<- ndiff1+ndiff2+ndiff3
				## datapoints:
				mybool		<- (geno1!=3)&(geno2!=3)
				ndata		<- length(mybool[mybool])
				ndatavec[i]	<- ndata
				mybool		<- (geno1==3)|(geno2==3)
				nna			<- 4*length(mybool[mybool])
				nnavec[i]	<- nna
				}
			## compare haplotypes within individuals (1 possible combination per individual:
			nhevec			<- vector() 
			ninddatavec		<- vector()
			nindnavec		<- vector()
			for (i in c(1:length(myinds)))
				{
				myind				<- myinds[i]
				mygeno				<- mymatrix[myind,]
				# To avoid that NA is included when stating mygeno==1, we change NA to 3:
				mygeno[is.na(mygeno)]<- 3				
				nhevec[i]			<- length(mygeno[mygeno==1]) 
				ninddatavec[i]		<- length(mygeno[mygeno!=3]) 
				nindnavec[i]		<- length(mygeno[mygeno==3]) 				
				}
			## store info in dataframe pidf (previously called 'mycomp'):
			pidf_between			<- data.frame("ind1"=indpairtable[1,],"ind2"=indpairtable[2,],"npairwise"=4,"nsites"=ndatavec,"nnasites"=nnavec/4,"ncomp"=ndatavec*4,"nnacomp"=nnavec,"ndiff"=ndiffvec,"asd1"=asd1vec,"asd2"=asd2vec)
			pidf_within				<- data.frame("ind1"=myinds,"ind2"=myinds,"npairwise"=1,"nsites"=ninddatavec,"nnasites"=nindnavec,"ncomp"=ninddatavec,"nnacomp"=nindnavec,"ndiff"=nhevec,"asd1"=0,"asd2"=0)
			pidf					<- as.data.frame(rbind(pidf_within,pidf_between)) 
			pidf$name1				<- NA
			pidf$name2				<- NA
			pidf$pop1				<- NA
			pidf$pop2				<- NA
			pidf$popcol1			<- NA
			pidf$popcol2			<- NA
			for(i in c(1:nrow(pidf)))
				{
				ind1nr				<- pidf$ind1[i]
				pidf$name1[i]		<- inds$name[inds$nr==ind1nr]			## 23-05-2023: removed error: inds$name[ind1nr]
				pidf$pop1[i]		<- inds$pop[inds$nr==ind1nr]			## 23-05-2023: removed error: inds$name[ind1nr]
				pidf$popcol1[i]		<- inds$popcol[inds$nr==ind1nr]			## 23-05-2023: removed error: inds$name[ind1nr]
				ind2nr				<- pidf$ind2[i]
				pidf$name2[i]		<- inds$name[inds$nr==ind2nr]			## 23-05-2023: removed error: inds$name[ind2nr]
				pidf$pop2[i]		<- inds$pop[inds$nr==ind2nr]			## 23-05-2023: removed error: inds$name[ind2nr]
				pidf$popcol2[i]		<- inds$popcol[inds$nr==ind2nr]			## 23-05-2023: removed error: inds$name[ind2nr]
				}	
			pidf$ndiffperhaplo		<- round(pidf$ndiff/pidf$npairwise,3)
			pidf$ndiffpersite		<- pidf$ndiffperhaplo/pidf$nsites
			pidf$ndiffpersite[!is.finite(pidf$ndiffpersite)]	<- NA	
			pidf$totalsites			<- pidf$nsites+pidf$nnasites
			pidf$ASD				<- (pidf$asd1+2*pidf$asd2)/pidf$nsites 		# 28-03-2022: calculation of measure 'allele sharing distance', after Gao & Starmer, 2007, Human population structure detection via multilocus genotype clustering
			pidf$ASD[!is.finite(pidf$ASD)]	<- NA
			pidf$pop1				<- mypop
			pidf$pop2				<- mypop
			#pidf$colour			<- mypopcol
			pidf_list[[p]]			<- pidf
			#
			# how many individuals (and therefore haplotypes) per snp on average? (Only individuals with non-missing data)
			popmatrix				<- mymatrix[myinds,]
			if(is.null(ncol(popmatrix)))
				{
				# counting NA is fine (counting 1's cause problems, because NA's are regarded as 1, but the other way around does not cause problems)
				nind				<- length(popmatrix[is.na(popmatrix)])
				}else{
				nind				<- mean(apply(popmatrix,2,function(x){sum(!is.na(x))}),na.rm=TRUE)
				}
			nhaplotypes				<- 2*nind
			# Number of (segregating) sites:
			nseg					<- length(mymaf[mymaf>0])
			nsitesall				<- length(mymaf)
			#
			##### CALCULATE PI, WATTERSON THETA AND TAJIMA'S D ##### 
			# Now we have all the information to calculate observed pi, watterson's theta, and thus also Tajima's D:
			popdf$mean_nsites[p]	<- round(mean(pidf$nsites,na.rm=TRUE),1)								# nsites with data
			uncorrected_pi			<- round(mean(pidf$ndiffperhaplo,na.rm=TRUE),2)
			corrected_pi			<- round(sum(pidf$ndiff,na.rm=TRUE)/sum(pidf$ncomp,na.rm=TRUE),4)	
			popdf$mean_pi[p]		<- ifelse(corrected,corrected_pi,uncorrected_pi)						# pi (mean number of differences between 2 sequences)	
			popdf$S[p]				<- nseg																	# segregating sites	
			popdf$mean_maf[p]		<- round(mean(mymaf[mymaf>0],na.rm=TRUE),2)								# mean maf of segregating sites
			popdf$expected_pi[p]	<- round((2*popdf$mean_maf[p]*(1-popdf$mean_maf[p])*popdf$S[p]),1)		# expected nucleotide diversity (pi) based on minor allele frequency
			popdf$harmonic_number[p]<- round(sum(1/(1:(nhaplotypes-1))),2)									# harmonic number
			popdf$Watterson[p]		<- round(popdf$S[p]/popdf$harmonic_number[p],2)							# watterson's theta
			popdf$TajimaD[p]		<- ifelse(corrected,NA,round(popdf$mean_pi[p]-popdf$Watterson[p],2))	# Tajima's D
			uncorrected_pisd		<- round(sd(pidf$ndiffperhaplo,na.rm=TRUE),4)
			popdf$sd_pi[p]			<- uncorrected_pisd														# not possible to calculate corrected (scaled) value?
			}
		}
	##### ADD POPULATION NAMES AND COLOURS TO PIDF #####
	if(!pi_per_pop)
		{
		pop_names				<- mysambar$populations2
		n_pops					<- length(pop_names)
		mycols					<- mysambar$mycolours2
		pidf					<- pidf_list[[1]]
		pidf$pop1 				<- NA
		pidf$pop2 				<- NA
		pidf$colour				<- NA
		for (i in c(1:nrow(pidf)))
			{
			#myindnr1			<- pidf$ind1[i]
			#myindnr2			<- pidf$ind2[i]
			myindname1			<- pidf$name1[i]
			myindname2			<- pidf$name2[i]
			#pop1				<- as.vector(inds$pop)[inds$nr==myindnr1]
			#pop2				<- as.vector(inds$pop)[inds$nr==myindnr2]
			pop1				<- as.vector(inds$pop)[inds$name==myindname1]
			pop2				<- as.vector(inds$pop)[inds$name==myindname2]
			pidf$pop1[i]		<- pop1
			pidf$pop2[i]		<- pop2
			if(pop1==pop2)
				{
				mycol1			<- mycols[which(pop_names==pop1)]
				mycol2			<- mycols[which(pop_names==pop2)]
				mycolfunc3 		<- colorRampPalette(c(mycol1,mycol2))
				pidf$colour[i]	<- mycolfunc3(3)[2]
				}else{
				mycol1			<- mycols[which(pop_names==pop1)]	
				}
			}
		pidf_list[[1]]			<- pidf 
		}
	#
	##### ADD EXTRA INFO TO POPDF #####
	if(corrected)
		{
		# edited on 16-5-2020: with new method the estimate is already scaled
		popdf$pi_scaled			<- popdf$mean_pi
		popdf$pi_scaled_sd		<- round(popdf$sd_pi/popdf$mean_nsites,4)
		popdf$mean_pi			<- round(popdf$pi_scaled*popdf$mean_nsites,2)
		}else{
		popdf$pi_scaled			<- round(popdf$mean_pi/popdf$mean_nsites,4)
		popdf$pi_scaled_sd		<- round(popdf$sd_pi/popdf$mean_nsites,4)
		}
	popdf$Watterson_scaled		<- round(popdf$Watterson/popdf$mean_nsites,4)
	if(corrected)
		{
		popdf$TajimaD_scaled	<- round(popdf$pi_scaled-popdf$Watterson_scaled,4)
		popdf$TajimaD			<- round(popdf$TajimaD_scaled*popdf$mean_nsites,2)
		}else{
		popdf$TajimaD_scaled	<- round(popdf$TajimaD/popdf$mean_nsites,4)
		}
	popdf$X2					<- round(((popdf$mean_pi-popdf$Watterson)^2)/popdf$Watterson,2)
	popdf$pvalue				<- round(pchisq(popdf$X2,df=1,lower.tail=FALSE),6)
	popdf$sign					<- ifelse(popdf$pvalue>0.05,"NS",ifelse(popdf$pvalue<0.01,"**","*"))
	popdf$rare_alleles			<- ifelse(popdf$TajimaD< -2,"many_rare",ifelse(popdf$TajimaD>2,"lack_of_rare","neutral"))
	popdf$demography			<- ifelse(popdf$TajimaD< -2,"expansion_after_bottleneck",ifelse(popdf$TajimaD>2,"contraction","neutral"))
	popdf$selection				<- ifelse(popdf$TajimaD< -2,"selective_sweep",ifelse(popdf$TajimaD>2,"balancing","neutral"))	
	#
	##### WRITE OUT DATA #####
	if(!is.null(mychrom)&!is.null(myrange))	{popdf2			<- popdf}
	if(!is.null(mychrom)&is.null(myrange))	{popdf2			<- popdf[,-c(3:5)]}	
	if(is.null(mychrom)&is.null(myrange))	{popdf2			<- popdf[,-c(2:5)]}
	if(pi_per_pop)
		{
		write.table(popdf2,paste(mysambar$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),col.names=TRUE,quote=FALSE,row.names=FALSE,sep="\t")
		cat("Table with summary statistics ('TajimaD.statistics.perpop.txt') has been exported to the Diversity subdirectory.",sep="\n") 
		}else{
		write.table(popdf2,paste(mysambar$diversitydir,"TajimaD.statistics.metapop.txt",sep="/"),col.names=TRUE,quote=FALSE,row.names=FALSE,sep="\t")
		cat("Table with summary statistics ('TajimaD.statistics.metapop.txt') has been exported to the Diversity subdirectory.",sep="\n")
		}
	mysambar$tajd				<<- popdf2
	if(!silent){cat("Table with population scores has been written to a dataframe called mysambar$tajd.",sep="\n")}
	#
	names(pidf_list)			<- popnames
	if(pi_per_pop)
		{
		mysambar$pidf_poplist	<<- pidf_list		# 22-03-2022: previously called 'mysambar$tajdlist_pop'
		if(!silent){cat("Table with individu-pair scores has been written to a list called mysambar$pidf_poplist.",sep="\n")}
		}else{
		mysambar$pidf_metalist	<<- pidf_list		# 22-03-2022: previously called 'mysambar$tajdlist_meta'
		if(!silent){cat("Table with individu-pair scores has been written to a list called mysambar$pidf_metalist.",sep="\n")}
		}
	#
	##### ADD INFO TO INDS DATAFRAME #####
	if(pi_per_pop)
		{
		myinds							<- inds$nr[inds$filter]
		nsnps							<- nrow(snps)
		ninds							<- nrow(inds[inds$filter,])
		inds$hetero_all2				<<- NA
		# add data heterozygosity to inds dataframe:
		for(i in c(1:ninds))
			{
			myind						<- myinds[i]
			mypop						<- inds$pop[inds$nr==myind]	
			pidf2						<- mysambar$pidf_poplist[[which(names(mysambar$pidf_poplist)==mypop)]]
			inds$hetero_all2[inds$nr==myind]<<- pidf2$ndiffpersite[pidf2$ind1==myind&pidf2$ind2==myind]
			}
		# add data pi to inds dataframe:
		inds$pi							<<- NA 
		for(i in c(1:ninds))
			{
			myind						<- myinds[i]
			mypop						<- inds$pop[inds$nr==myind]	
			npoly						<- inds$nsegsites1[inds$nr==myind]
			pidf2						<- mysambar$pidf_poplist[[which(names(mysambar$pidf_poplist)==mypop)]]
			inds$pi[inds$nr==myind]		<<- mean(pidf2$ndiffpersite[(pidf2$ind1==myind|pidf2$ind2==myind)&!(pidf2$ind1==myind&pidf2$ind2==myind)],na.rm=TRUE)
			}
		# add autozygosity to inds dataframe:
		inds$autozygosity				<<- 1-inds$hetero_all/inds$pi 
		# add TajimaD scores:
		inds$pi2						<- NA
		inds$pi2sd						<- NA
		inds$harmonic_number			<- NA
		inds$Watterson					<- NA
		inds$TajimaD					<- NA
		inds$pi2_scaled					<- NA
		inds$pi2_scaled_sd				<- NA
		inds$Watterson_scaled			<- NA
		inds$TajimaD					<- NA
		inds$rare_alleles				<- NA
		for (mypop in popnames)
			{
			myselection							<- inds$filter&inds$pop==mypop
			inds$pi2[myselection]				<- popdf2$mean_pi[popdf2$pop==mypop]
			inds$pi2sd[myselection]				<- popdf2$sd_pi[popdf2$pop==mypop]
			inds$harmonic_number[myselection]	<- popdf2$harmonic_number[popdf2$pop==mypop]
			inds$Watterson[myselection]			<- popdf2$Watterson[popdf2$pop==mypop]
			inds$TajimaD[myselection]			<- popdf2$TajimaD[popdf2$pop==mypop]
			inds$pi2_scaled[myselection]		<- popdf2$pi_scaled[popdf2$pop==mypop]
			inds$pi2_scaled_sd[myselection]		<- popdf2$pi_scaled_sd[popdf2$pop==mypop]
			inds$Watterson_scaled[myselection]	<- popdf2$Watterson_scaled[popdf2$pop==mypop]
			inds$TajimaD_scaled[myselection]	<- popdf2$TajimaD_scaled[popdf2$pop==mypop]
			inds$rare_alleles[myselection]		<- popdf2$rare_alleles[popdf2$pop==mypop]
			}
		}
	# remove duplicate columns:		
	inds 	<<- inds[, !duplicated(colnames(inds),fromlast=TRUE)]
	#
	## ADD INFO TO INDS2 DATAFRAME:
	if(!pi_per_pop)
		{
		cat("Adding columns to inds2 dataframe...",sep="\n")
		pidf			<- mysambar$pidf_metalist[[1]]
		pidf$indpair	<- paste(pidf$name1,pidf$name2,sep="_")
		#pidf$indpair	<- ifelse(pidf$name1<pidf$name2,paste(pidf$name1,pidf$name2,sep="_"),paste(pidf$name2,pidf$name1,sep="_"))
		if(!all(pidf$indpair%in%inds2$indpair))
			{
			return(cat("ERROR: pair names do not correspond. Information cannot be added to inds2 dataframe.",sep="\n"))
			}
		if("ndiffpersite"%in%colnames(inds2))
			{
			inds2$ndiffpersite	<<- NULL
			}
		if("ASD"%in%colnames(inds2))
			{
			inds2$ASD			<<- NULL
			}
		tempdf	<- pidf[,c("indpair","ndiffpersite","ASD")]
		combdf	<- merge(inds2,tempdf,by="indpair",all=TRUE)
		if(nrow(combdf)!=nrow(inds2))
			{
			combdf		<<- combdf
			return(cat("ERROR: data cannot be merged.",sep="\n"))
			}
		inds2	<<- combdf
		inds2pops()
		}
	}	

# End of calculations per sample pair
###############################################################################################################













###############################################################################################################
# Kinship/relatedness calculations

calckinship<-function(silent=TRUE,calcF=TRUE,plot_inbreeding=TRUE,F_correct_maf=TRUE,overwrite_kindf=TRUE,kin_thres=0.5,do_wahlund=TRUE,king_threshold=0.5,findroh=FALSE,matrix_perpop=FALSE,legend_cex=2)
	{
	setwd(mysambar$sambardir)
	kinshipdir			<- paste(mysambar$sambardir,"Kinship",sep="/")
	mysambar$kinshipdir	<<- kinshipdir
	if(!dir.exists("Kinship"))
		{
		if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
		dir.create(file.path(kinshipdir))
		setwd(kinshipdir)
		}else{
		setwd(kinshipdir)
		cat("Overwriting results in directory:",sep="\n")
		cat(getwd(),sep="\n")	
		}
	if(!overwrite_kindf&is.null(mysambar$kindf))
		{
		if(!file.exists("pairwise_relatedness.txt"))
			{
			cat("WARNING: the flag 'overwrite_kindf' is set to FALSE but mysambar$kindf does not exist, and Kinship directory does not contain the file 'pairwise_relatedness.txt' either. Setting the flag to TRUE.",sep="\n")
			overwrite_kindf	<- TRUE
			}
		}
	if(calcF)
		{
		if(!silent){cat("calc_indF(correctmaf=FALSE)",sep="\n")}
		calc_indF(correctmaf=FALSE)
		if(plot_inbreeding)
			{
			cat("Plotting individual inbreeding statistics. If you receive an error after this line, rerun the calckinship function with the flag plot_inbreeding set to FALSE.",sep="\n")
			if(!silent){cat("plot_indF",sep="\n")}
			plot_indF(export="eps",plotname="Inbreeding")	
			plot_indF(export="pdf",plotname="Inbreeding")
			plot_indF(export="png",plotname="Inbreeding")
			if(!silent){cat("plotscatter_indF",sep="\n")}
			plotscatter_indF(dolabels=TRUE,export="eps",legendcex=legend_cex)
			plotscatter_indF(dolabels=TRUE,export="png",legendcex=legend_cex)
			plotscatter_indF(dolabels=TRUE,export="pdf",legendcex=legend_cex)
			if(mysambar$os=="Windows"){plotscatter_indF(dolabels=TRUE,export="wmf",legendcex=legend_cex)}
			if(!silent){cat("barplotF_perind",sep="\n")}
			barplotF_perind(export="eps")
			barplotF_perind(export="pdf")
			barplotF_perind(export="png")
			if(mysambar$os=="Windows"){barplotF_perind(export="wmf")}
			FvsHe(export="eps",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)
			FvsHe(export="pdf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)
			FvsHe(export="png",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)}
			FvsHe(export="eps",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)
			FvsHe(export="pdf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)
			FvsHe(export="png",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=FALSE,legendcex=legend_cex)}
			popboxplot(myscore=inds$F[inds$filter],popvector=inds$poporder[inds$filter],ylabel="Inbreeding coefficient",export="pdf",exportname="Inbreeding_coefficient_boxplot")
			}
		if(!silent){cat("calc_indF(correctmaf=TRUE)",sep="\n")}
		if(F_correct_maf)
			{
			cat("Calculating individual inbreeding statistics using corrected minor allele frequencies (excluding individual under investigation). If you receive an error after this line, rerun the filterdata function with the flag F_correct_maf set to FALSE.",sep="\n")
			calc_indF(correctmaf=TRUE)
			if(!silent){cat("plot_indF(plotname='Inbreeding_corrected')",sep="\n")}
			plot_indF(export="eps",plotname="Inbreeding_corrected",Fcorrect=TRUE)	
			plot_indF(export="pdf",plotname="Inbreeding_corrected",Fcorrect=TRUE)
			plot_indF(export="png",plotname="Inbreeding_corrected",Fcorrect=TRUE)
			if(mysambar$os=="Windows"){plot_indF(export="png",plotname="Inbreeding_corrected",Fcorrect=TRUE)}
			FvsHe(export="eps",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)
			FvsHe(export="pdf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)
			FvsHe(export="png",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=FALSE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)}
			FvsHe(export="eps",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)
			FvsHe(export="pdf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)
			FvsHe(export="png",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)
			if(mysambar$os=="Windows"){FvsHe(export="wmf",showlabels=TRUE,popnames=mysambar$populations,Fcorrect=TRUE,legendcex=legend_cex)}
			popboxplot(myscore=inds$F[inds$filter],popvector=inds$poporder[inds$filter],ylabel="Inbreeding coefficient",export="pdf",exportname="Inbreeding_coefficient_boxplot")
			}
		if(!silent){cat("expHe_vs_He",sep="\n")}
		expHe_vs_He(export="eps",allsites=FALSE,legendcex=legend_cex)
		expHe_vs_He(export="pdf",allsites=FALSE,legendcex=legend_cex)
		expHe_vs_He(export="png",allsites=FALSE,legendcex=legend_cex)
		if(mysambar$os=="Windows"){expHe_vs_He(export="wmf",allsites=FALSE,legendcex=legend_cex)}
		if(!silent){cat("expHe_vs_He allsites",sep="\n")}
		expHe_vs_He(export="eps",allsites=TRUE,legendcex=legend_cex)
		expHe_vs_He(export="pdf",allsites=TRUE,legendcex=legend_cex)
		expHe_vs_He(export="png",allsites=TRUE,legendcex=legend_cex)
		if(mysambar$os=="Windows"){expHe_vs_He(export="wmf",allsites=TRUE,legendcex=legend_cex)}
		}
	if(!silent){cat("Calculating kinship...",sep="\n")}
	calckin(do_overwrite=overwrite_kindf,exporttype="pdf")
	if(mysambar$calckinerror){return(cat("ERROR: kinship calculations encountered a problem (see previous lines).",sep="\n"))}
	#
	cat("Exporting tables...",sep="\n")
	for (k in c(0,1,2,3))
		{
		kintable(mydegree=k,silent=TRUE)
		}
	if(!silent){cat("Plotting histogram with ...",sep="\n")}
	kinhisto(doexport=TRUE)
	#
	plotr1vsr0(silent=FALSE,exporttype="pdf")
	if(!silent){cat("Plotting matrices with king-robust scores...",sep="\n")}
	kinmatrix(exporttype="pdf",legendcex=2.5,plotperpop=matrix_perpop,silent=FALSE)
	if(!silent){cat("Plotting king-robust score versus kinship coefficient...",sep="\n")}
	kinscatter(export="eps",legendcex=legend_cex)
	kinscatter(export="pdf",legendcex=legend_cex)
	kinscatter(export="png",legendcex=legend_cex)
	if(mysambar$os=="Windows"){kinscatter(export="wmf",legendcex=legend_cex)}
	if(!silent){cat("Plotting 2D genotype frequencies...",sep="\n")}
	multi_geno2Dmat(maxplots=20,mythres=king_threshold,export_type="pdf")
	if(!silent){cat("Creating boxplots...",sep="\n")}
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_kingrobust",kinshipscore="kingrobust",ylabel="King-robust score",yline=4.5,onlywithin=TRUE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot",kinshipscore="kincoef",ylabel="Relatedness coefficient",yline=4.5,onlywithin=TRUE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_k2",kinshipscore="k2",ylabel="Proportion identical genotypes",yline=4.5,onlywithin=TRUE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_kingrobust",kinshipscore="kingrobust",ylabel="King-robust score",yline=4.5,onlywithin=FALSE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot",kinshipscore="kincoef",ylabel="Relatedness coefficient",yline=4.5,onlywithin=FALSE)
	kinboxplot(export="pdf",plotname="Relatedness_boxplot_k2",kinshipscore="k2",ylabel="Proportion identical genotypes",yline=4.5,onlywithin=FALSE)
	#
	# F vs kin:
	Fvskin(dolabels=FALSE,export="eps",limitrange=FALSE,legendcex=legend_cex)
	Fvskin(dolabels=FALSE,export="pdf",limitrange=FALSE,legendcex=legend_cex)
	Fvskin(dolabels=FALSE,export="png",limitrange=FALSE,legendcex=legend_cex)
	Fvskin(dolabels=TRUE,export="eps",limitrange=FALSE,legendcex=legend_cex)
	Fvskin(dolabels=TRUE,export="pdf",limitrange=FALSE,legendcex=legend_cex)
	Fvskin(dolabels=TRUE,export="png",limitrange=FALSE,legendcex=legend_cex)
	Fvskin(dolabels=FALSE,export="eps",limitrange=TRUE,legendcex=legend_cex)
	Fvskin(dolabels=FALSE,export="pdf",limitrange=TRUE,legendcex=legend_cex)
	Fvskin(dolabels=FALSE,export="png",limitrange=TRUE,legendcex=legend_cex)
	Fvskin(dolabels=TRUE,export="eps",limitrange=TRUE,legendcex=legend_cex)
	Fvskin(dolabels=TRUE,export="pdf",limitrange=TRUE,legendcex=legend_cex)
	Fvskin(dolabels=TRUE,export="png",limitrange=TRUE,legendcex=legend_cex)
	#
	cat("Filtering on relatedness...",sep="\n")
	kinfilter(mythres=kin_thres)
	indsfilter_perpop(export="pdf")
	if(do_wahlund)
		{
		cat("Creating Wahlund effect plot. If you receive an error after this line, set the flag do_wahlund to FALSE.",sep="\n")
		wahlundplot(export="eps")
		wahlundplot(export="pdf")
		wahlundplot(export="png")
		#if(mysambar$os=="Windows"){wahlundplot(export="wmf")}
		}
	if(findroh)
		{
		# 21-12-2022: still under construction.
		runrzooroh()
		}
	setwd(mysambar$inputdatadir)
	cat("Analysis finished.",sep="\n")
	}

find_roh<-function(snps_per_chrom=500,nsitesthres=15,lengththres=200000,silent=TRUE,my_yline=5)
	{
	ninds		<- nrow(inds)
	mychroms	<- names(table(snps$chr))
	nsnps		<- as.vector(table(snps$chr[snps$filter]))
	mychroms	<- mychroms[nsnps>=snps_per_chrom]
	nchroms		<- length(mychroms)
	#
	# output data frames:
	frohdf						<<- as.data.frame(matrix(NA,ncol=ninds,nrow=nchroms))
	colnames(frohdf)			<<- inds$name
	rownames(frohdf)			<<- mychroms
	frohdf2						<<- as.data.frame(matrix(NA,ncol=ninds,nrow=nchroms))
	colnames(frohdf2)			<<- inds$name
	rownames(frohdf2)			<<- mychroms
	nrohdf						<<- as.data.frame(matrix(NA,ncol=ninds,nrow=nchroms))
	colnames(nrohdf)			<<- inds$name
	rownames(nrohdf)			<<- mychroms
	lrohdf						<<- as.data.frame(matrix(NA,ncol=ninds,nrow=nchroms))
	colnames(lrohdf)			<<- inds$name
	rownames(lrohdf)			<<- mychroms
	# output list:
	rlelist						<- list()
	createnewdf					<- TRUE	
	#
	for(j in c(1:nchroms))
		{
		mychrom						<- mychroms[j]
		posvec						<- snps$pos[snps$chr==mychrom]
		snpnrvec					<- snps$nr[snps$chr==mychrom]
		nchromsnps					<- nrow(snps[snps$chr==mychrom,])
		cat(paste("Analysing chromosome ",mychrom,"...",sep=""),sep="\n")
		chromrlelist				<- list()
		for(k in c(1:ninds))
			{
			myind					<- inds$name[k]
			if(!silent){cat(myind,sep="\n")}
			mygeno					<- as.vector(as.matrix(mygenlight[inds$name==myind,snps$chr==mychrom]))
			mygeno[is.na(mygeno)]	<- 0
			mygeno[mygeno==2]		<- 0
			totallength				<- length(mygeno)
			rleout					<- rle(mygeno)
			myrleout				<<- rleout
			rlesnpnr				<- cumsum(rleout$lengths)-rleout$lengths[1]+1
			rlelengthsum			<- cumsum(rleout$lengths)
			myindices				<- c(1,rlelengthsum[1:(length(rlelengthsum)-1)])
			myindicesvec			<<- myindices
			chromsnpnrvec			<- c(1:nchromsnps)[myindices]
			genomesnpnrvec			<- snpnrvec[myindices] 
			startposvec				<- posvec[myindices]
			endposvec				<- posvec[myindices+rleout$lengths]		# or (?): posvec[myindices+rleout$lengths-1]	
			lengthvec				<- endposvec-startposvec
			RLEindices				<- which(rleout$values==0&rleout$lengths>=nsitesthres&lengthvec>=lengththres)			# here a ROH is defined as at minimum 15 adjacent homozygous snps, stretching over at least 200Kb (default) 
			# Calculate Froh: 
			frohdf[j,k]				<<- ifelse(is.na(totallength)|totallength==0,NA,round(sum(rleout$lengths[RLEindices],na.rm=TRUE)/totallength,2))
			nrohdf[j,k]				<<- ifelse(is.na(totallength)|totallength==0,NA,length(rleout$lengths[RLEindices]))
			lrohdf[j,k]				<<- ifelse(is.na(totallength)|totallength==0,NA,sum(lengthvec[RLEindices]))
			frohdf2[j,k]			<<- ifelse(is.na(totallength)|totallength==0,NA,sum(lengthvec[RLEindices]/max(posvec)))
			# Store ROH information:
			chromrlelist[[k]]		<- rleout
			if(length(RLEindices)!=0)
				{
				#indrohdf			<- data.frame("chrom"=mychrom,"ind"=myind,"snpnr"=chromsnpnrvec[RLEindices],"snpstart"=rlesnpnr[RLEindices],"nsnps"=rleout$lengths[RLEindices],"startpos"=startposvec[RLEindices],"endpos"=endposvec[RLEindices],"length"=lengthvec[RLEindices])
				indrohdf			<- data.frame("chrom"=mychrom,"ind"=myind,"snpnr"=genomesnpnrvec[RLEindices],"snpstart"=chromsnpnrvec[RLEindices],"nsnps"=rleout$lengths[RLEindices],"startpos"=startposvec[RLEindices],"endpos"=endposvec[RLEindices],"length"=lengthvec[RLEindices])
				if(createnewdf)
					{
					mysambar$rohdf	<<- indrohdf
					createnewdf		<- FALSE
					}else{
					mysambar$rohdf	<<- rbind(mysambar$rohdf,indrohdf)
					}
				}
			}
		names(chromrlelist)		<- inds$name	
		}
	cat("Adding f-roh statistics to inds dataframe...",sep="\n")
	inds$froh					<<- colMeans(frohdf2,na.rm=TRUE)
	inds$froh_sd				<<- as.vector(sapply(frohdf2,sd,na.rm=TRUE))
	inds$nroh					<<- colSums(nrohdf)
	inds$lroh					<<- colSums(lrohdf)
	inds$froh_propsites			<<- colMeans(frohdf,na.rm=TRUE)
	mysambar$rlelist			<<- rlelist
	#
	# Given the average heterozygosity in the dataset, what is probability that a stretch of adjacent homozygous sites of a given length occurs by chance?
	cat("Calculating p-values...",sep="\n")
	myhe						<- mean(snps$hetero[snps$filter])
	mysambar$rohdf$logp			<<- -log10((1-myhe)^(mysambar$rohdf$nsnps))
	mysambar$rohdf$sign2		<<- mysambar$rohdf$logp > -log10(0.05)
	mysambar$rohdf$sign			<<- mysambar$rohdf$logp > -log10(0.001)
	#
	cat("Plotting...",sep="\n")
	popboxplot(myscore=inds$froh[inds$filter],popvector=inds$poporder[inds$filter],ylabel="F-roh",export="pdf",exportname="Froh_boxplot",y_line=my_yline)
	if("hetero_all"%in%colnames(inds))
		{
		popboxplot(myscore=inds$hetero_all[inds$filter],popvector=inds$poporder[inds$filter],ylabel="Heterozygosity",export="pdf",exportname="He_boxplot",y_line=my_yline)
		}
	#
	rohdf	<- mysambar$rohdf
	pdf("ROH_pvalues_length.pdf")
	plot(rohdf$length/1000000,rohdf$logp,log="xy",xlab="ROH length (Mb)",ylab="-log(p-value)",las=1,pch=16,cex=0.5)
	abline(h=-log10(0.05),col="red")
	abline(h=-log10(0.001),col="red",lty=2)
	dev.off()
	#
	pdf("ROH_pvalues_nsnps.pdf")
	plot(rohdf$nsnps,rohdf$logp,log="xy",xlab="# nsnps per ROH",ylab="-log(p-value)",las=1,pch=16,cex=0.5)
	abline(h=-log10(0.05),col="red")
	abline(h=-log10(0.001),col="red",lty=2)
	dev.off()
	#
	pdf("ROH_nsnps_length.pdf")
	plot(rohdf$length/1000000,rohdf$nsnps,log="xy",xlab="ROH length (Mb)",ylab="# nsnps per ROH",las=1,pch=16,cex=0.5)
	dev.off()
	#
	cat("Exporting dataframe with individual froh values...",sep="\n")
	mydf				<- inds[inds$filter,c("name","nr","pop","miss","hetero_all","froh")]
	colnames(mydf)[5]	<- "heterozygosity"
	mydf$froh			<- round(mydf$froh,4)
	mydf$miss			<- round(mydf$miss,4)
	mydf$heterozygosity	<-round(mydf$heterozygosity,4)
	write.table(mydf,"Ind_he_froh.txt",sep="\t",col.names=TRUE,row.names=FALSE,quote=FALSE)
	}

# 21-01-2023: modified from getrohbin function of Darwindow:
find_rohbin<-function(snps_per_chrom=500,silent=TRUE,mybreaks=c(0,0.2,0.5,1,2,5,10,200),mylabels=c("0-0.2","0.2-0.5","0.5-1","1-2","2-5","5-10",">10"),my_yline=5)
	{
	if(is.null(mysambar$rohdf))
		{
		return(cat("ERROR: mysambar$rohdf does not exist. Did you run the find_roh function?",sep="\n"))
		}
	rohdf			<- mysambar$rohdf
	minlengths		<- mybreaks[-length(mybreaks)]
	nbins			<- length(minlengths)
	cat(paste("Dividing ROHs into ",nbins, " length bins, as defined with the mybreaks flag.",sep=""),sep="\n")
	if(nbins!=length(mylabels))
		{
		return(cat("ERROR: mylabels vectors should be one element shorter than mybreaks vectors.",sep="\n"))
		}
	ninds			<- nrow(inds)
	#
	agmax 			<- aggregate(pos~chr,data=snps[snps$filter,],max)
	agmin 			<- aggregate(pos~chr,data=snps[snps$filter,],min)
	chromnsnps		<- as.vector(table(snps$chr[snps$filter]))
	totalmb			<- sum(agmax$pos-agmin$pos)/1000000
	#
	nrohbinmat			<- matrix(NA,nrow=ninds,ncol=nbins)
	rownames(nrohbinmat)<- inds$name
	colnames(nrohbinmat)<- paste("X",minlengths,sep="_")
	lrohbinmat			<- nrohbinmat
	frohbinmat			<- nrohbinmat
	for(j in c(1:ninds))
		{
		myind				<- as.character(inds$name[j])
		if(!silent){cat(myind,sep="\n")}
		indrohs				<- rohdf$length[rohdf$ind==myind]/1000000
		indtotalmb			<- totalmb
		#
		# ROH bins:
		extravec			<- (mybreaks[2:(nbins+1)]+mybreaks[1:(nbins)])/2
		indrohs				<- c(indrohs,extravec)									# add one observation per category, so all categories are represented at least once (later subtracted)
		rohbins				<- cut(indrohs,mybreaks)
		#
		nrohbin				<- aggregate(indrohs,by=list(rohbins),FUN=length) 
		colnames(nrohbin)	<- c("size","nrohs")
		nrohbin$nrohs		<- nrohbin$nrohs-1										# subtract the observations we added a few lines above
		nrohbinmat[j,]		<- nrohbin$nrohs
		#
		lrohbin				<- aggregate(indrohs,by=list(rohbins),FUN=sum) 
		colnames(lrohbin)	<- c("size","lrohs")
		lrohbin$lrohs		<- lrohbin$lrohs-extravec								# subtract the observations we added a few lines above
		lrohbinmat[j,]		<- lrohbin$lrohs
		frohbinmat[j,]		<- lrohbin$lrohs/indtotalmb
		}
	mysambar$nrohbindf		<<- as.data.frame(nrohbinmat)
	mysambar$lrohbindf		<<- as.data.frame(lrohbinmat)
	mysambar$frohbindf		<<- as.data.frame(frohbinmat)
	mysambar$rohbinlabels	<<- mylabels
	#
	rohdf$bin				<- 	cut(rohdf$length/1000000,mybreaks,labels=mylabels)			
	mysambar$rohdf			<<- rohdf
	# how many ROHs pass 0.01 threshold?
	# rohdf<-droplevels(mysambar$rohdf)
	# table(rohdf$bin,rohdf$sign)
	#
	inds$froh				<<- rowSums(mysambar$frohbindf)
	inds$lroh2				<<- rowSums(mysambar$lrohbindf)
	inds$nroh2				<<- rowSums(mysambar$nrohbindf)
	cat("ROH-bin data has been stored at mysambar$nrohbindf, mysambar$lrohbindf and mysambar$frohbindf.",sep="\n")
	#
	cat("Plotting f-roh statistics per populations...",sep="\n")
	popboxplot(myscore=inds$froh[inds$filter],popvector=inds$poporder[inds$filter],ylabel="F-roh",export="pdf",exportname="Froh2_boxplot",y_line=my_yline)
	}

# 21-01-2023: modified from rohbarplot function of Darwindow:
roh_barplot<-function(inputdf=mysambar$nrohbindf,ylabel="# ROHs",mycorrection=0,mycolours=NULL,plotname="ROHn_barplot",export=NULL,mybg="white",axiscol="black",yline=5,mywidth=0.75,legendcex=1.5,legendpos="topleft",mylegend=mysambar$rohbinlabels,addlegend=TRUE,legx=NULL,legy=NULL,mycex=1,ypopcol=NULL)
	{
	if(is.null(mycolours))
		{
		if(length(mylegend)>7)
			{
			return(cat(paste("ERROR: provide a vector with the names/codes of ",length(mylegend)," colours to the mycolours flag.",sep=""),sep="\n"))
			}else{
			mycolours	<- c("grey90","grey70","grey50","steelblue3","mediumpurple1","darkorchid4","midnightblue")[1:length(mylegend)]
			}
		}else{
		if(length(mylegend)!=length(mycolours))
			{
			return(cat("ERROR: length of mylegend vector does not correspond with length of mycolour vector.",sep=""),sep="\n")
			}
		}
	indstemp	<- droplevels(inds[inds$filter,])
	ninds		<- nrow(indstemp)
	#
	mydf		<- inputdf[inds$filter,,drop=FALSE]
	mymat		<- t(as.matrix(mydf))
	if(!is.null(ypopcol))
		{
		ymax	<- max(colSums(mymat),na.rm=TRUE)*1.05		
		}else{
		ymax	<- max(colSums(mymat),na.rm=TRUE)
		}
	#
	# reorder:
	mymat		<- mymat[,order(indstemp$poporder)]
	indstemp	<- indstemp[order(indstemp$poporder),]
	#
	if(!is.null(export))
		{
		plotname	<- ifelse(mybg=="white",plotname,paste(plotname,mybg,sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=ninds*mywidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=ninds*mywidth,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=ninds*mywidth*100,height=900)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=ninds*mywidth,height=8)}
		}
	par(oma=c(13,8,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=2,bg=mybg,col=axiscol,col.axis=axiscol,col.lab=axiscol,col.main=axiscol)
	mybarplot	<- barplot(mymat,las=2,col=mycolours,border=NA,names.arg=indstemp$name,las=2,cex.names=mycex,ylim=c(0,ymax))
	if(!is.null(ypopcol))
		{
		mybarplot2	<- mybarplot[1:ninds]
		mypops		<- unique(as.character(indstemp$pop))
		for(mypop in mypops)
			{
			popindex	<- which(as.character(indstemp$pop)==mypop)+mycorrection		# 21-01-2023: temporary solution to realign the population colour bar
			npopind		<- length(popindex)
			popcol		<- as.character(indstemp$popcol[popindex][1])
			points(x=mybarplot2[popindex],y=rep(ypopcol,npopind),cex=2.5,col=popcol,pch=15)
			}
		}
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	if(addlegend)
		{
		mylegend	<- mysambar$rohbinlabels
		if(is.null(legx)|is.null(legy))
			{
			legend(legendpos,legend=rev(mylegend),fill=rev(mycolours),bty='n',cex=legendcex,title="ROH-size (Mb):",y.intersp=0.75)
			}else{
			legend(x=legx,y=legy,legend=rev(mylegend),fill=rev(mycolours),bty='n',cex=legendcex,title="ROH-length (Mb):",y.intersp=0.75)
			}
		}
	if(!is.null(export))
		{
		dev.off()
		cat("Stacked ROH barplot with ROH-score per bin per sample has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 21-12-2022: under construction
runrzooroh<-function()
	{
	# three steps:
	# 1. load data (with zoodata function)
	# 2. define model (with zoomodel function)
	# 3. run analysis (with zoorun function)
	#
	# install.packages("RZooRoH")
	# library("RZooRoH")
	#	
	## CREATE INPUT FILES
	## create genotype file:
	# The Rzooroh manual states that only four columns are required for gt format (chr, pos, allele1, allele2).
	# However, when I read the data with four columns, the information is not read in correctly.
	# No errors appear, but either a warning about number of sample names (in case of 4 columns, no row.names) or chromosome numbers are perceived incorrectly.
	# I found that these issues appear to be solved when including a second column (name or number for example) after the first column with chromosome names. 
	# After a bit more reading, it appears indeed that the software expects by default 5 columns, and that you can also use the following options: 'supcol = 4, poscol = 2, chrcol = 1'
	mydf	<- snps[snps$filter,c("chr","name","pos","minor2","major2")]
	# supcol = 4, poscol = 2, chrcol = 1)
	# The snps$filter boolean includes the snps$polyfilter boolean.
	# Monomorphic sites (which have NA-value in minor column), will cause an error when reading in the data using the zoodata function.
	mydf2	<- t(as.matrix(mygenlight[,snps$filter]))
	mydf2[is.na(mydf2)]<-9
	mydf3	<- cbind(mydf,mydf2)
	write.table(mydf3,"rzooroh_geno.txt",sep="\t",quote=FALSE,col.names=FALSE,row.names=FALSE)
	#
	## create sample file:
	write.table(inds$name,"rzooroh_samples.txt",sep="\t",quote=FALSE,col.names=FALSE,row.names=FALSE)
	#
	## STEP 1: read data
	mygt 		<- zoodata(genofile="rzooroh_geno.txt",samplefile="rzooroh_samples.txt",zformat="gt")
	#
	## STEP 2: define model
	# outcome critically depends on setting the correct model. Major model settings:
	# - K: 		number of homozygosity by descent (HBD) classes
	# - rate:	whilst sliding through the genome, probability to jump from one HBD-class to the nonHBD-class, or another HBD class? Can be predefined or determined by the software? 	
	mymodel 	<- zoomodel(predefined=FALSE,K=8)
	#
	## STEP 3:  detect ROHs using prespecified model:
	myrohs 		<- zoorun(mymodel,mygt)
	#
	## stacked barplot:
	pdf("zoo_barplot.pdf",width=10,height=6)
	mycolours	<- c("grey90","grey70","grey50","steelblue1","steelblue3","mediumpurple1","darkorchid4","midnightblue")
	zooplot_partitioning(myrohs,ylim=c(0,0.5),nonhbd=FALSE,cols=mycolours,border=FALSE,vertical=FALSE)
	dev.off()
	}

calckin<-function(exporttype=NULL,use_currentdir=FALSE,silent=TRUE,silentnr=5000,do_overwrite=FALSE,kinthreshold=0.5,exporttables=FALSE)
	{
	# for method behind king-robust calculations, see also:
	# Manichaikul et al. 2010, Robust relationship inference in genome-wide association studies
	mysambar$calckinerror	<<- FALSE
	my_wd		<- getwd()
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
		if(!dir.exists("Kinship"))
			{
			if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
			dir.create(file.path(kinshipdir))
			mysambar$kinshipdir	<<- kinshipdir
			setwd(kinshipdir)
			}else{
			setwd(kinshipdir)
			cat("Searching for input files in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		}
	npairs		<- nrow(inds2)
	npairs2		<- nrow(inds)*(nrow(inds)-1)/2
	if(all(c("ndata1","ndata2","F1","F2","r0","r1","kingrobust","k0","k1","k2","kincoef","samepop")%in%colnames(inds2))&!do_overwrite)
		{
		cat("WARNING: Using existing relatedness estimates stored in inds2 dataframe.",sep="\n")
		cat("If you receive an error shortly after this line, try again by setting the flag 'do_overwrite' ('overwrite_kindf' flag in wrapper calckinship function) to TRUE.",sep="\n")
		cat(" ",sep="\n")
		kindf	<- inds2[,c("ind1","ind2","name1","name2","pop1","pop2","popcol1","popcol2","filter1","filter2","ndata1","ndata2","F1","F2","r0","r1","kingrobust","k0","k1","k2","kincoef","samepop")]
		if(any(is.na(inds2$kingrobust[inds2$ind1!=inds2$ind2])))
			{
			mysambar$calckinerror	<<- TRUE
			return(cat("ERROR: NA-values in kingrobust column. Values stored in inds2$kingrobust cannot be used. Remove this column by typing 'inds2$kingrobust<-NULL', is try again.",sep="\n"))
			}
		}else{
		setwd(mysambar$kinshipdir)
		if(file.exists("pairwise_relatedness.txt")&!do_overwrite)
			{
			cat("Reading file 'pairwise_relatedness.txt'...",sep="\n")
			mydf1		<- read.table("pairwise_relatedness.txt",header=TRUE,comment.char="")
			if(nrow(mydf1)==npairs)
				{
				cat("Number of rows of input dataframe equals: ninds*ninds/2 + ninds.",sep="\n")		
				}else{
				if(nrow(mydf1==npairs2))
					{
					cat("Number of rows of input dataframe equals: ninds*ninds/2.",sep="\n")	
					}else{
					mysambar$calckinerror	<<- TRUE
					return(cat("ERROR: unexpected number of rows in file 'pairwise_relatedness.txt'. Delete or rename this file and try again.",sep="\n"))
					}
				}
			mydf2			<- mydf1[,!colnames(mydf1)%in%colnames(inds2)]
			mydf2$indpair	<- ifelse(as.character(mydf1$name1)<as.character(mydf1$name2),paste(as.character(mydf1$name1),as.character(mydf1$name2),sep="_"),paste(as.character(mydf1$name2),as.character(mydf1$name1),sep="_"))
			# merge:
			inds2temp		<- inds2[,!colnames(inds2)%in%c("ndata1","ndata2","r0","r1","kingrobust","k0","k1","k2","kincoef")]
			inds2temp2		<- merge(inds2temp,mydf2,by="indpair",all=TRUE)
			mydftest		<<- inds2temp2
			if(nrow(inds2temp2)!=nrow(inds2))
				{
				mysambar$calckinerror	<<- TRUE
				return(cat("ERROR: after merging data from pairwise_relatedness.txt, unexpected number of rows of inds2 dataframe. Contact developer of SambaR.",sep="\n")) 
				}
			if(any(is.na(inds2temp2$kingrobust[inds2temp2$ind1!=inds2temp2$ind2])))
				{
				mysambar$calckinerror	<<- TRUE
				return(cat("ERROR: after merging data from pairwise_relatedness.txt, NA-values in kingrobust column.",sep="\n"))
				}
			redo_analyses	<- FALSE
			inds2			<<- inds2temp2
			kindf			<- inds2[,c("ind1","ind2","name1","name2","pop1","pop2","popcol1","popcol2","filter1","filter2","ndata1","ndata2","F1","F2","r0","r1","kingrobust","k0","k1","k2","kincoef","samepop")]
			}else{
			redo_analyses	<- TRUE
			}
		if(redo_analyses)
			{
			cat("Pairwise_relatedness.txt file is not present or does not have the expected number of rows, or flag do_overwrite (flag 'overwrite_kindf' of wrapper calckinship function)is set to TRUE (default setting). Creating datafile now.",sep="\n")  
			cat("This will take some time, but the next time you run the calckinship() function this step will be automatically omitted (at least if the flag 'overwrite_kindf' is set to FALSE) and then it will be much faster.",sep="\n")  
			if("filter"%in%colnames(snps))
				{
				mymatrix		<- as.matrix(mygenlight[,snps$filter])
				}else{
				mymatrix		<- as.matrix(mygenlight)
				}
			inds2$ndata1	<<- NA
			inds2$ndata2	<<- NA
			inds2$F1		<<- NA
			inds2$F2		<<- NA
			inds2$r0		<<- NA 
			inds2$r1		<<- NA
			inds2$kingrobust<<- NA
			inds2$k0		<<- NA
			inds2$k1		<<- NA
			inds2$k2		<<- NA
			inds2$kincoef	<<- NA
			if(!silent){cat("Starting sample pairwise calculations...",sep="\n")}
			for (i in c(1:npairs))
				{
				if(i%%silentnr==0)
					{
					cat(paste(i," in ",npairs," pairwise comparisons.",sep=""),sep="\n") 
					}
				ind1			<- inds2$ind1[i]
				ind2			<- inds2$ind2[i]
				if("ndata"%in%colnames(inds))
					{
					inds2$ndata1[i]	<<- inds$ndata[inds$nr==ind1]
					inds2$ndata2[i]	<<- inds$ndata[inds$nr==ind2]
					}
				#if(!silent){cat("Adding inbreeding statistics...",sep="\n")}
				if("F"%in%colnames(inds))
					{
					inds2$F1[i]	<<- round(inds$F[ind1],4)
					inds2$F2[i]	<<- round(inds$F[ind2],4)
					}else{
					inds2$F1[i]	<<- NA
					inds2$F2[i]	<<- NA
					}
				#geno1			<- mymatrix[ind1,]	# error: 14-11-2023
				#geno2			<- mymatrix[ind2,]	# error: 14-11-2023
				geno1			<- mymatrix[inds$nr==ind1,]	# correction: 14-11-2023
				geno2			<- mymatrix[inds$nr==ind2,]	# correction: 14-11-2023
				# Optionally add genotypes if a genotype is missing (otherwise table function does not return the expected 4x4 table):
				if(length(unique(geno1[!is.na(geno1)]))<3)
					{
					geno1		<- c(geno1,0,1,2)
					geno2		<- c(geno2,0,1,2)
					}
				if(length(unique(geno2[!is.na(geno2)]))<3)
					{
					geno1		<- c(geno1,0,1,2)
					geno2		<- c(geno2,0,1,2)
					}
				# To avoid that NA is included when stating geno==0/1/2, we change NA to 3:
				geno1[is.na(geno1)]	<- 3
				geno2[is.na(geno2)]	<- 3
				# get 2D-SFS:
				indsfs			<- table(geno1,geno2)
				indsfs			<- indsfs[1:3,1:3]
				# calculate statistics:
				#if(!silent){cat("Calculating statistics...",sep="\n")}
				inds2$r0[i]		<<- (indsfs[3,1]+indsfs[1,3])/indsfs[2,2]  
				inds2$r1[i]		<<- (indsfs[2,2])/(indsfs[1,2]+indsfs[1,3]+indsfs[2,1]+indsfs[2,3]+indsfs[3,1]+indsfs[3,2])
				inds2$kingrobust[i]	<<- (indsfs[2,2]-2*(indsfs[1,3]+indsfs[3,1]))/(indsfs[2,1]+indsfs[1,2]+indsfs[2,3]+indsfs[3,2]+2*indsfs[2,2])
				mysum			<- sum(indsfs)
				inds2$k0[i]		<<- (indsfs[3,1]+indsfs[1,3])/mysum
				inds2$k1[i]		<<- (indsfs[1,2]+indsfs[2,1]+indsfs[2,3]+indsfs[3,2])/mysum
				inds2$k2[i]		<<- (indsfs[1,1]+indsfs[2,2]+indsfs[3,3])/mysum
				# kincoefficient values formula is based on explanation in introduction of Waples et al, 2018, Allele frequency free inference of close familial relationships from genotypes or low depth sequencing data
				# At first glance not very distinctive estimates, so I didn't bother (yet) plotting the results
				# still to incorporate: PLINK pi_hat estimates
				# for detailed description of pihat calculation see: Purcell et al, 2007, PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses
				#
				if(inds2$kingrobust[i]>=kinthreshold&(!silent)&ind1!=ind2)
					{
					cat(paste("High relatedness-score for individual ",ind1," and ",ind2,".",sep=""),sep="\n")
					}
				}
			inds2$kincoef	<<- round(inds2$k1/4+inds2$k2/2,3)
			if(!"samepop"%in%colnames(inds2))
				{
				inds2$samepop	<<- inds2$pop1==inds2$pop2
				}
			if(!silent){cat("Exporting data to file 'pairwise_relatedness.txt'...",sep="\n")}
			kindf			<- inds2[,c("ind1","ind2","name1","name2","pop1","pop2","popcol1","popcol2","filter1","filter2","ndata1","ndata2","F1","F2","r0","r1","kingrobust","k0","k1","k2","kincoef","samepop")]
			setwd(mysambar$kinshipdir)
			write.table(kindf,"pairwise_relatedness.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
			}
		}
	# EXPORT TABLE
	#kindf	<- inds2[inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2,]
	if(exporttables)
		{
		cat("Exporting tables...",sep="\n")
		for (k in c(0,1,2,3))
			{
			kintable(mydegree=k,silent=TRUE)
			}
		}
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	cat("Dataframe 'inds2' has been updated.",sep="\n")
	}

# 15-11-2023: histogram of king-robust scores:
kinhisto<-function(doexport=TRUE)
	{
	myvec<-inds2$kingrobust[!inds2$sameind&inds2$kingrobust>0]
	if(doexport){pdf("Kingrobust_histogram.pdf")}
	myplot<-hist(myvec,breaks=50,xlab="King-robust score",ylab="Number of sample pairs",main="",xlim=c(0,0.5))
	abline(v=0.044,col="red",lty=3) 
	abline(v=0.089,col="red",lty=3) 
	abline(v=0.177,col="red",lty=3) 
	abline(v=0.354,col="red",lty=3) 
	ymax<-max(myplot$counts)
	text(x=mean(c(0.044,0.089)),y=ymax,"3rd")
	text(x=mean(c(0.089,0.177)),y=ymax,"2nd")
	text(x=mean(c(0.177,0.354)),y=ymax,"1st")
	#
	text(x=mean(c(0.089,0.177)),y=ymax*0.95,"grand-parent/child")
	text(x=mean(c(0.089,0.177)),y=ymax*0.9,"half sibling")
	text(x=mean(c(0.089,0.177)),y=ymax*0.85,"aunt/uncle")
	text(x=mean(c(0.089,0.177)),y=ymax*0.79,"niece/nephew")
	#
	text(x=mean(c(0.177,0.354)),y=ymax*0.95,"parent/child")
	text(x=mean(c(0.177,0.354)),y=ymax*0.9,"full sibling")
	#
	text(x=mean(c(0.354,0.5)),y=ymax*0.95,"identical twin")
	text(x=mean(c(0.354,0.5)),y=ymax*0.9,"duplicated sample")
	#
	if(doexport){dev.off()}
	}
	
# 16-01-2023: depreciated: replaced by calckin function, which stores information in inds2 dataframe, not in kindf.
calckin_old<-function(exporttype=NULL,use_currentdir=TRUE,silent=TRUE,legendcex=2.5,do_overwrite=FALSE,kinthreshold=0.4,plotperpop=FALSE)
	{
	my_wd		<- getwd()
	myinds		<- inds$nr
	combitable	<- combn(myinds,m=2)
	npairs		<- ncol(combitable)
	if(!is.null(mysambar$kindf)&!do_overwrite)
		{
		if(!silent){cat("Using existing dataframe with relatedness estimates.",sep="\n")}
		kindf	<- mysambar$kindf
		}else{
		setwd(mysambar$inputdatadir)
		if(file.exists("pairwise_relatedness.txt")&!do_overwrite)
			{
			if(!silent){cat("Reading file 'pairwise_relatedness.txt'.",sep="\n")}
			mydftemp	<- read.table("pairwise_relatedness.txt",header=TRUE,comment.char="")
			}else{
			# create dummy:
			mydftemp	<- data.frame("col1"=c(1:2),"col2"=c(1:2)) 
			}
		if(nrow(mydftemp)==npairs&!do_overwrite)
			{
			if(!silent){cat("Generating dataframe with relatedness estimates.",sep="\n")}
			kindf			<<- mydftemp
			mysambar$kindf	<<- kindf
			}else{
			cat("Pairwise_relatedness.txt file is not present or does not have the expected number of rows, or flag do_overwrite is set to TRUE. Creating datafile now.",sep="\n")  
			cat("This will take some time, but the next time you run the filterdata() function this step will be automatically omitted and then it will be much faster.",sep="\n")  
			mymatrix	<- as.matrix(mygenlight[,snps$filter])
			ind1vec		<- vector()
			ind2vec		<- vector()
			name1vec	<- vector()
			name2vec	<- vector()
			pop1vec		<- vector()
			pop2vec		<- vector()
			popcol1vec	<- vector()
			popcol2vec	<- vector()
			ind1bool	<- vector()
			ind2bool	<- vector()
			ndata1vec	<- vector()
			ndata2vec	<- vector()
			f1vec		<- vector()
			f2vec		<- vector()
			r0vec		<- vector() 
			r1vec		<- vector()
			kingvec		<- vector()
			k0vec		<- vector()
			k1vec		<- vector()
			k2vec		<- vector()
			kincoef		<- vector()
			# indsfslist	<<- list()
			if(!silent){cat("Starting sample pairwise calculations...",sep="\n")}
			for (i in c(1:ncol(combitable)))
				{
				if(i%%1000==0&!silent)
					{
					cat(paste(i," in ",ncol(combitable)," pairwise comparisons.",sep=""),sep="\n") 
					}
				ind1		<- combitable[1,i]
				ind2		<- combitable[2,i]
				ind1vec[i]	<- ind1
				ind2vec[i]	<- ind2
				name1vec[i]	<- as.character(inds$name[ind1])
				name2vec[i]	<- as.character(inds$name[ind2])
				pop1vec[i]	<- as.character(inds$pop[ind1])
				pop2vec[i]	<- as.character(inds$pop[ind2])
				popcol1vec[i]<- as.character(inds$popcol[ind1])
				popcol2vec[i]<- as.character(inds$popcol[ind2])
				ind1bool[i]	<- inds$filter[ind1]
				ind2bool[i]	<- inds$filter[ind2]
				ndata1vec[i]<- inds$ndata[ind1]
				ndata2vec[i]<- inds$ndata[ind2]
				if("F"%in%colnames(inds))
					{
					f1vec[i]	<- round(inds$F[ind1],4)
					f2vec[i]	<- round(inds$F[ind2],4)
					}else{
					f1vec[i]	<- NA
					f2vec[i]	<- NA
					}
				geno1		<- mymatrix[ind1,]
				geno2		<- mymatrix[ind2,]
				# Optionally add genotypes if a genotype is missing (otherwise table function does not return the expected 4x4 table):
				if(length(unique(geno1[!is.na(geno1)]))<3)
					{
					geno1	<- c(geno1,0,1,2)
					geno2	<- c(geno2,0,1,2)
					}
				if(length(unique(geno2[!is.na(geno2)]))<3)
					{
					geno1	<- c(geno1,0,1,2)
					geno2	<- c(geno2,0,1,2)
					}
				# To avoid that NA is included when stating geno==0/1/2, we change NA to 3:
				geno1[is.na(geno1)]	<- 3
				geno2[is.na(geno2)]	<- 3
				# get 2D-SFS:
				indsfs		<- table(geno1,geno2)
				indsfs		<- indsfs[1:3,1:3]
				# 
				# indsfslist[[i]]	<<- indsfs
				# calculate statistics:
				r0vec[i]	<- (indsfs[3,1]+indsfs[1,3])/indsfs[2,2]  
				r1vec[i]	<- (indsfs[2,2])/(indsfs[1,2]+indsfs[1,3]+indsfs[2,1]+indsfs[2,3]+indsfs[3,1]+indsfs[3,2])
				kingvec[i]	<- (indsfs[2,2]-2*(indsfs[1,3]+indsfs[3,1]))/(indsfs[2,1]+indsfs[1,2]+indsfs[2,3]+indsfs[3,2]+2*indsfs[2,2])
				mysum		<- sum(indsfs)
				k0vec[i]	<- (indsfs[3,1]+indsfs[1,3])/mysum
				k1vec[i]	<- (indsfs[1,2]+indsfs[2,1]+indsfs[2,3]+indsfs[3,2])/mysum
				k2vec[i]	<- (indsfs[1,1]+indsfs[2,2]+indsfs[3,3])/mysum
				kincoef[i]	<- round(k1vec[i]/4+k2vec[i]/2,3)
				# kincoefficient values formula is based on explanation in introduction of Waples et al, 2018, Allele frequency free inference of close familial relationships from genotypes or low depth sequencing data
				# At first glance not very distinctive estimates, so I didn't bother (yet) plotting the results
				# still to incorporate: PLINK pi_hat estimates
				# for detailed description of pihat calculation see: Purcell et al, 2007, PLINK: A Tool Set for Whole-Genome Association and Population-Based Linkage Analyses
				#
				if(kingvec[i]>=kinthreshold&(!silent))
					{
					cat(paste("High relatedness-score for individual ",ind1," and ",ind2,".",sep=""),sep="\n")
					}
				}
			kindf			<- data.frame("ind1"=ind1vec,"ind2"=ind2vec,"name1"=name1vec,"name2"=name2vec,"pop1"=pop1vec,"pop2"=pop2vec,"popcol1"=popcol1vec,"popcol2"=popcol2vec,"ind1_bool"=ind1bool,"ind2_bool"=ind2bool,"ndata1"=ndata1vec,"ndata2"=ndata2vec,"F1"=f1vec,"F2"=f2vec,"r0"=r0vec,"r1"=r1vec,"kingrobust"=kingvec,"k0"=k0vec,"k1"=k1vec,"k2"=k2vec,"kincoef"=kincoef)
			kindf$samepop	<- kindf$pop1==kindf$pop2
			mysambar$kindf	<<- kindf
			setwd(mysambar$inputdatadir)
			write.table(mysambar$kindf,"pairwise_relatedness.txt",sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
			}
		setwd(my_wd)
		}
	#
	# PLOTTING
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
		if(!dir.exists("Kinship"))
			{
			if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
			dir.create(file.path(kinshipdir))
			mysambar$kinshipdir	<<- kinshipdir
			setwd(kinshipdir)
			}else{
			setwd(kinshipdir)
			if(!silent){cat("(Over)writing results in directory:",sep="\n")}
			cat(getwd(),sep="\n")	
			}
		}
	# scatterplot:
	if(!silent){cat("Creating kin scatter plot...",sep="\n")}
	if(!is.null(exporttype))
		{
		if(exporttype=="pdf"){pdf("kin_scatter.pdf",family=mysambar$myfont,width=16,height=8)}
		}
	par(mfrow=c(1,2),mar=c(4,5.5,1,1),oma=c(1,1,1,0.5))
	myfilter	<- kindf$ind1_bool&kindf$ind2_bool
	options(warn=-1)
	kindf	<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	plot(kindf$r1[myfilter],kindf$r0[myfilter],log="x",ylab="",xlab="R1",cex.lab=2.5,cex.axis=2,pch=16,las=1,cex=2,col="orange")
	mtext("R0",side=2,line=3.75,cex=2.5)
	plot(kindf$r1[myfilter],kindf$kingrobust[myfilter],log="x",ylab="",xlab="R1",cex.lab=2.5,cex.axis=2,pch=16,las=1,cex=2,col="orange")
	options(warn=0)
	mtext("KING-robust",side=2,line=3.75,cex=2.5)
	if(!is.null(exporttype)){dev.off()}
	#
	# 16-3-20: if only 1 sample per population, you will run into the error:
	# error in heatmap2.: x must be a numeric matrix.
	# matrix:
	kindf	<- mysambar$kindf
	if(any(is.infinite(kindf$kingrobust)))
		{
		if(!silent){cat("Infinite kingrobust values. Omitting kin matrix...",sep="\n")}
		}else{
		if(!silent){cat("Creating kin matrix...",sep="\n")}
		kingvalues					<- kindf$kingrobust
		kingvalues[kingvalues<0]	<- 0
		plot_indmatrix(export=exporttype,silent=silent,inputvalues=kingvalues,popnames=mysambar$populations,n_bins=5,mybreaks=NULL,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="KING-robust",plotprefix="KINGrelatedness",currentdir=TRUE,perpop=plotperpop)
		}
	#
	# EXPORT TABLE
	kindf	<- kindf[kindf$ind1_bool&kindf$ind2_bool,]
	for (k in c(0,1,2,3))
		{
		kintable(mydegree=k,silent=TRUE)
		}
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	}

kinfilter<-function(mythres=0.5)
	{
	# 16-11-2023: 
	# by default, retain all samples
	# To filter out 0st degree relatives (twins or duplicates), set threshold close to 0.5 (for instance 0.4) 
	# To filter out 1st degree relatives, set threshold to 0.177
	# To filter out 2nd degree relatives, set threshold to 0.089
	# To filter out 3rd degree relatives, set threshold to 0.044
	#
	# these thresholds are based on table1 and figure 1 in:
	# Manichaikul et al. 2010, Robust relationship inference in genome-wide association studies
	# 
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a kingrobust column. Did you run the calckin() function?",sep="\n"))
		}
	inds2$kingrobust[!is.finite(inds2$kingrobust)]	<<- NA
	inds2$kinfilter	<<- inds2$kingrobust<=mythres&!is.na(inds2$kingrobust)
	kindf			<- inds2[inds2$ind1!=inds2$ind2&(!inds2$kinfilter),]
	kindf			<- kindf[!is.na(kindf$kingrobust),]
	npairs			<- nrow(kindf)
	#
	inds$kinfilter	<<- TRUE
	if(npairs==0)
		{
		cat(paste("Number of sample pairs with kingrobust score above ",mythres," equals zero. All individuals pass kinship filter.",sep=""),sep="\n")
		}else{
		if(all(is.na(inds2$ndata1)))
			{
			cat(paste("Number of sample pairs with kingrobust score above ",mythres," equals ",npairs,". Randomly selecting one individual per pair (namely on alphabetical order).",sep=""),sep="\n")	
			}else{
			cat(paste("Number of sample pairs with kingrobust score above ",mythres," equals ",npairs,". For each pair selecting individual with most datapoints (least missing data), or, if no difference, on alphabetical order.",sep=""),sep="\n")	
			}
		for(k in c(1:npairs))
			{	
			# 23-01-2023: still need to consider filter column in inds dataframe.
			# If one individual has already been discarded and the other not, then no need to choose.
			if(is.na(kindf$ndata1[k])|is.na(kindf$ndata1[k]))
				{
				indname							<- as.character(kindf$name2[k])
				}else{
				indname							<- ifelse(kindf$ndata1[k]>=kindf$ndata2[k],as.character(kindf$name2[k]),as.character(kindf$name1[k]))
				}
			inds$kinfilter[inds$name==indname]	<<- FALSE
			}
		ninds	<- nrow(inds[!inds$kinfilter,])
		cat(paste("Number of discarded individuals due to relatedness: ",ninds,".",sep=""),sep="\n")
		}
	if("filter"%in%colnames(inds))
		{
		cat("Updating inds dataframe...",sep="\n")
		inds$filter			<<- inds$filter&inds$kinfilter
		inds$filter2		<<- inds$filter2&inds$kinfilter
		#
		cat("Updating inds2 dataframe ...",sep="\n")
		retainedvec			<- inds$name[inds$filter]
		inds2$filter1[inds2$name1%in%retainedvec]		<<- TRUE
		inds2$filter1[!inds2$name1%in%retainedvec]		<<- FALSE
		inds2$filter2[inds2$name2%in%retainedvec]		<<- TRUE
		inds2$filter2[!inds2$name2%in%retainedvec]		<<- FALSE
		inds2$filter		<<- inds2$filter1&inds2$filter2
		# checkpoint:
		inds2temp			<- inds2[inds2$name1!=inds2$name2,]
		boolvec				<- c(inds2temp$name1%in%retainedvec,inds2temp$name2%in%retainedvec)
		if(all(boolvec))
			{
			if(any(!inds$filter))
				{
				return(cat("ERROR: unexpected number of retained individuals (namely all) in inds2 dataframe after updating ind2 dataframe. Contact developer of SambaR.",sep="\n"))
				}
			}else{
			#nretained2		<- length(boolvec[boolvec])
			#ndiscarded2	<- length(boolvec[!boolvec])
			#nretained		<- length(inds$filter[inds$filter])
			#ndiscarded		<- length(inds$filter[!inds$filter])
			#nexpected2		<- ndiscarded2/ndiscarded*nretained
			#if(nretained2!=nexpected2)
			#	{
			#	return(cat(paste("ERROR: unexpected number of retained individuals in inds2 dataframe (",nretained2," instead of ",nexpected2,") after updating ind2 dataframe. Contact developer of SambaR.",sep=""),sep="\n"))
			#	}
			retainedvec		<- inds$name[inds$filter]
			discardedvec	<- inds$name[!inds$filter]
			check1			<- any(inds2$filter[inds2$name2%in%discardedvec|inds2$name2%in%discardedvec])
			check2			<- any(!inds2$filter[inds2$name1%in%retainedvec&inds2$name2%in%retainedvec])
			if(check1|check2)
				{
				return(cat(paste("ERROR: unexpected number of retained individuals in inds2 dataframe (",nretained2," instead of ",nexpected2,") after updating ind2 dataframe. Contact developer of SambaR.",sep=""),sep="\n"))
				}
			}
		cat("Filter settings (inds$filter) have been updated with kinship filter.",sep="\n")
		cat("To find out which individuals have been omitted, type: inds$name[!inds$kinfilter].",sep="\n")
		}
	}

kinscatter<-function(export=NULL,addlegend=TRUE,legendcex=1.5,plotname="Kingrobust_vs_kincoeff",legendpos="topleft",yline=5.5,symbolsize=2)
	{
	if(!is.null(export))
		{
		legendlabel	<- ifelse(addlegend,"withlegend","NOlegend")
		if(export=="eps"){postscript(paste(plotname,legendlabel,"eps",sep="."),width=8,height=8)}
		if(export=="pdf"){pdf(paste(plotname,legendlabel,"pdf",sep="."),width=8,height=8)}
		if(export=="png"){png(paste(plotname,legendlabel,"png",sep="."),width=720,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,legendlabel,"wmf",sep="."),width=8,height=8)} 
		}
	par(mar=c(5.5,8.5,2.5,0.5),cex.axis=2.5,cex.lab=3,cex.main=3)
	kindf	<- inds2[inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2,]
	plot(kindf$kingrobust,kindf$kincoef,pch=21,col=as.character(kindf$popcol1),bg=as.character(kindf$popcol2),cex=symbolsize,las=1,ylab="",xlab="",lwd=2)
	mtext(side=2,line=5.5,"Kin coefficient",cex=3)
	mtext(side=1,line=3.5,"King-robust score",cex=3)
	if(addlegend)
		{
		legend(legendpos,legend=mysambar$populations,bty='n',fill=mysambar$mycolours,border=mysambar$mycolours,cex=legendcex)
		}
	if(!is.null(export))
		{
		dev.off()
		#cat("Scatterplot has been exported to the directory:",sep="\n")
		#cat(getwd(),sep="\n")
		}
	}

plotr1vsr0<-function(silent=FALSE,exporttype=NULL)
	{
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a kingrobust column. Did you run the calckin() function?",sep="\n"))
		}
	cat("Plotting r1 vs ro...",sep="\n")
	if(!is.null(exporttype))
		{
		if(exporttype=="pdf"){pdf("kin_scatter.pdf",family=mysambar$myfont,width=16,height=8)}
		}
	par(mfrow=c(1,2),mar=c(4,5.5,1,1),oma=c(1,1,1,0.5))
	myfilter		<- inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2
	if(length(myfilter[myfilter])==0)
		{
		return(cat("ERROR: zero retained individual pairs.",sep="\n"))
		}
	options(warn=-1)
	plot(inds2$r1[myfilter],inds2$r0[myfilter],log="x",ylab="",xlab="R1",cex.lab=2.5,cex.axis=2,pch=16,las=1,cex=2,col="orange")
	mtext("R0",side=2,line=3.75,cex=2.5)
	plot(inds2$r1[myfilter],inds2$kingrobust[myfilter],log="x",ylab="",xlab="R1",cex.lab=2.5,cex.axis=2,pch=16,las=1,cex=2,col="orange")
	options(warn=0)
	mtext("KING-robust",side=2,line=3.75,cex=2.5)
	if(!is.null(exporttype)){dev.off()}
	}

multi_geno2Dmat<-function(maxplots=30,mythres=0.177,export_type="pdf",n_bins=5,silent=TRUE)
	{
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a kingrobust column. Did you run the calckin() function?",sep="\n"))
		}
	kindf		<- inds2[is.finite(inds2$kingrobust),]
	kindf		<- kindf[!is.na(kindf$kingrobust),]
	#kindf		<- kindf[kindf$filter1&kindf$filter2&kindf$kingrobust>=mythres&kindf$ind1!=kindf$ind2,]
	kindf		<- kindf[kindf$kingrobust>=mythres&kindf$ind1!=kindf$ind2,]
	npairs		<- nrow(kindf)
	cat(paste("Number of sample pairs with King-robust relatedness-score >= ",mythres," equals ",npairs,".",sep=""),sep="\n")
	if(npairs>maxplots)
		{
		return(cat("WARNING: Many related pairs. If you want to plot them anyway, run the multi_geno2Dmat function with a higher value specified to the flag maxplots (default is 20).",sep="\n"))
		}
	if(npairs==0)
		{
		return(cat("WARNING: Zero sample pairs with a relatedness score above the threshold. Not creating 2D-genotype matrices. You could try to rerun the calckinship function with a different value specified to the king_threshold flag.",sep="\n"))
		}
	cat("Creating heatmaps with 2D sample genotypes proportions of sample pairs with high relatedness scores.",sep="\n") 
	for(i in c(1:npairs))
		{
		if(!silent){cat(i,sep="\n")}
		geno2Dmat(ind1=kindf$ind1[i],ind2=kindf$ind2[i],export=export_type,use_currentdir=TRUE,nbins=n_bins,doprop=TRUE,ndecimals=3,myBreaks=seq(0,0.1,0.1/n_bins))
		}
	cat("Heatmaps with 2D individual genotype proportions have been exported to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	cat("Orange colour scale indicates deviation from random expectations (dark orange: high deviation; white: low deviation).",sep="\n")
	}
	
geno2Dmat<-function(ind1=1,ind2=2,export=NULL,use_currentdir=TRUE,nbins=5,doprop=TRUE,ndecimals=3,myBreaks=seq(0,0.1,0.1/nbins))
	{
	# This plot create a heatmap with two dimensional genotype score proportions.
	# The colours represent the magnitude of difference compared to expected (random combination) values.
	# If no relatedness, there will be hardly any orange colour.
	#
	############# get 2D genotype scores:
	name1				<- as.character(inds$name[inds$nr==ind1])
	name2				<- as.character(inds$name[inds$nr==ind2])
	genlightmat			<- as.matrix(mygenlight[,snps$filter])
	geno1				<- genlightmat[inds$nr==ind1,]
	geno2				<- genlightmat[inds$nr==ind2,]
	# To avoid that NA is included when stating geno==0/1/2, we change NA to 3:
	geno1[is.na(geno1)]	<- 3
	geno2[is.na(geno2)]	<- 3
	#
	if(length(geno1)==length(geno1[geno1==3]))
		{
		return(cat("WARNING: Ind1 has missing data only. Not creating heatmap.",sep="\n"))
		}
	if(length(geno2)==length(geno2[geno2==3]))
		{
		return(cat("WARNING: Ind2 has missing data only. Not creating heatmap.",sep="\n"))
		}
	obsmatrix			<- matrix(NA,nrow=3,ncol=3)
	genos				<- c(0,1,2)
	colnames(obsmatrix)	<- genos
	rownames(obsmatrix)	<- genos
	expmatrix			<- obsmatrix
	genoprop1			<- vector()
	genoprop2			<- vector()
	for (i in c(1:3))
		{
		g1	<- genos[i]
		for (j in c(1:3))
			{
			g2	<- genos[j]
			obsmatrix[i,j]	<- length(geno1[geno1==g1&geno2==g2])
			}
		}
	if(doprop)
		{
		mymatrix	<- round(obsmatrix/sum(obsmatrix),ndecimals)
		}else{
		mymatrix	<- obsmatrix
		}
	#
	############ expected 2D genotype scores:
	for (i in c(1:3))
		{
		g1				<- genos[i]
		p1				<- length(geno1[geno1==g1])/length(geno1[geno1!=3])
		genoprop1[i]	<- round(length(geno1[geno1==g1])/length(geno1[geno1!=3]),2)
		genoprop2[i]	<- round(length(geno2[geno2==g1])/length(geno2[geno2!=3]),2)
		for (j in c(1:3))
			{
			g2				<- genos[j]
			p2				<- length(geno1[geno2==g2])/length(geno2[geno2!=3])
			expmatrix[i,j]	<- p1*p2
			}
		}
	exppropmat	<- round(expmatrix/sum(expmatrix),ndecimals)
	ntotal		<- length(geno1[geno1!=3&geno2!=3])		
	obsmatrix	<- obsmatrix
	expnmat		<- round(expmatrix*ntotal)
	ndiffmat	<- expnmat-obsmatrix
	propdiffmat	<- abs(ndiffmat/sum(obsmatrix))
	#
	### PLOTTING
	# balloonplot(as.table(mymatrix),xlab=name1,ylab=name2,main="")
	# create colours:
	myvec	<- c("0","1","2")
	rownames(propdiffmat)	<- paste(myvec,genoprop1,sep=": ")
	colnames(propdiffmat)	<- paste(myvec,genoprop2,sep=": ")
	if(is.null(myBreaks))
		{
		mymin		<- min(propdiffmat,na.rm=TRUE)
		mymax		<- max(propdiffmat,na.rm=TRUE)
		binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
		myBreaks	<- seq(mymin,mymax,binsize)
		}
	myBreaks		<- myBreaks
	mycolfunc 		<- colorRampPalette(c("white","darkorange"))
	myColours		<- c(mycolfunc(length(myBreaks)-1))
	#
	my_wd			<- getwd()
	if(!use_currentdir)
		{
		setwd(kinshipdir)
		}
	graphics.off()
	if(!is.null(export))
		{
		ngeno	<- 3
		mysize	<- 3+ngeno*1.75
		mysize2	<- 300+ngeno*150
		plotname<- paste("Geno2Dmat",paste(ind1,"vs",ind2,sep=""),sep=".")
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
		}
	heatmap.2(propdiffmat,lwid=c(0.5,4),lhei=c(0.5,4),cellnote=mymatrix,
	notecol="black",notecex=2.5,Rowv=NA,cexCol=2.5,cexRow=2.5,Colv=NA,scale="none",
	col=myColours,breaks=myBreaks,dendrogram="none",key=FALSE,trace="none",srtRow=45,srtCol=45,margins=c(12,12))
	mtext(name1, side = 1, cex = 2, line = 3.5)
	mtext(name2, side = 4, cex = 2, line = 0.5)
	mtext("2D individual genotype proportions", side = 3, line = 1, cex = 2.5)	
	if(!is.null(export)){dev.off()}
	if(!use_currentdir)
		{
		setwd(my_wd)
		}
	}

kintable<-function(mydegree=0,silent=FALSE,dofilter=FALSE)
	{
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a column 'kingrobust'. Did you run the calckin function?",sep="\n"))
		}
	if(any(is.na(inds2$kingrobust[inds2$ind1!=inds2$ind2])))
		{
		return(cat("ERROR: NA-values in inds2$kingrobust column.",sep="\n"))
		}
	if(dofilter)
		{
		kindf			<- inds2[inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2,]
		}else{
		kindf			<- inds2[inds2$ind1!=inds2$ind2,]
		}
	kindf$r0		<- round(kindf$r0,3)
	kindf$r1		<- round(kindf$r1,3)
	kindf$kingrobust<- round(kindf$kingrobust,3)
	kindf$k0		<- round(kindf$k0,3)
	kindf$k1		<- round(kindf$k1,3)
	kindf$k2		<- round(kindf$k2,3)
	kindf$kincoef	<- round(kindf$kincoef,3)
	#
	if(mydegree>3)
		{
		return(cat("ERROR: only relationship degrees 0, 1, 2, 3 allowed.",sep="\n"))
		}
	minthres		<- ifelse(mydegree>=2,ifelse(mydegree==3,0.044,0.089),ifelse(mydegree==1,0.177,0.354))
	maxthres		<- ifelse(mydegree>=2,ifelse(mydegree==3,0.089,0.177),ifelse(mydegree==1,0.354,1))
	if(any(kindf$kingrobust>=minthres&kindf$kingrobust<maxthres,na.rm=TRUE))
		{
		closekindf	<- kindf[kindf$kingrobust>=minthres&kindf$kingrobust<maxthres,c("name2","name1","ind1","ind2","filter1","filter2","filter","pop1","pop2","ndata1","ndata2","kingrobust","kincoef")]
		write.table(closekindf,paste("Close_kin",paste("degree",mydegree,sep=""),"txt",sep="."),quote=FALSE,sep="\t",col.names=TRUE,row.names=FALSE)
		if(!silent){cat("A table listing close kin pairs has been exported to the directory:",sep="\n")}
		if(!silent){cat(getwd(),sep="\n")}
		}
	}

Fvskin<-function(dolabels=FALSE,export=NULL,limitrange=FALSE,legendcex=1.5)
	{
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a column 'kingrobust'. Did you run the calckin function?",sep="\n"))
		}
	kindf			<- inds2[inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2,]
	kindf$F			<- 0.5*(kindf$F1+kindf$F2)
	mycols			<- ifelse(kindf$samepop,as.character(kindf$popcol1),rep("grey10",nrow(kindf)))
	#
	if(!is.null(export))
		{
		plotname	<- ifelse(dolabels,"F_vs_relatedness.labels","F_vs_relatedness")
		plotlabel	<- ifelse(limitrange,"limitedrange","fullrange")
		if(export=="eps"){postscript(paste(plotname,plotlabel,"eps",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="pdf"){pdf(paste(plotname,plotlabel,"pdf",sep="."),family=mysambar$myfont,width=10,height=10)}
		if(export=="png"){png(paste(plotname,plotlabel,"png",sep="."),family=mysambar$myfont,width=720,height=720)}
		#if(export=="wmf"){win.metafile(paste(plotname,plotlabel,"wmf",sep="."),family=mysambar$myfont,width=10,height=10)} # this file is too big
		}
	par(mar=c(5,6,5,2),cex.axis=2.5,cex.lab=3,cex.main=3)
	if(!limitrange)
		{
		limx	<- c(-1,1)
		limy	<- c(-1,0.5)
		}else{
		limx	<- c(min(kindf$F,na.rm=TRUE),max(kindf$F,na.rm=TRUE))
		limy	<- c(min(kindf$kingrobust,na.rm=TRUE),max(kindf$kingrobust,na.rm=TRUE))
		}
	if(!dolabels)
		{
		plot(kindf$F,kindf$kingrobust,col=mycols,cex=3,pch=16,xlab="Inbreeding coefficient",ylab="King-robust score",xlim=limx,ylim=limy)
		points(kindf$F[kindf$samepop],kindf$kingrobust[kindf$samepop],pch=16,col=mycols[kindf$samepop],cex=3.5,xlim=limx,ylim=limy)
		}else{
		plot(kindf$F,kindf$kingrobust,cex=1.5,pch=16,col="white",xlab="Inbreeding coefficient",ylab="King-robust score",xlim=limx,ylim=limy)
		text(kindf$F,kindf$kingrobust,paste(kindf$ind1,kindf$ind2,sep="_"),pch=16,col=mycols,cex=0.25,xlim=limx,ylim=limy)
		}
	abline(h=0.5,lty=2)
	legend("bottomleft",legend=c(mysambar$populations,"between"),fill=c(mysambar$mycolours,"black"),bty='n',cex=legendcex)
	if(!is.null(export)){dev.off()}
	}


kinmatrix<-function(exporttype="pdf",legendcex=2.5,plotperpop=FALSE,silent=FALSE)
	{
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a column 'kingrobust'. Did you run the calckin function?",sep="\n"))
		}
	# 16-3-20: if only 1 sample per population, you will run into the error:
	# error in heatmap2.: x must be a numeric matrix.
	# matrix:
	if(any(is.infinite(inds2$kingrobust)))
		{
		if(!silent){cat("Infinite kingrobust values. Omitting kin matrix...",sep="\n")}
		}else{
		if(!silent){cat("Creating kin matrix...",sep="\n")}
		kingvalues					<- inds2$kingrobust[inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2]
		kingvalues[kingvalues<0]	<- 0
		plot_indmatrix(export=exporttype,silent=silent,inputvalues=kingvalues,popnames=mysambar$populations,n_bins=5,mybreaks=NULL,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="KING-robust",plotprefix="KINGrelatedness",currentdir=TRUE,perpop=plotperpop)
		}
	}

kinboxplot<-function(export=NULL,plotname="Relatedness_boxplot",kinshipscore="kincoef",ylabel="Relatedness coefficient",yline=4.5,onlywithin=TRUE)
	{
	if(!"kingrobust"%in%colnames(inds2))
		{
		return(cat("ERROR: inds2 dataframe does not contain a column 'kingrobust'. Did you run the calckin function?",sep="\n"))
		}
	kindf				<- inds2[inds2$filter1&inds2$filter2&inds2$ind1!=inds2$ind2,]
	kindf$withinpop		<- kindf$pop1==kindf$pop2
	kindf$pop3			<- ifelse(kindf$withinpop,as.character(kindf$pop1),rep("between",nrow(kindf)))	
	if(onlywithin)
		{
		tempdf			<- kindf[kindf$withinpop,c("pop1",kinshipscore)]
		colnames(tempdf)<- c("pop","kinscore")
		tempdf$poporder	<- factor(tempdf$pop,levels=mysambar$poporder2)
		tempdf			<- droplevels(tempdf[tempdf$pop%in%mysambar$populations,])
		popbool			<- mysambar$poporder%in%tempdf$pop
		npops			<- length(popbool[popbool])
		mycolours		<- mysambar$colorder[popbool]
		}else{		
		tempdf			<- kindf[,c("pop3",kinshipscore)]
		colnames(tempdf)<- c("pop","kinscore")
		tempdf$poporder	<- factor(tempdf$pop,levels=c("between",mysambar$poporder2))
		tempdf			<- droplevels(tempdf[tempdf$pop%in%c("between",mysambar$populations),])
		popbool			<- mysambar$poporder%in%tempdf$pop
		npops			<- length(popbool[popbool])+1
		mycolours		<- c("black",mysambar$colorder[popbool])
		}
	#
	if(!is.null(export))
		{
		mywidth=0.75
		mywidth2=75
		plotname		<- ifelse(onlywithin,plotname,paste(plotname,"with_betweenpops",sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),width=npops*mywidth+2,height=9)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=npops*mywidth+2,height=9)}
		if(export=="png"){png(paste(plotname,"png",sep="."),width=npops*mywidth2+200,height=1000)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),width=npops*mywidth+2,height=9)}
		}
	par(oma=c(12.5,7,1,1),mar=c(5,0.5,0.5,0.5),cex.axis=3)
	ymin	<- 0.975*min(tempdf$kinscore,na.rm=TRUE)
	if(kinshipscore=="kingrobust"|kinshipscore=="kincoef")
		{
		ymax	<- 0.5
		}else{
		ymax	<- 1.025*max(tempdf$kinscore,na.rm=TRUE)
		}
	#		
	boxplot(tempdf$kinscore~tempdf$poporder,border=mycolours,col="grey90",las=2,xlab="",ylab="",cex.axis=2,pch=16,outline=FALSE,ylim=c(ymin,ymax))
	stripchart(kinscore~poporder,data=tempdf,vertical=TRUE,method="jitter",pch=16,cex=2,col=mycolours,bg="bisque",add=TRUE) 
	mtext(side=2,ylabel,line=yline,cex=2.75,outer=TRUE,las=0)
	if(kinshipscore=="kingrobust"|kinshipscore=="kincoef")
		{
		abline(h=0.5,lty=2)
		}
	if(kinshipscore=="k2")
		{
		abline(h=1,lty=2)
		}
	#mtext(side=1,"Sample",line=6.5,cex=1.75)
	if(!is.null(export)){dev.off()}
	}

plinkrelatedness<-function(silent=TRUE,infile="plink.kin.retainedinds.genome",infile2="plink.kin.allinds.genome",popnames=mysambar$populations,per_pop=FALSE,export=NULL,shortpop=NULL,legendcex=2.5)
	{
	setwd(mysambar$inputfilesdir)
	infile1present	<- file.exists(infile)
	infile2present	<- file.exists(infile2)
	if((!infile1present)&(!infile2present))
		{
		cat(paste("ERROR: SambaR could not find files ",infile," (specified by 'infile' argument) and ",infile2," (specified by 'infile2' argument) in the directory:",sep=""),sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	if(!infile1present)
		{
		cat(paste("WARNING: SambaR could not find file called ",infile," (specified by 'infile' argument) in directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		cat("Omitting 'Relatedness.plink.between' and 'Relatedness.plink.within' plots.",sep="\n")
		}else{
		ibd			<<- read.table(infile,header=TRUE)
		ibd$PI_HAT[!is.finite(ibd$PI_HAT)]	<<- NA
		}
	infile2present	<- file.exists(infile2)
	if(!infile2present)
		{
		cat(paste("WARNING: SambaR could not find file called ",infile2," (specified by 'infile2' argument) in directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		cat("Omitting 'Relatedness.plink.matrix' plot.",sep="\n")
		}else{
		ibd2		<<- read.table(infile2,header=TRUE)
		ibd2$PI_HAT[!is.finite(ibd2$PI_HAT)]	<<- NA
		}
	#
	# 26-04-2021:
	setwd(mysambar$sambardir)
	kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
	if(!dir.exists("Kinship"))
		{
		if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
		dir.create(file.path(kinshipdir))
		mysambar$kinshipdir	<<- kinshipdir
		setwd(kinshipdir)
		}else{
		setwd(kinshipdir)
		if(!silent){cat("Overwriting results in directory:",sep="\n")}
		cat(getwd(),sep="\n")	
		}
	#setwd(mysambar$QCdir)
	if(infile1present)
		{
		infilepopnames	<- unique(c(as.vector(ibd$FID1),as.vector(ibd$FID2)))
		if(any(!infilepopnames%in%popnames))
			{
			cat(paste("ERROR: Population names in FID1 and FID2 columns of the file '",infile,"' do not correspond with population names in inds dataset.",sep=""),sep="\n")
			return(cat("Please rerun PLINK on dataset currently used by SambaR, or alternatively edit population names in the input file.",sep="\n"))
			}
		infilepopnames	<- unique(c(ibd$FID1,ibd$FID2))
		ibd$bothpops	<- paste(ibd$FID1,ibd$FID2,sep="_")
		ibd$bothpops2	<- paste(ibd$FID1,ibd$FID2,sep="\n")
		ibd$diffpop		<- ibd$FID1!=ibd$FID2
		# mypairwise	<- as.vector(unique(ibd$bothpops[ibd$diffpop]))
		# mypairwise2	<- as.vector(unique(ibd$bothpops2[ibd$diffpop]))
		mypairwise		<- combn(popnames,m=2)
		mypairwise2		<- paste(mypairwise[1,],mypairwise[2,],sep="_")
		mypairwise3		<- paste(mypairwise[2,],mypairwise[1,],sep="_")
		mypairwise4		<- paste(mypairwise[1,],mypairwise[2,],sep="\n")
		npairwise		<- length(mypairwise2)
		# create combicolours colours:
		mypops			<- mysambar$populations
		npops			<- length(mypops)
		mycolours		<- mysambar$mycolours[1:npops]
		mypopcols		<- cbind(mypops,mycolours)
		combicoltable	<- combn(mycolours,m=2)	
		combitable		<- combn(mypops,m=2)
		combivector		<- paste(combitable[1,],combitable[2,],sep="_")	
		mycombitable	<- rbind(combivector,combitable,combicoltable)	
		mycolvector		<- vector()
		# define short population names:
		if(is.null(shortpop))
			{
			shortpop<-substr(mypops,1,2)
			}
		for(i in c(1:npairwise))
			{
			mycol1		<- mycombitable[4,i]
			mycol2		<- mycombitable[5,i]
			mycolfunc 	<- colorRampPalette(c(mycol1,mycol2))
			mycolvector[i]	<- mycolfunc(3)[2]
			}
		myvector		<- rep(NA,ncol(mycombitable))
		mycombitable	<- rbind(mycombitable,myvector)
		#
		# Plot relatedness between populations:
		cat("Plotting relatedness between populations...",sep="\n")	
		# Prepare plotting:
		if("vioplot" %in% rownames(installed.packages()) == FALSE){install.packages("vioplot",repos='http://cran.us.r-project.org')}
		library(vioplot)
		# Plot relatedness between different populations:	
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Relatedness.plink.between.pdf",width=npairwise*2.75,height=7)}	
			if(export=="pdf"){pdf("Relatedness.plink.between.pdf",width=npairwise*2.75,height=7)}
			if(export=="png"){png("Relatedness.plink.between.png",width=npairwise*200,height=720)}
			if(export=="wmf"){win.metafile("Relatedness.plink.between.wmf",width=npairwise*2.75,height=7)}
			}
		par(mar=c(7,5,2,2),cex.axis=1.75)
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npairwise+0.5),col="white",ylim=c(min(ibd$PI_HAT,na.rm=TRUE),max(ibd$PI_HAT,na.rm=TRUE)),xaxt="n",xlab="",ylab="")
		for (i in c(1:npairwise))
			{
			mypair		<- mypairwise2[i]
			mypair_rev	<- mypairwise3[i]
			mypair_label<- mypairwise4[i]
			mycol	<- mycolvector[which(combivector==mypair)]
			# cat(mypair,sep="\n")
			if(sum(ibd$PI_HAT[ibd$bothpops==mypair])==0)
				{
				boxplot(ibd$PI_HAT[(ibd$bothpops==mypair|ibd$bothpops==mypair_rev)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names="",col=mycol,ylab="",yaxt='n')
				}else{
				vioplot(ibd$PI_HAT[(ibd$bothpops==mypair|ibd$bothpops==mypair_rev)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names="",col=mycol)
				}
			}
		axis(side=1,at=seq(1,npairwise),labels=mypairwise4,lty=1,las=1,mgp=c(3,3,0))
		mtext("Pairwise population comparison",1,line=5,cex=2)
		mtext("proportion IBD",2,line=3,cex=2)
		if(!is.null(export)){dev.off()}	
		#
		# Plot relatedness within populations:
		cat("Plotting relatedness within populations...",sep="\n")	
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Relatedness.plink.within.pdf",width=npops*2.5,height=7)}	
			if(export=="pdf"){pdf("Relatedness.plink.within.pdf",width=npops*2.5,height=7)}
			if(export=="png"){png("Relatedness.plink.within.png",width=npops*120,height=720)}
			if(export=="wmf"){win.metafile("Relatedness.plink.within.wmf",width=npops*2.5,height=7)}
			}
		par(mar=c(4,5,2,2),cex.axis=1.75)
		plot(c(1:5),c(1:5),main="",xlim=c(0.5,npops+0.5),col="white",ylim=c(min(ibd$PI_HAT,na.rm=TRUE),max(ibd$PI_HAT,na.rm=TRUE)),xaxt="n",xlab="",ylab="")
		for (i in c(1:npops))
			{
			mypop	<- mypops[i]
			mycol	<- mycolours[i]
			if(sum(ibd$PI_HAT[ibd$FID1==mypop&!ibd$diff])==0)
				{
				boxplot(ibd$PI_HAT[(ibd$FID1==mypop&!ibd$diff)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names=mypop,col=mycol,ylab="",yaxt='n')
				}else{
				vioplot(ibd$PI_HAT[(ibd$FID1==mypop&!ibd$diff)&!is.na(ibd$PI_HAT)],at=i,add=TRUE,names=mypop,col=mycol)
				}
			}
		axis(side=1,at=seq(1,npops),labels=mypops,lty=1,las=1,mgp=c(3,1,0))
		mtext("Population",1,line=2.5,cex=2)
		mtext("proportion IBD",2,line=3,cex=2)
		if(!is.null(export)){dev.off()}	
		#
		# Plot relatedness per sample:
		cat("Plotting relatedness per sample...",sep="\n")
		indstemp	<- inds[order(as.character(inds$pop)),]
		mycols	<- as.vector(indstemp$popcol[indstemp$filter])
		myinds	<- as.vector(indstemp$name[indstemp$filter])
		myindnrs<- indstemp$nr[indstemp$filter]
		ninds	<- length(myinds)
		#mypops	<- as.vector(unique(inds$pop[indstemp$filter]))
		mypops	<- mysambar$populations
		mypops2<- as.vector(indstemp$pop[indstemp$filter])
		npops	<- length(mypops)
		mylocs	<- vector()
		for (i in c(1:length(popnames)))
			{
			mypop		<- popnames[i]
			temppop		<- indstemp$pop[indstemp$filter]
			mylocs[i]	<- which(temppop==mypop)[1]-0.5
			}
		mylocs2	<- mylocs[2:length(mylocs)]
		graphics.off()
		if(!is.null(export))
			{
			if(export=="eps"){postscript("Relatedness.plink.persample.pdf",width=14,height=10)}	
			if(export=="pdf"){pdf("Relatedness.plink.persample.pdf",width=14,height=10)}
			if(export=="png"){png("Relatedness.plink.persample.png",width=14,height=720)}
			if(export=="wmf"){win.metafile("Relatedness.plink.persample.wmf",width=14,height=10)}
			}
		par(mfrow=c(npops,1),mar=c(0.5,5,0.5,0.5),oma=c(5,1,3,2),cex.lab=2.5,cex.main=2.5)
		for(j in c(1:npops))
			{
			mypop	<- mypops[j]
			plot(c(1:5),c(1:5),main="",xlim=c(0.5,ninds+0.5),col="white",ylim=c(min(ibd$PI_HAT),max(ibd$PI_HAT)),xaxt="n",xlab="",ylab="")
			for (i in c(1:ninds))
				{
				myind	<- myinds[i]
				mynr	<- myindnrs[i]
				mypop2	<- mypops2[i] 
				mycol	<- mycols[i]
				myibd	<- ibd[(ibd$IID1==myind|ibd$IID2==myind),]
				myibd	<- myibd[(myibd$FID1==mypop&myibd$FID2==mypop2)|(myibd$FID1==mypop2&myibd$FID2==mypop),]
				boxplot(myibd$PI_HAT[!is.na(myibd$PI_HAT)],at=i,add=TRUE,names=mynr,col=mycol,border=mycol,ylab="",yaxt='n')
				}
			abline(v=mylocs2,lwd=1)
			if(npops>5)
				{
				mtext(shortpop[j],side=4,line=1,cex=1.5)
				}else{
				mtext(popnames[j],side=4,line=1,cex=1.5)
				}
			if(j==1)
				{
				if(npops>5)
					{
					mtext(text=shortpop,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)
					}else{
					mtext(text=popnames,side=3,line=0.5,at=mylocs,adj=0,cex=1.5)
					}
				}
			}
		mtext("proportion IBD",side=2,line=-2,outer=TRUE,cex=2)
		axis(side=1,at=seq(1,ninds),labels=myindnrs,lty=1,las=1,mgp=c(3,1,0),cex=0.75,las=2)
		mtext("Individuals",side=1,line=3,outer=TRUE,cex=2)
		if(!is.null(export)){dev.off()}
		}
	# matrix:
	if(infile2present)
		{
		# 22-03-2022: removed following lines:
		# infilepopnames	<- unique(c(as.vector(ibd2$FID1),as.vector(ibd2$FID2)))
		# if(any(!infilepopnames%in%popnames))
		#	{
		#	cat(paste("ERROR: Population names in FID1 and FID2 columns of the file '",infile2,"' do not correspond with population names in inds dataset.",sep=""),sep="\n")
		#	return(cat("Please rerun PLINK on dataset currently used by SambaR, or alternatively edit population names in the input file.",sep="\n"))
		#	}
		cat("Plotting matrix...",sep="\n")
		myscores					<- ibd2$PI_HAT
		myscores[is.na(myscores)]	<- 0	# This is necessary to circumvent errors when running plot_indmatrix()
		plot_indmatrix(export="pdf",perpop=per_pop,inputvalues=myscores,popnames=mysambar$populations,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="Relatedness (pi_hat)",plotprefix="Relatedness.plink.matrix.5bins",currentdir=TRUE)	
		plot_indmatrix(export="pdf",perpop=per_pop,inputvalues=myscores,popnames=mysambar$populations,n_bins=8,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="Relatedness (pi_hat)",plotprefix="Relatedness.plink.matrix.8bins",currentdir=TRUE)	
		}
	cat("File(s) called 'Relatedness.plink' has/have been exported to the directory:",sep="\n")
	cat(mysambar$QCdir,sep="\n")
	setwd(mysambar$inputdatadir)
	}

ReadGRMBin<-function(prefix, AllN=F, size=4)
	{
	sum_i			<- function(i){return(sum(1:i))}
	BinFileName		<- paste(prefix,".grm.bin",sep="")
	NFileName		<- paste(prefix,".grm.N.bin",sep="")
	IDFileName		<- paste(prefix,".grm.id",sep="")
	id 				<- read.table(IDFileName)
	n				<- dim(id)[1]
	BinFile			<- file(BinFileName, "rb");
	grm				<- readBin(BinFile, n=n*(n+1)/2, what=numeric(0), size=size)
	NFile			<- file(NFileName, "rb");
	if(AllN==T)
		{
		N			<- readBin(NFile, n=n*(n+1)/2, what=numeric(0), size=size)
		}else{
		N			<- readBin(NFile, n=1, what=numeric(0), size=size)
		i			<- sapply(1:n, sum_i)
		return(list(diag=grm[i], off=grm[-i], id=id, N=N))
		}
	}	

# requires ReadGRMBin
# Note that GCTA needs to be run on all individuals, also once not retained by SambaR	
do_gctamatrix<-function(gctaprefix=NULL,use_currentdir=FALSE,legendcex=2.5)
	{
	# This function expects as input the base name of gcta output files.
	# 3 input files expected, ending on .grm.bin, .grm.id, grm.N.bin
	if(is.null(gctaprefix))
		{
		return(cat("ERROR: provide a name to gctaprefix argument (i.e. base name of input files). Default is NULL.",sep="\n"))
		}
	if(!use_currentdir)
		{
		setwd(mysambar$inputfilesdir)
		}
	cat("Searching for input files in directory:",sep="\n")
	cat(getwd(),sep="\n")
	cat("If you want to search within the working directory, set the flag currentdir to TRUE.",sep="\n")
	gctadata 						<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
	#mymatrix[upper.tri(mymatrix)] 	<- gctadata$off
	#mynames 						<- as.character(gctadata$id[,2])
	#mynames2 						<- gsub(".verysens.q20.1hit.conc","",mynames)
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		kinshipdir	<- paste(mysambar$sambardir,"Kinship",sep="/")
		if(!dir.exists("Kinship"))
			{
			if(!silent){cat("Creating output folder called 'Kinship'.",sep="\n")}
			dir.create(file.path(kinshipdir))
			mysambar$kinshipdir	<<- kinshipdir
			setwd(kinshipdir)
			}else{
			setwd(kinshipdir)
			if(!silent){cat("Overwriting results in directory:",sep="\n")}
			cat(getwd(),sep="\n")	
			}
		}
	plot_indmatrix(export="pdf",inputvalues=gctadata$off,popnames=mysambar$populations,n_bins=5,legpos_x=0.1,legpos_y=0.45,leg_cex=legendcex,matcol="orange",plottitle="Relatedness",plotprefix="GCTAmatrix",currentdir=TRUE)	
	if(!use_currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}

# requires ReadGRMBin:
# 02-12-2019: assumes all individuals are included
# 31-01-2020: I edited some lines, not sure if it works (better) now
# 09-03-2020: depreciated. Use do_gctamatrix instead.
do_gctamatrix_feb2020<-function(export=NULL,gctaprefix=NULL,inputvalues=NULL,popnames=mysambar$populations,n_bins=5,currentdir=FALSE,legpos_x=0.1,legpos_y=0.35,matcol="orange",plotprefix="GCTAmatrix")
	{
	if(is.null(inputvalues))
		{
		if(is.null(gctaprefix))
			{
			return(cat("ERROR: provide a name to gctaprefix argument (i.e. base name of input files). Default is NULL.",sep="\n"))
			}
		if(!currentdir)
			{
			setwd(mysambar$inputfilesdir)
			}
		cat("Searching for input files in directory:",sep="\n")
		cat(getwd(),sep="\n")
		cat("If you want to search within the working directory, set the flag currentdir to TRUE.",sep="\n")
		gctadata 		<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
		}
	# metapop:
	indstemp		<- inds
	nind			<- nrow(indstemp)
	mymatrix 		<- matrix(NA,nrow=nind,ncol=nind)
	if(is.null(inputvalues))
		{
		mymatrix[upper.tri(mymatrix)] 	<- gctadata$off
		mynames 						<- as.character(gctadata$id[,2])
		mynames2 						<- gsub(".verysens.q20.1hit.conc","",mynames)
		}else{
		mymatrix[upper.tri(mymatrix)] 	<- round(inputvalues,3)
		mynames2						<- as.character(inds$nr)							
		}
	gctamatrix				<- mymatrix
	colnames(gctamatrix)	<- mynames2
	rownames(gctamatrix)	<- mynames2
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(gctamatrix,na.rm=TRUE),1)
	if(max(gctamatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(gctamatrix,na.rm=TRUE),1)
		}
	binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
	mybreaks	<- seq(mymin,mymax,binsize)
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	gctamatrix_reordered<- gctamatrix[order(indstemp$pop),order(indstemp$pop)]
	inds_all			<- inds_reordered
	inds_all$filter		<- TRUE
	#
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.no_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.with_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	# filtered:
	gctafiltermat	<- gctamatrix_reordered[inds_reordered$filter,inds_reordered$filter]
	inds_all		<- inds_reordered[inds_reordered$filter,]
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,"metapop.filter.no_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_all,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,"metapop.filter.with_axis",sep="."),mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	#
	# for each population:
	for (mypop in popnames)
		{
		gctapop		<- gctamatrix[inds$filter&inds$pop==mypop,inds$filter&inds$pop==mypop]
		indspop		<- inds[inds$filter&inds$pop==mypop,]
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste(plotprefix,mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste(plotprefix,mypop,"with_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		}
	if(!is.null(export))
		{
		cat("Matrix heatmaps have been exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	cat("Note that the position of the legend can be editted with the 'legpos_x' and 'legpos_y'. Default is respectively 0.1 and 0.35.",sep="\n")
	cat("The colour tone of the matrix can be editted with the argument 'matcol'. Default is 'orange'.",sep="\n")
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}

# requires ReadGRMBin:
# 02-12-2019: assumes all individuals are included
do_gctamatrix_old<-function(export=NULL,gctaprefix=NULL,popnames=mysambar$populations,n_bins=5,currentdir=FALSE,legpos_x=0.1,legpos_y=0.35,matcol="orange")
	{
	if(is.null(gctaprefix))
		{
		return(cat("ERROR: provide a name to gctaprefix argument (i.e. base name of input files). Default is NULL.",sep="\n"))
		}
	if(!currentdir)
		{
		setwd(mysambar$inputfilesdir)
		}
	gctadata 		<<- ReadGRMBin(prefix=gctaprefix, AllN=F, size=4)
	# metapop:
	nind			<- nrow(inds)
	indstemp		<- inds
	indstemp$filter	<- TRUE
	mymatrix 		<- matrix(NA,nrow=nind,ncol=nind)
	mymatrix[upper.tri(mymatrix)] <- gctadata$off
	gctamatrix		<- mymatrix
	mynames 		<- as.character(gctadata$id[,2])
	mynames2 		<- gsub(".verysens.q20.1hit.conc","",mynames)
	colnames(gctamatrix)	<- mynames2
	rownames(gctamatrix)	<- mynames2
	#
	# get same scale for each pop:
	floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
	ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
	mymin		<- floor_dec(min(gctamatrix,na.rm=TRUE),1)
	if(max(gctamatrix,na.rm=TRUE)==1)
		{
		mymax	<- 1
		}else{
		mymax	<- ceiling_dec(max(gctamatrix,na.rm=TRUE),1)
		}
	binsize		<- ifelse(is.null(n_bins),(mymax-mymin)/10,(mymax-mymin)/n_bins)
	mybreaks	<- seq(mymin,mymax,binsize)
	#
	if(!currentdir)
		{
		setwd(mysambar$divergencedir)
		}
	#
	# metapop:
	# First create indstemp file with all samples clustered together per population:
	inds_reordered		<- indstemp[order(indstemp$pop),]
	gctamatrix_reordered<- gctamatrix[order(indstemp$pop),order(indstemp$pop)]
	# Ready to plot:
	# non filtered:
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=FALSE,exportname="GCTAmatrix.metapop.no_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctamatrix_reordered,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=TRUE,exportname="GCTAmatrix.metapop.with_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)		
	# filtered:
	gctafiltermat	<- gctamatrix_reordered[inds_reordered$filter,inds_reordered$filter]
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=FALSE,exportname="GCTAmatrix.metapop.filter.no_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctafiltermat,my_inds=inds_reordered,my_snps=snps,my_col=matcol,addlab=TRUE,exportname="GCTAmatrix.metapop.filter.with_axis",mytitle="Relatedness",myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
	#
	# for each population:
	for (mypop in popnames)
		{
		gctapop		<- gctamatrix[inds$filter&inds$pop==mypop,inds$filter&inds$pop==mypop]
		indspop		<- inds[inds$filter&inds$pop==mypop,]
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=FALSE,exportname=paste("GCTAmatrix",mypop,"no_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		do_heatmap(export_type=export,nbins=n_bins,mymatrix=gctapop,my_inds=indspop,my_snps=snps,my_col=matcol,addlab=TRUE,exportname=paste("GCTAmatrix",mypop,"with_axis",sep="."),mytitle=mypop,myBreaks=mybreaks,legposx=legpos_x,legposy=legpos_y)
		}
	if(!is.null(export))
		{
		cat("Matrix heatmaps have been exported to:",sep="\n")
		cat(getwd(),sep="\n")
		}
	cat("Note that the position of the legend can be editted with the 'legpos_x' and 'legpos_y'. Default is respectively 0.1 and 0.35.",sep="\n")
	cat("The colour tone of the matrix can be editted with the argument 'matcol'. Default is 'orange'.",sep="\n")
	if(!currentdir)
		{
		setwd(mysambar$sambardir)
		}
	}
		

# End of kinship analyses
##############################################################################################################








###############################################################################################################
# Population demography analyses

stairway_addgeo<-function()
        {
        #Flooding of Doggerland:
        polygon(x=c(6200,6500,6500,6200),y=c(100,100,200000,200000),col="grey60",border=NA)
        #Younger Dryas:
        polygon(x=c(11700,12900,12900,11700),y=c(100,100,200000,200000),col="grey55",border=NA)
        #LGM:
        polygon(x=c(16000,31000,31000,16000),y=c(100,100,200000,200000),col="grey50",border=NA)
        }

addlabels<-function(yaxis=TRUE)
        {
		axis(1, at=c(0,100,1000,10000,100000),labels=c(0,0.1,1,10,100),las=1)
		if(yaxis)
                {
                axis(2, at=c(0,1000,2000,3000,4000,5000,10000,20000,30000,40000,50000),labels=c(0,1,2,3,4,5,10,20,30,40,50),las=1)
                }
        }

# The next function depends on addgeo and addlabels
# It expects to find within the Demography directory files outputted by the Stairway_plot executable, one for each of your population.
# These files should have as prefix the name of your population (as defined in the populations vector) and as suffix: '.final.summary'. 

run_plotstairway<-function(mu_rate="2.5e-8",Gtime="20",x_range=c(100,100000),add_settings=TRUE,exporttype="pdf",pop_names=mysambar$populations,my_colours=mysambar$mycolours,my_suffix=NULL,add_glacials=FALSE)
	{
	setwd(mysambar$demographydir)
	if(is.null(my_suffix))
		{
		my_suffix	<- "final.summary" 
		}
	for (i in c(1:length(pop_names)))
		{
		# read data:
		mypop		<- pop_names[i]
		myfile		<- paste(mypop,my_suffix,sep=".")
		if(!file.exists(myfile))
			{
			cat(paste("ERROR: SambaR couldn't find the file ",myfile,". It expects to find this file within the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			cat("The file names should be your population name (as currently defined in SambaR) and the suffix defined by the my_suffix flag, seperated by a period (.).",sep="\n")
			cat("If my_suffix is set to NULL (default), SambaR expects the suffix to be 'final.summary'.",sep="\n")
			cat("By default, SambaR expects to find input files for all these populations:",sep="\n")
			cat(mysambar$populations,sep="\n")
			cat("By default, it assigns the following colours:",sep="\n")
			cat(mysambar$mycolours[1:length(pop_names)],sep="\n")
			return(cat("You can exclude one or more populations by defining the desired populations and colours with the 'pop_names' and 'my_colours' flags.",sep="\n"))
			}
		}
	plotstairway(logscale="",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="x",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="y",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="xy",u_rate=mu_rate,gen_time=Gtime,addsettings=add_settings,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	# grayscale:
	plotstairway(logscale="",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="x",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="y",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	plotstairway(logscale="xy",u_rate=mu_rate,gen_time=Gtime,grayscale=TRUE,addsettings=FALSE,xrange=x_range,export=exporttype,mycolours=my_colours,mysuffix=my_suffix,popnames=pop_names,addglacials=add_glacials)
	}
	
plotstairway<-function(u_rate="2.5e-8",gen_time="20",mysuffix=NULL,grayscale=FALSE,logscale="xy",addsettings=TRUE,popnames=mysambar$populations,export=NULL,addglacials=FALSE,mycolours=mysambar$mycolours,xrange=NULL)
	{
	# Note: u_rate and gen_time are just used as label. They don't affect the plot itself. 
	# This function expects to find inputfiles subdirectory output from stairwayplot software:	
	if(grayscale)
		{
		mycolours=rep("grey70",length(mysambar$populations))
		}
	setwd(mysambar$demographydir)
	if(is.null(mysuffix))
		{
		mysuffix	<- "final.summary" 
		}
	mylist			<<- list()
	mymaxall		<- 0
	myminall		<- 100000
	for (i in c(1:length(popnames)))
		{
		# read data:
		mypop		<- popnames[i]
		myfile		<- paste(mypop,mysuffix,sep=".")
		#cat(myfile,sep="\n")
		if(!file.exists(myfile))
			{
			cat(paste("ERROR: SambaR couldn't find the file ",myfile,". It expects to find this file within the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")
			cat("Replace or rename your files.",sep="\n")
			cat("The file names should be your popname (as currently defined in SambaR) followed by the suffix defined by the mysuffix flag.",sep="\n")
			return(cat("If mysuffix is set to NULL (default), SambaR expects the suffix to be 'final.summary'.",sep="\n"))
			}
		mylist[[i]] <<- read.table(paste(mypop,mysuffix,sep="."),header=TRUE)
		mymax		<- max(mylist[[i]]$Ne_97.5.)
		mymaxall	<- ifelse(mymax>mymaxall,mymax,mymaxall)
		mymin		<- min(mylist[[i]]$Ne_2.5.)
		myminall	<- ifelse(mymin<myminall,mymin,myminall)
		}
	npops		<- length(popnames)
	# linear scale or log scale?
	if(logscale=="y"|logscale=="")
        	{
			if(!is.null(xrange))
				{
				cat(paste("Using",xrange[1],"and",xrange[2],"as minimum and maximum values for the x axis.",sep=" "),sep="\n")
				myxaxis	<- xrange 				
				}else{
				cat("No range of x-axis defined for non-logarithmic x-axis.",sep="\n")
				cat("Defaults to xmin = 500 and xmax = 35000.",sep="\n")
				cat("Use xrange flag (i.e. xrange=c(500,35000)) to adjust.",sep="\n")
				myxaxis	<- c(500,35000)
				}
			}else{
        	if(!is.null(xrange))
				{
				cat(paste("Using",xrange[1],"and",xrange[2],"as minimum and maximum values for the x axis.",sep=" "),sep="\n")
				myxaxis	<- xrange 				
				}else{
				cat("No range of x-axis defined for logarithmic x-axis.",sep="\n")
				cat("Defaults to xmin = 500 and xmax = 35000.",sep="\n")
				cat("Use xrange flag (i.e. xrange=c(500,35000)) to adjust.",sep="\n")
				myxaxis	<- c(500,35000)
				}
		   	}
	myymax	<- mymaxall
	myymin	<- ifelse((logscale=="x"|logscale==""),0,ifelse(myminall<1000,1000,myminall))
	#
	# Plot:
	graphics.off()
	if(!is.null(export))
		{
		mywidth		<- npops*5.5
		mywidth2	<- npops*550
		mystring	<- ifelse(logscale=="xy","log_xy",ifelse(logscale=="x","log_x",ifelse(logscale=="y","log_y","linear")))
		mycolset	<- ifelse(grayscale,"grayscale","colour")
		if(export=="eps"){postscript(paste("stairwayplot",mystring,mycolset,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		if(export=="pdf"){pdf(paste("stairwayplot",mystring,mycolset,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		if(export=="png"){png(paste("stairwayplot",mystring,mycolset,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste("stairwayplot",mystring,mycolset,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=7)}
		}
	par(mfrow=c(1,length(popnames)),cex.axis=2.5,cex.lab=2,oma=c(2,6,2,2),mar=c(4,1,4,0))
	for (i in c(1:length(popnames)))
		{
		# first create plot outline:
		plot(mylist[[1]]$year,mylist[[1]]$Ne_97.5,type="l",log=logscale,xlab="",ylab="Ne (1k individuals)",las=1,yaxt="n",xaxt="n",col="white",main=NULL,xlim=myxaxis,ylim=c(myymin,myymax))
		mypop		<- popnames[i]
		if(i==1)
			{
			mtext("Time (kya)",side=1,cex=2.5,outer=TRUE)
			mtext("Ne (1k individuals)",2,line=4,cex=2.5)
			#mtext("Historic effective population sizes",cex=1.25,side=3,line=-1,outer=TRUE)
			if(addsettings)
				{
				mtext(paste("Generation time =",gen_time,"years; Mutation rate =",u_rate,"(per site per generation)",sep=" "),line=-2,outer=TRUE,cex=2.5)
				}
			#addlabels()
			if(logscale=="y"|logscale=="xy")
				{
				#axis(2, at=c(0,1000,2000,3000,4000,5000,10000,20000,30000,40000,50000),labels=c(0,1,2,3,4,5,10,20,30,40,50),las=1)
				if(max(mylist[[i]]$Ne_87.5,na.rm=TRUE)<2000)
					{
					cat("Using smaller y-scale.",sep="\n")
					axis(2, at=c(0,100,200,500,1000,2000),labels=c(0,0.1,0.2,0.5,1,2),las=1)
					}else{
					cat("Using larger y-scale.",sep="\n")
					axis(2, at=c(0,500,1000,2500,5000,10000,25000,50000),labels=c(0,0.5,1,2.5,5,10,25,50),las=1)
					}
				}else{
				ystep	<- ifelse(myymax>20000,ifelse(myxaxis[2]>50000,25000,10000),5000)
				xlabels	<- seq(0,myymax,ystep)
				axis(2,at=xlabels,labels=xlabels/1000,las=1)
				}
			}
		#addlabels(yaxis=FALSE)
		if(logscale=="y"|logscale=="")
        	{
			xstep	<- ifelse(myxaxis[2]>20000,ifelse(myxaxis[2]>50000,25000,10000),5000)
			xlabels	<- seq(0,myxaxis[2],xstep)
			axis(1,at=xlabels,labels=xlabels/1000)
			}else{
			axis(1, at=c(0,100,1000,10000,100000),labels=c(0,0.1,1,10,100),las=1)
			}
		if(addglacials)
			{
			stairway_addgeo()
			}
		# now add data:
		polygon(x=c(mylist[[i]]$year,rev(mylist[[i]]$year)),y=c(mylist[[i]]$Ne_2.5,rev(mylist[[i]]$Ne_97.5)),col=mycolours[i],border=NA) 
		points(mylist[[i]]$year,mylist[[i]]$Ne_median,type="l",lwd=1)
		points(mylist[[i]]$year,mylist[[i]]$Ne_87.5,type="l",lty=3,lwd=1)
		points(mylist[[i]]$year,mylist[[i]]$Ne_12.5,type="l",lty=3,lwd=1)
		mtext(mypop,side=3,line=-3,cex=2.5)
		}
	if(!is.null(export))
		{
		dev.off()
		cat(paste("A file called 'stairwayplot.",mystring,"' has been exported to a the 'Demography' directory.",sep=""),sep="\n")
		}
	setwd(mysambar$inputdatadir)
	}
	
# End of population demography analyses 
###############################################################################################################

	
	


###############################################################################################################
# Selection analyses

# Another not explored option, for phased data I suppose: R package rEHH
selectionanalyses<-function(export="pdf",do_meta=TRUE,plothisto=TRUE,dopiechart=TRUE,signlevel=0.05,do_pairwise=FALSE,do_pheno=FALSE,onlypooled=TRUE,add_bayescan=FALSE,bayescanFDR=0.01,overwrite_bayescan=FALSE,phenolabels=c("pheno1","pheno2"),do_lk=FALSE,do_pcadapt=TRUE,do_outflank=TRUE,do_fsthet=FALSE,bayescan_mapfile=NULL,silent=TRUE,pcadaptped=FALSE,overwriteped=TRUE,do_thin=FALSE,gwdsbinsize=1000000,my_correction="bonferroni",doplotvenn=TRUE,authors=NULL,species=NULL,selclaim=NULL,demography=NULL,ngenerations=NULL,geneflow=NULL,datainfo=NULL,controldata=FALSE,logp_max=NULL,export_data=FALSE)
	{
	if(!silent){cat("Checking settings...",sep="\n")}
	mysambar$pcadapt_error<<-FALSE
	if(do_meta)
		{
		if(!do_pcadapt)
			{
			return(cat("ERROR: The flag 'do_pcadapt' should be set to TRUE if the flag do_meta is set to TRUE.",sep="\n"))
			}
		}
	if(!is.null(my_correction))
		{
		if(my_correction!="holm"&my_correction!="bonferroni"&my_correction!="BH")
			{
			return(cat("ERROR: my_correction should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}
		}
	if(do_pheno)
		{
		if(!is.logical(inds$type))
			{
			return(cat("ERROR: column inds$type is not a logical vector (i.e. TRUE or FALSE values).",sep="\n"))
			}else{
			if(length(as.vector(unique(inds$type)))!=2)
				{
				return(cat("ERROR: number of classes defined in inds$type column does not equal 2.",sep="\n"))
				}
			}
		}
	if(!silent){cat("Checking input data...",sep="\n")}
	# my_correction can be 'holm', 'bonferroni', and 'BH' (Benjamini-Hochberg) or NULL (default)
	# if NULL, selection scans will be run with a correction method which have proved to give best results in the past
	#
	if(!"filter"%in%colnames(inds))
		{
		return(cat("ERROR: column inds$filter absent. Run the filterdata() function and try again.",sep="\n"))
		# This would lead to error message: Error in 1:nLoc(x) : NA/NaN argument.
		# a quick and dirty way of working around this would be to type:
		# inds$filter[is.na(inds$filter)]	<- FALSE
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column inds$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(!"filter"%in%colnames(snps))
		{
		cat("ERROR: column snps$filter absent.",sep="\n")
		return(cat("(Re)run the filterdata() function and try again.",sep="\n"))
		}else{
		if(any(is.na(inds$filter)))
			{
			return(cat("ERROR: The column snps$filter contains NA-values, which are not allowed.",sep="\n"))
			}
		}
	if(any(!row.names(as.matrix(mygenlight))==as.vector(inds$name)))
		{
		return(cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	if(!silent){cat("Checking pcadapt installation...",sep="\n")}
	if(do_pcadapt)
		{
		if("pcadapt" %in% rownames(installed.packages()) == FALSE)
			{
			cat("ERROR: The package 'pcadapt' is not installed on your computer. You have two options:",sep="\n")
			cat("Option 1: run selectionanalyses without pcadapt by setting the do_pcadapt flag to false, i.e.: selectionanalyses(do_pcadapt=FALSE).",sep="\n")
			return(cat("Option 2: try to install pcadapt 4.1.0 by running: getpackages(do_pcadapt=TRUE).",sep="\n"))
			}else{
			if(packageDescription("pcadapt")$Version!="4.1.0"&pcadaptped)
				{
				cat("ERROR: SambaR needs pcadapt version 4.1.0. You have another version of pcadapt installed on your computer. You have two options:",sep="\n")
				cat("Option 1: run selectionanalyses without pcadapt by setting the do_pcadapt flag to false, i.e.: selectionanalyses(do_pcadapt=FALSE).",sep="\n")
				return(cat("Option 2: try to install pcadapt 4.1.0 by running: getpackages(do_pcadapt=TRUE).",sep="\n"))
				}
			if("pcadapt" %in% (.packages()) == FALSE)
				{
				cat("Loading pcadapt...",sep="\n")
				library("pcadapt")
				}
			}
		}
	if(!silent){cat("Checking OutFLANK installation...",sep="\n")}
	if(do_outflank)
		{
		if("OutFLANK" %in% rownames(installed.packages()) == FALSE)
			{
			cat("ERROR: the package 'OutFLANK' is not installed on your computer. You have two options:",sep="\n")
			cat("Option 1: run selectionanalyses without pcadapt by setting the do_outflank flag to false, i.e.: selectionanalyses(do_outflank=FALSE).",sep="\n")
			return(cat("Option 2: try to install OutFLANK by running: getpackages(do_github=TRUE).",sep="\n"))
			}else{
			if("OutFLANK" %in% (.packages()) == FALSE)
				{
				cat("Loading OutFLANK...",sep="\n")
				library("OutFLANK")
				}
			}
		}
	# check whether bayescan output files are provided if needed:
	setwd(mysambar$inputfilesdir)
	# mybayefiles <- list.files(pattern = "\\.bayescanout.fst$")
	# 06-01-2023:
	mybayefiles	<- list.files(pattern = ".*.bayescanout.fst")
	if(length(mybayefiles)<1&add_bayescan)
		{
		cat("ERROR: the inputfiles directory does not contain files with the extension 'bayescanout.fst'.",sep="\n")
		return(cat("Either set the flag 'add_bayescan' to FALSE or place bayescan output files in the inputfiles directory (see Sambar manual for more details).",sep="\n"))
		}
	#
	my_devices	<- dev.list()
	n_devices	<- length(my_devices)
	if(n_devices!=0)
		{
		cat("Closing open devices...",sep="\n")
		my_devices	<- dev.list()
		for(k in rev(my_devices))
			{
			dev.off(k)
			}
		}
	#
	setwd(mysambar$selectiondir)
	cat("REMINDER: if you receive an error stating 'cannot open file' (without the addition 'No such file or directory') this is likely because the file is opened in another file viewer.",sep="\n")
	cat("If so, close the relevant file in the file viewer and try again.",sep="\n")
	if(!silent){cat("run_locusWCfst",sep="\n")}
	run_locusWCfst(doplot=FALSE,silent=silent)	# in case calcdistance() hasn't been executed yet.
	if(do_meta)
		{
		metapopdir		<- paste(mysambar$selectiondir,"metapop",sep="/")
		setwd(mysambar$selectiondir)
		if(!dir.exists("metapop"))
			{
			cat("Creating output folder called 'metapop'.",sep="\n")
			dir.create(file.path(metapopdir))
			setwd(metapopdir)
			}else{
			setwd(metapopdir)
			cat("Overwriting results in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		cat("Executing selection analyses for the metapopulation.",sep="\n")
		if(do_pcadapt)
			{
			cat("Running PCadapt...",sep="\n")
			if(pcadaptped)
				{
				setwd(mysambar$inputfilesdir)			
				if(!file.exists("metapop.filter2.miss0.letter.ped")|overwriteped)
					{
					cat("Creating PED and MAP file...",sep="\n")
					exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="metapop.filter2.miss0.letter",geno_nr=FALSE,do_all=FALSE)
					}else{
					cat("WARNING: Using existing PED and MAP file...",sep="\n")
					cat("If want to create new files (e.g. because of new filter settings) set the flag 'overwriteped' of the selectionanalyses function to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")  
					}
				setwd(metapopdir)
				}
			runPCadapt(my_dataset="metapop",my_sign_level=signlevel,mycorrection=my_correction,currentdir=TRUE,importped=pcadaptped)
			if(mysambar$pcadapt_error){return(cat("Aborting selectionanalyses run because of PCadapt error.",sep="\n"))}
			}else{
			cat("Skipping PCadapt because do_pcadapt flag is set to FALSE.",sep="\n")
			}
		if(do_lk)
			{
			# 16-10-2021: still under construction and not yet usable:
			# Lewontin-Krakauer test:
			LKtest()
			# Extended LK-test:
			FLKtest()
			}
		if(do_outflank)
			{
			cat("Running OutFLANK...",sep="\n")
			cat("If OutFLANK throws an error, set the flag do_outflank to FALSE.",sep="\n")
			setwd(metapopdir)
			runOutflank(my_dataset="metapop",my_sign_level=signlevel,mycorrection=my_correction,currentdir=TRUE)
			}
		if(do_fsthet)
			{
			setwd(mysambar$inputfilesdir)
			# Note: inputdatadir!! not inputfilesdir
			genepopfile 	<- list.files(pattern = "genepop")
			if(length(genepopfile)==0)
				{
				cat("WARNING: No file with the extension 'genepop' found in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				cat("The fsthet software needs a genepop file (same input as your ped and map file, but in different format) as input and will therefore be omitted.",sep="\n")
				setwd(metapopdir)
				#cat("Creating input file for fsthet...",sep="\n")
				#genlight2genepop(input=mygenlight,overwritefile=FALSE,snpsfilter=rep(TRUE,nrow(snps)),indsfilter=rep(TRUE,nrow(SNPS)),addcomma=TRUE,doexport=TRUE) 
				}else{
				cat("Running fsthet...",sep="\n")
				cat("Just so you know: fsthet is very slow compared to GWDS, PCadapt and OutFLANK.",sep="\n")
				cat("If you run into an error or the software takes forever, rerun the selectionanalyses function with the flag do_fsthet set to FALSE.",sep="\n")
				runfsthet(export=TRUE,dataset="metapop",reps=10,fstmethod="betahat",doanalysis=TRUE,my_sign_level=signlevel,currentdir=TRUE)
				}
			}
		setwd(metapopdir)
		cat("Generating Fdist plot...",sep="\n")
		Fdist_plot(my_dataset="metapop",showlegend=TRUE,showlabels=FALSE,exporttype="pdf",axislabels=TRUE,add_borders=FALSE,add_outliers=TRUE,dothin=TRUE)
		Fdist_plot(my_dataset="metapop",showlegend=FALSE,showlabels=FALSE,exporttype="pdf",axislabels=TRUE,add_borders=FALSE,add_outliers=FALSE,dothin=TRUE)
		# plot_scanlog(doexport="pdf",addGWDS=FALSE,addPCadapt=TRUE,add_outflank=do_outflank,addbayescan=add_bayescan,mydataset="metapop",outflankq=FALSE,markoutpheno=FALSE)
		cat("Plotting -log of locus specific p-values outputted by the selection scan(s)...",sep="\n")
		plot_scanlog(doexport="pdf",mydataset="metapop",outflankq=TRUE,markoutpheno=FALSE)
		cat("2D-plots metapop...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset="metapop",logpmax=logp_max)
		if(doplotvenn)
			{
			cat("Creating Venn diagram...",sep="\n")
			plot_venn(my_dataset="metapop")
			}else{
			cat("Skipping Venn diagram because the flag doplotvenn is set to FALSE.",sep="\n")
			}
		if(dopiechart)
			{
			cat("Creating piecharts of minor allele frequencies...",sep="\n")
			cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
			multipiemaf(my_dataset="metapop",do_export=TRUE)
			if(do_outflank|do_pcadapt)
				{
				cat("Combining all test scan piecharts into one plot...",sep="\n")
				cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
				allscans_piemaf(my_dataset="metapop",do_export=TRUE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5,addtestnames=FALSE)
				}
			}else{
			cat("Skipping piecharts because the flag 'dopiechart' is set to FALSE.",sep="\n")
			}
		cat("Writing outliers to bed files...",sep="\n")	
		writebed(my_dataset="metapop")
		cat("Writing outlier info...",sep="\n")
		outlierinfo(mydataset="metapop",control_data=controldata,my_authors=authors,my_species=species,sel_claim=selclaim,my_demo=demography,n_gen=ngenerations,my_geneflow=geneflow,data_info=datainfo)
		if(export_data)
			{
			cat("Exporting datasets...",sep="\n")
			exportneutral(my_dataset="metapop",include_gwds=FALSE,include_pcadapt=do_pcadapt,include_outflank=do_outflank,include_bayescan=add_bayescan,include_fsthet=do_fsthet,usetab=TRUE)
			}
		cat("Finished all selection analyses for 'metapop'.",sep="\n")
		}
	if(do_pairwise)
		{
		cat("Executing selection analyses for all pairwise population comparisons.",sep="\n")
		run_pairwise(overwrite_ped=overwriteped,pcadapt_ped=pcadaptped,dopheno=FALSE,only_pooled=FALSE,allpairwise=TRUE,sign_level=signlevel,do_piechart=dopiechart,addbayescan=add_bayescan,bayescan_FDR=bayescanFDR,bayescan_overwrite=overwrite_bayescan,dopcadapt=do_pcadapt,dooutflank=do_outflank,dofsthet=do_fsthet,do_thinning=do_thin,bin_size=gwdsbinsize,test_correction=my_correction,plotvenn=doplotvenn,log_p_max=logp_max,myauthors=authors,myspecies=species,s_claim=selclaim,demography_model=demography,n_generations=ngenerations,with_geneflow=geneflow,data_information=datainfo,control_dataset=controldata,exportdata=export_data)						
		if(mysambar$pcadapt_error){return(cat("Aborting selectionanalyses run because of PCadapt error.",sep="\n"))}
		cat("Plotting -log p values...",sep="\n")
		multi_plot_scanlog(allpairwise=TRUE,do_export=export,outflank_q=FALSE)
		if(plothisto)
			{
			cat("Creating GWDS histograms. If you receive an error after this line, set flag plothisto to FALSE.",sep="\n")
			gwdshisto_multi(doexport=TRUE,allpairwise=TRUE)	
			}
		cat("Creating He-Fst scatterplots...",sep="\n")
		pheno_Fdist_plot(doexport=export,allpairwise=TRUE,mylabels=phenolabels)
		}
	if(do_pheno)
		{
		if(!silent){cat("Flag do_pheno is set to TRUE.",sep="\n")}
		if(is.null(inds$type))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
			}
		if(!any(inds$type))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) contains FALSE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
			}
		if(!any(inds$type==FALSE))
			{
			return(cat("ERROR: column 'inds$type' (boolean vector) contains TRUE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
			}
		poptype1	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[inds$type&inds$filter]))),collapse=".")
		poptype2	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[!inds$type&inds$filter]))),collapse=".")
		if(controldata)
			{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),"pop_control",sep=".")
			}else{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),sep=".")
			}	
		phenodir		<- paste(mysambar$selectiondir,phenodir,sep="/")
		setwd(mysambar$selectiondir)
		if(!dir.exists(phenodir))
			{
			cat("Creating output folder called 'pheno'.",sep="\n")
			dir.create(file.path(phenodir))
			setwd(phenodir)
			}else{
			setwd(phenodir)
			cat("Overwriting results in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		cat("Writing out table with binary division of populations...",sep="\n")
		phenotable	<- table(inds$pop[inds$filter&inds$pop%in%mysambar$populations],inds$type[inds$filter&inds$pop%in%mysambar$populations])
		if(any(apply(phenotable, 1, min)!=0))
			{
			return(cat("ERROR: per population, all individuals should have the same value at the 'inds$type' column (so either TRUE or FALSE). Please redefine the inds$type column or run instead the assocfisher function.",sep="\n"))
			}
		write.table(phenotable,"pheno_popdivision.txt",row.names=TRUE,col.names=TRUE,sep="\t",quote=FALSE)
		cat("Calculating minor allele frequencies for pheno...",sep="\n")
		pheno_maf(indthreshold=inds$filter)
		cat("Executing selection analyses for pheno1 against pheno2.",sep="\n")
		if(onlypooled)
			{
			cat("Because the flag onlypooled is set to TRUE, selection scans will be run for the pooled comparison only.",sep="\n")
			}else{
			cat("Because the flag onlypooled is set to FALSE, selection scans will be run for the pooled comparison as well as for pairwise comparisons.",sep="\n")
			}
		run_pairwise(overwrite_ped=overwriteped,pcadapt_ped=pcadaptped,dopheno=TRUE,only_pooled=onlypooled,sign_level=signlevel,do_piechart=dopiechart,addbayescan=add_bayescan,bayescan_FDR=bayescanFDR,bayescan_overwrite=overwrite_bayescan,dopcadapt=do_pcadapt,dooutflank=do_outflank,dofsthet=do_fsthet,bayescanmapfile=bayescan_mapfile,do_thinning=do_thin,bin_size=gwdsbinsize,test_correction=my_correction,plotvenn=doplotvenn,log_p_max=logp_max,myauthors=authors,myspecies=species,s_claim=selclaim,demography_model=demography,n_generations=ngenerations,with_geneflow=geneflow,data_information=datainfo,control_dataset=controldata,exportdata=export_data)						
		if(mysambar$pcadapt_error){return(cat("Aborting selectionanalyses run because of PCadapt error.",sep="\n"))}
		setwd(phenodir)
		if(!onlypooled)
			{
			cat("Creating Manhattan plots for all pheno comparisons showing -ln(Fisher exact test p-values)...",sep="\n")
			pheno_manhattan(doexport=export,myphenolabels=phenolabels,dothinning=do_thin,show_fisher=TRUE)
			cat("Creating Manhattan plots for all pheno comparisons showing -log(GWDS p-values)...",sep="\n")
			pheno_manhattan(doexport=export,myphenolabels=phenolabels,dothinning=do_thin,show_fisher=FALSE)
			cat("Creating histograms...",sep="\n")
			if(plothisto)
				{
				cat("Creating GWDS histograms for all pheno comparisons. If you receive an error after this line, set flag plothisto to FALSE.",sep="\n")
				gwdshisto_multi(doexport=TRUE,allpairwise=FALSE)
				}
			cat("Creating He-Fst scatterplots for all pheno comparisons...",sep="\n")	
			pheno_Fdist_plot(doexport=export,allpairwise=FALSE,mylabels=phenolabels)
			}else{
			gwdshisto(exportname="pheno")
			}
		cat("Plotting -log p values...",sep="\n")
		multi_plot_scanlog(allpairwise=FALSE,do_export=export,outflank_q=FALSE)
		Fdist_plot(my_dataset="pheno",axislabels=TRUE,add_outliers=TRUE,add_borders=TRUE,legendpheno=TRUE,exporttype="pdf")
		cat("2D-plots pheno...",sep="\n")
		multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset="pheno",logpmax=logp_max)
		plotpvalues(export="pdf",test1="OutFLANK",test2="rfisherGWDS",mydataset="pheno",mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL)
		if(dopiechart)
			{
			cat("Creating piecharts of minor allele frequencies...",sep="\n")
			cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
			multipiemaf(my_dataset="pheno",do_export=TRUE)
			if(do_outflank|do_pcadapt)
				{
				cat("Combining all test scan piecharts into one plot...",sep="\n")
				cat("If you receive an error after this line, set the flag dopiechart to FALSE.",sep="\n")
				allscans_piemaf(my_dataset="metapop",do_export=TRUE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5,addtestnames=FALSE)
				}
			}else{
			cat("Skipping piecharts because the flag 'dopiechart' is set to FALSE.",sep="\n")
			}
		cat("Note that outliers for pooled data (pheno1 vs pheno2) is meaningful if (and only if) populations within both groups are isolated from each other (i.e. no gene flow).",sep="\n")
		cat("Independency of populations can be inferred from output of calcdistance() and calcdiversity() function.",sep="\n")
		}
	setwd(mysambar$inputdatadir)
	cat("Set the flag 'export_data' to TRUE if you want to output PED and MAP files of neutral and outlier datasets.",sep="\n")
	# makebayenvinput()
	}

selectionstudy_workflow<-function()
	{
	# say we have 4 populations, consisting (for example) of 2 saltwater (A and B) and 2 fresh water populations (C and D)
	#
	#### 1. EXPERIMENTAL POOLED AND EXPERIMENTAL PAIRWISE COMPARISON
	# run selection analyses for true population division, both group and pheno
	inds$type<-ifelse(inds$pop=="A"|inds$pop=="B",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=TRUE)
	# this will create outlier.pheno.info.txt for pooled comparison and for each pairwise comparison outlier.pop1_pop2.pairwise.info.txt files
	# if Outflank gives an error for one of the pairwise comparisons, then run twice:
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=TRUE,do_outflank=TRUE)
	#
	#### 2. CONTROL POOLED POPULATION COMPARISON
	# run selection analyses for artificial pooled population comparison for which no shared selective pressures are to be expected
	# say 2 repeats
	inds$type<-ifelse(inds$pop=="A"|inds$pop=="C",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=TRUE,controldata=TRUE)
	inds$type<-ifelse(inds$pop=="B"|inds$pop=="C",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=TRUE,onlypooled=FALSE,do_outflank=TRUE,controldata=TRUE)
	# this will create outlier.pheno.pop_control.info.txt files
	#
	#### 3. CONTROL PAIRWISE POPULATION COMPARISON
	# run selection analyses for artificial pairwise population comparison for which no shared selective pressures are to be expected
	# say 2 repeats
	excludepop(mysambar$populations[mysambar$populations!="A"&mysambar$populations!="B"])
	inds$type<-ifelse(inds$pop=="C"|inds$pop=="D",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=FALSE,do_pairwise=TRUE,do_outflank=TRUE,controldata=TRUE)
	excludepop(mysambar$populations[mysambar$populations!="A"&mysambar$populations!="B"])
	inds$type<-ifelse(inds$pop=="A"|inds$pop=="B",TRUE,FALSE)
	selectionanalyses(export="pdf",do_meta=FALSE,do_pheno=FALSE,do_pairwise=TRUE,do_outflank=TRUE,controldata=TRUE)
	# this will create outlier.pheno.pop_control.info.txt file
	#
	#### 4. CONTROL INDIVIDUAL COMPARISON
	# run selection analyses for artificial division of individuals
	excludepop()
	inds$randompheno <- sample(c(TRUE,FALSE),nrow(inds),replace=TRUE)
	assocfisher(pheno="randompheno",export="pdf")
	# this will create outlier.assoc1_assoc2.txt file
	}

run_pairwise<-function(dopheno=FALSE,do_analysis=TRUE,only_pooled=FALSE,allpairwise=FALSE,sign_level=0.05,do_piechart=TRUE,pheno_labels=NULL,mylabels=NULL,popnames=mysambar$populations,addbayescan=FALSE,bayescan_FDR=0.01,bayescan_overwrite=FALSE,dopcadapt=TRUE,pcadapt_ped=FALSE,dooutflank=TRUE,dofsthet=FALSE,bayescanmapfile=NULL,overwrite_ped=FALSE,do_thinning=TRUE,bin_size=1000000,overwritebin=TRUE,log_p_max=NULL,test_correction="bonferroni",plotvenn=TRUE,myauthors=NULL,myspecies=NULL,s_claim=NULL,demography_model=NULL,n_generations=NULL,with_geneflow=NULL,data_information=NULL,control_dataset=FALSE,exportdata=FALSE)
	{
	mysambar$pcadapt_error	<<- FALSE
	if(is.null(inds$type)&!allpairwise)
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(dopheno&!"maf_pheno1"%in%colnames(snps))
		{
		pheno_maf(indthreshold=inds$filter)
		}
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	# find all pairwise comparisons between type1 and type2:
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type&inds$filter]))
		type1		<- type1[order(type1)]
		type2		<- as.vector(unique(inds$pop[!inds$type&inds$filter]))
		type2		<- type2[order(type2)]
		allcombi	<- t(expand.grid(type1,type2))
		}
	#
	# grouping snps into bins (optionally needed to infer neutral distribution of gwds scores):
	if(do_thinning)
		{
		if("dist" %in% colnames(snps))
			{
			if("distbin"%in%colnames(snps)&!overwritebin)
				{
				cat("WARNING: Using existing position bins defined in column snps$distbin.",sep="\n")
				cat("If you want to create new position bins, set the flag overwritebin to TRUE or alternatively delete existing column.",sep="\n")
				}else{
				cat("Dividing snps into bins based on position in genome...",sep="\n")
				cat(paste("Binsize: ",bin_size," bp.",sep=""),sep="\n")
				snps$distbin	<<- NA
				mychroms		<- as.vector(unique(snps$chr))
				for(mychrom in mychroms)
					{
					#cat(mychrom,sep="\n")
					mysnpspos							<- snps$pos[snps$chr==mychrom]
					if(length(mysnpspos)>1)
						{
						mybreaks						<- seq(0,max(mysnpspos),bin_size)
						if(length(mybreaks)==1)
							{
							if(mybreaks==0)
								{
								snps$distbin[snps$chr==mychrom]<<- paste(as.character(mychrom),as.character(bin_size/2),sep="_")
								}else{
								mylabelstemp	<- mybreaks-bin_size/2
								mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
								snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
								}
							}else{
							mylabelstemp	<- mybreaks[2:length(mybreaks)]-bin_size/2
							mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
							snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
							}
						}else{
						snps$distbin[snps$chr==mychrom]	<<- paste(as.character(mychrom),as.character(mysnpspos),sep="_")
						}
					}
				cat("Selecting one snp per bin...",sep="\n")
				snps$binfilter						<<- NA
				snpstemp							<- snps[snps$filter2,]
				snps$binfilter[snps$filter2]		<<- !duplicated(snpstemp$distbin)
				snps$binfilter[is.na(snps$binfilter)]<<- FALSE
				nretained							<- nrow(snps[snps$binfilter,])
				cat(paste("Number of SNPs which will be used by GWDS to define the neutral distribution: ",nretained,".",sep=""),sep="\n")  
				}
			}else{
			cat("WARNING: No positional information. SambaR will infer neutral distribution of GWDS scores from unthinned dataset even do the flag 'dothin' is set to TRUE (default).",sep="\n")
			snps$binfilter							<<- snps$filter2
			}
		}else{
		cat("WARNING: The flag 'dothin' is set to FALSE (default is TRUE). SambaR will infer neutral distribution from unthinned dataset.",sep="\n")
		snps$binfilter								<<- snps$filter2
		}
	#	
	## pairwise comparisons:
	ncombi		<- ncol(allcombi)
	if(!only_pooled)
		{
		for(my_i in c(1:ncombi))
			{
			mypop_1		<- allcombi[1,my_i]
			mypop_2		<- allcombi[2,my_i]
			my_pops		<- c(mypop_1,mypop_2)
			my_pops		<- my_pops[order(my_pops)]
			my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
			cat(" ",sep="\n")
			cat(my_pair,sep="\n")
			#
			pairwisedir	<- paste(mysambar$selectiondir,my_pair,sep="/")
			setwd(mysambar$selectiondir)
			if(!dir.exists(my_pair))
				{
				cat(paste("Creating output folder called ",my_pair,".",sep=""),sep="\n")
				dir.create(file.path(pairwisedir))
				setwd(pairwisedir)
				}else{
				setwd(pairwisedir)
				cat("Overwriting results in directory:",sep="\n")
				cat(getwd(),sep="\n")	
				}
			#
			indselect	<- inds$filter&(inds$pop==allcombi[1,my_i]|inds$pop==allcombi[2,my_i])
			combiname	<- paste(my_pair,"filter2.miss0.letter",sep=".")
			cat("Running genome wide differentiation scan (GWDS)...",sep="\n")
			gwdsfisher(my_dataset=my_pair,my_sign_level=sign_level,dothin=do_thinning,binsize=bin_size,mycorrection=test_correction)
			cat("Creating Manhattan plot showing -ln(Fisher exact test p-values)...",sep="\n")
			gwdsmanhattan(my_dataset=my_pair,showfisher=TRUE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
			cat("Creating Manhattan plot showing -log(GWDS p-values)...",sep="\n")
			gwdsmanhattan(my_dataset=my_pair,showfisher=FALSE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
			if(dopcadapt)
				{
				# 28_10_2021: until now data was exported to ped and then imported with read.pcadapt function
				# However, this is not necessary, because read.pcadapt also accepts existing r objects
				if(pcadapt_ped)
					{
					# if importing data via ped-file
					cat("Checking if inputfiles for PCadapt are present...",sep="\n")
					setwd(mysambar$inputfilesdir)
					if(file.exists(paste(combiname,"ped",sep=".")))
						{
						if(!overwrite_ped)
							{
							cat(paste("WARNING: Using existing PED and MAP files (prefix: ",combiname,") in the inputfiles directory.",sep=""),sep="\n")
							cat("If these files have been generated using different filter settings than the current filter settings, you will encounter an error when running PCadapt.",sep="\n")
							cat("If want to create new files (e.g. because of new filter settings) set the flag 'overwriteped' of the selectionanalyses function to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")  
							}else{
							cat("Overwriting existing PED and MAP files...",sep="\n")
							exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)
							}
						}else{
						cat("Creating new PED and MAP files...",sep="\n")
						exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)		
						}
					setwd(pairwisedir)
					}
				cat("Running PCadapt...",sep="\n")
				runPCadapt(K=2,popnames=c(mypop_1,mypop_2),my_dataset=my_pair,my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE,importped=pcadapt_ped)
				if(mysambar$pcadapt_error){return(cat("Aborting run_pairwise run because of PCadapt error.",sep="\n"))}
				}else{
				cat("Skipping PCadapt because dopcadapt flag is set to FALSE.",sep="\n")
				}
			if(dooutflank)
				{
				cat("Running OutFLANK...",sep="\n")
				cat("If OutFLANK throws an error, set the flag do_outflank to FALSE.",sep="\n")
				setwd(pairwisedir)
				runOutflank(indselection=indselect,my_dataset=my_pair,my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE)
				}
			setwd(pairwisedir)
			if(addbayescan)
				{
				cat("Obtaining Bayescan results...",sep="\n")
				getbayescan(export="pdf",FDR=bayescan_FDR,my_dataset=my_pair,inputmapfile=bayescanmapfile,baye_overwrite=bayescan_overwrite)
				setwd(pairwisedir)
				}
			if(dofsthet)
				{
				setwd(mysambar$inputdatadir)
				# Note: inputdatadir!! not inputfilesdir
				genepopfile 	<- list.files(pattern = "genepop")
				if(length(genepopfile)==0)
					{
					cat("WARNING: No file with extension 'genepop' found in the directory:",sep="\n")
					cat(getwd(),sep="\n")
					cat("The fsthet software needs a genepop file as input and will therefore be omitted.",sep="\n")
					setwd(pairwisedir)
					# This did not work because genepop file generated by SambaR was not accepted by fsthet.
					#cat("Creating input file for fsthet...",sep="\n")
					#genlight2genepop(input=mygenlight,overwritefile=FALSE,snpsfilter=rep(TRUE,nrow(snps)),indsfilter=rep(TRUE,nrow(SNPS)),addcomma=TRUE,doexport=TRUE) 
					}else{
					cat("Running fsthet...",sep="\n")
					cat("Just so you know: fsthet is very slow compared to GWDS, PCadapt and OutFLANK.",sep="\n")
					cat("If you run into an error or the software takes forever, rerun the selectionanalyses function with the flag do_fsthet set to FALSE.",sep="\n")
					setwd(pairwisedir)
					runfsthet(export=TRUE,dataset=my_pair,reps=10,fstmethod="betahat",doanalysis=TRUE,my_sign_level=sign_level)
					}
				setwd(pairwisedir)
				}
			if(do_piechart)
				{
				cat("Creating piecharts...",sep="\n")
				cat("If you receive an error after this line, set the flag do_piechart (or dopiechart if running selectionanalyses function) to FALSE.",sep="\n")
				multipiemaf(my_dataset=my_pair,do_export=TRUE)
				cat("If you receive an error after this line, set the flag do_piechart (or dopiechart if running selectionanalyses function) to FALSE.",sep="\n")
				cat("Combining all test scan piecharts into one plot...",sep="\n")
				cat("If you receive an error after this line, set the flag do_piechart (or dopiechart if running selectionanalyses function) to FALSE.",sep="\n")
				allscans_piemaf(my_dataset=my_pair,do_export=TRUE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5)
				}else{
				cat("Skipping piecharts because the flag 'do_piechart' is set to FALSE.",sep="\n")
				}
			setwd(pairwisedir)
			if(plotvenn)
				{
				cat("Creating Venn diagram...",sep="\n")
				plot_venn(my_dataset=my_pair)
				}else{
				cat("Skipping Venn diagram because the flag plotvenn is set to FALSE.",sep="\n")
				}
			cat("2D-plots pairwise comparison...",sep="\n")
			multiplotp(doexport="pdf",add_numbers=FALSE,my_dataset=my_pair,logpmax=log_p_max)
			plotpvalues(export="pdf",test1="OutFLANK",test2="rfisherGWDS",mydataset=my_pair,mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL)
			cat("Writing outliers to bed files...",sep="\n")
			writebed(my_dataset=my_pair)
			cat("Writing outlier info...",sep="\n")
			outlierinfo(mydataset=my_pair,my_authors=myauthors,my_species=myspecies,sel_claim=s_claim,my_demo=demography_model,n_gen=n_generations,my_geneflow=with_geneflow,data_info=data_information,control_data=control_dataset)
			if(exportdata)
				{
				cat("Exporting datasets...",sep="\n")
				exportneutral(my_dataset=my_pair,include_gwds=TRUE,include_pcadapt=dopcadapt,include_outflank=dooutflank,include_bayescan=addbayescan,include_fsthet=dofsthet,usetab=TRUE)
				}
			}
		}
	## pooled comparison:
	if(dopheno)
		{
		cat(" ",sep="\n")
		cat("pheno1_pheno2 (pooled data)",sep="\n")
		poptype1	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[inds$type&inds$filter]))),collapse=".")
		poptype2	<- paste(which(mysambar$populations2%in%as.vector(unique(inds$pop[!inds$type&inds$filter]))),collapse=".")
		if(control_dataset)
			{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),"pop_control",sep=".")
			}else{
			phenodir	<- paste("pheno",paste(poptype1,"vs",poptype2,sep=""),sep=".")
			}
		phenodir		<- paste(mysambar$selectiondir,phenodir,sep="/")	
		setwd(mysambar$selectiondir)
		if(!dir.exists(phenodir))
			{
			cat("Creating output folder called 'pheno'.",sep="\n")
			dir.create(file.path(phenodir))
			setwd(phenodir)
			}else{
			setwd(phenodir)
			cat("Overwriting results in directory:",sep="\n")
			cat(getwd(),sep="\n")	
			}
		locusWCfst(my_dataset="pheno",do_plot=FALSE)
		cat("Running genome wide differentiation scan (GWDS)...",sep="\n")
		gwdsfisher(my_dataset="pheno",my_sign_level=sign_level,dothin=do_thinning,binsize=bin_size,mycorrection=test_correction)
		cat("Creating Manhattan plot showing -ln(Fisher exact test p-values)...",sep="\n")
		gwdsmanhattan(my_dataset="pheno",showfisher=TRUE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
		cat("Creating Manhattan plot showing -log(GWDS p-values)...",sep="\n")
		gwdsmanhattan(my_dataset="pheno",showfisher=FALSE,my_sign_level=sign_level,dothin=do_thinning,exporttype="pdf",addpairwiseout=FALSE,addlab=TRUE,popcex=1.5)
		if(dopcadapt)
			{
			if(pcadapt_ped)
				{
				# 28_10_2021: until now data was exported to ped and then imported with read.pcadapt function
				# However, this is not necessary, because read.pcadapt also accepts existing r objects
				cat("Checking if inputfiles for PCadapt are present...",sep="\n")
				setwd(mysambar$inputfilesdir)
				if(file.exists("pheno.filter2.miss0.letter.ped"))
					{
					if(!overwrite_ped)
						{
						cat(paste("WARNING: Using existing PED and MAP files (prefix: 'pheno.filter2.miss0.letter') in the inputfiles directory.",sep=""),sep="\n")
						cat("If these files have been generated using different filter settings than the current filter settings, you will encounter an error when running PCadapt.",sep="\n")
						cat("If want to create new files (e.g. because of new filter settings) set the flag 'overwriteped' of the selectionanalyses function to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")  
						}else{
						cat("Overwriting existing PED and MAP files...",sep="\n")
						exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.miss0.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)
						}
					}else{
					cat("Creating new PED and MAP files...",sep="\n")
					exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.miss0.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)		
					}
				setwd(phenodir)
				}
			cat("Running PCadapt...",sep="\n")
			# Here there are two options: run PCadapt with K = 2 (because two phenotypes) or with K equalling number of populations. 
			runPCadapt(K=2,popnames=mysambar$populations,my_dataset="pheno",my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE,importped=pcadapt_ped)	# K equalling 2
			if(mysambar$pcadapt_error){return(cat("Aborting run_pairwise run because of PCadapt error.",sep="\n"))}
			#runPCadapt(popnames=mysambar$populations,my_dataset="pheno")		# K equalling number of populations
			}else{
			cat("Skipping PCadapt because dopcadapt flag is set to FALSE.",sep="\n")
			}
		setwd(phenodir)
		if(dooutflank)
			{
			cat("Running OutFLANK...",sep="\n")
			cat("If OutFLANK throws an error, set the flag do_outflank to FALSE.",sep="\n")
			setwd(phenodir)
			runOutflank(indselection=inds$filter,my_dataset="pheno",popcolumn=inds$type,my_sign_level=sign_level,mycorrection=test_correction,currentdir=TRUE)
			}
		setwd(phenodir)
		if(addbayescan)
			{
			cat("Obtaining Bayescan results...",sep="\n")
			getbayescan(export="pdf",FDR=bayescan_FDR,my_dataset="pheno",inputmapfile=bayescanmapfile,baye_overwrite=bayescan_overwrite)
			}
		setwd(phenodir)
		if(dofsthet)
			{
			setwd(mysambar$inputdatadir)
			# Note: inputdatadir!! not inputfilesdir
			genepopfile 	<- list.files(pattern = "genepop")
			if(length(genepopfile)==0)
				{
				cat("WARNING: No file with extension 'genepop' found in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				cat("The fsthet software needs a genepop file (same input as your ped and map file, but in different format) as input and will therefore be omitted.",sep="\n")
				setwd(mysambar$selectiondir)
				#cat("Creating input file for fsthet...",sep="\n")
				#genlight2genepop(input=mygenlight,overwritefile=FALSE,snpsfilter=rep(TRUE,nrow(snps)),indsfilter=rep(TRUE,nrow(SNPS)),addcomma=TRUE) 
				}else{
				cat("Running fsthet...",sep="\n")
				cat("Just so you know: fsthet is very slow compared to GWDS, PCadapt and OutFLANK.",sep="\n")
				cat("If you run into an error or the software takes forever, rerun the selectionanalyses function with the flag do_fsthet set to FALSE.",sep="\n")
				runfsthet(export=TRUE,dataset="pheno",reps=10,fstmethod="betahat",doanalysis=TRUE,phenonames=pheno_labels,my_sign_level=sign_level)
				}
			}
		setwd(phenodir)
		cat("Creating Venn diagram...",sep="\n")
		if(plotvenn)
			{
			cat("Creating Venn diagram...",sep="\n")
			plot_venn(my_dataset="pheno")
			}else{
			cat("Skipping Venn diagram because the flag plotvenn is set to FALSE.",sep="\n")
			}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		cat("Writing outliers to bed files...",sep="\n")
		writebed(my_dataset="pheno")
		cat("Writing outlier info...",sep="\n")
		outlierinfo(mydataset="pheno",my_authors=myauthors,my_species=myspecies,sel_claim=s_claim,my_demo=demography_model,n_gen=n_generations,my_geneflow=with_geneflow,data_info=data_information,control_data=control_dataset)
		if(exportdata)
			{
			cat("Exporting datasets...",sep="\n")
			exportneutral(my_dataset="pheno",include_gwds=TRUE,include_pcadapt=dopcadapt,include_outflank=dooutflank,include_bayescan=addbayescan,include_fsthet=dofsthet,usetab=TRUE)
			}
		#cat("Plotting overlap between comparisons...",sep="\n")
		#multioverlap_approach(doexport="pdf",popnames=mysambar$populations,pmax=11,silent=TRUE,pheno_label=paste(pheno_labels,collapse="_"))
		}
	}

# 15-10-2020: this function can be used to create binary population divisions other than true binary division
allcontrol<-function(ntrue=3,maxcomp=5,popnames=mysambar$populations)
	{
	if(!"type"%in%colnames(inds))
		{
		return(cat("ERROR: define inds$type column with true binary division of populations.",sep="\n"))
		}
	poptype1			<- which(mysambar$populations%in%as.vector(unique(inds$pop[inds$type])))
	#
	mypops				<- c(1:length(popnames))
	allcombi			<- combn(mypops,ntrue)
	boolvec				<- apply(allcombi, 2, function(x) all(x == poptype1))
	allcombi			<- allcombi[,!boolvec]
	if(ncol(allcombi)>maxcomp)
		{
		allcombi		<<- allcombi[,sample(1:ncol(allcombi),maxcomp,replace=FALSE)]
		}
	}

# this function extracts all outlierinfo files present in subdirectories
run_getoutlierinfo<-function(my_dir=NULL,silent=TRUE)
	{
	if(is.null(my_dir))
		{
		return(cat("ERROR: define a directory to the my_dir flag.",sep="\n"))
		}
	if(file.exists(my_dir))
		{
		setwd(my_dir)
		}else{
		cat("ERROR: Non-existing directory specified to my_dir flag:",sep="\n")
		return(cat(my_dir,sep="\n"))	
		}
	mydatatypes				<- c('pooled','pooled_control','pairwise','pairwise_control','ind_control')
	outlierfileslist		<<- list()
	outlierdflist			<<- list()
	for(typenr in c(1:5))
		{
		getoutlierinfo(mydir=my_dir,selectall=FALSE,silent=silent,skipdata=TRUE,datatype=mydatatypes[typenr])
		outlierfileslist[[typenr]]	<<- filenames
		if(!getinfoerror)
			{
			outlierdflist[[typenr]]	<<- outlierdf_temp 
			}else{
			outlierdflist[[typenr]]	<<- NULL
			}
		}
	names(outlierdflist)	<<- mydatatypes
	names(outlierfileslist)	<<- mydatatypes
	#alloutliersdf			<<- rbind(pooleddf,pooledcontroldf,pairwisedf,pairwisecontroldf,indcontroldf)
	alloutliersdf			<<- do.call(rbind,outlierdflist)
	cat("The names of the input files are stored in a list object called 'outlierfileslist'.",sep="\n") 
	cat("All data has been stored in a dataframe called 'alloutliersdf'.",sep="\n") 
	mydatatypes	<- c('pooled','pooled_control','pairwise','pairwise_control','ind_control')
	if(any(!mydatatypes%in%alloutliersdf$datatype))
		{
		cat("WARNING: not all datatypes included. Missing:",sep="\n")
		cat(mydatatypes[!mydatatypes%in%alloutliersdf$datatype],sep="\n")
		}
	#
	# uniform distribution of p-values?
	alloutliersdf$gwds_p	<<- 10^(-alloutliersdf$rfisherGWDSlogp)
	alloutliersdf$gwds_padj	<<- NA
	for(j in c(1:nrow(alloutliersdf)))
		{
		alloutliersdf$gwds_padj[j]	<<- p.adjust(alloutliersdf$gwds_p[j],method="bonferroni",n=alloutliersdf$nsnps[j])
		}
	hist(alloutliersdf$gwds_padj[alloutliersdf$dataset=="pheno"&alloutliersdf$rfisherGWDS==TRUE])
	}

getoutlierinfo<-function(mydir=NULL,selectall=FALSE,silent=TRUE,skipdata=TRUE,datatype="pooled",checkclass=FALSE)
	{
	# datatype can be 'pooled', 'pooled_control', 'pairwise', 'pairwise_control', and 'ind_control'
	# file_extensions are "pheno.info.txt","pheno.pop_control.pooled.info.txt","pairwise.info.txt","pop_control.pairwise.info.txt","assoc1_assoc2.info.txt"
	#
	if(is.null(mydir))
		{
		return(cat("ERROR: define a directory to the mydir flag.",sep="\n"))
		}
	getinfoerror	<<- FALSE
	if(!silent){cat("Setting path defined to mydir as working directory...",sep="\n")}
	if(file.exists(mydir))
		{
		setwd(mydir)
		}else{
		cat("ERROR: Non-existing directory specified to mydir flag:",sep="\n")
		return(cat(mydir,sep="\n"))	
		}
	if(datatype!="pooled"&&datatype!="pooled_control"&&datatype!="pairwise"&&datatype!="pairwise_control"&&datatype!="ind_control")
		{
		cat(paste("ERROR: the flag datatype is currently set to: ",datatype,".",sep=""),sep="\n") 
		return(cat("The flag datatype should be set either to 'pooled', 'pooled_control', 'pairwise', 'pairwise_control', and 'ind_control'.",sep="\n"))  	
		}
	if(!silent){cat("Searching for files within subdirectories...",sep="\n")}
	if(datatype=="pooled")
		{
		cat(" ",sep="\n")
		cat("POOLED",sep="\n")
		cat("Datatype is set to 'pooled'. Importing outlierinfo files called 'myoutliers.GWDSorOutFLANK.pheno.info.txt'.",sep="\n")
		filenames		<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.pheno.info.txt",recursive = TRUE)
		filenames		<- filenames[!grepl("pop_control",filenames)]
		}
	if(datatype=="pooled_control")
		{
		cat(" ",sep="\n")
		cat("POOLED_CONTROL",sep="\n")
		cat("Datatype is set to 'pooled_control'. Importing outlierinfo files called 'myoutliers.GWDSorOutFLANK.pheno.pop_control.info.txt'...",sep="\n")
		filenames		<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.pheno.pop_control.pooled.info.txt",recursive = TRUE)
		}
	if(datatype=="pairwise")
		{
		cat(" ",sep="\n")
		cat("PAIRWISE",sep="\n")
		cat("Datatype is set to 'pairwise'. Importing outlierinfo files which do not contain the string 'pop_control' and which end on 'pairwise.info.txt'...",sep="\n")
		filenames		<- list.files(mydir,pattern=glob2rx("myoutliers.GWDSorOutFLANK*pairwise.info.txt"),recursive=TRUE)
		filenames		<- filenames[!grepl("pop_control",filenames)]
		}
	if(datatype=="pairwise_control")
		{
		cat(" ",sep="\n")
		cat("PAIRWISE_CONTROL",sep="\n")
		cat("Datatype is set to 'pairwise_control'. Importing outlierinfo files which end on 'pop_control.pairwise.info.txt'...",sep="\n")
		filenames		<- list.files(mydir,pattern=glob2rx("myoutliers.GWDSorOutFLANK*pop_control.pairwise.info.txt"),recursive=TRUE)
		}
	if(datatype=="ind_control")
		{
		cat(" ",sep="\n")
		cat("IND_CONTROL",sep="\n")
		cat("Datatype is set to 'ind_control'. Importing outlierinfo files called 'myoutliers.GWDSorOutFLANK.assoc1_assoc2.info.txt'.",sep="\n")
		filenames		<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.assoc1_assoc2.info.txt",recursive = TRUE)
		}
	nfiles			<- length(filenames)
	if(!silent){cat(paste("Importing ",nfiles," file(s)...",sep=""),sep="\n")}
	filenames		<<- filenames
	if(!silent){cat("File name(s):",sep="\n")}
	inputdatalist 	<<- lapply(filenames,function(x)
								{
								cat(x,sep="\n")
								read.table(x,header=TRUE)
								})
	inputdatalist2	<<- list()
	if(!silent){cat("Subselecting columns...",sep="\n")}
	if(selectall)
		{
		cat("Selecting all columns...",sep="\n")
		mycolumns	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		mycolnames	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		}else{
		cat("Selecting essential columns only...",sep="\n")
		if(datatype=="ind_control")
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p_assoc1_assoc2","rfisherGWDSlogp_assoc1_assoc2","OutFLANKlogp_assoc1_assoc2","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			# 08-02-2021: Use the following line if necessary (if outlier files have been generated with an old version of SambaR which labelled columns of indcontrol outlierinfo files incorrectly):
			#mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p","rfisherGWDSlogp","OutFLANKlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		if(datatype=="pooled"||datatype=="pooled_control")	
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","OutFLANKlogp_pheno","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p","rfisherGWDSlogp","OutFLANKlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		if(datatype=="pairwise"||datatype=="pairwise_control")	
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","rfisherlog_p","rfisherGWDSlogp","OutFLANKlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		}
	if(!silent){cat("Adding columns OutFLANK and PCadapt if absent...",sep="\n")}
	for(i in c(1:length(inputdatalist)))
		{
		if(!silent){cat(i,sep="\n")}
		mydf		<- inputdatalist[[i]]
		if(!"OutFLANK"%in%colnames(mydf))
			{
			mydf$OutFLANK						<- "error"
			}
		if(!"OutFLANKlogp"%in%colnames(mydf))
			{
			mydf$OutFLANKlogp					<- "error"
			}
		if(!"n_OutFLANK_adjacent"%in%colnames(mydf))
			{
			mydf$n_OutFLANK_adjacent			<- as.integer(0)
			}
		if(!"n_GWDS_adjacent"%in%colnames(mydf))
			{
			mydf$n_GWDS_adjacent				<- as.integer(0)
			}
		if(!"PCadapt"%in%colnames(mydf))
			{
			mydf$PCadapt						<- "error"
			}
		if(datatype=="pairwise"||datatype=="pairwise_control")	
			{
			if(!"OutFLANKlogp_pairwise"%in%colnames(mydf))
				{
				mydf$OutFLANKlogp_pairwise			<- NA
				}
			}
		if(datatype=="pooled"||datatype=="pooled_control")	
			{
			if(!"OutFLANKlogp_pheno"%in%colnames(mydf))
				{
				mydf$OutFLANKlogp_pheno				<- NA
				}
			}
		if(datatype=="ind_control")	
			{
			if(!"OutFLANKlogp_assoc1_assoc2"%in%colnames(mydf))
				{
				mydf$OutFLANKlogp_assoc1_assoc2		<- NA
				}
			}
		if(any(mydf$n_GWDS_adjacent=="de_novo",na.rm=TRUE))			{mydf$n_GWDS_adjacent		<- as.integer(0)}
		if(any(mydf$n_OutFLANK_adjacent=="de_novo",na.rm=TRUE))		{mydf$n_OutFLANK_adjacent	<- as.integer(0)}
		mydf$chr	<- as.character(mydf$chr)
		mydf$name	<- as.factor(mydf$name)
		mybool		<- mycolumns%in%colnames(mydf)
		#
		if(any(!mybool))
			{
			mycolumns2	<- mycolumns[!mybool]
			if(!skipdata)
				{
				cat(paste("ERROR: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				return(cat("Set the flag 'skipdata' to TRUE in order to continue with next dataset.",sep="\n")) 
				}else{
				cat(paste("WARNING: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				cat("The flag skipdata is set to TRUE. Omitting dataset.",sep="\n")
				inputdatalist2[[i]]	<<- NA
				}
			}else{
			if(!silent){cat("All columns present.",sep="\n")}
			inputdatalist2[[i]]		<<- mydf[,mycolumns]
			if(checkclass)
				{
				exp_class	<- c("logical","logical","character","integer","factor","factor","logical","character","character","numeric","numeric","numeric","integer","integer","integer","integer","integer","integer","integer","numeric","numeric")
				obs_class	<- as.vector(unlist(lapply(inputdatalist2[[i]],class)))
				if(any(exp_class!=obs_class))
					{
					return(cat("ERROR: unexpected classes.",sep="\n"))
					}
				}
			}
		}
	# remove skipped dataframes and then combine:	
	if(!silent){cat("Removing skipped datasets from list...",sep="\n")}
	inputdatalist3	<<- inputdatalist2[lapply(inputdatalist2,length)>1] 
	if(length(inputdatalist3)==0)
		{
		return(cat("ERROR: No data to combine. Perhaps set the flag skipdata to FALSE?",sep="\n"))
		}
	#
	if(!silent){cat("Combining dataframes from list into data frame 'outlierdf'...",sep="\n")}
	outlierdf				<- do.call(rbind,inputdatalist3)
	if(!silent){cat("Assigning column names to 'outlierdf' dataframe...",sep="\n")}
	colnames(outlierdf)		<- mycolnames
	outlierdf$outlierscore	<- outlierdf$rfisherGWDSlogp/outlierdf$bonf
	outlierdf$datatype		<- datatype
	outlierdf_temp			<<- outlierdf
	#
	if(!silent){cat("Returning dataframes...",sep="\n")}
	if(datatype=="pooled")
		{
		pooleddf			<<- outlierdf
		cat("All results stored in dataframe called 'pooleddf'.",sep="\n")
		}
	if(datatype=="pooled_control")
		{
		pooledcontroldf		<<- outlierdf
		cat("All results stored in dataframe called 'pooledcontroldf'.",sep="\n")
		}
	if(datatype=="pairwise")
		{
		pairwisedf			<<- outlierdf
		cat("All results stored in dataframe called 'pairwisedf'.",sep="\n")
		}	
	if(datatype=="pairwise_control")
		{
		pairwisecontroldf	<<- outlierdf
		cat("All results stored in dataframe called 'pairwisecontroldf'.",sep="\n")
		}	
	if(datatype=="ind_control")
		{
		indcontroldf		<<- outlierdf
		cat("All results stored in dataframe called 'indcontroldf'.",sep="\n")
		}
	}	

# 15-10-2020: this function can be used to collect all selection scan results (generated for all SNP datasets stored in specified folder)
getoutlierinfo_old<-function(mydir="C:/Users/Menno_de_Jong/Documents/SNPdatasets",selectall=FALSE,silent=TRUE,skipdata=TRUE,do_control=FALSE)
	{
	if(do_control)
		{
		cat("Importing outlierinfo files containing 'assoc1_assoc2' string...",sep="\n")
		filenames		<<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.assoc1_assoc2*",recursive = TRUE)
		}else{
		cat("Importing outlierinfo files containing 'assoc1_assoc2' string...",sep="\n")
		filenames		<<- list.files(mydir, pattern="myoutliers.GWDSorOutFLANK.pheno*",recursive = TRUE)
		}
	inputdatalist 	<<- lapply(filenames,function(x)read.table(x,header=TRUE))
	inputdatalist2	<<- list()
	if(selectall)
		{
		cat("Selecting all columns...",sep="\n")
		mycolumns	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		mycolnames	<- c("authors","species","selclaim","demography","ngen","geneflow","info","chr","pos","name","dataset","indmaxmiss","snpmaxmiss","snphefilter","snpdepthfilter","snpminmac","rfisherGWDS","PCadapt","OutFLANK","maf_pheno1","maf_pheno2","HWE","HWEchi2","Hdeficit","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_OutFLANK_adjacent","pop1","pop2","pheno1","pheno2","n_ind1","n_ind2","He","Fst") 
		}else{
		cat("Selection essential columns only...",sep="\n")
		if(do_control)
			{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p_assoc1_assoc2","rfisherGWDSlogp_assoc1_assoc2","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_GWDS_adjacent","n_OutFLANK","n_ind1","n_ind2","He","Fst")
			}else{
			mycolumns	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p_pheno","rfisherGWDSlogp_pheno","bonf","nsnps","n_GWDS","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			mycolnames	<- c("authors","species","chr","pos","name","dataset","rfisherGWDS","PCadapt","OutFLANK","rfisherlog_p","rfisherGWDSlogp","bonf","nsnps","n_GWDS","n_OutFLANK","n_OutFLANK_adjacent","n_ind1","n_ind2","He","Fst")
			}
		}
	for(i in c(1:length(inputdatalist)))
		{
		if(!silent){cat(i,sep="\n")}
		mydf		<- inputdatalist[[i]]
		if(!"OutFLANK"%in%colnames(mydf))
			{
			mydf$OutFLANK	<- "error"
			}
		if(!"PCadapt"%in%colnames(mydf))
			{
			mydf$PCadapt	<- "error"
			}
		if(!"PCadapt"%in%colnames(mydf))
			{
			mydf$PCadapt	<- "error"
			}
		mybool		<- mycolumns%in%colnames(mydf)
		if(any(!mybool))
			{
			mycolumns2	<- mycolumns[!mybool]
			if(!skipdata)
				{
				cat(paste("ERROR: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				return(cat("Set the flag 'skipdata' to TRUE in order to continue with next dataset.",sep="\n")) 
				}else{
				cat(paste("WARNING: the following column names are missing from ", filenames[i],":",sep=""),sep="\n")
				cat(paste(mycolumns2,collapse=","),sep="\n")
				cat("The flag skipdata is set to TRUE. Omitting dataset.",sep="\n")
				inputdatalist2[[i]]	<<- NA
				}
			}else{
			if(!silent){cat("All columns present.",sep="\n")}
			inputdatalist2[[i]]		<<- mydf[,mycolumns]
			}
		}
	# remove skipped dataframes and then combine:	
	if(!silent){cat("Removing skipped datasets from list...",sep="\n")}
	inputdatalist3	<<- inputdatalist2[lapply(inputdatalist2,length)>1] 
	if(!silent){cat("Combining dataframes into one data frame...",sep="\n")}
	if(do_control)
		{
		controldf				<<- do.call(rbind,inputdatalist3)
		colnames(controldf)		<<- mycolnames
		controldf$outlierscore	<<- controldf$rfisherGWDSlogp/controldf$bonf
		cat("All results stored in dataframe called 'controldf'.",sep="\n")
		}else{
		outlierdf				<<- do.call(rbind,inputdatalist3)
		colnames(outlierdf)		<<- mycolnames
		outlierdf$outlierscore	<<- outlierdf$rfisherGWDSlogp/outlierdf$bonf
		cat("All results stored in dataframe called 'outlierdf'.",sep="\n")
		}
	}	

outlierboxplot<-function()
	{
	perdataset	<- alloutliersdf[,c("dataset","bonf","nsnps","n_GWDS","n_OutFLANK","n_ind1","n_ind2","datatype")]
	perdataset	<- perdataset[!duplicated(perdataset),]
	#
	par(mfrow=c(1,2))
	# number of outliers:
	boxplot(perdataset$n_GWDS/perdataset$nsnps*100~perdataset$datatype,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Proportion of outliers (%)",las=1)
	stripchart(n_GWDS/nsnps*100~datatype,data=perdataset,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)	
	# p-values for GWDS outliers:
	alloutliers2df	<- alloutliersdf[alloutliersdf$rfisherGWDS,]
	boxplot(alloutliers2df$outlierscore~alloutliers2df$datatype,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Outlier score",las=1)
	stripchart(outlierscore~datatype,data=alloutliers2df,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
	}

outlierboxplot_old<-function()
	{
	combineddf	<<- rbind(outlierdf,controldf)
	combineddf	<<- combineddf[!is.na(combineddf$dataset),]
	perdataset	<<- combineddf[,c("dataset","bonf","nsnps","n_GWDS","n_OutFLANK","n_ind1","n_ind2")]
	perdataset	<<- perdataset[!duplicated(perdataset),]
	#
	par(mfrow=c(1,2))
	# number of outliers:
	boxplot(perdataset$n_GWDS/perdataset$nsnps*100~perdataset$dataset,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Proportion of outliers (%)",las=1)
	stripchart(n_GWDS/nsnps*100~dataset,data=perdataset,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)	
	# p-values:
	combined2df	<<- combineddf[combineddf$rfisherGWDS,]
	boxplot(combined2df$outlierscore~combined2df$dataset,col="grey90",border="grey50",outline=FALSE,xlab="Comparison",ylab="Outlier score",las=1)
	stripchart(outlierscore~dataset,data=combined2df,vertical=TRUE,method="jitter",pch=16,cex=1,col=c("black"),bg="bisque",las=2,xlab="",ylab="",add=TRUE)
	}


calcNI<-function(indmiss=0.25)
	{
	#inds$type<-ifelse(inds$pop=="polar",TRUE,FALSE)
	if(is.null(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(!any(inds$type))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) contains FALSE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
		}
	if(!any(inds$type==FALSE))
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) contains TRUE-values only, meaning that all populations are grouped together. Please redefine the inds$type column.",sep="\n"))
		}
	if(!"maf_pheno"%in%colnames(snps))
		{
		pheno_maf(indthreshold=indsmiss)	
		}
	#
	# polymorphic sites:
	Ps1	<- nrow(snps[snps$maf_pheno1>0&snps$maf_pheno2==0&snps$class=="intergenic"&snps$filter,])
	Ps2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2>0&snps$class=="intergenic"&snps$filter,])
	Ps	<- Ps1+Ps2
	Pn1	<- nrow(snps[snps$maf_pheno1>0&snps$maf_pheno2==0&snps$class!="intergenic"&snps$filter,])
	Pn2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2>0&snps$class!="intergenic"&snps$filter,])
	Pn	<- Pn1+Pn2
	# fixed differences:
	Ds1	<- nrow(snps[snps$maf_pheno1==1&snps$maf_pheno2==0&snps$class=="intergenic"&snps$filter,])
	Ds2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2==1&snps$class=="intergenic"&snps$filter,])
	Ds	<- Ds1 + Ds2
	Dn1	<- nrow(snps[snps$maf_pheno1==1&snps$maf_pheno2==0&snps$class!="intergenic"&snps$filter,])
	Dn2	<- nrow(snps[snps$maf_pheno1==0&snps$maf_pheno2==1&snps$class!="intergenic"&snps$filter,])
	Dn	<- Dn1 + Dn2
	# 
	P_dnds	<- Pn/Ps
	D_dnds	<- Dn/Ds							
	NI		<- P_dnds/D_dnds					# neutrality index: Is same as: NI<-(Ds*Pn)/(Dn*Ps)		# odds ratio (OR) of the MK table
	# McDonald and Kreitman (1991) argued that if mutations in N sites are simply drifting, they should have equal probabilities of fixation/loss and equal fixation time as mutations in synonomous sites, and hence:
	# P_dnds == D_dnds
	# NI	= 1
	# Because mutations under positive selection fixate quickly, positive selection on N mutations would result in: 
	# P_dnds< D_dnds
	# NI	< 1
	# Purifying selection on N mutations means that few N mutations will fixate, resulting in excess of Pn over Dn, and hence will result in: 
	# P_dnds> D_dnds
	# NI	> 1
	#
	DoS 	<- Dn/(Dn + Ds) - Pn/(Pn + Ps)		# direction of selection
	# From: Stoletzki et al, 2011, Estimation of the Neutrality Index
	#
	# proportion of adaptive substitutions: α = 1 - (Sfix*Npoly)/(Nfix*Spoly) = 1 - neutrality index
	myalpha	<- 1 - (Ds*Pn)/(Dn*Ps)
	#
	# distribution of fitness effect:
	table(snps$impact[snps$class!="intergenic"])
	}

# this function is to do a control run on a random binary division of individuals
# There shouldn't be any outliers, as individuals are randomly sampled from all populations, and hence we know there is no association between group division and selection pressure
randomassoc<-function(dopcadapt=FALSE)
	{
	#inds$randompheno	<<- sample(c(TRUE,FALSE),nrow(inds),TRUE)
	# 03_10_2021: changed method of random sampling:
	inds$randompheno	<<- ifelse(runif(nrow(inds))<0.5,TRUE,FALSE)
	runOutflank(export=TRUE,my_dataset="assoc1_assoc2",popcolumn=inds$randompheno,mycorrection="holm")
	if(dopcadapt)
		{
		#pcadapt not made for this, so excluding
		setwd(mysambar$inputfilesdir)
		genlight2ped(popvec=c("pop1","pop2")[as.factor(inds$randompheno)],snpsfilter=snps$filter2,indsfilter=inds$filter,exportname="assoc1_assoc2.filter2.miss0.letter",genonumber=FALSE,miss_char="0") 
		runPCadapt(K=2,popnames=mysambar$populations,my_dataset="assoc1_assoc2",mycorrection="holm")
		}
	assocfisher(pheno="randompheno",export="pdf")
	plot_scanlog(doexport="pdf",mydataset="assoc1_assoc2",outflankq=FALSE,markoutpheno=FALSE)
	plotpvalues(export="pdf",test1="OutFLANK",test2="rfisherGWDS",mydataset="assoc1_assoc2",mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL)
	outlierinfo(mydataset="assoc1_assoc2")
	}

outlierinfo<-function(popnames=mysambar$populations,mydataset="pheno",control_data=FALSE,silent=TRUE,my_authors=NULL,my_species=NULL,sel_claim=NULL,my_demo=NULL,n_gen=NULL,my_geneflow=NULL,data_info=NULL,myround=4)
	{
	# sel_claim: do the authors claim evidence for selection? e.g. string could be yes or no, or positive or negative
	# 
	if(mydataset=="meta")
		{
		mydataset	<- "metapop"
		cat("Specified mydataset is 'meta'. Assuming user means 'metapop'.",sep="\n")
		}
	file_extension	<- ifelse(!control_data,ifelse(mydataset!="pheno"&mydataset!="assoc1_assoc2"&mydataset!="metapop","pairwise.info.txt","info.txt"),ifelse(mydataset=="pheno","pop_control.pooled.info.txt","pop_control.pairwise.info.txt"))
	if(!silent){cat("Selecting outlier SNPs...",sep="\n")}
	mycolname	<- paste("out",mydataset,sep="_")
	mycolnrs	<- grep(mycolname,colnames(snps))
	if(length(mycolnrs)>0)
		{
		if(!silent){cat("Information present.",sep="\n")}
		booldf			<- snps[,grep(mycolname,colnames(snps))]
		}else{
		return(cat(paste("ERROR: no column names in snps dataset which include the string ",mycolname,".",sep=""),sep="\n")) 
		}
	if(is.null(dim(booldf)))
		{
		booldf			<- data.frame("V1"=booldf)
		mycolname2		<- names(snps)[grep(mycolname,colnames(snps))]
		mycolname2		<<- mycolname2
		colnames(booldf)<- mycolname2
		}
	if(paste("OutFLANK",mydataset,sep="_")%in%colnames(snps))
		{
		myoutflank		<- snps[,grep(paste("OutFLANK",mydataset,sep="_"),colnames(snps))]
		booldf$OutFLANK	<- myoutflank
		rle_output		<- rle(myoutflank)
		noutflank		<- sum(rle_output$lengths[rle_output$values==TRUE])
		if(max(snps$pos,na.rm=TRUE)<25000)	# arbitrary threshold
			{
			noutflankadjacent	<- "de_novo"
			}else{
			noutflankadjacent	<- sum(rle_output$lengths[rle_output$values==TRUE&rle_output$lengths>1])
			}
		}else{
		noutflank			<- NA
		noutflankadjacent	<- NA
		}
	mynames			<- colnames(booldf)
	mynames			<- gsub(paste("out_",mydataset,sep=""),"",mynames)
	mynames			<- gsub("rfisher","rfisherGWDS",mynames)
	colnames(booldf)			<- mynames
	if(!silent){mybooldf		<<- booldf}
	if(ncol(booldf)>1)
		{
		if(!silent){cat("More than one column.",sep="\n")}
		if(any(as.vector(apply(booldf,1,any))))
			{
			if(!silent){cat("Outliers detected.",sep="\n")}
			outpresent		<- TRUE
			outbool2df		<- booldf[as.vector(apply(booldf,1,any)),]
			myloci			<- as.vector(snps$name[as.vector(apply(booldf,1,any))])
			}else{
			if(!silent){cat("No outliers.",sep="\n")}
			outpresent		<- FALSE
			myloci			<- as.vector(snps$name[1])
			}
		}else{
		if(!silent){cat("One column.",sep="\n")}
		boolvec			<- booldf[,1]
		if(any(boolvec))
			{
			if(!silent){cat("Outliers detected.",sep="\n")}
			outpresent		<- TRUE
			myloci			<- as.vector(snps$name[boolvec])
			n_out			<- length(boolvec[boolvec])
			outbool2df		<- data.frame("rfisherGWDS"=rep(TRUE,n_out))
			}else{
			if(!silent){cat("No outliers.",sep="\n")}
			outpresent		<- FALSE
			myloci			<- as.vector(snps$name[1])
			outbool2df		<- data.frame("rfisherGWDS"=rep(FALSE,1))
			}
		}
	if(!silent){cat("Subsetting snps dataframe...",sep="\n")}
	infodf				<- snps[snps$name%in%myloci,c("chr","pos","name","filter2")]
	if(!outpresent)
		{
		infodf			<- data.frame("chr"=NA,"pos"=NA,"name"=NA)
		}
	infodf$dataset		<- mydataset
	infodf$indmaxmiss	<- mysambar$indmissfilter
	infodf$snpmaxmiss	<- mysambar$snpmissfilter
	infodf$snphefilter	<- mysambar$hefilter
	infodf$snpdepthfilter<-mysambar$snpdepthfilter
	infodf$snpminmac	<- mysambar$min_mac
	if(!silent){infodftemp	<<- infodf}
	if(!is.null(my_species)&!is.null(my_authors))
		{
		studydf				<- data.frame("authors"=my_authors,"species"=my_species)
		studydf$selclaim	<- ifelse(is.null(sel_claim),NA,sel_claim)
		studydf$demography	<- ifelse(is.null(my_demo),NA,my_demo)
		studydf$ngen		<- ifelse(is.null(n_gen),NA,n_gen)
		studydf$geneflow	<- ifelse(is.null(my_geneflow),NA,my_geneflow)
		studydf$info		<- ifelse(is.null(data_info),NA,data_info)
		infodf				<- cbind(studydf,infodf)		
		}else{
		studydf				<- data.frame("authors"=NA,"species"=NA,"selclaim"=NA,"demography"=NA,"ngen"=NA,"geneflow"=NA,"info"=NA)
		infodf				<- cbind(studydf,infodf)
		}
	#
	if(!silent){cat("Adding info...",sep="\n")}
	if(!silent){outbool2dftemp	<<- outbool2df}
	if(outpresent)
		{
		if(nrow(infodf)>1)
			{
			if(!silent){cat("Out NOT present and more than 1 row.",sep="\n")}
			info2df				<- cbind(infodf,outbool2df)
			}else{
			if(!silent){cat("Out NOT present and 1 row only.",sep="\n")}
			# 15-10-2021: make the following edit:
			#myboolvec		 	<- setNames(TRUE,"rfisherGWDS")
			myboolvec			<- apply(booldf,2,any)
			info2df				<- c(infodf,myboolvec)
			}
		}else{
		if(!silent){cat("Out present. Adding columns to info2df...",sep="\n")}
		info2df				<- infodf
		info2df$rfisherGWDS	<- FALSE
		info2df$OutFLANK	<- FALSE
		info2df$PCadapt		<- FALSE
		}
	if(!silent){cat("Adding MAF and HWE statistics...",sep="\n")}
	popmafdf		<- round(snps[snps$name%in%myloci,grep("maf_",colnames(snps))],myround)
	info2df			<- cbind(info2df,popmafdf)
	if("HWE"%in%colnames(snps))
		{
		info2df$HWE		<- snps$HWE[snps$name%in%myloci]
		}
	if("HWEchi2"%in%colnames(snps))
		{
		info2df$HWEchi2	<- round(snps$HWEchi2[snps$name%in%myloci],myround)
		}
	if("Hdeficit"%in%colnames(snps))
		{
		info2df$Hdeficit<- snps$Hdeficit[snps$name%in%myloci]
		}
	if(!silent){info2dftemp	<<- info2df}
	#
	# in case no outliers:
	if(!silent){cat("Creating info dataframe in case of no outliers...",sep="\n")}
	info7df					<- info2df[1,]
	info7df[1,]				<- NA
	info7df$authors			<- info2df$authors[1]
	info7df$species			<- info2df$species[1]
	info7df$selclaim		<- info2df$selclaim[1]
	info7df$geneflow		<- info2df$geneflow[1]
	info7df$dataset			<- info2df$dataset[1]		
	info7df$indmaxmiss		<- info2df$indmaxmiss[1]	
	info7df$snpmaxmiss		<- info2df$snpmaxmiss[1]	
	info7df$snphefilter		<- info2df$snphefilter[1]	
	info7df$snpdepthfilter	<- info2df$snpdepthfilter[1]
	info7df$snpminmac		<- info2df$snpminmac[1]
	if(!silent){info7dftemp	<<- info7df}
	#
	if(mydataset!="metapop")
		{
		if(!silent){cat("not metapop",sep="\n")}
		mycolname	<- paste("rfisherlog_p",mydataset,sep="_")
		mycolname2	<- paste("rfisherGWDSlogp",mydataset,sep="_")
		mycolname3	<- paste("OutFLANKlogp",mydataset,sep="_")
		outflankpresent	<- mycolname3%in%colnames(snps)
		if(outflankpresent)
			{
			mycolnrs	<- c(grep(mycolname,colnames(snps)),grep(mycolname2,colnames(snps)),grep(mycolname3,colnames(snps)))
			}else{
			mycolnrs	<- c(grep(mycolname,colnames(snps)),grep(mycolname2,colnames(snps)))
			}
		if(!silent){cat("creating logpdf dataset",sep="\n")}
		if(!silent){booltemp 	<<- booldf }
		if(!silent){outbool2temp<<- outbool2df }
		if(!silent){colnrstemp	<<- mycolnrs }
		if(ncol(booldf)>1)
			{
			if(outpresent)
				{
				if(!silent){cat("More than 1 column and out present.",sep="\n")}
				logpdf		<- round(snps[as.vector(apply(booldf,1,any)),mycolnrs],myround)	# or outbooldf?
				if(!silent){logpdftemp	<<- logpdf }
				if(mydataset!="pheno"&mydataset!="assoc1_assoc2")
					{
					if(outflankpresent)
						{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise")
						}else{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise")
						}
					}
				}else{
				if(!silent){cat("More than 1 column and out NOT present.",sep="\n")}
				logpdf		<- data.frame("rfisherlog_p"=NA,"rfisherGWDSlogp"=NA,"OutFLANKlogp"=NA)
				}
			}else{
			if(outpresent)
				{
				if(!silent){cat("1 column only and out present.",sep="\n")}
				logpdf		<- round(snps[boolvec,mycolnrs],myround)
				if(mydataset!="pheno"&mydataset!="assoc1_assoc2")
					{
					if(outflankpresent)
						{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise","OutFLANKlogp_pairwise")
						}else{
						colnames(logpdf)	<- c("rfisherlog_p_pairwise","rfisherGWDSlogp_pairwise")
						}
					}
				}else{
				if(!silent){cat("1 column only and out NOT present.",sep="\n")}
				logpdf		<- data.frame("rfisherlog_p"=NA,"rfisherGWDSlogp"=NA,"OutFLANKlogp"=NA)
				}
			}
		if(!silent){cat("Checking if only 1 outlier...",sep="\n")}
		nsnps			<- nrow(snps[snps$filter2,])
		if(!is.data.frame(logpdf))	# if only 1 outlier, and 1 only selection scan
			{
			logpdf		<- data.frame("rfisherGWDSlogp"=logpdf)
			}
		logpdf$bonf		<- round(-log10(0.05/nsnps),myround)
		logpdf$nsnps	<- nsnps
		#
		if(!silent){cat("selecting GWDS outliers",sep="\n")}
		mygwdsout		<- snps[,grep(paste("rfisherout",mydataset,sep="_"),colnames(snps))]
		rle_output		<- rle(mygwdsout)
		ngwdsout		<- sum(rle_output$lengths[rle_output$values==TRUE])
		if(max(snps$pos,na.rm=TRUE)<2500)	# arbitrary threshold
			{
			ngwdsadjacent	<- "de_novo"
			}else{
			ngwdsadjacent	<- sum(rle_output$lengths[rle_output$values==TRUE&rle_output$lengths>1])
			}
		if(!silent){cat("Adding GWDS info...",sep="\n")}
		logpdf$n_GWDS 			<- ngwdsout
		logpdf$n_GWDS_adjacent	<- ngwdsadjacent
		logpdf$n_OutFLANK		<- noutflank
		logpdf$n_OutFLANK_adjacent<- noutflankadjacent
		#
		if(!silent){cat("combining into info3df...",sep="\n")}
		info3df				<- cbind(info2df,logpdf) 
		# info file in case no outliers:
		#		
		if(mydataset=="pheno")
			{
			if(!silent){cat("pheno",sep="\n")}
			info3df$pop1	<- NA
			info3df$pop2	<- NA
			info3df$pheno1	<- paste(as.vector(unique(inds$pop[inds$type&inds$filter])),collapse="_")
			info3df$pheno2	<- paste(as.vector(unique(inds$pop[!inds$type&inds$filter])),collapse="_")
			info3df$n_ind1	<- length(inds$type[inds$type&inds$filter])
			info3df$n_ind2	<- length(inds$type[!inds$type&inds$filter])
			#
			info3df$He		<- round(snps$WeirHe_pheno[snps$name%in%myloci],myround)
			info3df$Fst		<- round(snps$WeirFst_pheno[snps$name%in%myloci],myround)
			}else{
			if(!silent){cat("not pheno",sep="\n")}
			mypop1			<- strsplit(mydataset, "_")[[1]][1]
			mypop2			<- strsplit(mydataset, "_")[[1]][2]
			info3df$pop1	<- mypop1
			info3df$pop2	<- mypop2
			info3df$pheno1	<- NA
			info3df$pheno2	<- NA
			if(mydataset=="assoc1_assoc2")
				{
				info3df$n_ind1	<- nrow(inds[inds$randompheno&inds$filter,])
				info3df$n_ind2	<- nrow(inds[!inds$randompheno&inds$filter,])
				}else{
				info3df$n_ind1	<- unique(inds$pop_ninds[inds$pop==mypop1&inds$filter])
				info3df$n_ind2	<- unique(inds$pop_ninds[inds$pop==mypop2&inds$filter])
				}
			#
			hetemp			<- snps[,colnames(snps)==paste("WeirHe",mydataset,sep="_")]
			fsttemp			<- snps[,colnames(snps)==paste("WeirFst",mydataset,sep="_")]
			info3df$He		<- round(hetemp[snps$name%in%myloci],myround)
			info3df$Fst		<- round(fsttemp[snps$name%in%myloci],myround)
			}
		if(!silent){info3dftemp	<<- info3df}
		#
		if(!silent){cat("Creating info6df...",sep="\n")}
		info6df					<- info3df[1,]
		info6df[1,]				<- NA
		info6df$authors			<- info3df$authors[1]
		info6df$species			<- info3df$species[1]
		info6df$selclaim		<- info3df$selclaim[1]
		info6df$geneflow		<- info3df$geneflow[1]
		info6df$dataset			<- info3df$dataset[1]		
		info6df$indmaxmiss		<- info3df$indmaxmiss[1]	
		info6df$snpmaxmiss		<- info3df$snpmaxmiss[1]	
		info6df$snphefilter		<- info3df$snphefilter[1]	
		info6df$snpdepthfilter	<- info3df$snpdepthfilter[1]
		info6df$snpminmac		<- info3df$snpminmac[1]
		info6df$bonf			<- info3df$bonf[1]
		info6df$nsnps			<- info3df$nsnps[1]
		info6df$n_GWDS			<- info3df$n_GWDS[1]
		info6df$n_GWDS_adjacent	<- info3df$n_GWDS_adjacent[1] 	
		info6df$n_OutFLANK		<- info3df$n_OutFLANK[1]	
		info6df$n_OutFLANK_adjacent	<- info3df$n_OutFLANK[1]
		info6df$pop1			<- info3df$pop1[1]
		info6df$pop2			<- info3df$pop2[1]	
		info6df$pheno1			<- info3df$pheno1[1]	
		info6df$pheno2			<- info3df$pheno2[1]	
		info6df$n_ind1			<- info3df$n_ind1[1]	
		info6df$n_ind2			<- info3df$n_ind2[1]
		if(!silent){info6dftemp	<<- info6df}
		#
		if(!silent){cat("Creating info4df and info5df...",sep="\n")}
		if(outpresent)
			{
			if(!"rfisherGWDS"%in%colnames(info3df))
				{
				info3dftemp		<<- info3df
				return(cat("ERROR: column 'rfisherGWDS' missing.",sep="\n"))
				}
			if(!is.logical("rfisherGWDS"%in%colnames(info3df)))
				{
				return(cat("ERROR: 'rfisherGWDS' is not logical.",sep="\n"))
				}
			if(any(info3df$rfisherGWDS,na.rm=TRUE))
				{
				info4df		<- info3df[info3df$rfisherGWDS,]
				}else{
				info4df		<- info6df
				}
			if(paste("OutFLANK",mydataset,sep="_")%in%colnames(snps))
				{
				if(any(info3df$rfisherGWDS|info3df$OutFLANK,na.rm=TRUE))
					{
					info5df		<- info3df[info3df$rfisherGWDS|info3df$OutFLANK,]
					}else{
					info5df		<- info6df
					}
				}else{
				if(any(info3df$rfisherGWDS,na.rm=TRUE))
					{
					info5df		<- info3df[info3df$rfisherGWDS,]
					}else{
					info5df		<- info6df
					}
				}
			}else{
			info4df		<- info6df
			info5df		<- info6df
			}
		write.table(info3df,paste("myoutliers",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		write.table(info4df,paste("myoutliers.GWDS",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		write.table(info5df,paste("myoutliers.GWDSorOutFLANK",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		}else{
		if(outpresent)
			{
			write.table(info2df,paste("myoutliers",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
			}else{
			write.table(info7df,paste("myoutliers",mydataset,file_extension,sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
			}
		}
	cat("Txt-file(s) with outlier info written to the directory:",sep="\n")
	cat(getwd(),sep="\n")
	}

allscans_piemaf<-function(my_dataset="pheno",do_export=FALSE,popnames=mysambar$populations,silent=TRUE,addlocinames=TRUE,pop_cex=3.5,addtestnames=FALSE)
	{
	if(my_dataset=="meta")
		{
		my_dataset	<- "metapop"
		cat("Specified my_dataset is 'meta'. Assuming user means 'metapop'.",sep="\n")
		}
	if(!silent){cat("Selecting outlier SNPs...",sep="\n")}
	mycolname	<- paste("out",my_dataset,sep="_")
	if(!mycolname%in%colnames(snps))
		{
		booldf			<- snps[,grep(mycolname,colnames(snps))]
		}else{
		return(cat(paste("ERROR: no column in snps dataset present called ",mycolname,".",sep=""),sep="\n")) 
		}
	if(is.null(dim(booldf)))
		{
		booldf			<- data.frame("V1"=booldf)
		mycolname2		<- names(snps)[grep(mycolname,colnames(snps))]
		mycolname2		<<- mycolname2
		colnames(booldf)<- mycolname2
		}
	if(paste("OutFLANK",my_dataset,sep="_")%in%colnames(snps))
		{
		myoutflank		<- snps[,grep(paste("OutFLANK",my_dataset,sep="_"),colnames(snps))]
		booldf$OutFLANK	<- myoutflank
		}
	mynames			<- colnames(booldf)
	mynames			<- gsub(paste("out_",my_dataset,sep=""),"",mynames)
	mynames			<- gsub("rfisher","rfisherGWDS",mynames)
	colnames(booldf)<- mynames
	#booldf			<<- booldf
	if(ncol(booldf)>1)
		{
		if(!silent){cat("More than one column.",sep="\n")}
		outbooldf		<- booldf[,as.vector(apply(booldf,2,any))]
		outbool2df		<- booldf[as.vector(apply(booldf,1,any)),]
		myloci			<- as.vector(snps$name[as.vector(apply(booldf,1,any))])
		}else{
		if(!silent){cat("One column.",sep="\n")}
		outbooldf		<- any(booldf[,1])
		outbool2df		<- booldf[,1]
		myloci			<- as.vector(snps$name[as.vector(outbooldf)])
		}
	if(length(myloci)==0){return(cat("No outliers. Skipping.",sep="\n"))}
	#
	if(!silent){cat("Preparing plot...",sep="\n")}
	npops		<- length(popnames)
	ntests		<- ncol(outbool2df)
	nloci		<- nrow(outbool2df)
	mytests		<- colnames(outbool2df)
	scancols	<- c("blue","darkgreen","red","darkorchid4","orange")
	myscans		<- c("rfisherGWDS","PCadapt","bayescan","Fsthet","OutFLANK")
	#
	if(nloci>200)
		{
		cat("More than 200 outlier loci. Sambar will plot first 200 outlier only.",sep="\n")
		myloci	<- myloci[1:200]
		nloci	<- 200
		}
	if(!silent){cat("Opening pdf device...",sep="\n")}
	if(do_export)
		{
		if(addlocinames)
			{
			plotname<-	paste("piechart.mafperpop.allscans",my_dataset,"loci_names.pdf",sep=".")
			}else{
			plotname<-	paste("piechart.mafperpop.allscans",my_dataset,"pdf",sep=".")
			}
		if(nloci>1)
			{
			pdf(plotname,height=npops*ntests*2+3,width=nloci*2+4)
			}else{
			pdf(plotname,height=npops*ntests*2+3,width=nloci*4+4)
			}
		}
	if(!silent){cat("Creating plot...",sep="\n")}
	layout(matrix(c(1:(npops*nloci*ntests)),npops*ntests,nloci,byrow=FALSE))
	if(addtestnames)
		{
		par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,6.5))
		}else{
		par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,2))
		}
	for(k in c(1:nloci))
		{
		mylocus	<- myloci[k] 
		if(!silent){cat(mylocus,sep="\n")}
		for(m in c(1:ntests))
			{
			mytest	<- mytests[m]
			mycol	<- scancols[myscans==mytest]
			if(!silent){cat(mytest,sep="\n")}
			if(!silent){cat(mycol,sep="\n")}
			for (j in c(1:npops))
				{
				mypop		<- popnames[j]
				if(!silent){cat(mypop,sep="\n")}
				nind		<- nrow(inds[inds$filter&inds$pop==mypop,])
				popmiss		<- snps[snps$name==mylocus,paste("miss",mypop,sep="_")]
				if(outbool2df[k,m])
					{
					if(popmiss<1&nind>0)		
						{
						popmaf		<- snps[snps$name==mylocus,paste("maf",mypop,sep="_")]
						nallelles	<- round((2*nind)*(1-popmiss))
						popminor	<- round(nallelles*popmaf)
						popmajor	<- nallelles-popminor
						pie(c(popminor,popmajor),labels=NA,main=NA,col=c("grey50",mycol),border=NA)
						}else{
						# if no data available for population:
						pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="grey50")
						}
					}else{
					pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="white")
					}
				if(j==1&m==1&addlocinames)
					{
					mtext(side=3,mylocus,las=2,cex=2,line=-0.5)
					}
				if(k==1)
					{
					mtext(side=2,mypop,cex=pop_cex,las=1,line=0.5)
					}
				}
			}
		}
	if(addtestnames)
		{
		# if only 3 (without outflank):
		#mtext(text="Bayescan",side=4,line=4,at=0,adj=0,cex=5.5)
		#mtext(text="PCadapt",side=4,line=4,at=7.5,adj=0,cex=5.5)
		#mtext(text="GWDS",side=4,line=4,at=15.5,adj=0,cex=5.5)
		mtext(text="OutFLANK",side=4,line=4,at=-0.5,adj=0,cex=5.5)
		mtext(text="PCadapt",side=4,line=4,at=7.5,adj=0,cex=5.5)
		mtext(text="GWDS",side=4,line=4,at=15.5,adj=0,cex=5.5)
		mtext(text="Bayescan",side=4,line=4,at=22.25,adj=0,cex=5.5)
		}
	if(do_export){dev.off()}
	}

multipiemaf<-function(my_dataset="pheno",do_export=TRUE)
	{
	if(paste("bayescanlogq",my_dataset,sep="_")%in%colnames(snps))
		{
		cat("Including Bayescan...",sep="\n")
		bayescanlogq		<- snps[,grep(paste("bayescanlogq",my_dataset,sep="_"),colnames(snps))]
		snps$Bayescantemp	<<- bayescanlogq
		#colnames(logp)[colnames(logp)=="Bayescan"]		<- paste("bayescanlogp",my_dataset,sep="_")
		colnames(snps)[colnames(snps)=="Bayescantemp"]	<<- paste("bayescanlogp",my_dataset,sep="_")
		snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		}
	mytests		<- colnames(snps)[grep(paste("logp",my_dataset,sep="_"),colnames(snps))]
	mytests		<- gsub(paste("logp",my_dataset,sep="_"),"",mytests)
	scancols	<- c("blue","darkgreen","red","darkorchid4","orange")
	myscans		<- c("rfisherGWDS","PCadapt","bayescan","Fsthet","OutFLANK")
	for(mytest in mytests)
		{
		cat(mytest,sep="\n")
		scancol	<- scancols[myscans==mytest] 
		#cat(scancol,sep="\n")
		piemaf(export=do_export,popnames=mysambar$populations,mycol=scancol,myscan=mytest,mydataset=my_dataset)
		}
	}
	
piemaf<-function(export=FALSE,popnames=mysambar$populations,mycol="blue",myscan="rfisherGWDS",mydataset="pheno",silent=TRUE)
	{
	if(mydataset=="meta")
		{
		mydataset	<- "metapop"
		cat("Specified mydataset is 'meta'. Assuming user means 'metapop'.",sep="\n")
		}
	if(myscan=="OutFLANK")
		{
		mycolumn<- unlist(snps[,paste(myscan,"_",mydataset,sep="")])
		}else{
		if(myscan=="rfisherGWDS")
			{
			mycolumn<- unlist(snps[,paste("rfisherout_",mydataset,sep="")])
			}else{
			mycolumn<- unlist(snps[,paste(myscan,"out_",mydataset,sep="")])
			}
		}
	myloci	<- as.vector(snps$name[mycolumn&snps$filter2])	
	#myloci	<<- myloci
	if(length(myloci)==0)
		{
		return(cat("No outliers. Skipping piecharts.",sep="\n"))
		}
	nloci	<- length(myloci)
	if(nloci>200)
		{
		cat("More than 200 outlier loci. Sambar will plot first 200 outlier only.",sep="\n")
		myloci	<- myloci[1:200]
		nloci	<- 200
		}
	if(!silent){cat(paste("nloci: ",nloci,".",sep=""),sep="\n")}
	if(mydataset!="pheno"&mydataset!="metapop")
		{
		pop1	<- strsplit(mydataset, "_")[[1]][1]
		pop2	<- strsplit(mydataset, "_")[[1]][2]
		popnames<- c(pop1,pop2)
		}
	npops	<- length(popnames)
	if(export)
		{
		plotname<-	paste("piechart.mafperpop",myscan,mydataset,"pdf",sep=".")
		if(nloci>1)
			{
			pdf(plotname,height=npops*2+3,width=nloci*2+4)
			}else{
			pdf(plotname,height=npops*2+3,width=nloci*4+4)
			}
		}
	layout(matrix(c(1:(npops*nloci)),npops,nloci,byrow=FALSE))
	par(mar=c(0.5,1,0.5,1),oma=c(2,30,24,2))
	for(k in c(1:nloci))
		{
		mylocus	<- myloci[k] 
		#cat(mylocus,sep="\n")
		for (j in c(1:npops))
			{
			mypop		<- popnames[j]
			if(!silent){cat(mypop,sep="\n")}
			nind		<- nrow(inds[inds$filter&inds$pop==mypop,])
			popmiss		<- snps[snps$name==mylocus,paste("miss",mypop,sep="_")]
			if(popmiss<1&nind>0)		
				{
				popmaf		<- snps[snps$name==mylocus,paste("maf",mypop,sep="_")]
				nallelles	<- round((2*nind)*(1-popmiss))
				popminor	<- round(nallelles*popmaf)
				popmajor	<- nallelles-popminor
				pie(c(popminor,popmajor),labels=NA,main=NA,col=c("grey50",mycol),border=NA)
				}else{
				# if no data available for population:
				pie(c(1,0),labels=NA,main=NA,col=c("white","white"),border="grey50")
				}
			if(j==1)
				{
				mtext(side=3,mylocus,las=2,cex=2,line=-0.5)
				}
			if(k==1)
				{
				mtext(side=2,mypop,cex=3.5,las=1,line=0.5)
				}
			}
		}
	if(export){dev.off()}
	}
	
runfsthet<-function(export=FALSE,dataset=NULL,my_sign_level=0.05,reps=10,fstmethod="betahat",doanalysis=TRUE,phenonames=NULL,currentdir=FALSE,do_overwrite=TRUE)
	{
	current_dir	<- getwd()
	# dataset should be NULL, pop1_pop2, or meta.
	#
	# 4 options for fstmethod:
	# - For Wright's Fst: fst, FST, Fst
	# - For a variance-based Fst (beta): var, VAR, Var
	# - For Cockerham and Weir's Theta: theta, Theta, THETA	# no shark fin, mostly negative values
	# - For Beta-hat (LOSITAN): betahat, Betahat, BETAHAT	# shark fin
	#
	if(doanalysis)
		{
		setwd(mysambar$inputdatadir)
		# sambarfunction_selection:
		##### SELECTION ANALYSES #####
		# sambarfunction_selection:
		### FstHet:
		# sambarfunction_selection:
		if(is.null(mysambar$gpop)|do_overwrite)
			{
			genepopfile 	<- list.files(pattern = "genepop")
			if(length(genepopfile)==0)
				{
				cat("ERROR: No file with extension 'genepop' found in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				return(cat("The fsthet software needs a genepop file as input. Operation halted.",sep="\n"))
				}
			if(length(genepopfile)>1)
				{	
				cat("WARNING: SambaR found multiple files with the string 'genepop' in the directory:",sep="\n")
				cat(getwd(),sep="\n")
				return(cat("Only keep the file which should be used as input and try again.",sep="\n"))
				}
			# sambarfunction_selection:
			gpop			<- my.read.genepop(genepopfile)
			gpop2			<- gpop[order(gpop$ind.names),]
			mysambar$gpop	<<- gpop2
			cat("Genepop file stored at mysambar$gpop.",sep="\n")
			}else{
			cat("WARNING: Using genepop file stored at mysambar$gpop.",sep="\n")
			gpop2			<- mysambar$gpop
			}
		#
		gpop_ninds		<- length(gpop2$ind.names)
		ninds			<- nrow(inds)
		nindsfilter		<- nrow(inds[inds$filter,])
		#
		cat(paste("Number of individuals in genepop file: ",gpop_ninds,".",sep=""),sep="\n")
		if(gpop_ninds!=ninds)
			{
			if(gpop_ninds!=nindsfilter)
				{
				return(cat("ERROR: number of samples in genepop file does not correspond with number of samples in inds dataframe (nor total, nor retained). Not running FstHet analyses.",sep="\n"))
				}else{
				cat("Number of samples in genepop file corresponds with number of retained samples in inds dataframe.",sep="\n")
				}
			}else{
			cat("Number of samples in genepop file corresponds with total number of samples in inds dataframe. Subselecting...",sep="\n")
			indstemp	<- inds[order(as.character(inds$name)),]
			gpop2		<- gpop2[order(as.character(gpop2$ind.names)),]
			#
			indnames	<- as.character(indstemp$name)
			gpopnames	<- as.character(gpop2$ind.names)
			mybool		<- indnames==gpopnames
			#
			if(any(!mybool))
				{
				indnames	<<- indnames
				gpopnames	<<- gpopnames
				mybool		<<- mybool
				return(cat("Sample names in input genepop file do not correspond with names of retained samples in inds dataframe. Aborting. Type indnames, gpopnames and mybool for further details.",sep="\n"))
				}
			gpop2	<- gpop2[indstemp$filter,]
			}
		#
		gpop2		<- gpop2[order(as.character(gpop2$ind.names)),]
		indstemp	<- inds[inds$filter,]
		indstemp	<- indstemp[order(as.character(indstemp$name)),]
		indnames	<- as.character(indstemp$name)
		gpopnames	<- as.character(gpop2$ind.names)
		mybool		<- indnames==gpopnames
		#
		if(any(!mybool))
			{
			indnames	<<- indnames
			gpopnames	<<- gpopnames
			mybool		<<- mybool
			return(cat("Sample names in input genepop file do not correspond with names of retained samples in inds dataframe. Aborting. Type indnames, gpopnames and mybool for further details.",sep="\n"))
			}
		#
		if(!is.null(dataset))
			{
			if(dataset=="pheno")
				{
				if(!"type"%in%colnames(indstemp))
					{
					return(cat("Dataset set to 'pheno' but no column 'inds$type'. Define the column inds$type and try again. See SambaR manual for more details.",sep="\n"))
					}
				if(is.null(phenonames))
					{
					mytypes		<- c("pheno1","pheno2")
					}else{
					mytypes		<- phenonames
					}
				mylabel			<- "pheno"
				cat(paste("Starting fsthet analyses for comparison between ",mytypes[1]," and ",mytypes[2],".",sep=""),sep="\n")
				gpop2$popinfo	<- as.character(indstemp$type)
				gpop3			<- gpop2[indstemp$filter,]
				}else{
				if(dataset=="metapop")
					{
					cat("SambaR will run fsthet on entire dataset (i.e. metapop: all populations combined).",sep="\n")
					gpop2$popinfo	<- indstemp$pop	
					gpop3			<- gpop2
					mylabel			<- "metapop"
					}else{
					mypop1			<- strsplit(dataset, "[_]")[[1]][1]
					mypop2			<- strsplit(dataset, "[_]")[[1]][2]
					mylabel			<- dataset
					cat(paste("Starting fsthet analyses for comparison between ",mypop1," and ",mypop2,".",sep=""),sep="\n")
					gpop2$popinfo	<- as.character(indstemp$pop)	# fsthet crashes if popinfo column consists of factors
					gpop3			<- gpop2[indstemp$filter&(indstemp$pop==mypop1|indstemp$pop==mypop2),]
					}
				}
			}else{
			cat("No dataset defined. SambaR will run fsthet on entire dataset (i.e. metapop: all populations combined).",sep="\n")
			gpop2$popinfo	<- as.character(indstemp$pop)	# fsthet crashes if popinfo column consists of factors	
			gpop3			<- gpop2
			mylabel			<- "metapop"
			}
		if(currentdir)
			{
			setwd(current_dir)
			}else{
			setwd(mysambar$selectiondir)
			}
		nind	<- nrow(gpop3)
		cat(paste("Input dataset contains",nind,"individuals which passed filter settings as defined with the filterdata() function.",sep=" "),sep="\n")
		cat(paste("The number of bootstrap replicates (defined with the 'reps' argument) is set to ",reps,". Default is 10.",sep=""),sep="\n")
		cat("Starting 'fsthet' analysis now. This analysis may take a while.",sep="\n")
		if(export)
			{
			plotname		<- paste("fsthet",fstmethod,mylabel,"pdf",sep=".")
			pdf(plotname)
			}
		gpop3				<<- gpop3
		# sambarfunction_selection:
		fsthetout			<- fhetboot(gpop3,fst.choice=fstmethod,alpha=my_sign_level,nreps=reps)
		if(export)
			{
			dev.off()
			cat(paste("A file called '",plotname,"' has been written to the directory:",sep=""),sep="\n")
			cat(getwd(),sep="\n")	
			}
		fsthetout$locus		<- substring(fsthetout$Locus, 2)
		cat("Output of fsthet software is stored in a dataframe called 'fsthetout'.",sep="\n")
		}else{
		if(!is.null(dataset))
			{
			if(dataset=="pheno")
				{
				mytypes			<- unique(indstemp$type)
				mylabel			<- "pheno"
				}else{
				mylabel			<- dataset
				}
			}else{
			mylabel			<- "metapop"
			}
		}
	#
	# remove snps which occur on same position in genome:
	setwd(mysambar$inputdatadir)
	if(file.exists("removedloci.txt"))
		{
		removed			<- read.table("removedloci.txt",header=TRUE)
		fsthetout$bool	<- fsthetout$locus%in%removed$name
		fsthetout		<- fsthetout[!fsthetout$bool,]
		}
	if(currentdir)
		{
		setwd(current_dir)
		}else{
		setwd(mysambar$selectiondir)
		}
	#
	# add results to snps dataframe:
	snpstemp	<- snps[order(snps$name),]
	fsttemp		<- fsthetout[order(fsthetout$locus),]
	if(any(snpstemp$name!=fsttemp$locus))
		{
		return(cat("ERROR: order of snp names in genepop file does not correspond with order in snps dataframe.",sep="\n"))
		}
	snpstemp$fsthetlogp	<- NULL
	snpstemp$fsthetout	<- NULL
	snpstemp$fsthetlogp	<- -log10(fsttemp$P.value)
	outliers			<- fsttemp$P.value<(my_sign_level/nrow(fsttemp))
	snpstemp$fsthetout	<- outliers
	noutliers			<- length(outliers[outliers])
	cat(paste("Found ",noutliers," outlier(s).",sep=""),sep="\n")
	names(snpstemp)[names(snpstemp) == "fsthetlogp"] 	<- paste("fsthetlogp",mylabel,sep = "_")
	names(snpstemp)[names(snpstemp) == "fsthetout"] <- paste("fsthetout",mylabel,sep = "_")
	#
	# reorder:
	snps				<<- snpstemp[order(snpstemp$chr,as.numeric(snpstemp$pos)),]
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	if(any(!colnames(as.matrix(mygenlight))==snps$genlightname))
		{	
		return(cat("ERROR: after reordering, column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
		}
	cat("Columns 'fsthetlogp' and 'fsthetout' have been added to the snps dataframe.",sep="\n")
	}
		
plot_diagram<-function(export=NULL,mycol="grey80")
	{
	#install.packages('diagram')
	#library('diagram')
	my_text_size 		<- 1.5
	segment_size		<- 0.08
	width_height_ratio	<- 2.5
	xvector				<- c(rep(0.75,3),rep(0.25,2))
	yvector				<- c(0.125,0.375,0.75,0.25,0.75)
	pos					<- cbind(xvector,yvector)
	my_label			<- c("founder_2\n(Barff)", "founder_1\n(Busen)", "both founders\n(Busen & Barff)","source\n(Norway)","source\n(Norway)")
	# plot:
	graphics.off()	
	if(!is.null(export))
		{
		if(export=="pdf"){pdf("Approach.diagram.pdf",onefile=FALSE)}
		if(export=="emf"){emf("Approach.diagram.emf")}
		}
	openplotmat()
	plot(pos,xlim=c(0,1),ylim=c(0,1),type='n',xaxt='n',yaxt='n',ann=FALSE,bty='n')
	straightarrow (from = pos[1, ], to = pos[4, ],arr.pos=1)
	straightarrow (from = pos[2, ], to = pos[4, ],arr.pos=1)
	straightarrow (from = pos[3, ], to = pos[5, ],arr.pos=1)
	for(i in c(1:length(my_label)))
		{
		textrect(mid = pos[i,], shadow.size = 0, radx = segment_size*width_height_ratio, rady = segment_size, lab = my_label[i], cex = my_text_size, box.col = mycol)
		}
	text(x=0.5,y=0.9,labels="pooled approach",cex=1.5,font=2)
	text(x=0.5,y=0.5,labels="pairwise approach",cex=1.5,font=2)
	if(!is.null(export)){dev.off()}
	}

pheno_Fdist_plot<-function(doexport=NULL,allpairwise=FALSE,popnames=mysambar$populations,addoutliers=TRUE,mylabels=NULL,outlier_cex=2)
	{
	npops			<- length(mysambar$populations)
	if(npops==1)
		{
		return(cat("ERROR: only one population specified.",sep="\n"))
		}
	if(npops==2)
		{
		return(cat("WARNING: only two populations specified. Not creating combined figure of Fdist plots.",sep="\n"))
		}
	popsubset		<- as.vector(which(table(inds$pop[inds$filter])==0))
	if(length(popsubset)>0)
		{
		popnames		<- popnames[-(popsubset)]
		}
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		ncombi		<- ncol(allcombi)
		ntiles		<- ncombi
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type&inds$filter]))
		type2		<- as.vector(unique(inds$pop[(!inds$type)&inds$filter]))
		allcombi	<- t(expand.grid(type1,type2))		
		ncombi		<- ncol(allcombi)
		ntiles		<- ncombi+1
		# don't add pheno in this case (because already incorporated below)
		}
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plotname	<- ifelse(allpairwise,"Fdist_outliers_allpairwise","Fdist_outliers_allpheno")
		if(doexport=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		if(doexport=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=(ncombi+1)*400,height=500)}
		if(doexport=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=(ncombi+1)*4,height=5)}
		}
	par(mfrow=c(1,ntiles),oma=c(5,6,1,1),mar=c(1,1,1,1),cex.axis=2.5,cex.lab=3,cex.main=3.5)	
	if(!allpairwise)
		{
		#cat("pheno",sep="\n")
		Fdist_plot(my_dataset="pheno",axislabels=FALSE,my_labels=mylabels,add_outliers=addoutliers,outliercex=outlier_cex,add_borders=TRUE,legendpheno=TRUE)
		}
	for(my_i in c(1:ncombi))
		{
		#cat(my_i,sep="\n")
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		#cat(my_pair,sep="\n")
		if(!paste("WeirHe",my_pair,sep="_")%in%colnames(snps))
			{
			cat(paste("WARNING: snps dataframe does not contain a column with Weir He scores for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}else{
			y_ax	<- ifelse(allpairwise&my_i==1,'s','n')
			if(addoutliers)
				{
				Fdist_plot(my_dataset=my_pair,axislabels=FALSE,y_axis=y_ax,add_outliers=TRUE,outliercex=outlier_cex,add_borders=TRUE)
				}else{
				Fdist_plot(my_dataset=my_pair,axislabels=FALSE,y_axis=y_ax,add_outliers=FALSE,outliercex=outlier_cex,add_borders=TRUE)
				}
			}
		}
	mtext("Weir & Cockerham (1987) Fst", side = 2, cex = 2, line = 3,outer=TRUE)
	mtext("Weir & Cockerham (1987) He", side = 1, cex = 2, line = 3,outer=TRUE)
	if(!is.null(doexport)){dev.off()}
	}

pheno_manhattan<-function(doexport=NULL,allpairwise=FALSE,popnames=mysambar$populations,myphenolabels=c("pheno1","pheno2"),dothinning=FALSE,markoutpheno=TRUE,show_fisher=TRUE)
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		}
	ncombi		<- ncol(allcombi)
	if(ncombi==1)
		{
		return(cat("ERROR: only 1 comparison to consider. Not creating 'Manhattan_GWDS_allpheno_fisherlogp' plot.",sep="\n"))
		}
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plot_name	<- ifelse(show_fisher,"Manhattan_GWDS_allpheno_fisherlogp","Manhattan_GWDS_allpheno_gwdslogp")  
		if(doexport=="eps"){postscript(paste(plot_name,"eps",sep="."),family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		if(doexport=="pdf"){pdf(paste(plot_name,"pdf",sep="."),family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		if(doexport=="png"){png(paste(plot_name,"png",sep="."),family=mysambar$myfont,width=1200,height=(ncombi+1)*250)}
		if(doexport=="wmf"){win.metafile(paste(plot_name,"wmf",sep="."),family=mysambar$myfont,width=14,height=(ncombi+1)*2.5)}
		}
	par(mfrow=c((ncombi+1),1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,1.5),cex.axis=2,cex.lab=2.5)
	gwdsmanhattan(my_dataset="pheno",showfisher=show_fisher,my_labels=myphenolabels,myxaxis='n',addlab=FALSE,dothin=dothinning)
	if(markoutpheno)
		{
		rfisheroutliers	<- snps$rfisherout_pheno
		gwdsoutnr		<- which(rfisheroutliers&snps$filter2)
		if(length(gwdsoutnr)>0){abline(v=gwdsoutnr,col="grey")}
		}
	for(my_i in c(1:ncombi))
		{
		my_xaxis	<- ifelse(my_i==ncombi,'s','n')
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_pair		<- paste(my_pops[1],my_pops[2],sep="_")
		if(paste("rfisherGWDSlogp",my_pair,sep="_")%in%colnames(snps))
			{
			gwdsmanhattan(my_dataset=my_pair,showfisher=show_fisher,myxaxis=my_xaxis,dothin=dothinning)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		if(markoutpheno)
			{
			if(length(gwdsoutnr)>0){abline(v=gwdsoutnr,col="grey")}
			}
		}
	if(show_fisher)
		{
		mtext("-ln(Fisher exact test p-value)",side=2,line=0.75,cex=2.5,outer=TRUE)
		}else{
		mtext("-log10(GWDS p-value)",side=2,line=0.5,cex=2.75,outer=TRUE)
		}
	mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
	if(!is.null(doexport))
		{
		dev.off()	
		cat("Manhattan plot exported to the directory.",sep="\n")
		cat(getwd(),sep="\n")
		}
	}	

ils<-function()
	{
	macmatrix			<- snps[,c("mac_ABCa","mac_ABCcoast","mac_polar","mac_Black")]
	macmatrix			<- t(macmatrix)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	}

# GWDS (Fisher test)
# This function is not as fast as plink. If you have millions of snps, probs better to use plink.
# comparison of output:
# my R function:	0.1374497 0.0000000 0.3262634 0.5235213	1.9187528
# plink:			0.1374247 0.0000000 0.3262843 0.5235732	1.9186842 		
# odds ratios are different though.	
	
gwdsfisher<-function(my_dataset="pheno",my_sign_level=0.05,pheno=inds$type,binsize=1000000,overwrite_bin=FALSE,dothin=FALSE,make_global=FALSE,mycorrection=NULL,wingwds=FALSE)
	{
	if(is.null(mycorrection))
		{
		cat("No multiple testing correction method specified. Defaulting to using bonferroni correction.",sep="\n")
		}else{
		if(mycorrection!="holm"&mycorrection!="bonferroni"&mycorrection!="BH")
			{
			return(cat("ERROR: mycorrection should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}else{
			cat(paste("Using ",mycorrection," method to correct for multiple testing.",sep=""),sep="\n")
			}
		# 16-06-2021: added following lines because I don't see how to adjust p-values using a thinned subset (as it looks at entire distribution of p-values)
		if(dothin)
			{
			cat("WARNING: because the flag 'dothin' is set to TRUE, the correction method will be the Bonferroni correction, even if another method has been specified.",sep="\n")  
			mycorrection	<- NULL
			}
		}
	#
	# This function expects as input for my_dataset either the string 'pheno' or strings defining two populations separated by underscore (e.g. 'pop1_pop2') 
	#
	### OPTIONAL THINNING
	if(dothin)
		{
		# 15-10-2021: added following line:
		cat("WARNING: flag dothin is set to TRUE. The use of the thinning option is discouraged.",sep="\n")
		if("dist" %in% colnames(snps))
			{
			if("distbin"%in%colnames(snps)&!overwrite_bin)
				{
				cat("WARNING: Using existing position bins defined in column snps$distbin.",sep="\n")
				cat("If you want to create new position bins, set the flag overwrite_bin to TRUE or alternatively delete existing column.",sep="\n")
				}else{
				cat("Dividing snps into bins based on position in genome...",sep="\n")
				snps$distbin	<<- NA
				mychroms		<- as.vector(unique(snps$chr))
				for(mychrom in mychroms)
					{
					#cat(mychrom,sep="\n")
					mysnpspos							<- snps$pos[snps$chr==mychrom]
					if(length(mysnpspos)>1)
						{
						mybreaks						<- seq(0,max(mysnpspos),binsize)
						if(length(mybreaks)==1)
							{
							if(mybreaks==0)
								{
								snps$distbin[snps$chr==mychrom]<<- paste(as.character(mychrom),as.character(binsize/2),sep="_")
								}else{
								mylabelstemp	<- mybreaks-binsize/2
								mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
								snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
								}
							}else{
							mylabelstemp	<- mybreaks[2:length(mybreaks)]-binsize/2
							mylabels		<- paste(as.character(mychrom),as.character(mylabelstemp),sep="_")
							snps$distbin[snps$chr==mychrom]	<<- as.vector(cut(mysnpspos,mybreaks,labels=mylabels))
							}
						}else{
						snps$distbin[snps$chr==mychrom]	<<- paste(as.character(mychrom),as.character(mysnpspos),sep="_")
						}
					}
				cat("Selecting one snp per position bin.",sep="\n")
				snps$binfilter						<<- NA
				snpstemp							<- snps[snps$filter2,]
				snps$binfilter[snps$filter2]		<<- !duplicated(snpstemp$distbin)
				snps$binfilter[is.na(snps$binfilter)]<<- FALSE
				nretained							<- nrow(snps[snps$binfilter,])
				cat(paste("Number of SNPs which will be used to define the neutral distribution: ",nretained,".",sep=""),sep="\n")  
				}
			}else{
			cat("WARNING: No positional information. SambaR will infer neutral distribution from unthinned dataset even do the flag 'dothin' is set to TRUE (default).",sep="\n")
			snps$binfilter							<<- snps$filter2
			}
		}else{
		cat("The flag 'dothin' is set to FALSE (default). SambaR will infer neutral distribution from unthinned dataset.",sep="\n")
		snps$binfilter								<<- snps$filter2
		}
	#
	##### EXTRACT MINOR AND MAJOR ALLELE COUNTS ####
	if(my_dataset=="pheno")
		{
		popfilter	<- rep(TRUE,nrow(inds))
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		popfilter	<- inds$pop==pop_1|inds$pop==pop_2
		}
	#
	# For phenotype 1:
	# number of minor alleles per locus:
	if(my_dataset=="pheno")
		{
		indfilter		<- inds$filter&popfilter&pheno
		}else{
		indfilter		<- inds$filter&popfilter&inds$pop==pop_1
		}
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for inds$pheno==TRUE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor1			<- as.vector(glSum(mygenlight[indfilter,]))
	major1			<- nonmisscount-minor1
	#
	# For phenotype 2:
	if(my_dataset=="pheno")
		{
		indfilter		<- inds$filter&popfilter&!pheno
		}else{
		indfilter		<- inds$filter&popfilter&inds$pop==pop_2
		}
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for inds$pheno==FALSE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor2			<- as.vector(glSum(mygenlight[indfilter,]))
	major2			<- nonmisscount-minor2	
	#
	##### CALCULATE FISHER EXACT TEST P-VALUES #####
	snps$rfisherlog_p	<<-	NULL
	snps$rfisherout		<<- NULL
	macmatrix			<- rbind(major1,minor1,major2,minor2)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	snps$rfisherlog_p	<<- -log(rfisherp)
	snps$rfisherlog_p[snps$rfisherlog_p<0.0001]	<<- 0	# 10-11-2019: to avoid negative or infinitely small values
	if(make_global)
		{
		macmatrix			<<- t(macmatrix)
		plist				<<- plist
		rfisherp			<<- rfisherp
		}
	#
	##### FIT EXPONENTIAL DISTRIBUTION #####
	cat("Fitting exponential distribution...",sep="\n")
	# we assume that the distribution of the logp values fit an exponential distribution.
	if(dothin)
		{
		mylogpvalues		<- snps$rfisherlog_p[snps$filter2&snps$binfilter]
		}else{
		mylogpvalues		<- snps$rfisherlog_p[snps$filter2]
		}
	mynsnps				<- length(mylogpvalues)
	mynsnps2			<- nrow(snps[snps$filter2,])
	cat(paste("Number of SNPs used to infer neutral distribution: ",mynsnps," out of ",mynsnps2,".",sep=""),sep="\n")
	mymean				<- mean(mylogpvalues)	
	myrate				<- 1/mymean
	#
	# bonferroni correction:
	# 21-07-2020: out of use: mybonf<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
	# 17-06-2021: out of use: mybonf<- 1-(my_sign_level/(length(mylogpvalues)))			
	# 17-06-2021: back to use (I realized that otherwise all what thinning does is decreasing number of SNPs and thereby relaxing the Bonferroni treshold, which is undesirable): 
	mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))				
	myvalue				<- qexp(mybonf,myrate)
	#
	##### CALCULATE GWDS P-VALUES #####
	cat("Testing which loci are outliers using Bonferroni correction...",sep="\n")
	# Now we have deduced the neutral distribution and defined a threshold, we can mark snps as outliers: 
	gwds_pvalues		<- 1-pexp(snps$rfisherlog_p,myrate)
	if(any(gwds_pvalues==0&!is.na(gwds_pvalues))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
	snps$rfisherGWDSlogp<<- ifelse(gwds_pvalues==0&!is.na(gwds_pvalues),20,-log10(gwds_pvalues))	# 04-09-2020: if p-values == 0, setting log10(p-value) to 20.
	snps$rfisherout		<<-	snps$rfisherlog_p>myvalue
	#
	if(is.null(mycorrection))
		{
		cat(paste("Threshold Fisher exact test log p-value: ",round(myvalue,2),".",sep=""),sep="\n")
		}else{
		# 02-08-2020: adjust p-values rather than the threshold value.
		# This way different multiple test correction methods can be used (i.e. not only Bonferroni, but also Benjamini-Hochberg and the Holm correction)
		# this will overwrite the snps$rfisherout
		cat(paste("Correcting GWDS p-values using the ",mycorrection," method.",sep=""),sep="\n")
		snps$rfisherGWDS_padj							<<- NA
		snps$rfisherGWDS_padj[snps$filter2]				<<- p.adjust(gwds_pvalues[snps$filter2],method=mycorrection)
		snps$rfisherout									<<-	snps$rfisherGWDS_padj<=my_sign_level
		snps$rfisherout[is.na(snps$rfisherout)]			<<- FALSE	
		names(snps)[names(snps) == "rfisherGWDS_padj"] 	<<- paste("rfisherGWDS_padj",my_dataset,sep = "_")
		}
	noutliers			<- nrow(snps[snps$rfisherout&snps$filter2,])
	cat(paste("Found",noutliers,"outlier loci.",sep=" "),sep="\n")
	#
	if(wingwds)
		{
		# 16-10-2021: not useful because gwds-scores are distributed non-randomly due to linkage
		##### INFER MULTI-LOCUS NEUTRAL DISTRIBUTION ####
		# expected random distribution:
		multip				<- vector()
		for(j in c(1:mynsnps2))
			{
			# product does not fit exponential distribution 
			# multip[j]		<- prod(sample(exp(-snps$rfisherlog_p[snps$filter2]),3,replace=FALSE),na.rm=TRUE)
			multip[j]		<- mean(sample(exp(-snps$rfisherlog_p[snps$filter2]),3,replace=FALSE),na.rm=TRUE)
			}
		simwinlogp			<- -log(multip)
		multimean			<- mean(simwinlogp)	
		multirate			<- 1/multimean
		multibonf			<- 1-(my_sign_level/mynsnps2)				
		multivalue			<- qexp(multibonf,multirate)
		# empirical distribution:
		winfisherlogp		<- rollapply(snps$rfisherlog_p,3,mean,by=1,na.rm=TRUE)
		snps$winfisherlogp	<<- c(snps$rfisherlog_p[1],winfisherlogp,snps$rfisherlog_p[length(snps$rfisherlog_p)])
		# assign p-values:
		wingwdspvalues		<- 1-pexp(snps$winfisherlogp,myrate)
		snps$winGWDSlogp	<<- ifelse(wingwdspvalues==0&!is.na(wingwdspvalues),20,-log10(wingwdspvalues))
		snps$winGWDSout		<<-	snps$winfisherlogp>multivalue
		}
	#
	##### FINALIZE OUTPUT COLUMNS #####
	if(any(is.infinite(snps$rfisherlog_p)))		{cat("WARNING: infinite values present in fisher exact test results. Replacing with NA.",sep="\n")}
	if(any(is.infinite(snps$rfisherGWDSlogp)))	{cat("WARNING: infinite values present in GWDS p-values. Replacing with NA.",sep="\n")}
	snps$rfisherlog_p[is.infinite(snps$rfisherlog_p)]		<<- NA
	snps$rfisherGWDSlogp[is.infinite(snps$rfisherGWDSlogp)]	<<- NA
	#
	# rename columns:
	names(snps)[names(snps) == "rfisherlog_p"] 	<<- paste("rfisherlog_p",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherOR"] 	<<- paste("rfisherOR",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherout"] 	<<- paste("rfisherout",my_dataset,sep = "_")
	names(snps)[names(snps) == "rfisherGWDSlogp"]<<- paste("rfisherGWDSlogp",my_dataset,sep = "_")
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

gwdshisto_multi<-function(doexport=FALSE,allpairwise=FALSE,popnames=mysambar$populations,bin_width=1,chi_threshold=2000,silent=TRUE)
	{
	mychilist		<- list()
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		ncombi		<- ncol(allcombi)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		ncombi		<- ncol(allcombi)+1
		}
	for(k in c(1:ncombi))
		{
		graphics.off()
		if(k==ncombi&!allpairwise)
			{
			my_dataset	<- "pheno"
			mypop_1		<- "pheno1"
			mypop_2		<- "pheno2"
			}else{
			mypop_1		<- allcombi[1,k]
			mypop_2		<- allcombi[2,k]
			my_pops		<- c(mypop_1,mypop_2)
			my_pops		<- my_pops[order(my_pops)]
			my_dataset	<- paste(my_pops[1],my_pops[2],sep="_")
			}
		if(!silent){cat(my_dataset,sep="\n")}
		if(paste("rfisherlog_p",my_dataset,sep="_")%in%colnames(snps))
			{
			mylogp		<- snps[,paste("rfisherlog_p",my_dataset,sep="_")]
			if(length(table(mylogp))==1)
				{
				cat(paste("WARNING: no variation in fisher test logp values for population pair ",mypop_1," and ",mypop_2,". Omitting histogram.",sep=""),sep="\n")
				mychilist[[k]]		<<- data.frame("mychi"=NA,"mydf"=NA,"mychiout"=NA,"dataset"=my_dataset)
				}else{
				if(doexport){pdf(paste("GWDS.histo",my_dataset,"pdf",sep="."),width=10,height=6)}
				par(oma=c(2.5,3,0,0))
				gwdshisto(myinput=mylogp,myxaxt='s',binwidth=bin_width,chithreshold=chi_threshold)
				mtext(my_dataset,side=3,line=-1,cex=1.5)
				mtext("Frequency",side=2,line=4,cex=2)
				mtext("-log(pvalue)",side=1,line=2.5,cex=2)
				if(doexport){dev.off()}
				mysambar$mychidf$dataset	<<- my_dataset 
				mychilist[[k]]				<- mysambar$mychidf
				}
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	if(doexport)
		{
		cat("Histograms with fitted curves have been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	if(length(mychilist)>1)
		{
		mychidf 	<- do.call("rbind",mychilist)
		write.table(mychidf,"GWDS.histo.goodness_of_fit.txt",row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		cat("File 'GWDS.histo.goodness_of_fit.txt' with chi-squared values for goodness of fit written to directory:",sep="\n")
		cat(getwd(),sep="\n")
		if(any(mychidf$chi2>chi_threshold))
			{
			fileConn	<- file("GWDS.WARNING.txt")
			writeLines(c("IMPORTANT WARNING: for one or more pairwise comparisons, a low goodness of fit was observed between observed and fitted distribution (see file 'GWDS.histo.goodness_of_fit.txt').",
			paste("Preferably this value should be below ",chi_threshold," (rough guideline).",sep=""),
			"As a result, the output might be unreliable. Please observe the output plots with caution before drawing any conclusions.",
			""),fileConn)
			close(fileConn)
			}
		}
	}	
		
gwdshisto<-function(myinput=snps$rfisherlog_p_pheno,nbreaks=100,binwidth=1,myxaxt='s',chithreshold=2000,exportname=NULL,ymax=NULL,silent=FALSE,dofilter=TRUE)
	{
	if(dofilter)
		{
		mylogscores	<- myinput[snps$filter2&!is.na(myinput)]	
		}else{
		mylogscores	<- myinput[!is.na(myinput)]
		}
	if(length(table(mylogscores))==1)
		{
		cat(paste("WARNING: no variation in fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
		}		
	nloci		<- length(mylogscores)
	mycurve		<- rexp(n=nloci,rate=1/mean(mylogscores))		# expected distribution
	mymax		<- 1.2*max(c(mylogscores,mycurve),na.rm=TRUE)
	mybreaks	<- seq(0,mymax,binwidth)
	if(!is.null(exportname))
		{
		pdf(paste("GWDS.histo",exportname,"pdf",sep="."))
		}
	if(is.null(ymax))
		{
		myobs		<- hist(mylogscores,freq=FALSE,breaks=mybreaks,col="grey",las=1,main="",xlab="",ylab="",cex.axis=1.5,xaxt=myxaxt)
		}else{
		myobs		<- hist(mylogscores,freq=FALSE,breaks=mybreaks,col="grey",las=1,main="",xlab="",ylab="",cex.axis=1.5,xaxt=myxaxt,ylim=c(0,2))
		}
	#
	# add fitted distribution and corresponding curve:
	mydensity	<- density(mycurve)
	myfit		<- hist(mycurve,breaks=mybreaks,freq=FALSE,add=TRUE,col=rgb(1,0,0,1/6))
	lines(mydensity$x,mydensity$y,col="red",lwd=2)
	legend("topright",legend=c("observed","fitted"),fill=c("grey","red"),bty='n',cex=1.5)
	if(!is.null(exportname)){dev.off()}
	#
	# test goodness of fit:
	myobs		<- round(myobs$density*nloci)
	myfit		<- round(myfit$density*nloci)
	mytable		<- cbind(myobs,myfit)
	mytable		<- mytable[rowSums(mytable)!=0,]
	options(warn=-1)
	mychiout	<- chisq.test(mytable)
	options(warn=0)
	mychi		<- round(mychiout[[1]],2)
	mydf		<- mychiout[[2]]
	myp			<- round(mychiout[[3]],5)
	mychi2df	<- data.frame("chi2"=mychi,"df"=mydf,"pvalue"=myp)
	mysambar$mychidf	<<- mychi2df 
	if(mychi>=chithreshold)
		{
		cat("WARNING: low goodness of fit between observed and fitted distribution.",sep="\n")
		cat(paste("Chi-squared value for goodness of fit: ",mychi,".",sep=""),sep="\n")
		cat(paste("Preferably this value should be below ",chithreshold,".",sep=""),sep="\n")
		}
	if(!is.null(exportname))
		{
		write.table(mychi2df,paste("GWDS.histo.goodness_of_fit",exportname,"txt",sep="."),row.names=FALSE,col.names=TRUE,quote=FALSE,sep="\t")
		cat("File 'GWDS.histo.goodness_of_fit.txt' with chi-squared values for goodness of fit written to directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}
	
# first execute gwdsfisher 
gwdsmanhattan<-function(my_dataset="pheno",showfisher=TRUE,my_sign_level=0.05,dothin=FALSE,exporttype=NULL,mycolours=c("black","red","orange"),mycex=1,mycexout=1.5,my_labels=NULL,myxaxis='s',addpairwiseout=FALSE,addlab=FALSE,popcex=1.25,addaxis2=TRUE,silent=TRUE)
	{
	#if(any(nchar(my_labels)>6))
	#	{
	#	my_labels<-substr(my_labels,1,6)
	#	}
	# rather than black we can also use: mycolours=c("#99CCFF","red","orange")
	# input vectors:
	if(!silent){cat("Extracting p-values from SNP dataset...",sep="\n")}
	if(showfisher)
		{
		#cat("Plotting -ln(Fisher exact test p-values)...",sep="\n")
		mylogp				<- snps[,paste("rfisherlog_p",my_dataset,sep="_")]
		mylogp2				<- snps[,paste("rfisherGWDSlogp",my_dataset,sep="_")]
		if(!any(mylogp2!=0,na.rm=TRUE))
			{
			cat("All GWDS log(p-values) equal to 0. Not adding to Manhattan plot.",sep="\n")
			}
		}else{
		#cat("Plotting -log(GWDS p-values)...",sep="\n")
		mylogp				<- snps[,paste("rfisherGWDSlogp",my_dataset,sep="_")]
		mylogp2				<- snps[,paste("rfisherlog_p",my_dataset,sep="_")]
		if(!any(mylogp!=0,na.rm=TRUE))
			{
			return(cat("All GWDS log(p-values) equal to 0. Not creating Manhattan plot.",sep="\n"))
			}
		}
	if(!silent)
		{
		mylogtemp	<<- mylogp
		mylogtemp2	<<- mylogp2
		}
	mylogp[is.infinite(mylogp)]		<- NA
	mylogp2[is.infinite(mylogp2)]	<- NA
	myfisherout			<- snps[,paste("rfisherout",my_dataset,sep="_")]
	# bonferroni threshold:
	mymean				<- mean(mylogp[snps$filter2])	
	myrate				<- 1/mymean
	if(!dothin)
		{
		mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
		mybonf2				<- my_sign_level/(nrow(snps[snps$filter2,]))
		}else{
		mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
		mybonf2				<- my_sign_level/(nrow(snps[snps$filter2,]))
		# 17-06-2021: replaced lines below with lines above, for reasons explained in gwdsfisher plot.
		# mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2&snps$binfilter,])))
		# mybonf2			<- my_sign_level/(nrow(snps[snps$filter2&snps$binfilter,]))
	}
	if(showfisher)
		{
		myvalue				<- qexp(mybonf,myrate)
		myvalue2			<- -log10(mybonf2)
		}else{
		myvalue				<- -log10(mybonf2)
		myvalue2			<- qexp(mybonf,myrate)
		}
	# find maximum logp value for all comparisons (pooled and pairwise):
	if(!silent){cat("Defining y-limit...",sep="\n")}
	if(addpairwiseout)
		{
		if(showfisher)
			{
			mylogpdf			<- snps[, grep('^rfisherlog_p', names(snps))] 
			mymax				<- 1.1*max(mylogpdf)
			}else{
			mylogpdf			<- snps[, grep('^rfisherGWDSlogp', names(snps))] 
			mymax				<- 1.1*max(myvalue)
			if(mymax<(1.1*max(mylogpdf)))
				{
				mymax		<- 1.1*max(mylogpdf)
				}
			}
		myoutdf				<- snps[, grep('^rfisherout', names(snps))]
		myoutallvec			<- apply(myoutdf,1,any)
		myoutother			<- myoutallvec&(!myfisherout)
		}else{
		if(showfisher)
			{
			mymax			<- 1.1*max(mylogp[snps$filter2],na.rm=TRUE)	
			}else{
			mymax			<- 1.1*max(myvalue)
			if(mymax<(1.1*max(mylogp[snps$filter2])))
				{
				mymax		<- 1.1*max(mylogp[snps$filter2])
				}
			}
		}
	# define plot colours:
	if(!silent){cat("Creating plot...",sep="\n")}
	myfishercol			<- mycolours[as.factor(myfisherout)]
	#outvectors			<- names(snps)[grepl("rfisherout",names(snps))]
	# plot:
	snpnumber			<- c(1:nrow(snps))
	if(!is.null(exporttype))
		{
		if(showfisher)
			{
			plotname		<- paste("Manhattan_GWDS_fisherlogp",my_dataset,sep="_")
			}else{
			plotname		<- paste("Manhattan_GWDS_gwdslogp",my_dataset,sep="_")
			}
		if(exporttype=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=15,height=5)}
		if(addlab)
			{
			par(oma=c(0,1,0,2.5),cex.axis=1.5)
			}else{
			par(oma=c(0,1,0,1.5),cex.axis=1.5)
			}
		}
	plot(snpnumber[snps$filter2],mylogp[snps$filter2],col=mycolours[1],cex=mycex,ylim=c(0,mymax),pch=16,ylab="",xlab="",main="",xaxt=myxaxis,las=1)
	if(addpairwiseout)
		{
		points(snpnumber[myoutother&snps$filter2],mylogp[myoutother&snps$filter2],col=mycolours[3],cex=mycexout,pch=16)
		}
	points(snpnumber[myfisherout&snps$filter2],mylogp[myfisherout&snps$filter2],col=mycolours[2],cex=mycexout,pch=16)
	segments(x0=0,y0=myvalue,x1=nrow(snps),y1=myvalue,lty=2,lwd=1,col="grey")
	if(!silent){cat("Adding dataset labels...",sep="\n")}
	if(my_dataset=="pheno")
		{
		if(!is.null(my_labels))
			{
			mtext(paste(my_labels[1],"vs",my_labels[2],sep=" "),side=4,cex=1.25,line=1.5)
			}else{
			if(addlab)
				{
				mtext("typeA vs typeB",side=3,cex=1.25,line=1.5)
				}else{
				mtext("typeA vs typeB",side=4,cex=1.25,line=1.5)
				}
			}
		}else{
		pop_1		<- unlist(strsplit(my_dataset, split="_"))[1]
		pop_2		<- unlist(strsplit(my_dataset, split="_"))[2]
		if(addlab)
			{
			mtext(paste(pop_1,"vs",pop_2,sep=" "),side=3,cex=popcex,line=1.5)
			}else{
			mtext(paste(pop_1,"vs",pop_2,sep=" "),side=4,cex=popcex,line=1.5)
			}
		}
	if(!silent){cat("Adding axis labels...",sep="\n")}
	if(addlab)
		{
		mtext("SNP index",side=1,cex=2,line=3)
		if(showfisher)
			{
			mtext("-ln(Fisher p-value)",side=2,cex=2,line=3.5)
			}else{
			mtext("-log10(GWDS p-value)",side=2,cex=2,line=3.5)
			}
		if(addaxis2&any(mylogp2!=0,na.rm=TRUE))
			{
			par(new=TRUE)
			y2max	<- 1.1*max(mylogp2[snps$filter2],na.rm=TRUE)
			y2range	<- c(0,y2max)
			y2sub	<- head(mylogp2[snps$filter2],5)
			plot(c(0,0,0),col="black",yaxt='n',xaxt='n',ylab="",xlab="",xaxt='n',ylim=y2range)
			#segments(x0=0,y0=myvalue2,x1=nrow(snps),y1=myvalue,lty=2,lwd=1,col="grey")
			if(showfisher)
				{
				mtext("-log10(GWDS p-value)",side=4,cex=2,line=3.5)
				}else{
				mtext("-ln(Fisher p-value)",side=4,cex=2,line=3.5)
				}
			axis(side=4,las=1)
			}
		}
	if(!is.null(exporttype)){dev.off()}
	}

runPCadapt<-function(K=NULL,my_sign_level=0.05,popnames=mysambar$populations,my_dataset="metapop",currentdir=FALSE,mycorrection="holm",store_adjusted=FALSE,importped=FALSE)
	{
	# my correction can be 'holm', 'bonferroni', and 'BH' (Benjamini-Hochberg) or NULL (default)
	# if NULL, this function will use the holm correction (because I found this gives the best results)
	if(is.null(mycorrection))
		{
		cat("No multiple testing correction method specified. Defaulting to using holm correction.",sep="\n")
		mycorrection	<- "holm"
		}else{
		if(mycorrection!="holm"&mycorrection!="bonferroni"&mycorrection!="BH")
			{
			return(cat("ERROR: mycorrection should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}else{
			cat(paste("Using ",mycorrection," method to correct for multiple testing.",sep=""),sep="\n")
			}
		}
	cat(paste("Specified dataset: ",my_dataset,".",sep=""),sep="\n")
	cat(paste("Specified significance threshold: ",my_sign_level,".",sep=""),sep="\n")
	if(is.null(K))
		{
		npops		<- length(popnames)
		cat("WARNING: K not defined. Assuming K equals length of input vector to popnames flag (default input vector is mysambar$populations).",sep="\n")
		}else{
		npops		<- K
		cat(paste("Using predefined K of ",npops,".",sep=""),sep="\n")
		}
	setwd(mysambar$inputfilesdir)
	# sambarfunction_selection:
	### PCadapt:
	if(importped)
		{
		# 28_10_2021: until now data was exported to ped and then imported with read.pcadapt function
		# However, this is not necessary, because read.pcadapt also accepts existing r objects
		# The option to export/import ped is still available (assuming the installation of an old version of pcadapt (4.1)), but is now by default disabled.
		#
		cat("Importing ped-file...",sep="\n")
		# sambarfunction_selection:
		myinput		<- paste(my_dataset,"filter2.miss0.letter.ped",sep=".")
		# sambarfunction_selection:
		x			<- read.pcadapt(myinput,type="ped")
		nrsnps_exp	<- nrow(snps[snps$filter2,])
		nrsnps_obs	<- attr(x,"p")
		if(nrsnps_exp!=nrsnps_obs)
			{
			cat("ERROR: number of lines in PED file does not correspond with expected number (i.e. nrow(snps[snps$filter2,])).",sep="\n")
			cat("Are the PED/MAP files perhaps generated with different filter settings than the current filter settings?",sep="\n")
			cat("If so, rerun the selectionanalyses function with the flag 'overwriteped' set to TRUE, or alternatively remove the existing files from the inputfiles directory.",sep="\n")
			mysambar$pcadapt_error	<<- TRUE
			return(cat(" ",sep="\n"))
			}else{
			mysambar$pcadapt_error	<<- FALSE
			}
		}else{
		cat("Converting directly from genlight...",sep="\n")
		genomat		<- as.matrix(mygenlight[inds$filter,snps$filter2])		
		x			<- read.pcadapt(genomat,type="lfmm")
		# x			<- read.pcadapt(genomat,type.out="matrix",type="lfmm")		# PCadapt versions more recent than 4.1.0 give warning: In read.pcadapt(genomat, type.out = "matrix", type = "lfmm") : Argument 'type.out' is not used with matrices.
		# class(genomat) returns "matrix" "array"
		# This leads to the warning messages:
		# 1: In if (class(input) == "character") { :
		# the condition has length > 1 and only the first element will be used
		# 2: In if (class(input) %in% c("matrix", "data.frame", "array")) { :
		# the condition has length > 1 and only the first element will be used
		}
	#
	# sambarfunction_selection:
	z			<- pcadapt(x,K=npops)
	# optional graphs (not insightful for main conclusion):
	# plot(z,option="qqplot",threshold=0.1)
	# hist(z$pvalues,xlab="p-values",main=NULL,breaks=50)
	# plot(z,option="stat.distribution")
	# 
	# sambarfunction_selection:
	padj 			<- p.adjust(z$pvalues,method=mycorrection)
	myoutliers 		<- which(padj<my_sign_level)
	if(store_adjusted)
		{
		pcadaptlogp	<- -log10(padj) 
		}else{
		pcadaptlogp	<- -log10(z$pvalues)
		}
	if(any(is.infinite(pcadaptlogp))){cat("WARNING: Infinite PCadapt log10(p-values) detected. Replacing with NA.",sep="\n")}
	pcadaptlogp[is.infinite(pcadaptlogp)]	<- NA
	noutliers		<- length(myoutliers)
	## store outliers (TRUE/FALSE) in snps dataset:
	# remove previous results, if present
	if(!is.null(snps$PCadaptoutlier))
		{
		snps$PCadaptoutlier	<<- NULL
		}
	#outtemp		<- snps[snps$filter2,]
	if(importped)
		{
		myinput2				<- paste(my_dataset,"filter2.miss0.letter.map",sep=".")
		mymapfile				<- read.table(myinput2)
		mymapfile$V1			<- NULL
		mymapfile$V3			<- NULL
		mymapfile$V4			<- NULL
		mymapfile$PCadaptoutlier<- TRUE			# we set all to true because in following step we select outlier loci only)
		colnames(mymapfile)[1]	<- "name"
		}else{
		mymapfile				<- snps[snps$filter2,c("name","pos")]
		mymapfile$pos			<- NULL
		mymapfile$PCadaptoutlier<- TRUE			# we set all to true because in following step we select outlier loci only)
		}
	outtemp2		<- mymapfile[myoutliers,]
	outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
	#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
	#outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
	outtemp4		<- outtemp3[order(outtemp3$nr_neworder),]	# 24_11_2020
	outtemp4$PCadaptoutlier[is.na(outtemp4$PCadaptoutlier)]<-FALSE
	if(any(outtemp4$name!=snps$name))
		{
		cat("ERROR: something went wrong whilst reordering the data. Contact developer of SambaR.",sep="\n")
		}
	snps			<<- outtemp4
	# change column name:
	mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
	cat(paste("PCadapt detected ",noutliers," outlier loci using the ",mycorrection," method correction for multiple testing.",sep=""),sep="\n")
	names(snps)[names(snps) == "PCadaptoutlier"] <<- mycolumnname
	cat(paste("Outliers are marked as TRUE in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
	## store pcadapt -logp scores in snps dataset:
	if(!is.null(snps$PCadaptlogp))
		{
		snps$PCadaptlogp			<<- NULL
		}
	snps$PCadaptlogp				<<- NA
	#pcadaptlogp						<<- pcadaptlogp
	if(length(pcadaptlogp)!=nrow(snps[snps$filter2,]))
		{
		return(cat("ERROR: number of SNPs in the pcadapt input/output does not correspond with number of snps defined by snps$filter2 column. Halting execution. Potential solution: set overwriteped flag of the selectionanalyses function to TRUE.",sep="\n"))
		}
	snps$PCadaptlogp[snps$filter2]	<<- pcadaptlogp		# 27-09-2019: snps$filter2 or snps$filter?
	mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
	names(snps)[names(snps) == "PCadaptlogp"] <<- mycolumnname
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	cat(paste("PCadapt -log(p) values are stored in the ",mycolumnname," column in the snps dataframe.",sep=""),sep="\n")
	}


runPCadapt_old<-function(K=NULL,my_sign_level=0.05,popnames=mysambar$populations,my_dataset="metapop",currentdir=FALSE,do_plot=FALSE,mycorrection="holm")
	{
	cat("PCadapt will be run using 3 methods for multiple testing correction: Bonferroni, Benjamini-Hochberg, and Holm.",sep="\n")
	cat(paste("The",mycorrection,"method will eventually be used."),sep="\n")
	cat("To use another correction method, change the input to the mycorrection flag.",sep="\n")
	#
	if(is.null(K))
		{
		npops		<- length(popnames)
		cat("WARNING: K not defined. Assuming K equals length of input vector to popnames flag (default input vector is mysambar$populations).",sep="\n")
		}else{
		npops		<- K
		cat(paste("Using predefined K of ",npops,".",sep=""),sep="\n")
		}
	if(!currentdir){setwd(mysambar$inputfilesdir)}
	myinput		<- paste(my_dataset,"filter2.miss0.letter.ped",sep=".")
	x			<- read.pcadapt(myinput,type="ped")
	nrsnps_exp	<- nrow(snps[snps$filter2,])
	nrsnps_obs	<- attr(x,"p")
	if(nrsnps_exp!=nrsnps_obs)
		{
		cat("ERROR: number of lines in PED file does not correspond with expected number (i.e. nrow(snps[snps$filter2,])).",sep="\n")
		cat("Are the PED/MAP files perhaps generated with different filter settings than the current filter settings?",sep="\n")
		return(cat("If so, recreate the PED/MAP files and try again.",sep="\n"))
		}
	z			<- pcadapt(x,K=npops)
	# optional graphs (not insightful for main conclusion):
	# plot(z,option="qqplot",threshold=0.1)
	# hist(z$pvalues,xlab="p-values",main=NULL,breaks=50)
	# plot(z,option="stat.distribution")
	# we do both bonferroni_correction and Bennjamini-Hochberg (BH) correction:
	for (my_k in c(1:1))
		{
		if(my_k==1){padj 	<- p.adjust(z$pvalues,method="bonferroni")}
		if(my_k==2){padj	<- p.adjust(z$pvalues,method="BH")}		
		if(my_k==3){padj	<- p.adjust(z$pvalues,method="holm")}
		myoutliers 		<- which(padj<my_sign_level)
		pcadaptlogp		<- -log(padj) 
		pcadaptlogp		<<- pcadaptlogp
		noutliers		<- length(myoutliers)
		## store outliers (TRUE/FALSE) in snps dataset:
		# remove previous results, if present
		if(!is.null(snps$PCadaptoutlier))
			{
			snps$PCadaptoutlier	<<- NULL
			}
		#outtemp		<- snps[snps$filter2,]
		myinput2		<- paste(my_dataset,"filter2.miss0.letter.map",sep=".")
		mymapfile		<- read.table(myinput2)
		mymapfile$V1	<- NULL
		mymapfile$V3	<- NULL
		mymapfile$V4	<- NULL
		mymapfile$PCadaptoutlier<- TRUE
		colnames(mymapfile)[1]	<- "name"
		outtemp2		<- mymapfile[myoutliers,]
		outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
		#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
		outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
		outtemp4$PCadaptoutlier[is.na(outtemp4$PCadaptoutlier)]<-FALSE
		# just to check:
		# mymapfile		<<- mymapfile
		# outtemp2		<<- outtemp2
		# outtemp3		<<- outtemp3
		# outtemp4		<<- outtemp4
		if(any(outtemp4$name!=snps$name))
			{
			cat("ERROR: something went wrong whilst reordering the data. Contact developer of SambaR.",sep="\n")
			}
		snps			<<- outtemp4
		# change column name:
		if(my_k==1)
			{
			if(mycorrection=="bonferroni")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_bonf",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the Bonferroni method correction for multiple testing.",sep=" "),sep="\n")
			}
		if(my_k==2)
			{
			if(mycorrection=="BH")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_BH",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the Benjamini-Hochberg procedure correction for multiple testing.",sep=" "),sep="\n")
			}
		if(my_k==3)
			{
			if(mycorrection=="holm")
				{
				mycolumnname	<- paste("PCadaptout",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptout_holm",my_dataset,sep="_")
				}
			cat(paste("PCadapt detected",noutliers,"outlier loci using the holm correction for multiple testing.",sep=" "),sep="\n")
			}
		names(snps)[names(snps) == "PCadaptoutlier"] <<- mycolumnname
		cat(paste("Outliers are marked as TRUE in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
		## store pcadapt -logp scores in snps dataset:
		if(!is.null(snps$PCadaptlogp))
			{
			snps$PCadaptlogp			<<- NULL
			}
		snps$PCadaptlogp				<<- NA
		pcadaptlogp						<<- pcadaptlogp
		if(length(pcadaptlogp)!=nrow(snps[snps$filter2,]))
			{
			return(cat("ERROR: number of SNPs in the pcadapt input/output does not correspond with number of snps defined by snps$filter2 column. Halting execution. Potential solution: set overwriteped flag of the selectionanalyses function to TRUE.",sep="\n"))
			}
		snps$PCadaptlogp[snps$filter2]	<<- pcadaptlogp		# 27-09-2019: snps$filter2 or snps$filter?
		# change column name:
		if(my_k==1)
			{
			if(mycorrection=="bonferroni")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_bonf",my_dataset,sep="_")
				}
			}
		if(my_k==2)
			{
			if(mycorrection=="BH")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_BH",my_dataset,sep="_")
				}
			}
		if(my_k==3)
			{
			if(mycorrection=="holm")
				{
				mycolumnname	<- paste("PCadaptlogp",my_dataset,sep="_")
				}else{
				mycolumnname	<- paste("PCadaptlogp_holm",my_dataset,sep="_")
				}
			}
		names(snps)[names(snps) == "PCadaptlogp"] <<- mycolumnname
		snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		cat(paste("PCadapt -log(p) values are stored in the",mycolumnname,"column in the snps dataframe.",sep=" "),sep="\n")
		}
	if(!currentdir){setwd(mysambar$selectiondir)}
	if(do_plot)
		{
		pdf(paste("PCadapt",my_dataset,"pdf"),width=18,height=9)
		par(mfrow=c(2,1))
		plot(snps$PCadaptlogp_BH_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		mtext("Benjamini-Hochberg pvalues",side=2,line=2.5,cex=2)
		points(c(1:nrow(snps))[snps$PCadaptout_BH_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_BH_pheno],col="blue",pch=16,cex=1.5)
		points(c(1:nrow(snps))[snps$PCadaptout_holm_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_holm_pheno],col="darkgreen",pch=16,cex=1.5)	
		points(c(1:nrow(snps))[snps$PCadaptout_bonf_pheno],snps$PCadaptlogp_BH_pheno[snps$PCadaptout_bonf_pheno],col="red",cex=1.5,pch=16)
		legend("topleft",legend=c("Bonferroni outliers","holm outliers","Benjamini-Hochberg outliers"),fill=c("red","darkgreen","blue"),bty='n',cex=1.5)
		plot(snps$PCadaptlogp_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		mtext("Bonferroni pvalues",side=2,line=2.5,cex=2)
		points(c(1:nrow(snps))[snps$PCadaptout_BH_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_BH_pheno],col="blue",pch=16,cex=1.5)
		points(c(1:nrow(snps))[snps$PCadaptout_holm_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_holm_pheno],col="darkgreen",pch=16,cex=1.5)	
		points(c(1:nrow(snps))[snps$PCadaptout_bonf_pheno],snps$PCadaptlogp_pheno[snps$PCadaptout_bonf_pheno],col="red",cex=1.5,pch=16)
		plot(snps$PCadaptlogp_pheno,ylab="",cex.lab=2,cex.axis=1.5,pch=16)
		dev.off()
		}
	}

runOutflank<-function(indselection=inds$filter,export=TRUE,my_sign_level=0.05,my_dataset="metapop",popcolumn=inds$pop,myloci=snps$name[snps$filter2],mycorrection=NULL,domerge=TRUE,silent=TRUE,store_adjusted=FALSE,right_trim=0.95,no_balancing=TRUE,currentdir=FALSE)
	{
	current_dir	<- getwd()
	if(exists("P1"))
		{
		P1	<<- NULL
		}
	if(exists("outflankinput"))
		{
		outflankinput	<<- NULL
		}
	if(is.null(mycorrection))
		{
		cat("No multiple testing correction method specified. Defaulting to using q-value.",sep="\n")
		}else{
		if(mycorrection!="holm"&mycorrection!="bonferroni"&mycorrection!="BH")
			{
			return(cat("ERROR: mycorrection should be either 'holm', 'bonferroni', 'BH' or NULL.",sep="\n"))
			}else{
			cat(paste("Using ",mycorrection," method to correct for multiple testing.",sep=""),sep="\n")
			}
		}
	cat(paste("Specified dataset: ",my_dataset,".",sep=""),sep="\n")
	cat(paste("Specified significance threshold: ",my_sign_level,".",sep=""),sep="\n")
	cat(paste("Specified right_trim threshold: ",right_trim,". This means that whilst inferring the null Fst distribution, the SNPs with the top ",(1-right_trim)*100," percent Fst values will be ignored.",sep=""),sep="\n")
	cat(paste("Number of individuals: ",length(indselection[indselection]),".",sep=""),sep="\n")
	tempname				<- paste("OutFLANK",my_dataset,sep="_")
	tempname2				<- paste("OutFLANKlogp",my_dataset,sep="_")
	tempname3				<- paste("OutFLANKlogq",my_dataset,sep="_")
	if(tempname %in% colnames(snps))
		{
		snps[,tempname]	<<- NULL
		}
	if(tempname2 %in% colnames(snps))
		{
		snps[,tempname2]	<<- NULL
		}
	if(tempname3 %in% colnames(snps))
		{
		snps[,tempname3]	<<- NULL
		}
	#
	# Optionally fst distribution plots will be exported.
	# 19-01-2020: snps$filter2 contains !snps$polyfilter. Non-polymorphic loci result in errors.
	# sambarfunction_selection:
	### OutFLANK:
	# sambarfunction_selection:
	mymatrix					<- as.matrix(mygenlight[indselection,snps$filter2])	
	mymatrix[is.na(mymatrix)] 	<- 9
	# sambarfunction:
	outflankinput				<- MakeDiploidFSTMat(SNPmat=mymatrix,locusNames=myloci,popNames=popcolumn[indselection])
	if(!silent)
		{
		cat("passed MakeDiploidFstMat",sep="\n") 
		mymatrix		<<- mymatrix
		outflankinput	<<- outflankinput
		}
	#
	## Calibrating the null distribution of fst-values.
	# To do so we need a pruned dataset.
	# According to the manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
	# We assume that less than 5 percent are outliers (or other value specified by right_trim):
	# sambarfunction_selection:
	mymean				<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
	# sambarfunction_selection:
	myrate				<- 1/mymean
	# sambarfunction_selection:
	myvalue				<- qexp(right_trim,myrate)
	# sambarfunction_selection:
	prunevector			<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
	if(!silent)
		{
		cat("passed prunevector",sep="\n")
		prunevector		<<- prunevector
		} 
	# 12-10-2019: I used the above settings for the simulations, but this might be incorrect to do it this way.
	# Because in the function below OutFLANK trims 5 percent of top values and 5 percent of bottom values, so it is double. 
	# sambarfunction_selection:
	nrsamples			<- length(inds$pop[indselection])
	# sambarfunction_selection:
	npops				<- length(as.vector(unique(inds$pop[indselection])))
	# sambarfunction_selection:
	myfstmax			<- round(max(outflankinput$FSTNoCorr[prunevector],na.rm=TRUE),3)
	cat(paste("Highest Fst-value of pruned dataset: ", myfstmax,".",sep=""),sep="\n")
	if(!myfstmax<=0.99)
		{
		# This is to prevent the error:
		# ERROR: The largest FST in the trimmed set must be < 1. Please use a larger RightTrimFraction.
		# Error in !data$OutlierFlag : invalid argument type
		cat("Fst of pruned dataset ranges until 1. SambaR will not run OutFLANK and assume there are no outliers.",sep="\n")
		snps$OutFLANK		<<- FALSE
		snps$OutFLANKlogp	<<- 0
		snps$OutFLANKlogq	<<- 0
		colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
		}else{
		# NumberOfSamples is number of populations:
		# sambarfunction_selection:
		out_trim 			<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=npops,qthreshold=0.05,Hmin = 0.1)
		if(!silent){cat("passed OutFLANK",sep="\n")} 
		if(export)
			{
			if(!currentdir)
				{
				current_dir	<- mysambar$selectiondir
				setwd(current_dir)
				}
			if(dir.exists("OutFlankplots"))
				{
				setwd(file.path(current_dir,"OutFlankplots"))
				}else{
				dir.create(file.path(current_dir,"OutFlankplots"))
				setwd(file.path(current_dir,"OutFlankplots"))
				}
			pdf(paste("Outflank.fstdistribution",my_dataset,"pdf",sep="."))
			OutFLANKResultsPlotter(out_trim)
			dev.off()
			pdf(paste("Outflank.pvalues.righttail",my_dataset,"pdf",sep="."))
			hist(out_trim$results$pvaluesRightTail,main="",xlab="pvalues right tail",ylab="Frequency")
			dev.off()
			setwd(current_dir)
			}
		#
		## So now we have estimated neutral mean FST and df using the pruned dataset (snps$filter).
		# So now we can go back and calculate P-values and q-values for all loci.
		# sambarfunction_selection:
		P1 <- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar = out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = 0.05, Hmin=0.1)
		if(!silent){cat("pOutlierFinderChiSqNoCorr",sep="\n")} 
		#
		## Outliers?
		P1$negativelogp			<- -log10(P1$pvalues)
		P1$negativelogq			<- -log10(P1$qvalues)
		myfstmean				<- mean(P1$FST,na.rm=TRUE)
		P1$OutlierFlag_ALL		<- P1$qvalues<my_sign_level
		if(no_balancing)
			{
			cat("Because the flag 'no_balancing' is set to TRUE, SNPs putatively under balancing selection will be ignored.",sep="\n") 
			P1$OutlierFlag			<- P1$OutlierFlag_ALL&P1$FST>myfstmean
			}else{
			cat("Because the flag 'no_balancing' is set to FALSE, SNPs putatively under balancing selection will be included.",sep="\n") 
			P1$OutlierFlag			<- P1$OutlierFlag_ALL
			}
		if(!is.null(mycorrection))
			{
			cat(paste("Using the ",mycorrection," method to corrected p-values (rather than q-values (default)) to score outliers.",sep=""),sep="\n")
			P1$pvalues_adj		<- p.adjust(P1$pvalues,method=mycorrection) 
			P1$OutlierFlag_ALL	<- P1$pvalues_adj<my_sign_level
			if(no_balancing)
				{
				P1$OutlierFlag		<- P1$OutlierFlag_ALL&P1$FST>myfstmean
				}else{
				P1$OutlierFlag		<- P1$OutlierFlag_ALL
				}
			if(store_adjusted)
				{
				if(any(P1$pvalues_adj==0&!is.na(P1$pvalues_adj))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
				P1$negativelogp	<- ifelse(P1$pvalues_adj==0&!is.na(P1$pvalues_adj),20,-log10(P1$pvalues_adj))
				}else{
				if(any(P1$pvalues==0&!is.na(P1$pvalues_adj))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
				P1$negativelogp	<- ifelse(P1$pvalues==0&!is.na(P1$pvalues),20,-log10(P1$pvalues))
				}
			}
		if(any(is.infinite(P1$negativelogp))){cat("WARNING: Infinite OutFLANK log10(p-values) detected. Replacing with NA.",sep="\n")}
		P1$negativelogp[is.infinite(P1$negativelogp)]	<- 20
		P1$OutlierFlag[is.na(P1$OutlierFlag)]			<- FALSE
		noutliers_all			<- nrow(P1[P1$OutlierFlag_ALL&!is.na(P1$OutlierFlag_ALL),])
		noutliers				<- nrow(P1[P1$OutlierFlag&!is.na(P1$OutlierFlag),])
		cat(paste("OutFLANK detected",noutliers_all,"outlier SNPs (also including SNPs which might not have passed the filter settings).",sep=" "),sep="\n")
		cat(paste("Of these,",noutliers,"are supposedly under positive selection (rather than balancing selection).",sep=" "),sep="\n")
		if(export)
			{
			setwd(file.path(current_dir,"OutFlankplots"))
			pdf(paste("Outflank.outliers",my_dataset,"pdf",sep="."))
			#plot(P1$He[snps$filter2],P1$FST[snps$filter2],pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			plot(P1$He,P1$FST,pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			points(P1$He[P1$OutlierFlag],P1$FST[P1$OutlierFlag],pch=19,col="#336633")
			dev.off()			
			setwd(current_dir)
			}
		outtemp2		<- P1[,c("LocusName","OutlierFlag","negativelogp","negativelogq")]
		if(domerge)
			{
			# Merging keeps on returning errors (more rows than expected), so by default I choose for the more time consuming alternative option.
			colnames(outtemp2)<- c("name",tempname,tempname2,tempname3)
			outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
			if(nrow(outtemp3)!=nrow(snps))
				{
				return(cat("ERROR: number of rows in merged dataset does not correspond with number of rows of snps dataframe. Contact developer of SambaR.",sep="\n"))
				}
			#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
			#outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
			#outtemp4		<- outtemp3[order(outtemp3$chr,outtemp3$pos),]
			outtemp4		<- outtemp3[order(outtemp3$nr_neworder),]	# 23_11_2020
			if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
				{	
				outtemp2	<<- outtemp2
				outtemp3	<<- outtemp3
				outtemp4	<<- outtemp4
				return(cat("ERROR: after reordering (in order to incorporate OutFLANK results in snps dataframe) column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}
			snps			<<- outtemp4
			}else{
			cat("Adding results to the snps dataframe using a slow method. This will take a while...")
			snps$OutFLANK		<<- NA
			snps$OutFLANKlogp	<<- NA
			snps$OutFLANKlogq	<<- NA
			for(i in c(1:nrow(outtemp2)))
				{
				if(i%%5000==0){cat(i,sep="\n")}
				mylocus			<- outtemp2$LocusName[i]
				if(mylocus%in%snps$name)
					{
					snps$OutFLANK[snps$name==mylocus]		<<- outtemp2$OutlierFlag[i]
					snps$OutFLANKlogp[snps$name==mylocus]	<<- outtemp2$negativelogp[i]
					snps$OutFLANKlogq[snps$name==mylocus]	<<- outtemp2$negativelogq[i]
					}
				}
			colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
			}
		# replace NAs with FALSE:
		mycolumn					<- snps[,paste("OutFLANK",my_dataset,sep="_")]
		mycolumn[is.na(mycolumn)]	<- FALSE
		snps[,paste("OutFLANK",my_dataset,sep="_")]	<<- mycolumn
		cat(paste("Outliers, if present, are marked as TRUE in the",tempname,"column in the snps dataframe.",sep=" "),sep="\n")
		cat("Negative log of the pvalues and qvalues are saved as well.",sep="\n")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

runOutflank_old<-function(indselection=inds$filter,export=TRUE,my_sign_level=0.05,my_dataset="metapop",popcolumn=inds$pop,myloci=snps$name[snps$filter2],q_value=FALSE,domerge=TRUE,silent=TRUE)
	{
	#
	tempname				<- paste("OutFLANK",my_dataset,sep="_")
	tempname2				<- paste("OutFLANKlogp",my_dataset,sep="_")
	tempname3				<- paste("OutFLANKlogq",my_dataset,sep="_")
	if(tempname %in% colnames(snps))
		{
		snps[,tempname]	<<- NULL
		}
	if(tempname2 %in% colnames(snps))
		{
		snps[,tempname2]	<<- NULL
		}
	if(tempname3 %in% colnames(snps))
		{
		snps[,tempname3]	<<- NULL
		}
	#
	# Optionally fst distribution plots will be exported.
	mymatrix					<- as.matrix(mygenlight[indselection,snps$filter2])	# 19-01-2020: snps$filter2 contains !snps$polyfilter. Non-polymorphic loci result in errors.
	mymatrix[is.na(mymatrix)] 	<- 9
	outflankinput				<- MakeDiploidFSTMat(SNPmat=mymatrix,locusNames=myloci,popNames=popcolumn[indselection])
	if(!silent)
		{
		cat("passed MakeDiploidFstMat",sep="\n") 
		mymatrix		<<- mymatrix
		outflankinput	<<- outflankinput
		}
	#
	## Calibrating the null distribution of fst-values.
	# To do so we need a pruned dataset.
	# According to the manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
	# We assume that less than 5 percent are outliers:
	mymean				<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
	myrate				<- 1/mymean
	myvalue				<- qexp(0.95,myrate)
	prunevector			<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
	if(!silent)
		{
		cat("passed prunevector",sep="\n")
		prunevector		<<- prunevector
		} 
	# 12-10-2019: I used the above settings for the simulations, but this might be incorrect to do it this way.
	# Because in the function below OutFLANK trims 5 percent of top values and 5 percent of bottom values, so it is double. 
	nrsamples			<- length(inds$pop[indselection])
	npops				<- length(as.vector(unique(inds$pop[indselection])))
	myfstmax			<- max(outflankinput$FSTNoCorr[prunevector],na.rm=TRUE)
	if(myfstmax==1)
		{
		# This is to prevent the error:
		# ERROR: The largest FST in the trimmed set must be < 1. Please use a larger RightTrimFraction.
		# Error in !data$OutlierFlag : invalid argument type
		cat("Fst of pruned dataset ranges until 1. SambaR will not run OutFLANK and assume there are no outliers.",sep="\n")
		snps$OutFLANK		<<- FALSE
		snps$OutFLANKlogp	<<- 0
		snps$OutFLANKlogq	<<- 0
		colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
		colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
		}else{
		# NumberOfSamples is number of populations:
		out_trim 			<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=npops,qthreshold=0.05,Hmin = 0.1)
		if(!silent){cat("passed OutFLANK",sep="\n")} 
		if(export)
			{
			setwd(mysambar$selectiondir)
			if(file.exists("OutFlankplots"))
				{
				setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
				}else{
				dir.create(file.path(mysambar$selectiondir,"OutFlankplots"))
				setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
				}
			pdf(paste("Outflank.fstdistribution",my_dataset,"pdf",sep="."))
			OutFLANKResultsPlotter(out_trim)
			dev.off()
			pdf(paste("Outflank.pvalues.righttail",my_dataset,"pdf",sep="."))
			hist(out_trim$results$pvaluesRightTail,main="",xlab="pvalues right tail",ylab="Frequency")
			dev.off()
			setwd(mysambar$selectiondir)
			}
		#
		## So now we have estimated neutral mean FST and df using the pruned dataset (snps$filter).
		# So now we can go back and calculate P-values and q-values for all loci.
		P1 <- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar = out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = 0.05, Hmin=0.1)
		if(!silent){cat("pOutlierFinderChiSqNoCorr",sep="\n")} 
		#
		## Outliers?
		P1$negativelogp			<- -log(P1$pvalues)
		P1$negativelogq			<- -log(P1$qvalues)
		if(!q_value)
			{
			cat("Using holm corrected p-values rather than q-values (default) to score outliers.",sep="\n")
			P1$pvalues_holm		<- p.adjust(P1$pvalues,method="holm") 
			P1$OutlierFlag		<- P1$pvalues_holm<my_sign_level
			P1$negativelogp		<- -log(P1$pvalues_holm)
			}
		P1$OutlierFlag[is.na(P1$OutlierFlag)]	<- FALSE
		#noutliers				<- nrow(P1[P1$OutlierFlag&snps$filter2&!is.na(P1$OutlierFlag),])
		noutliers				<- nrow(P1[P1$OutlierFlag&!is.na(P1$OutlierFlag),])
		#P1						<<- P1
		cat(paste("OutFLANK detected",noutliers,"outlier loci.",sep=" "),sep="\n")
		if(export)
			{
			setwd(file.path(mysambar$selectiondir,"OutFlankplots"))
			pdf(paste("Outflank.outliers",my_dataset,"pdf",sep="."))
			#plot(P1$He[snps$filter2],P1$FST[snps$filter2],pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			plot(P1$He,P1$FST,pch=19,cex=0.5,col="#99CCFF",xlab="He",ylab="Fst")
			points(P1$He[P1$OutlierFlag],P1$FST[P1$OutlierFlag],pch=19,col="#336633")
			dev.off()			
			setwd(mysambar$selectiondir)
			}
		outtemp2		<- P1[,c("LocusName","OutlierFlag","negativelogp","negativelogq")]
		if(domerge)
			{
			# Merging keeps on returning errors (more rows than expected), so by default I choose for the more time consuming alternative option.
			colnames(outtemp2)<- c("name",tempname,tempname2,tempname3)
			outtemp3 		<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
			#outtemp4		<- outtemp3[order(as.numeric(outtemp3$chr),as.numeric(outtemp3$pos)),]
			outtemp4		<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
			#outtemp4		<- outtemp3[order(outtemp3$chr,outtemp3$pos),]
			if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
				{	
				outtemp2	<<- outtemp2
				outtemp3	<<- outtemp3
				outtemp4	<<- outtemp4
				return(cat("ERROR: after reordering column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}
			snps			<<- outtemp4
			}else{
			cat("Adding results to the snps dataframe using a slow method. This will take a while...")
			snps$OutFLANK		<<- NA
			snps$OutFLANKlogp	<<- NA
			snps$OutFLANKlogq	<<- NA
			for(i in c(1:nrow(outtemp2)))
				{
				if(i%%5000==0){cat(i,sep="\n")}
				mylocus			<- outtemp2$LocusName[i]
				if(mylocus%in%snps$name)
					{
					snps$OutFLANK[snps$name==mylocus]		<<- outtemp2$OutlierFlag[i]
					snps$OutFLANKlogp[snps$name==mylocus]	<<- outtemp2$negativelogp[i]
					snps$OutFLANKlogq[snps$name==mylocus]	<<- outtemp2$negativelogq[i]
					}
				}
			colnames(snps)[which(colnames(snps)=="OutFLANK")]		<<- paste("OutFLANK",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogq")]	<<- paste("OutFLANKlogp",my_dataset,sep="_")
			colnames(snps)[which(colnames(snps)=="OutFLANKlogp")]	<<- paste("OutFLANKlogq",my_dataset,sep="_")
			}
		# replace NAs with FALSE:
		mycolumn					<- snps[,paste("OutFLANK",my_dataset,sep="_")]
		mycolumn[is.na(mycolumn)]	<- FALSE
		snps[,paste("OutFLANK",my_dataset,sep="_")]	<<- mycolumn
		cat(paste("Outliers, if present, are marked as TRUE in the",tempname,"column in the snps dataframe.",sep=" "),sep="\n")
		cat("Negative log of the pvalues and qvalues are saved as well.",sep="\n")
		}
	snps <<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	}

multi_plot_scanlog<-function(popnames=mysambar$populations,allpairwise=FALSE,do_export=NULL,outflank_q=FALSE,silent=TRUE)
	{
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		plot_scanlog(doexport=do_export,outflankq=outflank_q,mydataset="pheno")
		}
	#allcombitemp	<<- allcombi
	ncombi		<- ncol(allcombi)	
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		my_data_set	<- paste(my_pops[1],my_pops[2],sep="_")
		if(paste("rfisherGWDSlogp",my_data_set,sep="_")%in%colnames(snps))
			{
			if(!silent){cat(my_data_set,sep="\n")}
			plot_scanlog(doexport=do_export,outflankq=outflank_q,mydataset=my_data_set,silent=silent)
			}else{
			cat(paste("WARNING: snps dataframe does not contain column with fisher test logp values for population pair ",mypop_1," and ",mypop_2,".",sep=""),sep="\n")
			}
		}
	}

# Note: if OutFLANK p-values are determined based on q-value, possibly some neutral SNPs which have a higher p-value than SNPs marked as outlier 
plot_scanlog<-function(doexport=NULL,outflankq=FALSE,mydataset=NULL,markoutpheno=TRUE,silent=TRUE)
	{
	if(is.null(mydataset))
		{
		return(cat("ERROR: Specify an input dataset!",sep="\n"))
		}
	# This function plots negative logs of pvalues of GWDS and PCadapt, and qvalues of OutFLANK and optionally Bayescan
	snpcolnames		<- names(snps)
	alloci			<- c(1:nrow(snps))
	# GWDS:
	mycolumn		<- paste("rfisherout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		myGWDSlog		<- snps[,paste("rfisherGWDSlogp",mydataset,sep="_")]
		myGWDSout		<- snps[,paste("rfisherout",mydataset,sep="_")]
		}else{
		myGWDSlog		<- rep(NA,nrow(snps))
		myGWDSout		<- rep(NA,nrow(snps))
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		myPCadaptlog	<- snps[,paste("PCadaptlogp",mydataset,sep="_")]
		myPCadaptout	<- snps[,paste("PCadaptout",mydataset,sep="_")]
		}else{
		myPCadaptlog	<- rep(NA,nrow(snps))
		myPCadaptout	<- rep(NA,nrow(snps))
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		if(outflankq)
			{
			myOutFLANKlog	<- snps[,paste("OutFLANKlogq",mydataset,sep="_")]
			}else{
			myOutFLANKlog	<- snps[,paste("OutFLANKlogp",mydataset,sep="_")]
			}
		myOutFLANKout	<- snps[,paste("OutFLANK",mydataset,sep="_")]
		}else{
		myOutFLANKlog	<- rep(NA,nrow(snps))
		myOutFLANKout	<- rep(NA,nrow(snps))
		}
	# Bayescan:
	mycolumn		<- paste("bayescanout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		myBayescanlog	<- snps[,paste("bayescanlogq",mydataset,sep="_")]
		myBayescanout	<- snps[,paste("bayescanout",mydataset,sep="_")]
		}else{
		myBayescanlog	<- rep(NA,nrow(snps))
		myBayescanout	<- rep(NA,nrow(snps))
		}
	# fsthet:
	mycolumn		<- paste("fsthetout",mydataset,sep="_")
	if(mycolumn%in%snpcolnames)	
		{
		myfsthetlog		<- snps[,paste("fsthetlogp",mydataset,sep="_")]
		myfsthetout		<- snps[,paste("fsthetout",mydataset,sep="_")]
		}else{
		myfsthetlog		<- rep(NA,nrow(snps))
		myfsthetout		<- rep(NA,nrow(snps))
		}
	mylogvaluesdf		<- as.data.frame(cbind(myBayescanlog,myfsthetlog,myGWDSlog,myOutFLANKlog,myPCadaptlog))
	colnames(mylogvaluesdf)	<- c("Bayescan","Fsthet","GWDS","OutFLANK","PCadapt")
	myoutdf				<- as.data.frame(cbind(myBayescanout,myfsthetout,myGWDSout,myOutFLANKout,myPCadaptout))
	colnames(myoutdf)	<- c("Bayescan","Fsthet","GWDS","OutFLANK","PCadapt")
	# myoutdf				<<- myoutdf
	if(!silent){mylogvaluesdf	<<- mylogvaluesdf}
	mylogmax			<- max(mylogvaluesdf,na.rm=TRUE)
	#
	mytests				<- as.vector(which(colSums(is.na(myoutdf))<nrow(myoutdf)))
	mytestnames			<- colnames(myoutdf)[mytests]
	myoutdf				<- myoutdf[,colSums(is.na(myoutdf))<nrow(myoutdf)]
	myoutdf				<- as.data.frame(myoutdf)
	colnames(myoutdf)	<- mytestnames
	mylogvaluesdf			<- mylogvaluesdf[,colSums(is.na(mylogvaluesdf))<nrow(mylogvaluesdf)]
	mylogvaluesdf			<- as.data.frame(mylogvaluesdf)
	colnames(mylogvaluesdf)	<- mytestnames
	#	
	graphics.off()	
	ntiles				<- ncol(myoutdf)
	if(!is.null(doexport))
		{
		outputfile		<- paste("Selectionscan.logpvalues",mydataset,sep=".")
		if(doexport=="pdf"){pdf(paste(outputfile,"pdf",sep="."),height=ntiles*2+3,width=14)}
		}
	par(mfrow=c(ntiles,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	for(j in c(1:ntiles))
		{
		#if(!silent){cat(j,sep="\n")}
		mylogvalues	<- mylogvaluesdf[,j]
		myoutliers	<- myoutdf[,j]
		myymax		<- ifelse(!is.null(mylogmax),max(mylogvalues[is.finite(mylogvalues)],na.rm=TRUE),mylogmax)
		myymax		<- ifelse(myymax<1,1,myymax)
		myylim		<- c(0,myymax)
		myxaxt		<- ifelse(j==ntiles,'s','n')
		plot(alloci[snps$filter2],mylogvalues[snps$filter2],xaxt=myxaxt,ylab="",pch=16,ylim=myylim,las=1)
		if(markoutpheno)
			{
			rfisheroutliers	<- snps[,paste("rfisherout",mydataset,sep="_")]
			gwdsoutnr		<- which(rfisheroutliers&snps$filter2)
			abline(v=gwdsoutnr,col="grey")
			}
		if(length(myoutliers[myoutliers])>0)
			{
			points(alloci[myoutliers&snps$filter2],mylogvalues[myoutliers&snps$filter2],col="red",pch=16)
			}
		mylabel		<- mytestnames[j]
		mtext(mylabel,side=4,line=1.5,cex=1.75)
		mtext("-log(test statistic)",side=2,line=0.5,cex=2.5,outer=TRUE)
		mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
		}
	if(!is.null(doexport))
		{
		dev.off()
		cat(paste("A file called",outputfile,"has been exported.",sep=" "),sep="\n")
		}
	}

writebed<-function(my_dataset="pheno")
	{
	if(paste("bayescanout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("bayescanout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("Bayescanoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("PCadaptout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("PCadaptout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("PCadaptoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("OutFlank",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("OutFlank",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("OutFlankoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	if(paste("rfisherout",my_dataset,sep="_")%in%colnames(snps))
		{
		outfilter	<- snps[,paste("rfisherout",my_dataset,sep="_")]
		mybed		<- snps[outfilter,c("chr","pos","pos","name")]
		mybed$pos.1	<- mybed$pos+1
		write.table(mybed,paste("GWDSoutliers",my_dataset,"bed",sep="."),sep="\t",col.names=FALSE,row.names=FALSE,quote=FALSE)
		}
	cat("BED-files with outliers have been written to the selection subdirectory",sep="\n")
	}

# this function can not be in exportsambarfiles(), because at that stage pheno has not been defined yet. 	
createbayescaninput<-function(allpairwise=FALSE,baye_overwrite=FALSE,popnames=mysambar$populations)
	{
	if(is.null(inds$type)&!allpairwise)
		{
		return(cat("ERROR: column 'inds$type' (boolean vector) does not exist. First create this column as explained in manual.",sep="\n"))
		}
	if(allpairwise)
		{
		allcombi	<- combn(popnames,m=2)
		combinames	<- paste(allcombi[1,],allcombi[2,],sep="_")
		}else{
		type1		<- as.vector(unique(inds$pop[inds$type]))
		type2		<- as.vector(unique(inds$pop[!inds$type]))
		allcombi	<- t(expand.grid(type1,type2))
		combinames	<- paste(allcombi[1,],allcombi[2,],sep="_")
		}
	ncombi			<- ncol(allcombi)
	for(my_i in c(1:ncombi))
		{
		mypop_1		<- allcombi[1,my_i]
		mypop_2		<- allcombi[2,my_i]
		my_pops		<- c(mypop_1,mypop_2)
		my_pops		<- my_pops[order(my_pops)]
		mypop_1		<- my_pops[1]
		mypop_2		<- my_pops[2]
		indselect	<- inds$filter&(inds$pop==mypop_1|inds$pop==mypop_2)
		combiname	<- paste(combinames[my_i],"filter2.letter",sep=".")
		exportdata(indsfilter=indselect,snpsfilter=snps$filter2,export_name=combiname,geno_nr=FALSE,do_all=FALSE)
		}
	if(!allpairwise)
		{
		cat("pheno1_pheno2 (pooled data)",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=snps$filter2,export_name="pheno.filter2.letter",geno_nr=FALSE,do_all=FALSE,do_pheno=TRUE)
		}
	}	

getbayescan<-function(FDR=0.01,export=NULL,my_dataset=NULL,use_merge=TRUE,inputmapfile=NULL,baye_overwrite=FALSE,silent=FALSE,dolog10=TRUE,my_qmax=NULL,my_fstmax=NULL)
	{
	# the Bayescan output file consists of the following columns: 
	# 1. The index of the locus corresponding to the index in the input file.
	# 2. The Bayesian posterior probability for the model including selection. 
	#	 E.g. p=0.75 means that the selection and neutral models have probabilities of 0.75 and 0.25, hence Bayes factor (BF) or odds ratio (OR) is 3 (0.75/0.25). Ergo, selection model is 3x more likely than neutral model. 
	#	 E.g. p=0.95 means that the selection and neutral models have probabilities of 0.95 and 0.05, hence Bayes factor (BF) or odds ratio (OR) is 19 (0.95/0.05). Ergo, selection model is 19x more likely than neutral model.
	#	 E.g. p=0.999 means that the selection and neutral models have probabilities of 0.999 and 0.001, hence Bayes factor (BF) or odds ratio (OR) is 999 (0.999/0.001). Ergo, selection model is 999x more likely than neutral model.
	# 	 E.g. p=0.1 means that the selection and neutral models have probabilities of 0.1 and 0.9, hence Bayes factor (BF) or odds ratio (OR) is 0.11 (0.1/0.9). Ergo, selection model is 10x LESS likely than neutral model.
	# 3. The logarithm of Posterior Odds (Bayes factor) to base 10 for the model including selection. Note that this value is arbitrarily fixed to 1000 when the posterior probability is 1 (should be infinity).
	#	 E.g. for p=0.75, BF=3, and log10(BF)=0.47
	#	 E.g. for p=0.95, BF=19, and log10(BF)=1.28
	#	 E.g. for p=0.999, BF=999, and log10(BF)=3
	#	 E.g. for p=0.1, BF=0.11, and log10(BF)=-0.96
	#	 According to Jeffrey's model of interpreting odds ratios, evidence can be interpreted as follows:
	#	 BF			log10(BF)	Jeffrey's interpretation
	#	 1-3		0-0.5		(barely) worth mentioning
	#	 3-10		0.5-1		substantial		
	#	 10-32		1-1.5		strong
	#	 32-100		1.5-2		very strong
	#	 100-inf	2-inf		decisive
	# 4. The q-value for the model including selection.
	#	 A bit of explanation: 
	#	 Recall that a p-value of 0.05 implies a chance of 5% of false positives. Say we have a dataset of 50000 SNPs, just by chance we expect 2500 SNPs with a p-value below 0.05.
	#	 A q-value of 0.05, in contrast, implies that 5% of all SNPs with a q-value equal or lower than 0.05, are false positives. Say there are 100 SNPs with a q-value below 0.05, 5 SNPs are expected to be false positives. 
	#	 In other words: a q-value denotes the false discovery rate (FDR).
	# 	 So how do get from a p-value to a q-value? In essence, a q-value is an adjusted p-value, like a Bonferroni adjusted p-value.
	#	 A (or the?) method used to correct p-values to q-values is the Benjamini-Hochberg correction. The function is like this: 
	#	 q-value = p-value*N/k
	#	 in which N is the total number of p-values, and k is the rank of this particular p-value (i.e. which indicates how many SNPs with lower p-values the dataset contains.)
	# 	 E.g.: in a dataset of 4 SNPs with p-values 0.01, 0.05, 0.1, 0.5, we get:
	#	 p-value	rank	N	q-value (=FDR)
	#	 0.5		4		4	0.5
	# 	 0.1		3		4	0.10*4/3 = 0.13
	#	 0.05		2		4	0.05*4/2 = 0.1
	#	 0.01		1		4	0.01*4/1 = 0.04
	# 	 Why does this simple formula indeed show FDR? Because:
	#	 The numerator 'p-value*N' (in short: pN) gives expected number of false positives if the p-value would be the significance threshold.
	#	 The denominator 'k' gives the actual number of SNPs with p-values below this threshold.
	# 	 The ratio therefore shows the false discovery rate. In case of k>pN, there are more SNPs with p-values below the threshold, than expected. The excess likely represents true outliers.
	#	 Note however that the output of p.adjust(prob,method="BH") differs from Bayescan q-value estimates.
	# 5. The estimated alpha coefficient indicates the strength and direction of selection. A positive value of alpha suggests diversifying selection, whereas negative values suggest balancing or purifying selection.
	# 6. The FST coefficient averaged over populations. In each population FST is calculated as the posterior mean using model averaging.
	#
	# IMPORTANT NOTE:
	# Bayescan logp values displayed by SambaR are -log10(1-prob) values, in which prob denotes Bayesian posterior probabilities of selection model.
	# These scores are normally not displayed, and just reflect the preference of the developer of SambaR.
	#
	if(is.null(my_dataset))
		{
		return(cat("ERROR: please specify a dataset to the my_dataset flag.",sep="\n"))
		}else{
		cat(paste("Specified dataset (my_dataset flag): ",my_dataset,".",sep=""),sep="\n")
		}
	cat(paste("False discovery rate is set to:",FDR,sep=" "),sep="\n")
	tempname	<- paste("bayescanout",my_dataset,sep="_")
	if(tempname%in%colnames(snps)&!baye_overwrite)
		{
		if(!silent){cat("Bayescan outlier column already present. Bayescan results will not be added. To force overwrite, set baye_overwrite to TRUE.",sep="\n")}
		tempname2	<- paste("bayescanlogq",my_dataset,sep="_")
		mylogqscores<- snps[,which(names(snps) == tempname2)]
		myqscores	<- 10^(-mylogqscores)
		bayeout		<- myqscores<FDR&!is.na(myqscores)
		noutliers	<- length(which(bayeout))
		snps[,which(names(snps) == tempname)]	<<- bayeout 
		}else{
		setwd(mysambar$inputfilesdir)
		if(is.null(inputmapfile))
			{
			mapfile	<- paste(my_dataset,"filter2.miss0.letter.map",sep=".")
			}else{
			mapfile	<- inputmapfile
			}
		if(!file.exists(mapfile))
			{
			cat(paste("ERROR: the inputfiles directory does not contain a file called ",mapfile,". Path to inputfiles directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}else{
			y		<- read.table(mapfile)	# mapfile used when converting ped/map to geste/bayescan.
			}
		myloci		<- y$V2
		# import bayescan results: 
		bayescanfile		<- paste(my_dataset,"bayescanout.fst.txt",sep=".")
		if(!file.exists(bayescanfile))
			{
			cat(paste("ERROR: the inputfiles directory does not contain a file called ",bayescanfile,". Path to inputfiles directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}else{
			x		<- read.table(bayescanfile) 
			bayescan_data	<<- x
			}
		if(nrow(x)!=nrow(y))
			{
			cat(paste("ERROR: Number of rows in '",mapfile,"' file does not correspond with number of rows in '",bayescanfile,"'.",sep=""),sep="\n") 
			cat("From which PED and MAP file did you convert your data to the Bayescan input file?",sep="\n") 
			return(cat("Store the MAP file in the inputfiles directory, and rerun the getbayescan function by full name of the MAP file to the 'inputmapfile'.",sep="\n"))
			}
		x$name			<- myloci
		x$bayescanout	<- x$qval<FDR
		noutliers		<- length(which(x$bayescanout))
		if(dolog10)
			{
			x$bayescanlogp	<- -log10(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log10(x$qval)
			}else{
			x$bayescanlogp	<- -log(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log(x$qval)
			}
		# add to snps dataframe:
		if(!use_merge|!is.null(inputmapfile))
			{
			# Not using merge (i.e. this for loop) returns NA values for non-outliers for bayescanlogq, so not an option really.
			#outtemp2			<- x[x$bayescanout,c("name","bayescanout","bayescanlogq")]		
			outtemp2			<- x[,c("name","bayescanout","bayescanlogq","bayescanlogp","log10.PO.")]	
			snps$bayescanout	<<- FALSE
			snps$bayescanlogq	<<- NA
			snps$bayescanlogp	<<- NA
			snps$bayescanlogBF	<<- NA
			for(j in 1:nrow(outtemp2))
				{
				mylocus	<- as.vector(outtemp2$name[j])
				myout	<- as.vector(outtemp2$bayescanout[j])
				mylogq	<- as.vector(outtemp2$bayescanlogq[j])
				mylogp	<- as.vector(outtemp2$bayescanlogp[j])
				mylogBF	<- as.vector(outtemp2$log10.PO.[j])
				#cat(mylocus,sep="\n")
				#snps$bayescanout[snps$name==mylocus]	<<- TRUE
				snps$bayescanout[snps$name==mylocus]	<<- myout
				snps$bayescanlogq[snps$name==mylocus]	<<- mylogq
				snps$bayescanlogp[snps$name==mylocus]	<<- mylogp
				snps$bayescanlogBF[snps$name==mylocus]	<<- mylogBF
				}
			}else{
			# Rather than for loop, we could also use merge function, which is faster:
			if(!is.null(snps$bayescanout))
				{
				snps$bayescanout	<<- NULL
				}
			if(!is.null(snps$bayescanlogq))
				{
				snps$bayescanlogq	<<- NULL
				}
			if(!is.null(snps$bayescanlogp))
				{
				snps$bayescanlogp	<<- NULL
				}
			if(!is.null(snps$bayescanlogBF))
				{
				snps$bayescanlogBF	<<- NULL
				}
			outtemp2	<- x[,c("name","alpha","bayescanout","bayescanlogq","bayescanlogp","log10.PO.")]
			names(outtemp2)[which(names(outtemp2)=="alpha")]	<- "bayescanalpha"
			names(outtemp2)[which(names(outtemp2)=="log10.PO.")]<- "bayescanlogBF"
			outtemp3 	<- merge(x = snps, y = outtemp2, by = "name", all = TRUE)
			outtemp4	<- outtemp3[order(outtemp3$chr,as.numeric(outtemp3$pos)),]
			outtemp4$bayescanout[is.na(outtemp4$bayescanout)]	<- FALSE
			if(length(colnames(as.matrix(mygenlight)))!=length(outtemp4$genlightname))
				{
				return(cat("ERROR: Number of columns of genlight object does not correspond with number of rows bayescan file.",sep="\n"))
				}
			if(any(!colnames(as.matrix(mygenlight))==outtemp4$genlightname))
				{	
				outtemp3	<<- outtemp3
				outtemp4	<<- outtemp4
				return(cat("ERROR: after reordering column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n"))
				}	
			snps		<<- outtemp4
			}
		# export pdf:
		setwd(mysambar$selectiondir)
		if(!silent){cat("Plotting Bayescan qvalue plot...",sep="\n")}
		if(!is.null(export))
			{
			plotname	<- paste("Bayescanplot",my_dataset,"FDR",FDR,sep="_")
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
			}
		par(cex.lab=2,cex.axis=2)
		my_qmax		<- ifelse(is.null(my_qmax),4,my_qmax)
		my_fstmax	<- ifelse(is.null(my_fstmax),0.4,my_fstmax)
		my_qmin		<- ifelse(min(-log10(x$qval))>=0,0,min(-log10(x$qval)))
		plot(-log10(x$qval),x$fst,xlab="-log10(qvalue)",ylab="",pch=16,xlim=c(my_qmin,my_qmax),ylim=c(0,my_fstmax))
		points(-log10(x$qval)[x$qval<FDR],x$fst[x$qval<FDR],col="red",pch=16)
		abline(v=-log10(FDR),lty=2)	
		mtext(side=2,"Fst",cex=2,line=2.5)
		mtext(side=3,my_dataset,cex=2,line=0.5)
		legend("topleft",lty=2,legend=paste("FDR = ",FDR),bty='n',cex=2)
		if(!is.null(export)){dev.off()}
		#
		if(!is.null(export))
			{
			plotname	<- paste("Bayescanplot2",my_dataset,"FDR",FDR,sep="_")
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
			}
		par(cex.lab=2,cex.axis=2)
		plot(x$alpha,-log10(x$qval),xlab="alpha",ylab="",pch=16)
		points(x$alpha[x$qval<FDR],-log10(x$qval)[x$qval<FDR],col="red",pch=16)
		abline(h=-log10(FDR),lty=2)	
		mtext(side=2,"-log10(qvalue)",cex=2,line=2.5)
		mtext(side=3,my_dataset,cex=2,line=0.5)
		legend("topleft",lty=2,legend=paste("FDR = ",FDR),bty='n',cex=2)
		if(!is.null(export)){dev.off()}
		#
		if(!silent){cat("Plotting Bayescan qvalue plot with various threshold...",sep="\n")}
		if(!is.null(export))
			{
			plotname	<- paste("Bayescanplot2_multiFDR",my_dataset,sep="_")
			if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."))}
			}
		par(cex.lab=2,cex.axis=2)
		plot(x$alpha,-log10(x$qval),xlab="alpha",ylab="",pch=16,ylim=c(my_qmin,my_qmax))
		points(x$alpha[x$qval<0.05],-log10(x$qval)[x$qval<0.05],col="grey",pch=16)
		points(x$alpha[x$qval<0.02],-log10(x$qval)[x$qval<0.02],col="darksalmon",pch=16)
		points(x$alpha[x$qval<0.01],-log10(x$qval)[x$qval<0.01],col="red",pch=16)
		abline(h=-log10(0.01),lty=3)	
		abline(h=-log10(0.02),lty=2)
		abline(h=-log10(0.05),lty=1)
		mtext(side=2,"-log10(qvalue)",cex=2,line=2.5)
		mtext(side=3,my_dataset,cex=2,line=0.5)
		legend("topleft",lty=c(3,2,1),legend=c("FDR = 0.01","FDR = 0.02","FDR = 0.05"),bty='n',cex=2)
		if(!is.null(export)){dev.off()}
		#	
		# rename:
		tempname	<- paste("bayescanout",my_dataset,sep="_")
		tempname2	<- paste("bayescanlogq",my_dataset,sep="_")
		tempname3	<- paste("bayescanalpha",my_dataset,sep="_")
		tempname4	<- paste("bayescanlogp",my_dataset,sep="_")
		tempname5	<- paste("bayescanlogBF",my_dataset,sep="_")
		names(snps)[names(snps) == "bayescanout"] 	<<- tempname
		names(snps)[names(snps) == "bayescanlogq"] 	<<- tempname2
		names(snps)[names(snps) == "bayescanalpha"] <<- tempname3
		names(snps)[names(snps) == "bayescanlogp"] 	<<- tempname4
		names(snps)[names(snps) == "bayescanlogBF"] <<- tempname5
		snps 		<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
		cat("Columns 'bayescanout_dataset','bayescanlogq_dataset', 'bayescanlogp_dataset', 'bayescanlogBF_dataset' and 'bayescanalpha_dataset' have been added to the snps dataframe.",sep="\n")
		if(!is.null(export))
			{
			cat("Plots have been exported to the selection directory.",sep="\n")
			}
		}
	cat(paste("A FDR of ",FDR," results in ",noutliers," outliers.",sep=""),sep="\n",spec_min=0.999)
	}

# 15-11-2019: currently applicable to reindeer dataset only		
exp_nout<-function(export="pdf",bayescanfile=NULL,nloci=60000,nsel=1000,comp_nr=3,spec_min=0.9995,my_datasets=c("Barff_Norway","Busen_Norway","pheno"),bayescanFDR=0.01)
	{
	mytestscores	<- mysambarsim$mytestscores				
	mytestscores2	<- mysambarsim$mytestscores2
	if(!exists("snps"))
		{
		return(cat("ERROR: no SNPs dataframe.",sep="\n"))
		}
	if(!"Barff"%in%mysambar$population2)
		{
		return()
		}
	# testspec		<- c(0.9998,0.99995,1,0.9996)	# Bayescan, GWDS, OutFLANK, PCadapt
	# Barff_Norway	<- c(0,7,0,35)					
	# Busen_Norway	<- c(12,0,0,16)
	# pheno			<- c(13,3,0,25)
	# Barff_Norway	<- c(6,5,0,13)
	# Busen_Norway	<- c(0,2,0,41)
	# pheno			<- c(10,3,0,15)
	# points(testspec*100,Barff_Norway,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	# points(testspec*100,Busen_Norway,col=c("red","blue","yellow","darkgreen"),pch=16,cex=2)
	# points(testspec*100,pheno,col=c("red","blue","orange","darkgreen"),pch=16,cex=2)
	#
	#
	cat("Extracting from SNPs dataset number of observed outliers per selection scan...",sep="\n")
	ndatasets			<- length(my_datasets)
	mymatrix			<- matrix(NA,ncol=ifelse(!is.null(bayescanfile),4,3),nrow=ndatasets) 
	rownames(mymatrix)	<- my_datasets
	if(!is.null(bayescanfile))
		{
		colnames(mymatrix)		<- c("GWDS","OutFLANK","PCadapt","Bayescan")
		mycols					<- c("blue","orange","darkgreen","darkred")
		}else{
		colnames(mymatrix)		<- c("GWDS","OutFLANK","PCadapt")
		mycols					<- c("blue","orange","darkgreen")
		}
	for (k in c(1:ndatasets))
		{
		my_dataset	<- my_datasets[k]
		cat(paste("Dataset: ",my_dataset,".",sep=""),sep="\n")
		snpcolnames				<- names(snps)
		# GWDS:
		mycolumn				<- paste("rfisherout",my_dataset,sep="_")
		if(mycolumn%in%snpcolnames)		
			{
			outfilter			<- snps[,mycolumn]
			mymatrix[k,1]		<- nrow(snps[outfilter&snps$filter2,])
			}else{
			return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan GWDS.",sep="\n"))  
			}
		# OutFLANK:
		mycolumn				<- paste("OutFLANK",my_dataset,sep="_")
		if(mycolumn%in%snpcolnames)		
			{
			outfilter			<- snps[,mycolumn]
			mymatrix[k,2]		<- nrow(snps[outfilter&snps$filter2,])
			}else{
			return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan OutFLANK.",sep="\n"))  
			}
		# PCadapt:
		mycolumn				<- paste("PCadaptout",my_dataset,sep="_")
		if(mycolumn%in%snpcolnames)		
			{
			outfilter			<- snps[,mycolumn]
			mymatrix[k,3]		<- nrow(snps[outfilter&snps$filter2,])
			}else{
			return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan PCadapt.",sep="\n"))  
			}
		if(!is.null(bayescanfile))
			{
			# bayescan:
			mycolumn			<- paste("bayescanout",my_dataset,sep="_")
			if(mycolumn%in%snpcolnames)		
				{
				outfilter		<- snps[,mycolumn]
				mymatrix[k,4]	<- nrow(snps[outfilter&snps$filter2,])
				}else{
				return(cat("ERROR: no results for specified dataset in SNPs dataset for the selection scan Bayescan.",sep="\n"))  
				}
			}
	 	}
	#
	cat("Extracting specificity of selection scans from simulation output...",sep="\n")
	if(is.null(bayescanfile))
		{
		cat("Not including Bayescan.",sep="\n")
		testspec		<- c(mytestscores2$gwds_specificity[3],mytestscores2$OutFLANK_specificity[3],mytestscores2$PCadapt_specificity[3])
		}else{
		cat("Including Bayescan output...",sep="\n")
		getbayescansim(bayescanfile=bayescanfile,FDR=bayescanFDR)
		cat(paste("Specified number of SNPs: ",nloci,".",sep=""),sep="\n")
		cat(paste("Specified number of adaptive SNPs: ",nsel,".",sep=""),sep="\n")
		neutralnr		<- nloci-nsel
		retainednr		<- round(neutralnr*mytestscores$retained_neutral[3])
		bayescanspec	<- 1-length(which(simbayescan$bayescanout[1:neutralnr]))/retainednr
		testspec		<- c(mytestscores2$gwds_specificity[comp_nr],mytestscores2$OutFLANK_specificity[comp_nr],mytestscores2$PCadapt_specificity[comp_nr],bayescanspec)
		}
	#
	mymatrix	<<- mymatrix
	mytestspec	<<- testspec
	#
	# outline of plot:
	nloci	<- nrow(snps[snps$filter2,])
	spec_min<- ifelse(spec_min<min(testspec),spec_min,min(testspec)-0.0002)
	spec	<- seq(1,spec_min,-0.0001)			# specificity
	nout	<- (1-spec)*nloci					# number of outliers
	#
	cat("Plotting number of observed outliers per selection scan (in empirical SNP dataset) against specificity of selection scan (estimate based on simulations).",sep="\n") 
	setwd(mysambar$selectiondir)
	if(!is.null(export))
		{
		plotname		<- ifelse(is.null(bayescanfile),"Expected_falsepositives","Expected_falsepositives_withbayescan")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=8,width=8)}
		}
	par(mar=c(5,5.5,3,1.5))
	plot(spec*100,nout,type='l',lwd=1.5,xlab="",ylab="",cex.axis=2,las=1)
	mypch	<- ifelse(rownames(mymatrix)=="pheno",16,1)
	for (k in c(1:ncol(mymatrix)))
		{
		mycol	<- mycols[k]
		points(rep(testspec[k]*100,nrow(mymatrix)),mymatrix[,k],col=mycol,pch=mypch,cex=3)
		}
	mtext(side=1,"Specificity (%)",cex=2.5,line=3)
	mtext(side=2,"Number of outlier SNPs",cex=2.5,line=3.5)
	mtext(side=3,paste(nloci,"SNPs",sep=" "),line=0.5,cex=2.5)
	if(!is.null(bayescanfile))
		{
		legend("topright",legend=c("Bayescan","GWDS","OutFLANK","PCadapt"),fill=c("darkred","blue","orange","darkgreen"),bty='n',cex=2.5)
		}else{
		legend("topright",legend=c("GWDS","OutFLANK","PCadapt"),fill=c("blue","orange","darkgreen"),bty='n',cex=2.5)
		}
	legend("right",legend=c("pooled","pairwise"),pch=c(16,1),bty='n',cex=2.5)
	if(!is.null(export))
		{
		dev.off()
		cat("Plot called 'Expected_falsepositives.pdf' has been written to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

# 15-11-2019: currently applicable to reindeer dataset only	
multioverlap_approach_old<-function(doexport=NULL,add_numbers=FALSE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Overlap.approaches.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpoverlap_approach(mycomparison=1,mylog="",addnumbers=add_numbers)
	plotpoverlap_approach(mycomparison=2,mylog="",addnumbers=add_numbers)
	plotpoverlap_approach(mycomparison=3,mylog="",addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}		

multioverlap_approach<-function(doexport=NULL,popnames=mysambar$populations,pmax=11,pheno_label=NULL,silent=TRUE)
	{
	mycomparisonslog<- colnames(snps)[grep("rfisherGWDSlogp_",colnames(snps))]
	if(length(mycomparisonslog)<2)
		{
		return(cat("Only 1 comparison detected in snps dataframe. Omitting 'Overlap_between_comparisons' plot.",sep="\n")) 
		}
	mycomparisons	<- gsub("rfisherGWDSlogp_","",mycomparisonslog)
	combitable		<- combn(mycomparisons,m=2)
	ncombi			<- ncol(combitable)
	#
	graphics.off()
	if(!is.null(doexport))
		{
		plotname	<- "Overlap_between_comparisons"
		if(doexport=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=ncombi*4,height=4)}
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=ncombi*4,height=4)}
		if(doexport=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=ncombi*400,height=400)}
		if(doexport=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=ncombi*4,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	for(combinr in c(1:ncombi))
		{
		mypair		<- paste(combitable[1,combinr]," vs ",combitable[2,combinr],sep="")
		if(!silent){cat(mypair,sep="\n")}
		mypair		<- paste(combitable[1,combinr],combitable[2,combinr],sep=",")
		myapproach1	<- combitable[1,combinr]
		myapproach2	<- combitable[2,combinr]
		plotpoverlap_approach(approach1=myapproach1,approach2=myapproach2,phenolabel=pheno_label)
		}
	if(!is.null(doexport)){dev.off()}
	}

plotpoverlap_approach<-function(approach1=NULL,approach2=NULL,mycex=1,pmax=11,phenolabel=NULL)
	{
	if(is.null(approach1)|is.null(approach2))
		{
		return(cat("ERROR: provide input string (either 'pheno' or name of pairwise comparison) to approach1 and approach2 flags.",sep="\n"))    
		}
	mylog1		<- snps[snps$filter2,paste("rfisherGWDSlogp",approach1,sep="_")]
	mylog2		<- snps[snps$filter2,paste("rfisherGWDSlogp",approach2,sep="_")]
	myout1		<- snps[snps$filter2,paste("rfisherout",approach1,sep="_")]
	myout2		<- snps[snps$filter2,paste("rfisherout",approach2,sep="_")]
	#
	mybonf		<- -log10(0.05/nrow(snps[snps$filter2,]))
	mylim		<- c(0,pmax)
	#
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=mylim,ylim=mylim,col="grey50",las=1)
	points(mylog1[myout1|myout2],mylog2[myout1|myout2],cex=mycex,col="orange",pch=16)
	if("rfisherout_pheno"%in%colnames(snps))
		{
		outpheno	<- snps$rfisherout_pheno[snps$filter2]
		points(mylog1[outpheno],mylog2[outpheno],cex=mycex,col="red",pch=16)
		}
	mylabel1	<- ifelse(approach1=="pheno"&!is.null(phenolabel),phenolabel,approach1)
	mylabel2	<- ifelse(approach2=="pheno"&!is.null(phenolabel),phenolabel,approach2)
	mtext(mylabel1,side=1,cex=1.5,line=3)
	mtext(mylabel2,side=2,cex=1.5,line=3)
	abline(v=mybonf,lty=2)
	abline(h=mybonf,lty=2)
	}

# 15-11-2019: currently applicable to reindeer dataset only	
plotpoverlap_approach_old<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE,pmax=11)
	{
	mybonf		<- -log10(0.05/nrow(snps[snps$filter,]))
	mylim		<- c(0,pmax)
	if(mycomparison==1)
		{
		mylog1	<- snps$rfisherGWDSlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "Founder vs Source"
		mylog2	<- snps$rfisherGWDSlogp_Busen_Norway
		myout2	<- snps$rfisherout_Busen_Norway
		mytest2	<- "Busen vs Norway"
		}
	if(mycomparison==2)
		{
		mylog1	<- snps$rfisherGWDSlogp_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "Founder vs Source"
		mylog2	<- snps$rfisherGWDSlogp_Barff_Norway
		myout2	<- snps$rfisherout_Barff_Norway
		mytest2	<- "Barff vs Norway"
		}
	if(mycomparison==3)
		{
		mylog1	<- snps$rfisherGWDSlogp_Busen_Norway
		myout1	<- snps$rfisherout_Busen_Norway
		mytest1	<- "Busen vs Norway"
		mylog2	<- snps$rfisherGWDSlogp_Barff_Norway
		myout2	<- snps$rfisherout_Barff_Norway
		mytest2	<- "Barff vs Norway"
		}
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',xlim=mylim,ylim=mylim)
	points(mylog1[snps$rfisherout_pheno],mylog2[snps$rfisherout_pheno],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	#mymin1	<- min(mylog1[myout1])
	#mymin2	<- min(mylog2[myout2])
	abline(v=mybonf,lty=2)
	abline(h=mybonf,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- 0
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- nrow(snps)-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
			if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

multiplotp<-function(doexport=NULL,add_numbers=FALSE,my_dataset="pheno",silent=TRUE,no_outflank=FALSE,mytests=NULL,logpmax=11,n_sample=NULL)
	{
	logp 			<- snps[,grep(paste("logp",my_dataset,sep="_"),colnames(snps))]
	# 28-08-2020: the following lines are not needed anymore after I added some commands to the getbayescan function which include bayescan p-values to snps dataframe (rather than q-values only)
	#if(!paste("bayescanlogp",my_dataset,sep="_")%in%colnames(snps))
	#	{
	#	if(paste("bayescanlogq",my_dataset,sep="_")%in%colnames(snps))
	#		{
	#		if(!silent){cat("Renaming within SNPs dataframe Bayescan q-value to Bayescan p-value.",sep="\n")}
	#		logp$Bayescan		<- snps[,grep(paste("bayescanlogq",my_dataset,sep="_"),colnames(snps))]
	#		snps$Bayescantemp	<<- logp$Bayescan
	#		colnames(logp)[colnames(logp)=="Bayescan"]		<- paste("bayescanlogp",my_dataset,sep="_")
	#		colnames(snps)[colnames(snps)=="Bayescantemp"]	<<- paste("bayescanlogp",my_dataset,sep="_")
	#		snps 			<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	#		}else{
	#		cat("Bayescan q-values not present.",sep="\n")
	#		}
	#	if(!silent){cat("Renamed column with Bayescan q-values already present.",sep="\n")}
	#	}
	if(is.null(dim(logp)))
		{
		return(cat("Executed one selection scan (not multiple selection scans). Skipping 2D plots.",sep="\n"))
		}
	logp		<- logp[,order(colnames(logp))]
	if(!silent){mylogp	<<- logp}
	if(is.null(mytests))
		{
		mytests		<- colnames(logp)
		mytests		<- gsub(paste("logp",my_dataset,sep="_"),"",mytests)
		if(no_outflank)
			{
			mytests	<- mytests[mytests!="OutFLANK"] 
			}
		}
	combitable	<- combn(mytests,m=2)
	# easier to compare if PCadapt is on y-axis and GWDS on x-axis:
	compnr		<- which(combitable[1,]=="PCadapt"&combitable[2,]=="rfisherGWDS")
	if(length(compnr)==1)
		{
		combitable[1,compnr]	<- "rfisherGWDS"
		combitable[2,compnr]	<- "PCadapt"
		}
	ncombi		<- ncol(combitable)
	if(is.null(logpmax))
		{
		logpmax		<- max(logp,na.rm=TRUE)
		}
	if(!silent){cat(paste("Y-axis limit: ",logpmax,sep=""),sep="\n")}
	if(!is.null(doexport))
		{
		plotname<-paste("Selectionscan.logpvalues.2D",my_dataset,sep=".")
		if(doexport=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=ncombi*4+1,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	for(j in c(1:ncombi))
		{
		test_1	<- combitable[1,j]
		test_2	<- combitable[2,j]
		if(!silent){cat(paste(test_1," vs ",test_2,sep=""),sep="\n")}
		plotpvalues(test1=test_1,test2=test_2,mydataset=my_dataset,mycex=1,addnumbers=FALSE,pmax=logpmax,nsample=n_sample)
		}
	if(!is.null(doexport))
		{
		dev.off()
		cat(paste("A file called '",plotname,"' has been written to the directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		}
	}	
	
plotpvalues<-function(export=NULL,test1="OutFLANK",test2="rfisherGWDS",mydataset=NULL,mycex=1,addnumbers=FALSE,silent=TRUE,pmax=NULL,nsample=NULL)
	{
	if(is.null(mydataset))
		{
		return(cat("ERROR: Please provide input to the mydataset flag (i.e. pop1_pop2 or pheno).",sep="\n"))
		}
	# Note: displayed thresholds are either Bonferroni corrected thresholds, or or Bayes factor of 50 (10^1.7) in the case of Bayescan.
	# This are not necessarily the thresholds used when running the selection scans.
	# Also note that Bayescan p-values are different Bayesian posterior probabilities, and can not be directly compared to the frequentist p-values of the other tests, which display probabilities that SNPs are drawn from the null distribution. 
	test1string	<- paste(paste(test1,"logp",sep=""),mydataset,sep="_")
	if(!test1string%in%colnames(snps))
		{
		return(cat(paste("ERROR: scores for ",test1," not present in SNPs dataframe.",sep=""),sep="\n"))
		}else{
		mylog1	<- snps[,paste(paste(test1,"logp",sep=""),mydataset,sep="_")]
		}
	if(test1=="OutFLANK")
		{
		myout1	<- snps[,paste(test1,mydataset,sep="_")]
		}else{
		if(test1=="rfisherGWDS")
			{
			myout1	<- snps[,paste(paste("rfisher","out",sep=""),mydataset,sep="_")]
			}else{
			myout1	<- snps[,paste(paste(test1,"out",sep=""),mydataset,sep="_")]
			}
		}
	mytest1	<- ifelse(test1=="rfisherGWDS","GWDS",test1)
	#
	test2string	<- paste(paste(test2,"logp",sep=""),mydataset,sep="_")
	if(!test1string%in%colnames(snps))
		{
		return(cat(paste("ERROR: scores for ",test2," not present in SNPs dataframe.",sep=""),sep="\n"))
		}else{
		mylog2	<- snps[,paste(paste(test2,"logp",sep=""),mydataset,sep="_")]
		}
	if(test2=="OutFLANK")
		{
		myout2	<- snps[,paste(test2,mydataset,sep="_")]
		}else{
		if(test2=="rfisherGWDS")
			{
			myout2	<- snps[,paste(paste("rfisher","out",sep=""),mydataset,sep="_")]
			}else{
			myout2	<- snps[,paste(paste(test2,"out",sep=""),mydataset,sep="_")]
			}
		}
	mytest2	<- ifelse(test2=="rfisherGWDS","GWDS",test2)
	#
	if(test1=="bayescan")
		{
		mymin1	<- 1.7	# arbitrary: 10^1.7 = 50x more likely
		}else{
		mymin1	<- -log10(0.05/nrow(snps[snps$filter2,]))
		}
	if(test2=="bayescan")
		{
		mymin1	<- 1.7	# arbitrary: 10^1.7 = 50x more likely
		}else{
		mymin2	<- -log10(0.05/nrow(snps[snps$filter2,]))
		}
	if(is.null(pmax))
		{
		pmax1	<- max(c(mylog1[is.finite(mylog1)&!is.na(mylog1)],mylog2[is.finite(mylog2)&!is.na(mylog2)]))
		pmax2	<- 1.1*-log10(0.05/nrow(snps[snps$filter2,]))
		pmax	<- ifelse(pmax1<pmax2,pmax2,pmax1)
		}
	if(!silent)
		{
		mylog1temp	<<- mylog1
		mylog2temp	<<- mylog2
		pmaxtemp	<<- pmax
		}
	if(!is.null(export))
		{
		plotname<-paste("Selectionscan.logpvalues.2D",mydataset,mytest1,mytest2,sep=".")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=4,width=4)}
		par(mar=c(1,1,1,1),oma=c(2.5,2.5,0,0))
		}
	if(!is.null(nsample))
		{
		sampleset	<- sample(c(1:length(mylog1)),nsample)
		plot(mylog1[sampleset],mylog2[sampleset],pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		}else{
		plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		}
	points(mylog1[myout1],mylog2[myout1],cex=mycex,col="red",pch=16)
	points(mylog1[myout2],mylog2[myout2],cex=mycex,col="red",pch=16)
	myxline	<- ifelse(!is.null(export),2.5,3.5)
	myyline	<- ifelse(!is.null(export),2,3.5)
	mtext(mytest1,side=1,cex=1.5,line=myxline)
	mtext(mytest2,side=2,cex=1.5,line=myyline)
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		cat("Adding numbers...",sep="\n")
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	if(!is.null(export)){dev.off()}
	}	

# depreciated on 14-11-2019:	
multiplotp_old<-function(doexport=NULL,add_numbers=TRUE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Testlogvalues.2D.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpvalues_old(mycomparison=1,mylog="",addnumbers=add_numbers)
	plotpvalues_old(mycomparison=2,mylog="y",addnumbers=add_numbers)
	plotpvalues_old(mycomparison=3,mylog="y",addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}
	
# depreciated on 14-11-2019:	
plotpvalues_old<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE)
	{
	if(mycomparison==1)
		{
		mylog1	<- snps$rfisherlog_p_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "GWDS"
		myxlim	<- c(0,100)
		mylog2	<- snps$bayescanlogq_pheno
		myout2	<- snps$bayescanout_pheno
		mytest2	<- "Bayescan"
		myylim	<- c(0,10) 
		}
	if(mycomparison==2)
		{
		mylog1	<- snps$rfisherlog_p_pheno
		myout1	<- snps$rfisherout_pheno
		mytest1	<- "GWDS"
		myxlim	<- c(0,100)
		mylog2	<- -log10(p.adjust(10^-snps$PCadaptlogp_pheno,method="bonf"))
		#mylog2	<- -log(p.adjust(10^-snps$PCadaptlogp_pheno,method="holm"))
		myout2	<- snps$PCadaptout_pheno
		mytest2	<- "PCadapt"
		myylim	<- c(0.01,100)
		}
	if(mycomparison==3)
		{
		mylog1	<- snps$bayescanlogq_pheno
		myout1	<- snps$bayescanout_pheno
		mytest1	<- "Bayescan"
		myxlim	<- c(0,10)
		mylog2	<- -log10(p.adjust(10^-snps$PCadaptlogp_pheno,method="bonf"))
		#mylog2	<- -log(p.adjust(10^-snps$PCadaptlogp_pheno,method="holm"))
		myout2	<- snps$PCadaptout_pheno
		mytest2	<- "PCadapt"
		myylim	<- c(0.01,100)
		}
	mylog1[mylog1<0.01]	<- 0.01
	mylog2[mylog2<0.01]	<- 0.01
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n',ylim=myylim,xlim=myxlim)
	points(mylog1[snps$rfisherout_pheno],mylog2[snps$rfisherout_pheno],cex=mycex,col="red",pch=16)
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	if(mycomparison==1|mycomparison==2)
		{
		mymin1	<- 44
		}else{
		mymin1	<- min(mylog1[myout1])
		}
	mymin2	<- min(mylog2[myout2])
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

plot_venn<-function(my_dataset="pheno1_pheno2",export=TRUE,mysmall=1,silent=TRUE)
	{
	if(!silent){cat(my_dataset,sep="\n")}
	snpcolnames		<- names(snps)
	# GWDS:
	mycolumn		<- paste("rfisherout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		gwdsout		<- snps$name[outfilter]
		if(any(is.na(gwdsout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		gwdsout		<- snps$name[FALSE]
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		pcadaptout	<- snps$name[outfilter]	
		if(any(is.na(pcadaptout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		pcadaptout	<- snps$name[FALSE]
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		outflankout	<- snps$name[outfilter]
		if(any(is.na(outflankout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		outflankout	<- snps$name[FALSE]
		}
	# bayescan:
	mycolumn		<- paste("bayescanout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		bayescanout	<- snps$name[outfilter]
		if(any(is.na(bayescanout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		bayescanout	<- snps$name[FALSE]
		}
	# Fsthet:
	mycolumn		<- paste("fsthetout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames)		
		{
		outfilter	<- snps[,mycolumn]
		fsthetout	<- snps$name[outfilter]
		if(any(is.na(fsthetout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		fsthetout	<- snps$name[FALSE]
		}
	# plot:
	if(length(bayescanout)>1|length(gwdsout)>1|length(pcadaptout)>1|length(outflankout)>1|length(fsthetout)>1)
		{
		if(export){pdf(paste("venn",my_dataset,"pdf",sep="."),height=6,width=8)}
		baye		<- paste("bayescanout",my_dataset,sep="_")
		fsthet		<- paste("fsthetout",my_dataset,sep="_")
		outfla		<- paste("OutFLANK",my_dataset,sep="_")
		pcout		<- paste("PCadaptout",my_dataset,sep="_")
		if(pcout%in%snpcolnames)
			{
			if(outfla%in%snpcolnames)
				{
				if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","orange","darkorchid4"),col=c("darkred","blue","darkgreen","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","orange","darkorchid4"),col=c("darkred","darkgreen","orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","orange"),col=c("darkred","blue","darkgreen","orange"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","orange"),col=c("darkred","darkgreen","orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","orange","darkorchid4"),col=c("blue","darkgreen","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","orange","darkorchid4"),col=c("darkgreen","orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","orange"),col=c("blue","darkgreen","orange"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","orange"),col=c("darkgreen","orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}else{	# IF NOT OUTFLANK
						if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen","darkorchid4"),col=c("darkred","blue","darkgreen","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen","darkorchid4"),col=c("darkred","darkgreen","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkgreen"),col=c("darkred","blue","darkgreen"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkgreen"),col=c("darkred","darkgreen"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen","darkorchid4"),col=c("blue","darkgreen","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen","darkorchid4"),col=c("darkgreen","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkgreen"),col=c("blue","darkgreen"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen"),col=c("darkgreen"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}
			}else{ 	# IF NOT PCADAPT
			if(outfla%in%snpcolnames)
				{
				if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","orange","darkorchid4"),col=c("darkred","blue","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,OutFLANK=outflankout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","orange","darkorchid4"),col=c("darkred","orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","orange"),col=c("darkred","blue","orange"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","orange"),col=c("darkred","orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","orange","darkorchid4"),col=c("blue","orange","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(OutFLANK=outflankout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("orange","darkorchid4"),col=c("orange","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","orange"),col=c("blue","orange"),margin=0.1)
						}else{
						# this will lead to errors:
						v1 <- venn.diagram(list(OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("orange"),col=c("orange"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}else{	# IF NOT OUTFLANK
						if((baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue","darkorchid4"),col=c("darkred","blue","darkorchid4"),margin=0.1)
						}else{
						v1 <- venn.diagram(list(Bayescan=bayescanout,Fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","darkorchid4"),col=c("darkred","darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(Bayescan=bayescanout,GWDS=gwdsout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred","blue"),col=c("darkred","blue"),margin=0.1)
						}else{
						# this will lead to errors:
						v1 <- venn.diagram(list(Bayescan=bayescanout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkred"),col=c("darkred"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&(fsthet%in%snpcolnames))
					{
					if(my_dataset!="metapop")
						{
						v1 <- venn.diagram(list(GWDS=gwdsout,fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue","darkorchid4"),col=c("blue","darkorchid4"),margin=0.1)
						}else{
						# This will lead to errors:
						v1 <- venn.diagram(list(fsthet=fsthetout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkorchid4"),col=c("darkorchid4"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				if((!baye%in%snpcolnames)&!(fsthet%in%snpcolnames))
					{
					#venn(list(GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),small=mysmall)	
					if(my_dataset!="metapop")
						{
						# This will lead to errors:
						v1 <- venn.diagram(list(GWDS=gwdsout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("blue"),col=c("blue"),margin=0.1)
						#}else{
						#v1 <- venn.diagram(list(PCadapt=pcadaptout),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("darkgreen"),col=c("darkgreen"),margin=0.1)
						}
					grid.newpage()
					grid.draw(v1)
					}
				}
			}
		if(export){dev.off()}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		}else{
		cat("No outliers. Skipping Venn diagram.",sep="\n")
		}
	}

# Create input for bayenv:
makebayenvinput<-function(popnames=mysambar$populations,type=FALSE)
	{
	# execute analysis:
	if(type)
		{
		if(length(popnames)!=length(unique(inds$type3)))
			{
			cat("Length of popnames does not correspond to expected number of population names")
			}
		}
	bayenvinput			<<- matrix(ncol=(length(popnames)),nrow=2*nrow(snps[snps$filter&snps$minorcount>0,]))
	for (i in (1:length(popnames)))
		{
		if(type)
			{
			tempgenlight<- mygenlight[inds$filter&inds$type3==popnames[i],snps$filter&snps$minorcount>0]
			}else{
			tempgenlight<- mygenlight[inds$filter&inds$pop==popnames[i],snps$filter&snps$minorcount>0]
			}
		misscount		<- glNA(tempgenlight,alleleAsUnit=FALSE)
		nonmissallelecount 	<- 2*(nInd(tempgenlight)-misscount)
		minorcount		<- as.vector(glSum(tempgenlight))
		majorcount		<- nonmissallelecount-minorcount	
		z 			<- c(rbind(minorcount,majorcount))
		bayenvinput[,i]		<<- z 
		colnames(bayenvinput)	<<- popnames
		}
	# Export:
	write.table(bayenvinput,"Bayenvinput.metapop.txt",col.names=FALSE,row.names=FALSE,sep="\t")
	}	
	
# depends on function windowfst()
peakvalley<-function(myxby=5,my_lwd=2,mychrom=25,myregion=NULL,mywidth=20,add_legend=TRUE,export=FALSE,excludeoutliers=FALSE)
	{
	# myregion is vector which start and end in kB
	mypositions	<- snps$pos[snps$rfisherout_pheno]/1000000
	setwd(mysambar$selectiondir)
	if(export&excludeoutliers){pdf(paste("Peakvalley",(paste("chrom",mychrom,sep="")),(paste(mywidth,"snpsperwindow.excludingoutliers",sep="")),"pdf",sep="."),width=12,height=7)}
	if(export&(!excludeoutliers)){pdf(paste("Peakvalley",(paste("chrom",mychrom,sep="")),(paste(mywidth,"snpsperwindow.withoutliers",sep="")),"pdf",sep="."),width=12,height=7)}
	par(mfrow=c(2,1),mar=c(0.5,2.5,0.5,0.5),oma=c(4,3,4,2),cex.axis=1.5)
	if(excludeoutliers)
		{
		mysnpselection	<- snps$filter2&(!snps$rfisherout_pheno)
		}else{
		mysnpselection	<- snps$filter2
		}
	windowfst(chrom=mychrom,width=mywidth,snpselection=mysnpselection,addlegend=add_legend,xrange=c(0,40000000),selectcombi=c(2,3),yrange=c(0,0.25),xby=myxby,xaxislabels=FALSE,addchrom=FALSE,mylwd=my_lwd,region=myregion)	
	abline(v=mypositions,lty=2)
	windowfst(chrom=mychrom,width=mywidth,snpselection=mysnpselection,addlegend=add_legend,xrange=c(0,40000000),selectcombi=1,yrange=c(0,0.3),xby=myxby,addchrom=FALSE,mylwd=my_lwd,region=myregion)
	abline(v=mypositions,lty=2)
	mtext("Position along chromosome (Mb)",side=1,line=2.5,outer=TRUE,cex=2)
	mtext("WC Fst",side=2,line=1.25,outer=TRUE,cex=2)
	mtext(paste("Chromosome",mychrom,sep=" "),side=3,line=0.5,outer=TRUE,cex=2)
	if(export){dev.off()}
	setwd(mysambar$inputdatadir)
	}

# plot location of genes on scaffold/contig/chromosome:	
multiplotscaffold<-function(my_bed=NULL,doexport=FALSE,background_pop=NULL,x_range=NULL,y_loc=c(0.4,0.65))
	{
	if(is.null(my_bed))
		{
		return(cat("Input file to my_bed argument is missing.",sep="\n"))
		}
	mygenes				<- read.table(my_bed,header=FALSE)
	colnames(mygenes)	<- c("chr","startbp","endbp","feature")
	mygenes				<<- mygenes
	for(mycontig in mygenes$chr)
		{
		plotscaffold(export=doexport,scaffold=mycontig,backgroundpop=background_pop,mybed=my_bed,xrange=NULL,yloc=y_loc)
		}
	}
	
plotscaffold<-function(export=FALSE,scaffold="scaffold1947_size412474",backgroundpop=NULL,mybed=NULL,popnames=mysambar$populations,xrange=NULL,yloc=c(0.4,0.65))
	{
	setwd(mysambar$selectiondir)
	npop	<- length(popnames)
	mycols	<- mysambar$mycolours[1:npop]
	if(!is.null(backgroundpop))
		{
		otherpops	<- popnames[popnames!=backgroundpop]
		othercols	<- mycols[popnames!=backgroundpop]
		backgroundcol<- mycols[popnames==backgroundpop]
		mycols		<- c(backgroundcol,othercols)
		popnames	<- c(backgroundpop,otherpops)
		}
	plotname<- paste("MAF",scaffold,"pdf",sep=".")
	if(is.null(xrange)){xrange=c(min(snps$pos[snps$chr==scaffold]),max(snps$pos[snps$chr==scaffold]))}
	xrange	<- xrange/1000
	xrange	<<- xrange
	if(export)
		{
		pdf(plotname,width=10,height=5)
		}
	par(mar=c(5,5,1,1))
	for(p in c(1:npop))
		{
		mypop	<- popnames[p]
		mycol	<- mycols[p]
		mypopmaf<- snps[,paste("maf",mypop,sep="_")]
		if(p==1)
			{
			plot(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],type='l',col="white",ylim=c(0,1),xlim=xrange,lwd=1,ylab="MAF",xlab="Position (kb)",pch=16,las=1,cex.axis=1.5,cex.lab=2)
			mycol2<-adjustcolor(mycol,alpha.f = 0.3) 
			polygon(c(snps$pos[snps$chr==scaffold]/1000,rev(snps$pos[snps$chr==scaffold]/1000)),c(rep(0,length(mypopmaf[snps$chr==scaffold])),rev(mypopmaf[snps$chr==scaffold])),col=mycol2,border=NA)
			points(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],col=mycol,pch=16)
			points(snps$pos[snps$chr==scaffold&snps$rfisherout_pheno]/1000,mypopmaf[snps$chr==scaffold&snps$rfisherout_pheno]+0.025,col="black",pch=8,cex=1.25)
			}else{
			points(snps$pos[snps$chr==scaffold]/1000,mypopmaf[snps$chr==scaffold],col=mycol,lwd=1.5,pch=16,type='b')
			}
		}
	mtext(side=3,scaffold,line=-1.5,cex=1.5)	
	legend("topright",legend=popnames,fill=mycols,cex=1.5,bty='n')
	if(!is.null(mybed))
		{
		mygenes				<- read.table(mybed,header=FALSE,sep="\t")
		colnames(mygenes)	<- c("chr","startbp","endbp","feature")
		mygenes				<- mygenes[mygenes$chr==scaffold,]
		mygenes$overlap		<- 1000000
		if((nrow(mygenes))>1)
			{
			for(j in c(2:nrow(mygenes))){mygenes$overlap[j]<-mygenes$startbp[j]-mygenes$startbp[j-1]}
			}
		mygenes$overlap2	<-ifelse((abs(mygenes$overlap))<5000,FALSE,TRUE)
		if(any(mygenes$overlap2))
			{
			text(mygenes$feature[mygenes$overlap2],x=mygenes$startbp[mygenes$overlap2]/1000,y=yloc[1],srt=90,adj=0)
			if(any(!mygenes$overlap2))
				{
				text(mygenes$feature[!mygenes$overlap2],x=mygenes$startbp[!mygenes$overlap2]/1000,y=yloc[2],srt=90,adj=0)
				}
			}
		}
	if(export){dev.off()}
	}

	
# End of selection analyses 
###############################################################################################################







###############################################################################################################
# Association analysis

# depends on locusWCfst:
assocfisher<-function(pheno=NULL,my_sign_level=0.05,export=NULL,mylabels=c("control","affected"))
	{
	setwd(mysambar$selectiondir)
	# pheno should be name of column in inds dataframe
	if(is.null(pheno))
		{
		return(cat("ERROR: define input to pheno flag (name of a column in the inds dataframe containing binary division (e.g. TRUE/FALSE, or male/female)).",sep="\n"))
		}
	if(!pheno%in%colnames(inds))
		{
		return(cat("ERROR: input to pheno flag should be the name of a column in the inds dataframe.",sep="\n"))
		}
	mypheno		<- inds[inds$filter,pheno]
	mylevels	<- unique(mypheno[!is.na(mypheno)])
	if(length(mylevels)!=2)
		{
		return(cat("ERROR: pheno should contain 2 levels (after filtering). Not more, not less.",sep="\n"))
		}
	mypheno2	<- inds[,pheno]
	phenobool	<- ifelse(mypheno2==mylevels[1],TRUE,FALSE)
	ninds1		<- nrow(inds[inds$filter&phenobool,])
	ninds2		<- nrow(inds[inds$filter&(!phenobool),])
	cat(paste("Number of retained individuals group 1: ", ninds1,".",sep=""),sep="\n") 
	cat(paste("Number of retained individuals group 2: ", ninds2,".",sep=""),sep="\n") 
	if(ninds1==0|ninds2==0)
		{
		return(cat("ERROR: Both groups should contain at least one individual.",sep="\n")) 
		}
	#
	cat("Extracting minor allele frequencies...",sep="\n")
	snps$maf_assoc1 	<<- glMean(mygenlight[inds$filter&phenobool,])
	snps$maf_assoc2 	<<- glMean(mygenlight[inds$filter&!phenobool,])
	#
	cat("Calculation locus specific He and Fst...",sep="\n")
	locusWCfst(my_dataset="assoc1_assoc2",mycol="grey",do_plot=TRUE)
	#
	cat("Executing Fisher exact tests...",sep="\n")
	# For phenotype 1:
	indfilter	<- inds$filter&phenobool
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for pheno==TRUE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor1			<- as.vector(glSum(mygenlight[indfilter,]))
	major1			<- nonmisscount-minor1
	# For phenotype 2:
	indfilter		<- inds$filter&!phenobool
	if(length(indfilter[indfilter])==0)
		{
		return(cat("ERROR: No retained individuals for pheno==FALSE",sep="\n"))
		}
	misscount		<- glNA(mygenlight[indfilter,],alleleAsUnit=FALSE)
	nonmisscount 	<- 2*(nInd(mygenlight[indfilter,])-misscount)
	minor2			<- as.vector(glSum(mygenlight[indfilter,]))
	major2			<- nonmisscount-minor2	
	#
	snps$assoclogp		<<-	NULL
	snps$assocout		<<- NULL
	macmatrix			<- rbind(major1,minor1,major2,minor2)
	plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(1,2,3,4),i],2,2,byrow=TRUE)})
	rfisherp			<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
	snps$assoclogp		<<- -log(rfisherp)
	snps$assoclogp[snps$assoclogp<0.0001]	<<- 0	# 10-11-2019: to avoid negative or infinitely small values
	#
	cat("Testing which loci are outliers using Bonferroni correction...",sep="\n")
	# we apply the bonferroni correction and assume that the distribution of the logp values fit an exponential distribution
	mymean				<- mean(snps$assoclogp[snps$filter2])	
	myrate				<- 1/mymean
	mybonf				<- 1-(my_sign_level/(nrow(snps[snps$filter2,])))
	myvalue				<- qexp(mybonf,myrate)
	snps$assocout		<<-	snps$assoclogp>myvalue
	noutliers2			<- nrow(snps[snps$assocout,])
	noutliers			<- nrow(snps[snps$assocout&snps$filter2,])
	cat(paste("Found",noutliers2,"outlier loci, of which",noutliers,"passed filter settings.",sep=" "),sep="\n")
	#
	gwds_pvalues		<- 1-pexp(snps$assoclogp,myrate)
	if(any(gwds_pvalues==0&!is.na(gwds_pvalues))){cat("WARNING: one or more p-values equal to 0, which would result in an infinite log10 conversion. Setting those log10 values to 20.",sep="\n")}
	snps$assocGWDSlogp	<<- ifelse(gwds_pvalues==0&!is.na(gwds_pvalues),20,-log10(gwds_pvalues))	# 04-09-2020: if p-values == 0, setting log10(p-value) to 20.
	# rename columns:
	names(snps)[names(snps) == "assoclogp"] 	<<- paste("rfisherlog_p","assoc1","assoc2",sep = "_")
	names(snps)[names(snps) == "assocGWDSlogp"] <<- paste("rfisherGWDSlogp","assoc1","assoc2",sep = "_")
	names(snps)[names(snps) == "assocout"] 		<<- paste("rfisherout","assoc1","assoc2",sep = "_")
	snps 				<<- snps[, !duplicated(colnames(snps), fromLast = TRUE)]
	cat("Creating Fdist plot...",sep="\n")
	Fdist_plot(my_dataset="assoc1_assoc2",showlabels=TRUE,exporttype=export,axislabels=TRUE,add_borders=TRUE,add_outliers=TRUE,y_axis='s',x_axis='s',my_labels=mylabels,dothin=TRUE,silent=TRUE)
	}	

# envfile="ENVDATAr5noBSCLEAN_MJ.txt"
# to run as a stand-alone function (outside of SambaR environment), run as follows:
# Assuming your data file is called "mydata.txt", and your file with environmental variables "myenv.txt", and assuming your:
# runRDA(inputmatrix="mydata.txt",use_currentdir=TRUE,export="pdf",legendpos="topleft",colourvec="grey50",envfile="myenv.txt",myrepos='http://cran.us.r-project.org')
# Optionally you can specify colours of your samples using the colourvec (either one colour, or a vector of colours correspond to number and order of your samples).
runRDA<-function(inputmatrix=NULL,use_currentdir=FALSE,export="pdf",legendpos="topleft",colourvec=NULL,envfile=NULL,dofilter=TRUE,myrepos='http://cran.us.r-project.org')
	{
	if("psych" %in% rownames(installed.packages()) == FALSE) {install.packages('psych',repos=myrepos)}
	if("vegan" %in% rownames(installed.packages()) == FALSE) {install.packages('vegan',repos=myrepos)}
	if("vegan"%in%(.packages()) == FALSE) {library(vegan)}
	if("psych"%in%(.packages()) == FALSE) {library(psych)}
	# 
	# Get data:
	if(is.null(inputmatrix))
		{
		# get imputed dataset:
		if(!exists("mysambar"))
			{
			return(cat("ERROR: sambar objects do not exists. You can run this function outside of R, but only if you provide an input matrix (with zero missing data points) to the 'inputmatrix' flag.",sep="\n"))
			}
		if(is.null(mysambar$imputedmatrix))
			{
			sambarimpute()
			}
		if(!dofilter)
			{
			gen.imp			<- mysambar$imputedmatrix[,snps$filter]
			}else{
			gen.imp			<- mysambar$imputedmatrix[inds$filter,snps$filter]
			}
		rownames(gen.imp)	<- as.character(rownames(gen.imp))
		genimp				<- gen.imp[order(rownames(gen.imp)),]
		cat("WARNING: because data imputing has a stochastic component, the RDA plot may look different if you rerun the imputation.",sep="\n")
		}else{
		genimp				<- inputmatrix
		}
	#
	# read environmental data:
	if(is.null(envfile))
		{
		return(cat("ERROR: provide the name of file with environmental data to 'envfile' flag:",sep="\n"))
		}
	if(!use_currentdir)
		{
		setwd(mysambar$inputdatadir)
		}
	cat("Reading envfile (file with environmental data) from:",sep="\n")
	cat(getwd(),sep="\n")
	env.data 				<- read.table(file = envfile, header = T, na.strings = NA)
	env.data$individual 	<- as.character(env.data$individual)
	envdata					<- env.data[order(env.data$individual),]
	if(!identical(rownames(genimp),envdata$individual))
		{
		return(cat("ERROR: sample names in environmental data file do not correspond with sample names in inds dataframe.",sep="\n"))
		}
	#
	# variables correlated?
	# pairs.panels(Ocean.Data[,4:5], scale=T,las=2,hist.col="blue")
	#
	cat("Executing RDA analysis.",sep="\n")	
	myrda 					<- rda(genimp ~ SST + salinity, data=envdata, scale=T)
	cat("Stored RDA output in 'myrda'. Generating plot...",sep="\n")	
	#
	# Make the RDA plots
	if(!is.null(export))
		{
		my_font		<- ifelse(!exists("mysambar"),"sans",mysambar$font)
		if(!use_currentdir)(setwd(mysambar$selectiondir))
		if(export=="eps"){postscript("RDA.1_2.eps",family=my_font,width=10,height=10)}
		if(export=="pdf"){pdf("RDA.1_2.pdf",family=my_font,width=10,height=10)}
		if(export=="png"){png("RDA.1_2.png",family=my_font,width=720,height=720)}
		if(export=="wmf"){win.metafile("RDA.1_2.wmf",family=my_font,width=10,height=10)}
		}
	eco 	<- as.factor(envdata$population)		# 10-11-2021: added 'as.factor()'
	if(is.null(colourvec))
		{
		bg		<- mysambar$mycolours
		}else{
		bg		<- colourvec
		}
	par(cex.axis=2.5,mar=c(5,5,1,1))
	plot(myrda, type="n", scaling=3, xlab="", ylab = "")
	mtext(side=1,"RDA 1", line=3.5, cex = 3)
	mtext(side=2,"RDA 2", line=2.75, cex = 3)
	points(myrda, display="species",pch=16,cex=0.75,col="gray30",scaling=3)
	points(myrda, display="sites",pch=21,cex=3,col="gray30",scaling=3,bg=bg[eco])
	legend(legendpos,legend=levels(eco), bty="n", col="gray30", pch=21, cex=3, pt.bg=bg)
	text(myrda, scaling=3, display="bp", col="darkorange", cex=2.75)
	if(!is.null(export))
		{
		dev.off()
		cat("RDA plot has been exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		if(!use_currentdir)(setwd(mysambar$inputdatadir))
		}
	}

# End of association analyses 	
###############################################################################################################











###############################################################################################################
# Data management and generally used functions

do_heatmap<-function(export_type=NULL,masklower=TRUE,nbins=NULL,roundlevel=2,showvalues=FALSE,note_cex=1,note_round=2,shownegative=FALSE,mymatrix=nei,my_inds=inds,my_snps=snps,my_col="orange",my_col2="white",my_midcol=NULL,doublemidcol=FALSE,exportname="mymatrix",mytitle=NULL,titlecex=2,titleline=1,addlegend=TRUE,myBreaks=NULL,addlab=TRUE,misslabels=FALSE,printname=FALSE,legposx=0.1,legposy=0.52,legcex=2,subtitle=NULL)
		{
		# This plot will use all data in mymatrix input.
		# It assumes that nrow(mymatrix) and ncol(mymatrix) corresponds with nrow(my_inds[my_inds$filter,])
		if("gplots" %in% rownames(installed.packages()) == FALSE) {install.packages('gplots',repos=myrepos)}
		library(gplots)
		if(masklower)
			{
			mymatrix[lower.tri(mymatrix, diag = FALSE)]<-NA
			}
		# create colours:
		if(is.null(myBreaks))
			{
			floor_dec 	<- function(x, level=1) round(x - 5*10^(-level-1), level)
			ceiling_dec <- function(x, level=1) round(x + 5*10^(-level-1), level)
			mymin		<- floor_dec(min(mymatrix,na.rm=TRUE),roundlevel)
			if(max(mymatrix,na.rm=TRUE)==1)
				{
				mymax	<- 1
				}else{
				mymax	<- ceiling_dec(max(mymatrix,na.rm=TRUE),roundlevel)
				}
			binsize		<- ifelse(is.null(nbins),(mymax-mymin)/10,(mymax-mymin)/nbins)
			myBreaks	<- seq(mymin,mymax,binsize)
			}
		if(!is.null(my_midcol))
			{
			cat("Using colour gradient with a prespecified colour for central bin(s)...",sep="\n")
			if(length(myBreaks)%%2==0)
				{
				nbins	<- length(myBreaks)/2			# e.g. 6 breaks, 5 bins: 2 left, 1 central (midcol), 2 right. nbins = 2+1
				}else{
				if(doublemidcol)
					{
					nbins	<- (length(myBreaks)-1)/2		# e.g. 7 breaks, 6 bins: 2 left, 2 central (midcol), 2 right 
					}else{
					nbins	<- (length(myBreaks)-1)/2+1		# e.g. 7 breaks, 6 bins: 3 left, no central (no midcol), 3 right
					}
				}
			mycolfunc1 	<- colorRampPalette(c(my_col,my_midcol))
			myColours1	<- c(mycolfunc1(nbins))
			# right:
			mycolfunc2 	<- colorRampPalette(c(my_midcol,my_col2))
			myColours2	<- c(mycolfunc2(nbins))
			# combine:
			if(length(myBreaks)%%2==0)
				{
				myColours	<- c(myColours1,myColours2[-1])
				}else{
				if(doublemidcol)
					{
					myColours	<- c(myColours1,myColours2)
					}else{
					myColours	<- c(myColours1[-nbins],myColours2[-1])
					}
				}
			}else{
			mycolfunc 	<- colorRampPalette(c(my_col2,my_col))
			myColours	<- c(mycolfunc(length(myBreaks)-1))
			}
		if(length(myBreaks)!=length(myColours)+1)
			{
			coloursvec	<<- myColours
			breaksvec	<<- myBreaks
			return(cat("ERROR: unexpected length of myColours vector. Contact the developer of SambaR.",sep="\n"))
			}
		myinds		<- my_inds$nr[my_inds$filter]
		ninds		<- ncol(mymatrix)
		mypopcols	<- my_inds$popcol[my_inds$filter]
		# cat(ninds,sep="\n")
		# cat(length(mypopcols),sep="\n")
		# plot:
		graphics.off()
		if(!is.null(export_type))
			{
			# if many samples, not all sample labels are shows. Increase to show. 
			if(addlab)
				{
				if(ninds<100)
					{
					mysize	<- 10
					mysize2	<- 720
					}else{
					mysize	<- ninds*0.1
					mysize2	<- ninds*7.2
					}
				}else{
				mysize	<- 10
				mysize2	<- 720
				}
			if(export_type=="eps"){postscript(paste(exportname,"eps",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
			if(export_type=="pdf"){pdf(paste(exportname,"pdf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
			if(export_type=="png"){png(paste(exportname,"png",sep="."),family=mysambar$myfont,width=mysize2,height=mysize2)}
			if(export_type=="wmf"){win.metafile(paste(exportname,"wmf",sep="."),family=mysambar$myfont,width=mysize,height=mysize)}
			}
		if(addlab)
			{
			if(misslabels)
				{
				axislabels	<- round(my_inds$miss[my_inds$filter],3)
				}else{
				if(printname)
					{
					axislabels	<- my_inds$name[my_inds$filter]
					}else{
					axislabels	<- my_inds$nr[my_inds$filter]
					}
				}
			if(ninds<100)
				{
				mycex	<- 0.75
				}else{
				mycex	<- 0.5
				}
			if(showvalues)
				{
				heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=axislabels,labCol=axislabels,cexRow=mycex,cexCol=mycex,key=FALSE,Rowv=NA,Colv=NA,cellnote=round(mymatrix,note_round),notecol="black",notecex=note_cex,
				scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
				}else{
				heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=axislabels,labCol=axislabels,cexRow=mycex,cexCol=mycex,key=FALSE,Rowv=NA,Colv=NA,
				scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
				}
			if(misslabels)
				{
				if(ninds<100)
					{
					mtext("sample miss", side = 1, cex = 1.5, line = 4)
					mtext("sample miss", side = 4, cex = 1.5, line = 1)
					}
				}else{
				if(ninds<100)
					{
					if(!printname)
						{
						mtext("sample nr", side = 1, cex = 1.5, line = 4)
						mtext("sample nr", side = 4, cex = 1.5, line = 1)
						}
					}
				}
			}else{
			if(showvalues)
				{
				heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,cellnote=round(mymatrix,note_round),notecol="black",notecex=note_cex,
				Colv=NA,scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
				}else{
				heatpos	<- heatmap.2(mymatrix,lwid=c(0.5,4),lhei=c(0.5,4),labRow=NA,labCol=NA,key=FALSE,Rowv=NA,
				Colv=NA,scale="none",RowSideColors=mypopcols,ColSideColors=mypopcols,col=myColours,breaks=myBreaks,dendrogram="none",trace="none")
				}
			}
		if(!is.null(mytitle)){mtext(mytitle,side=3,line=titleline,cex=titlecex)}
		if(!is.null(subtitle)){mtext(subtitle,side=3,line=titleline-1,cex=0.75*titlecex)}
		if(addlegend)	
			{
			if(showvalues)
				{
				legend(x=legposx,y=legposy,legend=mysambar$poporder,fill=mysambar$colorder,bty='n',cex=legcex)
				}else{
				mylimits	<- paste("(",round(heatpos$colorTable$low,3),",",round(heatpos$colorTable$high,3),"]",sep="")		# 16-11-2023: interval notation: correction from [,) to (,]
				legend(x=legposx,y=legposy,legend=mylimits,fill=myColours,bty='n',cex=legcex)
				}
			}
		if(!is.null(export_type)){dev.off()}
		}	

genlight2DNAbin<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,export=FALSE,exportname="filtereddata.diploid.fa",quiet=FALSE) 
	{
	cat("Converting from genlight to DNAbin format...",sep="\n")
	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	genot2			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	minor		<- in_snps$minor[snpsfilter]
	major		<- in_snps$major[snpsfilter]
	# We first convert to diploid genotype score matrix:
	for (j in c(1:ncol(x))) 
		{
    	maj			<- major[j]
    	min			<- minor[j]
    	g			<- x[,j]
     	g[is.na(g)]	<- paste("N")  				
    	g[g==0]		<- paste(maj,maj,sep="") 			 
    	g[g==1]		<- paste(min,maj,sep="") 		
    	g[g==2]		<- paste(min,min,sep="") 		
    	genot[,j]	<- g
		}
	# Next we convert to diploid sequences:
	for (j in c(1:ncol(x))) 
		{
		g					<- genot[,j]
		g[g=="11"] 			<- "A"
        g[g=="22"]  		<- "C"
		g[g=="33"]			<- "G"
		g[g=="44"]  		<- "T"
		g[g=="12"|g=="21"] 	<- "M"		
       	g[g=="13"|g=="31"]	<- "R"		
		g[g=="14"|g=="41"] 	<- "W"		
        g[g=="23"|g=="32"]  <- "S"		
		g[g=="24"|g=="42"]	<- "Y"		
		g[g=="34"|g=="43"]  <- "K"		
		genot2[,j]			<- g
		}
	mydnabin			<<- as.DNAbin(genot2)
	rownames(mydnabin)	<<- in_inds$name[indsfilter]
	mysambar$mydnabin	<<- mydnabin
	cat("Genotypes converted to sequences, stored as an DNAbin object called 'mydnabin' (and also stored under mysambar$mydnabin).",sep="\n")
	if(export)
		{
		exportname2		<- paste(mysambar$inputfilesdir,exportname,sep="/")
		cat(file=exportname2,paste(paste0(">",rownames(mydnabin)),sapply(mydnabin, paste, collapse=""), sep="\n"), sep="\n")
		if(!quiet)
			{
			cat(paste("Fasta file has been written to", exportname, sep =" "),sep="\n")
			}
		}
	}	

# 01-12-2021:
DNAbin2genlight<-function(mydnabin=mysambar$mydnabin)
	{
	if(is.null(mydnabin))
		{
		return(cat("ERROR: specified dnabin object (to mydnabin argument) not found.",sep="\n")) 
		}
	x				<- toupper(as.character(mydnabin))
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
	snpnames		<- paste("SNP",c(1:ncol(x)),sep="")
	#
	# find out major and minor allele:
	cat("Determining alleles...",sep="\n")
	mydf			<- as.data.frame(matrix(NA,nrow=ncol(x),ncol=11))
	colnames(mydf)	<- c("a","c","g","t","m","r","w","s","y","k","INDEL")
	for (j in c(1:ncol(x))) 
		{
		g				<- x[,j]
		mydf[j,1]		<- length(g[g=="A"])
		mydf[j,2]		<- length(g[g=="C"])
		mydf[j,3]		<- length(g[g=="G"])
		mydf[j,4]		<- length(g[g=="T"])
		mydf[j,5]		<- length(g[g=="M"])
		mydf[j,6]		<- length(g[g=="R"])
		mydf[j,7]		<- length(g[g=="W"])
		mydf[j,8]		<- length(g[g=="S"])
		mydf[j,9]		<- length(g[g=="Y"])
		mydf[j,10]		<- length(g[g=="K"])
		mydf[j,11]		<- length(g[g=="-"])	# INDEL
		}
	# M = AC
	# R = AG
	# W = AT
	# S = CG
	# Y = CT
	# K = GT
	mydf2				<- data.frame("A"=mydf$a+mydf$m+mydf$r+mydf$w,"C"=2*mydf$c+mydf$m+mydf$s+mydf$y,"G"=2*mydf$g+mydf$r+mydf$s+mydf$k,"T"=2*mydf$t+mydf$w+mydf$y+mydf$k)
	nalleles			<- apply(mydf2,1,FUN=function(x) length(which(x!=0)) )
	mybool				<- nalleles<=2
	mybool2				<- nalleles==2
	if(all(mybool))
		{
		if(all(mybool2))
			{
			cat("All sites are biallelic.",sep="\n")
			}else{
			cat("All sites are either monomorphic or biallelic.",sep="\n")
			}
		}else{
		nmulti	<- length(mybool[!mybool])
		nsites	<- length(mybool)
		cat(paste("WARNING: ",nmulti," multi-allelic sites found (out of ",nsites," in total). These sites will be excluded from the genlight object.",sep=""),sep="\n")
		if(nmulti==nsites)
			{
			return(cat("ERROR: all sites are multi-allelic. Not converting to genlight.",sep="\n"))
			}
		mydf	<- mydf[mybool,]
		mydf2	<- mydf2[mybool,]
		x		<- x[,mybool]
		genot	<- genot[,mybool]
		snpnames<- snpnames[mybool]
		}
	#
	cat("Determining minor and major alleles...",sep="\n")
	majorvec			<- c("A","C","G","T")[apply(mydf2,1,which.max)]
	mydf3				<- mydf2[,c("T","G","C","A")]		# reverse order, because in case maximum value is represented by two rather than one column, which.max returns first occurence.
	mydf3[mydf3==0]		<- 1000								# this enables to find minor.allele (assuming that no minor allele is represented by 1000 copies or more)
	minorvec			<- c("T","G","C","A")[apply(mydf3,1,which.min)]
	#
	# next convert to genlight:	
	cat("Converting to genlight...",sep="\n")
	cat("WARNING: if present, indels (-), will be converted to NA-values.",sep="\n")
	for (j in c(1:ncol(x))) 
		{
		g						<- x[,j]
		mymajor					<- majorvec[j]
		myminor					<- minorvec[j]
		g[g==mymajor&!is.na(g)] <- "0"
		g[g==myminor&!is.na(g)] <- "2"
       	g[(g=="M"|g=="R"|g=="W"|g=="S"|g=="Y"|g=="K")&!is.na(g)] 	<- "1"
       	g[g=="N"]				<- NA
		g[g=="-"]				<- NA
		genot[,j]				<- g
		}
	mygeno						<- as.data.frame(genot)
	rownames(mygeno)			<- rownames(x)
	colnames(mygeno)			<- snpnames
	mygl						<<- as.genlight(mygeno)
	mygl@loc.all				<<- paste(majorvec,minorvec,sep="/")
	mygl@other[[1]]				<<- majorvec
	mygl@other[[2]]				<<- minorvec
	cat("Data has been stored in a genlight object called 'mygl'.",sep="\n")
	cat("Vectors listing the major and minor alleles are stored at mygl@other[[1]] and mygl@other[[2]].",sep="\n")   
	}

genlight2structure<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname=NULL,quiet=FALSE,popasfirstcolumn=TRUE) 
	{
  	cat("Converting from genlight to structure format...",sep="\n")
	# Input should be a genlight object
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x)*2)
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	minor		<- in_snps$minor[snpsfilter]
	major		<- in_snps$major[snpsfilter]
	for (j in c(1:ncol(x))) 
		{
    	maj					<- major[j]
    	min					<- minor[j]
    	g					<- x[,j]
    	allele1				<- rep(NA,nrow(x))
		allele2				<- rep(NA,nrow(x))
		allele1[is.na(g)]	<- -9
		allele2[is.na(g)]	<- -9
	   	allele1[g==0]		<- maj
		allele2[g==0]		<- maj			 
    	allele1[g==1]		<- maj
		allele2[g==1]		<- min	
    	allele1[g==2]		<- min 
		allele2[g==2]		<- min 		
    	genot[,j*2-1]		<- allele1
		genot[,j*2]			<- allele2
		}
  	if(popasfirstcolumn)
		{
		strufile		<- cbind(pop=(in_inds$pop[indsfilter]),sample=indNames(input[indsfilter,]),as.data.frame(genot))
		}else{
		strufile		<- cbind(sample=indNames(input[indsfilter,]),pop=(in_inds$pop[indsfilter]),as.data.frame(genot))
		}
	# add column names:
	lociname1		<- snps$name[snps$filter]
	lociname1		<- paste(lociname1,"1",sep="_")
	lociname2		<- snps$name[snps$filter]
	lociname2		<- paste(lociname2,"2",sep="_")
	locnames		<- c(rbind(lociname1,lociname2))
	if(popasfirstcolumn)
		{
		colnames(strufile)	<- c("pop","sample",locnames)
		}else{
		colnames(strufile)	<- c("sample","pop",locnames)
		}
	mysambar$mystructure <<- strufile
	if(!quiet)
		{
		cat("Structure format has been saved in mysambar$mystructure.",sep="\n")
		}
	if(!is.null(exportname))
		{
		# Export:
		cat("Exporting structure file...",sep="\n")
		exportname2		<- paste(exportname,"stru",sep = ".")
		exportname3		<- paste(mysambar$inputfilesdir,exportname2,sep="/")
		write.table(strufile,file=exportname3,sep="\t",row.names=FALSE,col.names=TRUE,quote=FALSE)
		if(!quiet)
			{
			cat(paste("Structure file has been written to", exportname3, sep =" "),sep="\n")
			}
		}
	}	
	
# Export to ped and map
# To create input for software PopCluster, run as follows: 
# genlight2ped(exportname="PopCluster_input",genonumber=TRUE,miss_char="0",use_tab=FALSE,popcluster=TRUE)
genlight2ped<-function(input=mygenlight,in_snps=snps,in_inds=inds,popvec=NULL,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="filtered.data",pheno=NULL,genonumber=TRUE,quiet=FALSE,silent=TRUE,miss_char="0",use_tab=TRUE,popcluster=FALSE) 
	{
	# miss_char can be 'N' or '0'
	# Input should be a genlight object
	# 03-04-2020: because I ran into an error I added the line:
	# snpsfilter		<- snpsfilter&in_snps$minor!="0"&in_snps$major!="0"&in_snps$minor2!="N"&in_snps$major2!="N"
	# 19-07-2020: If I include the line above, I get the error:
	# Error in 1:nLoc(x) : NA/NaN argument
	#
	# We are going to convert this genlight object input file into a matrix with 0,1,2 or NA-values:
	x				<- as.matrix(input[indsfilter,snpsfilter]) 
  	# Now we are ready to create our PED-file, starting with an empty matrix:
	genot			<- matrix(NA,nrow=nrow(x),ncol=ncol(x))
  	rownames(genot)	<- rownames(x)
  	colnames(genot)	<- colnames(x)
	# We create vectors of minor and major alleles (should match with the columns of the x-matrix):
	if(!silent){cat("Creating vectors of minor and major alleles...",sep="\n")}
	if(any(!c("minor","major")%in%colnames(snps)))
		{
		cat("WARNING: columns 'minor' and major' absent from SNPs dataframe. Replacing with dummy values.",sep="\n")	
		snps$minor	<- 1
		snps$major	<- 4
		}
	if(any(!c("minor2","major2")%in%colnames(snps)))
		{
		cat("WARNING: columns 'minor2' and major2' absent from SNPs dataframe. Replacing with dummy values.",sep="\n")	
		snps$minor2	<- "A"
		snps$major2	<- "T"
		}
	if(genonumber)
		{
		minor		<- in_snps$minor[snpsfilter]
		major		<- in_snps$major[snpsfilter]
		missing		<- as.character(0)
		}else{
		minor		<- in_snps$minor2[snpsfilter]
		major		<- in_snps$major2[snpsfilter]
		missing		<- miss_char					# 08-02-2020: changed from as.character(0) to "N". # 11-03-2020: this gives an error with PCadapt, which expects '0'. Decided to make two output files. 
		}
	if(genonumber)
		{
		if(any(is.na(minor)))
			{
			return(cat("ERROR: NA's in snps$minor column.",sep="\n"))
			}
		if(any(is.na(major)))
			{
			return(cat("ERROR: NA's in snps$major column.",sep="\n"))
			}
		}else{
		if(any(minor=="NA"))
			{
			return(cat("ERROR: NA's in snps$minor column.",sep="\n"))
			}
		if(any(major=="NA"))
			{
			return(cat("ERROR: NA's in snps$major column.",sep="\n"))
			}
		}
	if(!silent){cat("Creating genot matrix...",sep="\n")}
	for (j in c(1:ncol(genot))) 
		{
    	g			<- x[,j]
    	maj			<- as.character(major[j])
    	min			<- as.character(minor[j])
    	g[is.na(g)]	<- paste(missing,missing,sep=" ")  				
    	g[g==0]		<- paste(maj,maj,sep=" ") 			 
    	g[g==1]		<- paste(min,maj,sep=" ") 		
    	g[g==2]		<- paste(min,min,sep=" ") 		
    	genot[,j]	<- g
  		}
  	pedfiledata<-as.data.frame(genot)
	if(!silent){genottemp	<<- genot}
	#
	if(is.null(popvec))
		{
		popvec		<- in_inds$pop[indsfilter]
		}else{
		popvec		<- popvec[indsfilter]
		}
	# Include additional information to pedfile:
	if(!silent){cat("Creating ped file...",sep="\n")}
	if(popcluster)
		{
		pedfile			<-cbind(IID=indNames(input[indsfilter,]),FID=popvec,POPFLAG=0,pedfiledata)
		}else{
		if(is.null(pheno))	
			{
			pedfile		<-cbind(FID=popvec,IID=indNames(input[indsfilter,]),PAT=0,MAT=0,SEX=0,PHENOTYPE=-9,pedfiledata)
			}else{
			pedfile		<-cbind(FID=popvec,IID=indNames(input[indsfilter,]),PAT=0,MAT=0,SEX=0,PHENOTYPE=pheno[indsfilter],pedfiledata)
			}
		}
	# pedfile		<<- pedfile
	# Next create the MAP-file:
	# if(any(names(snps) == "chr"))
	#{
	if(!silent){cat("Creating map file...",sep="\n")}
	if(is.factor(in_snps$name))
		{
		locus_names	<- in_snps$name
		}else{
		if(is.integer(in_snps$name)|is.character(in_snps$name))
			{
			# 15-07-2020: is.integer: to avoid error: Error in as.character.factor(in_snps$name) : attempting to coerce non-factor
			# 19-08-2020: is.character: to avoid error: Error in as.character.factor(in_snps$name) : attempting to coerce non-factor
			locus_names	<- in_snps$name
			}else{
			locus_names	<- as.character.factor(in_snps$name)
			}
		}
	if(any(!c("chr","pos")%in%colnames(snps)))
		{
		cat("WARNING: column(s) with positional information ('chr' and 'pos') missing. Replacing in map-file with dummy values.",sep="\n")
		mapfile		<- data.frame("chr"="scaffold1","name"=locus_names[snpsfilter],"gd"=0,"pos"=50000*c(1:nrow(snps[snps$filter,])))
		}else{
		mapfile		<- data.frame("chr"=(as.vector(in_snps$chr[snpsfilter])),"name"=locus_names[snpsfilter],"gd"=0,"pos"=in_snps$pos[snpsfilter])
		}
	# Finally, export the files:
	if(use_tab)
		{
		mysep <- c("\t")
		}else{
		mysep <- c(" ")
		}
	write.table(pedfile,file=paste(exportname,"ped",sep = "."),sep=mysep,na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	if(!popcluster)
		{
		write.table(mapfile,file=paste(exportname,"map",sep = "."),sep=mysep,na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
		}
	if(!quiet)
		{
		path1<- paste(getwd(),exportname,sep="/")
		cat(paste("PED and MAP files have been written to", path1, sep =" "),sep="\n")
		}
	}

exportneutral<-function(my_dataset="pheno",silent=TRUE,include_gwds=TRUE,include_pcadapt=TRUE,include_outflank=TRUE,include_bayescan=FALSE,include_fsthet=FALSE,current_dir=FALSE,export_outlier=TRUE,export_neutral=TRUE,usetab=TRUE)
	{
	currentdir	<- getwd()
	if(!current_dir)
		{
		setwd(mysambar$inputfilesdir)
		}
	if(!silent){cat(my_dataset,sep="\n")}
	snpcolnames		<- names(snps)
	# GWDS:
	mycolumn		<- paste("rfisherout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_gwds)		
		{
		gwdsout		<- snps[,mycolumn]
		gwdsout2	<- gwdsout
		if(any(is.na(gwdsout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_gwds){cat("WARNING: column with GWDS outlier info not present in snps dataframe.",sep="\n")}
		gwdsout		<- rep(FALSE,nrow(snps))
		gwdsout2	<- rep(TRUE,nrow(snps))
		}
	# PCadapt:
	mycolumn		<- paste("PCadaptout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_pcadapt)		
		{
		pcadaptout	<- snps[,mycolumn]
		pcadaptout2	<- pcadaptout
		if(any(is.na(pcadaptout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_pcadapt){cat("WARNING: column with PCadapt outlier info not present in snps dataframe.",sep="\n")}
		pcadaptout	<- rep(FALSE,nrow(snps))
		pcadaptout	<- rep(TRUE,nrow(snps))
		}
	# OutFLANK:
	mycolumn		<- paste("OutFLANK",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_outflank)		
		{
		outflankout	<- snps[,mycolumn]
		outflankout2<- outflankout	
		if(any(is.na(outflankout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_outflank){cat("WARNING: column with OutFLANK outlier info not present in snps dataframe.",sep="\n")}
		outflankout	<- rep(FALSE,nrow(snps))
		outflankout2<- rep(TRUE,nrow(snps))
		}
	# bayescan:
	mycolumn		<- paste("bayescanout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_bayescan)		
		{
		bayescanout	<- snps[,mycolumn]
		bayescanout2<- bayescanout
		if(any(is.na(bayescanout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_bayescan){cat("WARNING: column with Bayescan outlier info not present in snps dataframe.",sep="\n")}
		bayescanout	<- rep(FALSE,nrow(snps))
		bayescanout2<- rep(TRUE,nrow(snps))
		}
	# Fsthet:
	mycolumn		<- paste("fsthetout",my_dataset,sep="_")
	if(mycolumn%in%snpcolnames&include_fsthet)		
		{
		fsthetout	<- snps[,mycolumn]
		fsthetout2	<- fsthetout
		if(any(is.na(fsthetout))){cat(paste("WARNING: NA in column ",mycolumn," of SNPs dataset.",sep=""),sep="\n")}
		}else{
		if(include_fsthet){cat("WARNING: column with FstHet outlier info not present in snps dataframe.",sep="\n")}
		fsthetout	<- rep(FALSE,nrow(snps))
		fsthetout2	<- rep(TRUE,nrow(snps))
		}
	outdf	<<- cbind(gwdsout,pcadaptout,outflankout,bayescanout,fsthetout)
	outdf2	<<- cbind(gwdsout2,pcadaptout2,outflankout2,bayescanout2,fsthetout2)
	if(!any(outdf))
		{
		return(cat("No outliers present. Not possible to split dataset in neutral and outlier SNPs. Not exporting files.",sep="\n"))
		}
	outfilter		<- apply(outdf,1,any)
	outfilter2		<- apply(outdf2,1,all)
	outlierfilter	<- snps$filter&outfilter		# union
	outlierfilter2	<- snps$filter&outfilter2		# intersect (overlap)
	#
	# outliers of all selection scans:
	if(export_outlier)
		{
		cat("Exporting dataset with all outlier SNPs marked by at least one selection scan, in PED and MAP format...",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=outlierfilter,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.allscans",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
		if(any(outlierfilter2))
			{
			cat("Exporting dataset with outlier SNPs marked by all (used) selection scans, in PED and MAP format...",sep="\n")
			exportdata(indsfilter=inds$filter,snpsfilter=outlierfilter2,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.overlap",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}else{
			cat("No SNP has been marked by all outlier scans.",sep="\n")
			}
		# outliers of individual selection scans:
		if(any(gwdsout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&gwdsout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.GWDS",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(pcadaptout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&pcadaptout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.PCadapt",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(outflankout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&outflankout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.OutFLANK",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(bayescanout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&bayescanout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.Bayescan",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(fsthetout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&fsthetout,popnames=mysambar$populations,export_name=paste(my_dataset,"outlierSNPs.FstHet",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		}
	#
	if(export_neutral)
		{
		neutralfilter	<- snps$filter&(!outfilter)
		cat("Exporting dataset with neutral SNPs in PED and MAP format...",sep="\n")
		exportdata(indsfilter=inds$filter,snpsfilter=neutralfilter,popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.allscans",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
		#
		if(any(gwdsout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!gwdsout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.GWDS",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(pcadaptout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!pcadaptout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.PCadapt",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(outflankout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!outflankout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.OutFLANK",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(bayescanout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!bayescanout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.Bayescan",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		if(any(fsthetout))
			{
			exportdata(indsfilter=inds$filter,snpsfilter=snps$filter&(!fsthetout),popnames=mysambar$populations,export_name=paste(my_dataset,"neutralSNPs.FstHet",sep="."),geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=usetab)
			}
		}
	setwd(currentdir)
	}


# this function exports PED and MAP files for all populations separately and for all pops combined:
# depends on function 'genlight2ped':
exportdata<-function(input_genlight=mygenlight,indsfilter=inds$filter,snpsfilter=snps$filter,popnames=mysambar$populations,export_name="filter1",geno_nr=TRUE,quiet2=FALSE,do_all=FALSE,do_pheno=FALSE,misschar="0",silent=TRUE,dotab=TRUE)
	{ 
	if(do_all)
		{
		exportnametemp	<- paste("metapop",export_name,sep=".")
		}else{
		exportnametemp	<- export_name
		}
	genlighttemp		<- input_genlight[indsfilter,snpsfilter]
	snpstemp			<- snps[snpsfilter,]
	indstemp			<- inds[indsfilter,]
	if(do_pheno)
		{
		indstemp$pop	<- indstemp$type
		}
	if(!silent)
		{
		cat("Exporting...",sep="\n")
		snpstemp		<<- snpstemp
		indstemp		<<- indstemp
		genlighttemp	<<- mygenlight
		}
	genlight2ped(genonumber=geno_nr,exportname=exportnametemp,input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),quiet=quiet2,miss_char=misschar,use_tab=dotab)
	if(do_all)
		{
		for (mypop in popnames)
			{
			genlighttemp	<- input_genlight[inds$pop==mypop&indsfilter,snpsfilter]
			snpstemp		<- snps[snpsfilter,]
			indstemp		<- inds[inds$pop==mypop&indsfilter,]
			exportnametemp	<- paste(mypop,export_name,sep=".")
			genlight2ped(genonumber=geno_nr,exportname=exportnametemp,input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),quiet=quiet2,miss_char=misschar,use_tab=dotab)
			}
		}
	}

# Export to Treemix input:
exporttreemix<-function(snpsfilter=snps$filter,exportname="Treemixinput.snpsfilter.txt",silent=TRUE)
	{
	if(!silent){cat("Creating input for Treemix...",sep="\n")}
	mycolumns			<- grep("ac_", colnames(snps))
	if(length(mycolumns)==0)
		{
		return(cat("ERROR: columns with allele counts (starting with 'ac_' and 'mac_') missing from SNPs dataframe. These columns are normally generated by the snp_maf function, invoked by filterdata function."))
		}
	mydf				<- snps[snpsfilter, grep("ac_", colnames(snps))]
	alldf				<- mydf[,c(TRUE,FALSE),drop=FALSE]
	minordf				<- mydf[,c(FALSE,TRUE),drop=FALSE]
	if(ncol(alldf)!=ncol(minordf))
		{
		alldf	<<- alldf
		minordf	<<- minordf
		return(cat("ERROR: number of columns of alldf and minordf do not correspond.",sep="\n"))
		}
	majordf				<- alldf-minordf
	#
	if(!silent){cat("Ordering dataframes...",sep="\n")}
	alldf				<- alldf[,order(colnames(alldf))]
	minordf				<- minordf[,order(colnames(minordf))]
	majordf				<- majordf[,order(colnames(majordf))]	
	#
	if(!silent){cat("Adding column names...",sep="\n")}
	popnames			<- mysambar$populations2
	npops				<- length(popnames)
	colnames(alldf)		<- popnames
	colnames(minordf)	<- popnames 
	colnames(majordf)	<- popnames
	alldf2				<- alldf
	#
	if(!silent){cat("Generating final output file...",sep="\n")}
	for(k in c(1:npops))
		{
		alldf2[,k]		<- paste(majordf[,k],minordf[,k],sep=",")	
		}
	if(!silent){cat("Selecting populations...",sep="\n")}
	alldf2				<- alldf2[,colnames(alldf2)%in%mysambar$populations]
	if(!silent){cat("Writing output...",sep="\n")}
	write.table(alldf2,exportname,sep=" ",quote=FALSE,row.names=FALSE)
	cat("Treemix input file (unzipped) has been exported to the directory:...",sep="\n")
	cat(getwd(),sep="\n")
	}

# Export to Immanc format:
genlight2immanc<-function(input=mygenlight,in_snps=snps,in_inds=inds,snpsfilter=snps$filter,indsfilter=inds$filter,exportname="Bayesassinput.immanc.txt",quiet=FALSE) 
	{
	# immanc format:
	# Ind1 	pop1	locus1	allele1	allele2
	# Ind2 	pop1	locus1	allele1	allele2
	# Ind3 	pop1	locus1	allele1	allele2
	# Ind1 	pop1	locus2	allele1	allele2
	# Ind2 	pop1	locus2	allele1	allele2
	# Ind3 	pop2	locus2	allele1	allele2
	# etc.
	#
	# example for 3 individuals (from 2 pop) and 2 loci:
	# Ind374	North	15	2	2
	# Ind375	SouthWest	15	1	2
	# Ind376	SouthWest	15	1	1
	# Ind374	North	16	2	2
	# Ind375	SouthWest	16	1	2
	# Ind376	SouthWest	16	1	1
	#
	# Consider that the genlight code means the following:
	# genlight	allele1	allele2
	# 0 	= 	1 		1		
	# 1 	= 	1 		2		
	# 2 	= 	2 		2
	#
	# To change the genlight format in a code for the first allele, we only have to change the code for homozygous major: 
	g1				<- as.matrix(input[indsfilter,snpsfilter])
	g1[g1==0]		<- 1		
	g1[is.na(g1)]	<- 0		# missing data coded as 0
	allele1			<- as.vector(unlist(g1))		
	#
	# second allele:
	# To change the genlight format in a code for the second allele, we have to change the code for homozygous major as well as for heterozygous:
	g2				<- as.matrix(input[indsfilter,snpsfilter]) 
	g2[g2==1]		<- 2
	g2[g2==0]		<- 1
	g2[is.na(g2)]	<- 0		# missing data coded as 0
	allele2			<- as.vector(unlist(g2))
	#
	# create dataframe:
	mysnps			<- snps$name[snpsfilter]
	nsnps			<- length(mysnps)
	myinds			<- inds[indsfilter,c("name","pop")]
	ninds			<- nrow(myinds)
	mysnps2			<- rep(mysnps,each=ninds)
	myinds2			<- coredata(myinds)[rep(seq(nrow(myinds)),nsnps),]
	myoutput		<<- as.data.frame(cbind(myinds2,mysnps2,allele1,allele2))
	# export:
	write.table(myoutput,exportname,sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	if(!quiet)
		{
		path1	<- paste(getwd(),exportname,sep="/")
		cat(paste("Bayesass input (immanc format) has been written to", path1, sep =" "),sep="\n")
		}
	}

# This function converts everything to 01 and/or 02, regardless of actual allele.
genlight2genepop<-function(input=mygenlight,overwritefile=FALSE,snpsfilter=snps$filter,indsfilter=inds$filter,group1="pheno",group2="pheno",addcomma=TRUE,exportsubset=FALSE,use_alleles=TRUE) 
	{
	nsnps		<- nrow(snps[snps$filter,])
	minorvec	<- snps$minor[snps$filter]
	majorvec	<- snps$major[snps$filter]
	# Input should be a genlight object.
	if(!is.null(mysambar$genepop)&!overwritefile)
		{
		cat("WARNING: using existing genepop dataframe saved at mysambar$genepop.",sep="\n")
		cat("If you want to generate a new dataframe, set flag overwritefile to TRUE.",sep="\n")
		g1			<- mysambar$genepop
		}else{
		cat("Converting genlight to genepop object...",sep="\n")
		g1				<- as.data.frame(input[,snpsfilter])
		if(use_alleles)
			{
			# 27-06-2023:
			for(j in c(1:nsnps))
				{
				if(j%%2500==0){cat(paste("SNP ",j," out of ",nsnps," in total.",sep=""),sep="\n")} 
				snpvec					<- g1[,j]
				snpmajor				<- majorvec[j]
				snpminor				<- minorvec[j]
				snpvec[is.na(snpvec)]	<- "0000"
				snpvec[snpvec==0]		<- paste("0",snpmajor,"0",snpmajor,sep="")
				snpvec[snpvec==1]		<- paste("0",snpmajor,"0",snpminor,sep="")
				snpvec[snpvec==2]		<- paste("0",snpminor,"0",snpminor,sep="")
				g1[,j]					<- snpvec
				}
			}else{
			# indicate whether allele1 and allele2 are major (1) or minor allele (2):
			g1[g1==0]		<- "0101"
			g1[g1==1]		<- "0102"
			g1[g1==2]		<- "0202"
			}
		mygenepop			<<- g1
		mysambar$genepop	<<- g1
		}
	mysnpnames		<- as.vector(snps$name[snpsfilter])
	setwd(mysambar$inputfilesdir)
	if(exportsubset)
		{
		if(group1=="pheno")
			{
			cat("Dividing into pheno1 and pheno2...",sep="\n") 
			gsub1	<- g1[indsfilter&inds$type==TRUE,]
			gsub2	<- g1[indsfilter&inds$type==TRUE,]
			}else{
			cat("Dividing into pheno1 and pheno2...",sep="\n") 
			gsub1	<- g1[indsfilter&inds$pop==group1,]
			gsub2	<- g1[indsfilter&inds$pop==group2,]
			}
		if(addcomma)
			{
			#rownames(g1)<- paste(rownames(g1),",",sep="\t")
			rownames(gsub1)<- paste(rownames(gsub1),",",sep="")
			rownames(gsub2)<- paste(rownames(gsub2),",",sep="")
			}
		if(doexport)
			{
			mysnpnames		<- as.vector(snps$name[snpsfilter])
			if(group1=="pheno")
				{
				myfilename		<- "pheno.mygenepop"
				}else{
				myfilename		<- paste(group1,group2,"genepop",sep="_")
				}
			cat("# Genepop file generated by SambaR\n", file=myfilename)
			cat(mysnpnames, file=myfilename, append=TRUE, sep=",")
			cat("\npop\n", file=myfilename, append=TRUE)
			write.table(gsub1, file=myfilename, append=TRUE, sep="\t",col.names=FALSE,quote=FALSE)
			cat("pop\n", file=myfilename, append=TRUE)
			write.table(gsub2, file=myfilename, append=TRUE, sep="\t",col.names=FALSE, quote=FALSE)
			}
		cat(paste("Genepop file called '",myfilename,"' exported to the directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		}else{
		myfilename		<- "all.genepop"
		cat("# Genepop file generated by SambaR\n", file=myfilename)
		cat(mysnpnames, file=myfilename, append=TRUE, sep=",")
		cat("\npop\n", file=myfilename, append=TRUE)
		write.table(g1, file=myfilename, append=TRUE, sep="\t",col.names=FALSE,quote=FALSE)
		cat(paste("Genepop file called '",myfilename,"' exported to the directory:",sep=""),sep="\n")
		cat(getwd(),sep="\n")
		}
	}

listobjects<-function()
	{
	myobjectnames	<- ls(envir = .GlobalEnv)
	myobjects		<- lapply(X=myobjectnames,FUN=get)
	myboolvec		<- vector()	
	for(k in c(1:length(myobjects)))
		{
		myboolvec[k]<- !is.function(myobjects[[k]])
		}
	myobjectnames2<-myobjectnames[myboolvec]
	cat(paste(myobjectnames2,collapse=","),sep="\n")
	}

# from inds, snps and mygenlight to sambar list:
backupdata<-function(myprefix=NULL,overwrite=FALSE)
	{
	if(is.null(myprefix))
		{
		cat("ERROR: You have to provide a prefix.",sep="\n")
		}else{
		if(exists(myprefix)&!overwrite)
			{
			return(cat(paste("ERROR: there is already an object called '",myprefix,"'. Please choose another name to save your data or set the flag 'overwrite' to TRUE.",sep=""),sep="\n"))
			}
		myglobal		<- globalenv()
		mylist			<- mysambar
		mylist$inds		<- inds
		mylist$snps		<- snps
		mylist$genlight	<- mygenlight
		mylist$inds2	<- inds2
		mylist$pops2	<- pops2
		assign(myprefix,mylist,envir=myglobal)
		cat(paste("A back up of your data objects has been stored in a list object called:", myprefix,sep=" "),sep="\n")
		cat("The data can be loaded any time using the getdata() function.",sep="\n")
		}
	}

# from sambar list to inds, snps and mygenlight:
getdata<-function(myprefix=NULL,silent=TRUE,do_check=TRUE)
	{
	# which mysambar lists available?
	if(!silent){cat("Creating a list of available SambaR datasets...",sep="\n")}
	myobjectnames<- ls(envir = .GlobalEnv)
	myobjects	<- lapply(X=myobjectnames,FUN=get)
	myboolvec	<- vector()
	for(k in c(1:length(myobjects)))
		{
		myboolvec[k]<- is.list(myobjects[[k]])
		}
	mylistnames<- myobjectnames[myboolvec]
	mylists		<- myobjects[myboolvec]
	myboolvec	<- vector()
	for(k in c(1:length(mylists)))
		{
		#cat(k,sep="\n")
		mylist			<- mylists[[k]]
		myboolvec[k] 	<- "inds" %in% names(mylist)
		}
	mysambarlists	<- mylistnames[myboolvec]
	mysambarlists	<- mysambarlists[mysambarlists!="mysambar"]
	if(length(mysambarlists)==0)
		{
		mysambarlists	<- "none"
		}
	if(is.null(myprefix))
		{
		cat("ERROR: You have to provide a prefix (the name you used to backup your data) to the myprefix flag.",sep="\n")
		cat("Available SambaR datasets:",sep="\n")
		cat(paste(mysambarlists,collapse=","),sep="\n")
		return(cat(" ",sep="\n"))
		}else{
		if(do_check)
			{
			if(!exists(myprefix))
				{
				cat("ERROR: Object with specified name does not exist.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(!silent){cat("Object present.",sep="\n")}
			myobject	<- get(myprefix)
			if(!is.list(myobject))
				{
				cat("ERROR: Specified object is not a list object.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(!silent){cat("Object is a list.",sep="\n")}		
			mylist		<- get(myprefix)
			if(!"inds" %in% names(mylist))
				{
				cat("ERROR: Specified object is a list, but not a SambaR list object.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(myprefix=="mysambar")
				{
				cat("ERROR: It is not possible to select 'mysambar'.",sep="\n")
				cat("Available SambaR datasets:",sep="\n")
				cat(paste(mysambarlists,collapse=","),sep="\n")
				return(cat(" ",sep="\n"))
				}
			if(!silent){cat("Object is a SambaR list.",sep="\n")}		
			}
		myglobal	<- globalenv()
		mylist		<- get(myprefix,envir=myglobal)
		inds		<<- mylist$inds
		snps		<<- mylist$snps
		mygenlight	<<- mylist$genlight
		inds2		<<- mylist$inds2
		pops2		<<- mylist$pops2
		mylist$snps		<- "snps"
		mylist$inds		<- "inds"
		mylist$genlight	<- "genlight"
		mysambar		<<- mylist
		cat("Data has been loaded to inds, snps and mygenlight objects.",sep="\n")
		setwd(mysambar$inputdatadir)
		cat("Working directory has been set to:",sep="\n")
		cat(mysambar$inputdatadir,sep="\n")
		}
	}

# Exlude certain individuals from subsequent analyses:
subset_pop<-function(include_pops=NULL)
	{
	if(is.null(include_pops))
		{
		cat("ERROR: provide an input vector to the 'include_pops' argument. E.g.:",sep="\n")
		cat('popsubset(include_pops=c("popname1","popname2","etc"))',sep="\n")
		return(cat("This input vector should contain the names of the populations you want to select.",sep="\n"))
		}
	cat("Subselecting populations. Note that this function should be executed after the filterdata() function, not before!",sep="\n")
	if(any(!include_pops%in%mysambar$populations))
		{
		return(cat("ERROR: one or more population names not found in existing dataset.",sep="\n"))
		}
	mybool					<- mysambar$populations%in%include_pops
	mysambar$populations	<<- mysambar$populations[mybool]
	mysambar$mycolours		<<- mysambar$mycolours[mybool]	
	mysambar$mycolours2		<<- mysambar$mycolours
	mybool2					<- inds$pop%in%include_pops
	inds$filter				<<- inds$filter&mybool2
	#
	# Screen info:
	snpstemp				<- snps[,paste("maf",include_pops,sep="_")]
	mafsum					<- rowSums(snpstemp)
	npoly					<- length(mafsum[mafsum>0])
	nind					<- nrow(inds[inds$filter,])
	cat("Done. Individuals which don't belong to populations defined in the include_pops argument, will be excluded from subsequent analyses.",sep="\n")
	cat(paste("This smaller dataset contains ",nind," retained individuals and ",npoly," polymorphic sites.",sep=""),sep="\n")
	cat("Don't run the filterdata() function, because this will partially undo the changes. To undo the changes, rerun the importdata() function.",sep="\n")
	#table(inds$pop,inds$filter)
	}
	
# create a targetted subset of SNP dataset:
subselectdata<-function(snp_names=NULL,name2=TRUE,name3=FALSE)
	{
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","forestgreen","gray80","midnightblue","lavenderblush3","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	#defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	#
	if(is.null(snp_names))
		{
		return(cat("ERROR: no snpnames provided to snp_names argument.",sep="\n"))
		}	
	if(name2)
		{
		myselection		<- snps$name2%in%snp_names
		}else{
		if(name3)
			{
			myselection		<- snps$name3%in%snp_names
			}else{
			myselection		<- snps$name%in%snp_names
			}
		}
	nhits			<- length(myselection[myselection])
	cat(paste("Found",nhits,"snps",sep=" "),sep="\n")
	if(nhits==0)
		{
		return(cat("0 hits. Subsetting aborted.",sep="\n"))
		}
	matrixtemp		<- as.matrix(mygenlight)[,myselection]
	snpstemp		<- snps[myselection,]
	# create sambar list:
	# sambar list:
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Subset",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambarsubset			<<- list()
	mysambarsubset[[1]]		<<- mysambar$populations
	mysambarsubset[[2]]		<<- inds
	mysambarsubset[[3]]		<<- snpstemp
	mysambarsubset[[4]]		<<- as.genlight(matrixtemp)
	mysambarsubset[[5]]		<<- inputdatadir
	mysambarsubset[[6]]		<<- sambardir
	mysambarsubset[[7]]		<<- QCdir
	mysambarsubset[[8]]		<<- structuredir
	mysambarsubset[[9]]		<<- divergencedir
	mysambarsubset[[10]]	<<- diversitydir
	mysambarsubset[[11]]	<<- demographydir
	mysambarsubset[[12]]	<<- selectiondir
	mysambarsubset[[13]]	<<- inputfilesdir
	mysambarsubset[[14]]	<<- "sans"
	mysambarsubset[[17]]	<<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
	mysambarsubset[[18]]	<<- geomapsdir
	names(mysambarsubset)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambarsubset$populations2		<<- mysambarsubset$populations	# needed for excludepop()
	mysambarsubset$mycolours2		<<- mysambarsubset$mycolours	# needed for excludepop()
	mysambarsubset$defaultcolours	<<- defaultcolours
	mysambarsubset$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambarsubset$datasource		<<- "subselectdata"
	cat("Data subset has been stored in a list object called 'mysambarsubset'.",sep="\n")
	cat("You can load the data by typing: getdata('mysambarsubset').",sep="\n")
	cat("However, before loading make sure to first backup original dataset using the backupdata()-function.",sep="\n")
	cat("Also note: the information in snps and inds data is still based on entire dataset, not on subset.",sep="\n")
	cat("Therefore, after loading run the filterdata(), findstructure(), calcdistance() and calcdiversity() functions again.",sep="\n")
	}	
	
# create a random subset of SNP dataset (subset can be based on snps and/or inds):
subsampledata<-function(nrinds=NULL,nrsnps=NULL,exportprefix=NULL,remove_stats=TRUE,popcolours=NULL)
	{
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","forestgreen","gray80","midnightblue","lavenderblush3","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	#defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	#
	if(is.null(nrinds)&is.null(nrsnps))
		{
		return(cat("ERROR: how many individuals (nrinds) and how many loci (nrsnps) should be subsampled?",sep="\n"))
		}
	if(!is.null(nrinds))
		{
		indstemp1	<- inds[inds$filter,]
		indstemp2	<- c(1:nrow(indstemp1))
		indstemp3	<- sample(indstemp2,nrinds,replace = FALSE)
		indstemp3	<- indstemp3[order(indstemp3)]
		indstemp	<- indstemp1[indstemp3,]
		}else{
		indstemp	<- inds
		indstemp3	<- c(1:nrow(indstemp))
		}
	if(!is.null(nrsnps))
		{
		snpstemp1	<- snps[snps$filter,]
		snpstemp2	<- c(1:nrow(snpstemp1))
		snpstemp3	<- sample(snpstemp2,nrsnps,replace = FALSE)
		snpstemp3	<- snpstemp3[order(snpstemp3)]
		snpstemp	<- snpstemp1[snpstemp3,]
		}else{
		snpstemp	<- snps[snps$filter,]
		snpstemp3	<- c(1:nrow(snpstemp))
		}
	#
	# subsample genlight:
	if(!is.null(nrsnps)&(!is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[inds$filter,snps$filter]
		}
	if(!is.null(nrsnps)&(is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[,snps$filter]
		}
	if(is.null(nrsnps)&(!is.null(nrinds)))
		{
		matrixtemp		<- as.matrix(mygenlight)[inds$filter,]
		}
	matrixtemp		<- matrixtemp[indstemp3,snpstemp3]
	genlighttemp	<- as.genlight(matrixtemp)
	if(remove_stats)
		{
		indstemp	<- indstemp[,c("name","pop","pop2","nr","popcol","meandepth","name2")]
		snpstemp	<- snpstemp[,c("chr","name","morgan","pos","minor","major","minor2","major2","stackID","stackbp","readpos","sameread","name2","placed","autosomal","dist","dist2","samepos","uniqpos","meandepth","depthfilter","poly")]
		}
	#
	# sambar list:
	setwd(mysambar$inputdatadir)
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Subsetdata",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	# store in list called mysambarsubset: 
	mysambarsubset				<<- list()
	populationstemp				<- as.vector(unique(indstemp$pop))
	mysambarsubset$populations	<<- populationstemp
	mysambarsubset$inds			<<- indstemp
	mysambarsubset$snps			<<- snpstemp
	mysambarsubset$genlight		<<- genlighttemp
	mysambarsubset[[5]]			<<- inputdatadir
	mysambarsubset[[6]]			<<- sambardir
	mysambarsubset[[7]]			<<- QCdir
	mysambarsubset[[8]]			<<- structuredir
	mysambarsubset[[9]]			<<- divergencedir
	mysambarsubset[[10]]		<<- diversitydir
	mysambarsubset[[11]]		<<- demographydir
	mysambarsubset[[12]]		<<- selectiondir
	mysambarsubset[[13]]		<<- inputfilesdir
	mysambarsubset[[14]]		<<- "sans"
	if(is.null(popcolours))
		{
		mysambarsubset[[17]]	<<- c("blue","darkgreen","darkred","orange","darkorchid4","#654321","yellow","gray20")
		}else{
		mysambarsubset[[17]]	<<- popcolours
		}
	mysambarsubset[[18]]	<<- geomapsdir
	names(mysambarsubset)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambarsubset$populations2		<<- mysambarsubset$populations	# needed for excludepop()
	mysambarsubset$mycolours2		<<- mysambarsubset$mycolours	# needed for excludepop()
	mysambarsubset$defaultcolours	<<- defaultcolours
	mysambarsubset$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambarsubset$datasource		<<- "subsampledata"
	#
	cat("Data subset has been stored in a list object called 'mysambarsubset'.",sep="\n")
	cat("You can load the data by typing: getdata('mysambarsubset').",sep="\n")
	cat("However, before loading make sure to first backup original dataset using the backupdata()-function.",sep="\n")
	#
	# optionally export:
	if(!is.null(exportprefix))
		{
		setwd(inputdatadir)
		genlight2ped(input=genlighttemp,in_snps=snpstemp,in_inds=indstemp,snpsfilter=rep(TRUE,nrow(snpstemp)),indsfilter=rep(TRUE,nrow(indstemp)),exportname=exportprefix) 
		}
	}

#be sure to first back up your data using the backupdata function
dummydata<-function(nind=2,nsnp=4,q=0.15,popname="pop1",popcol="blue",mygeno=NULL,major=1,minor=4,colourvector=NULL,mafvec=NULL,silent=TRUE)
	{
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","forestgreen","gray80","midnightblue","lavenderblush3","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	#defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(colourvector))
		{
		colourvector	<- defaultcolours
		}
	# q = minor allele freq
	# myprobs = probability of occurence of homo_major, hetero, hetero_minor
	myprobs			<- c((1-q)^2,2*(1-q)*q,(q^2))
	#
	# snps:
	if(!silent){cat("Creating snps dataframe...",sep="\n")}
	snpnr			<- c(1:nsnp)
	snpname			<- paste("snp",snpnr,sep="")
	snps			<<- as.data.frame(cbind(snpnr,snpname))
	colnames(snps)	<<- c("nr","name")
	snps$chr		<<- "dummy_chr1"
	snps$pos		<<- snpnr
	snps$miss		<<- 0
	snps$misscount_pop1								<<- 0
	names(snps)[colnames(snps)=="misscount_pop1"]	<<- paste("misscount",popname,sep="_")
	snps$filter		<<- TRUE
	snps$uniqpos	<<- TRUE
	snps$polyfilter	<<- TRUE
	snps$depthfilter<<- TRUE
	snps$nr_neworder<<- c(1:nrow(snps))
	# inds:
	if(!silent){cat("Creating inds dataframe...",sep="\n")}
	indnr			<- c(1:nind)
	indname			<- paste("ind",indnr,popname,sep="")	
	inds			<<- as.data.frame(cbind(indnr,indname))
	colnames(inds)	<<- c("nr","name")
	inds$pop		<<- popname
	inds$pop2		<<- popname
	inds$popcol		<<- popcol
	inds$miss		<<- 0
	inds$filter		<<- TRUE
	inds$nsites2	<<- nsnp
	#
	# genlight:
	if(!silent){cat("Creating genlight dataframe...",sep="\n")}
	if(is.null(mafvec))
		{
		if(!is.null(mygeno))
			{
			mymatrix 			<- matrix(mygeno,nrow=nind,ncol=nsnp,byrow=FALSE)
			}else{
			mymatrix			<- matrix(NA,nrow=nind,ncol=nsnp) 
			for (i in c(1:nsnp))
				{
				mymatrix[,i]	<- sample(c(0,1,2),nind,replace=TRUE,prob=myprobs)
				}
			}
		}else{
		cat("Generating snp data from input maf-vector.",sep="\n")
		mymatrix				<- matrix(NA,nrow=nind,ncol=nsnp) 
		for (i in c(1:nsnp))
			{
			q					<- mafvec[i]
			myprobs				<- c((1-q)^2,2*(1-q)*q,(q^2))
			mymatrix[,i]		<- sample(c(0,1,2),nind,replace=TRUE,prob=myprobs)
			}
		}
	rownames(mymatrix)			<- inds$name
	colnames(mymatrix)			<- snps$name
	mygenlight					<<- as.genlight(mymatrix)
	# add info on minor allele to snps data frame:
	if(!silent){cat("Updating snps dataframe...",sep="\n")}
	misscount					<- glNA(mygenlight,alleleAsUnit=FALSE)
	snps$nonmissallelecount 	<<- 2*nInd(mygenlight)-misscount
	inds$filter					<<- TRUE
	snps$filter					<<- TRUE
	snp_maf(popnames=popname,indthreshold=0.2)
	snps$minor					<<- minor
	snps$major					<<- major
	snps$minor2					<<- c("A","C","G","T")[minor]
	snps$major2					<<- c("A","C","G","T")[major]
	# sambar list:
	if(!silent){cat("Creating directies...",sep="\n")}
	inputdatadir		<- getwd()
	inputdatadir		<- paste(inputdatadir,"Dummydata",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	if(!silent){cat("Creating Sambar object...",sep="\n")}
	mysambar		<<- list()
	mysambar[[1]]	<<- popname
	mysambar[[5]]	<<- inputdatadir
	mysambar[[6]]	<<- sambardir
	mysambar[[7]]	<<- QCdir
	mysambar[[8]]	<<- structuredir
	mysambar[[9]]	<<- divergencedir
	mysambar[[10]]	<<- diversitydir
	mysambar[[11]]	<<- demographydir
	mysambar[[12]]	<<- selectiondir
	mysambar[[13]]	<<- inputfilesdir
	mysambar[[14]]	<<- "sans"
	mysambar[[17]]	<<- colourvector
	mysambar[[18]]	<<- inputfilesdir
	names(mysambar)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambar$populations2	<<- mysambar$populations	# needed for excludepop()
	mysambar$mycolours2		<<- mysambar$mycolours		# needed for excludepop()
	mysambar$defaultcolours	<<- defaultcolours
	mysambar$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambar$datasource		<<- "dummydata"
	#
	cat("New inds, snps and genlight objects have been created.",sep="\n")
	}	

# cbind two genlight objects (assuming same individuals)
glmerge<-function(mygl)
	{
	simgl				<- glSim(nrow(mygl),n.snp.nonstruc=10000,ploidy=2)
	indNames(simgl)		<- indNames(mygl)
	pop(simgl)			<- pop(mygl)
	locNames(simgl)		<- locNames(mygl)
	combigl				<- cbind(mygl,simgl)
	}

# Find overlap between two datasets (stored as sambar list objects)	
findoverlap<-function(mylist1=NULL,mylist2=NULL,mycolours=NULL,silent=TRUE,combine_divstats=FALSE,myworkdir=NULL,do_continue=FALSE)
	{
	#
	if(is.null(myworkdir))
		{
		cat("The user did not define a path to the 'myworkdir' flag. Assuming that a new directory called 'Combined_dataset' (to store the new SambaR output) of the combined dataset should be created in the current working directory:",sep="\n")
		inputdatadir		<- getwd()
		cat(inputdatadir,sep="\n")
		if(!do_continue)
			{
			return(cat("If this is correct, set the flag do_continue to TRUE. If not, define the desired directory to the myworkdir flag, or alternative change working directory.",sep="\n"))
			}
		inputdatadir		<- paste(inputdatadir,"Combined_data",sep="/")
		}else{
		if(!dir.exists(myworkdir))
			{
			cat("Directory specified to the myworkdir does not exist.",sep="\n")
			}else{
			inputdatadir	<- myworkdir
			cat("The SambaR directory of the combined dataset will be created in the directory (specified to the 'myworkdir' flag):",sep="\n")
			cat(inputdatadir,sep="\n")
			if(!do_continue)
				{
				return(cat("If this is correct, set the flag do_continue to TRUE. Specify another directory to the myworkdir flag, or alternative change working directory.",sep="\n"))
				}
			inputdatadir	<- paste(inputdatadir,"Combined_data",sep="/")
			}
		}
	# Note: provide input to mylist1 and mylist2 without quotes
	defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","forestgreen","gray80","midnightblue","lavenderblush3","darkorange3","aquamarine4","burlywood4","gold3","darkcyan","dodgerblue","deepskyblue1","mediumpurple2","tan4","lightseagreen","deepskyblue3","khaki2","springgreen3","steelblue2","yellowgreen","plum1","mediumblue","royalblue3","yellow2")
	#defaultcolours		<- c("blue","darkgreen","darkred","orange","darkorchid4","indianred1","deepskyblue","greenyellow","#654321","#009595","gray20","gray50","gray80","midnightblue","lavenderblush3","ivory2","aquamarine4","burlywood4")
	if(is.null(mycolours))
		{
		return(cat("ERROR: You have to provide the colours of all populations to combine, in alphabetical order of population names",sep="\n"))
		}
	ncolours					<- length(mycolours)
	### rename datasets:
	mydataset1.snps				<- mylist1$snps
	mydataset1.inds				<- mylist1$inds
	mydataset1.genlight			<- mylist1$genlight
	mydataset1.populations		<- mylist1$populations
	mydataset2.snps				<- mylist2$snps
	mydataset2.inds				<- mylist2$inds
	mydataset2.genlight			<- mylist2$genlight
	mydataset2.populations		<- mylist2$populations
	#
	if(any(!colnames(as.matrix(mydataset1.genlight))==mydataset1.snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column for dataset1. Contact developer of SambaR.",sep="\n"))
		}
	if(any(!colnames(as.matrix(mydataset2.genlight))==mydataset2.snps$genlightname))
		{	
		return(cat("ERROR: column names of genlight object do not correspond with snps$genlightname column for dataset2. Contact developer of SambaR.",sep="\n"))
		}
	# combine populations vectors:
	if(!silent){cat("Combine population vectors.",sep="\n")}
	populationscombi		<- as.vector(unique(c(mydataset1.populations,mydataset2.populations)))
	populationscombi		<- populationscombi[order(populationscombi)]
	if(length(populationscombi)!=ncolours)
		{
		return(cat("ERROR: Number of colours does not match overall number of populations in both datasets.",sep="\n"))
		}
	# How many individuals?
	n_ind1						<- nrow(mylist1$inds)
	n_ind2						<- nrow(mylist2$inds)
	n_both						<- n_ind1+n_ind2
	cat(paste("Dataset 1 contains",n_ind1,"individuals.",sep=" "),sep="\n")
	cat(paste("Dataset 2 contains",n_ind2,"individuals.",sep=" "),sep="\n")
	cat(paste("Combined dataset will contain",n_both,"individuals.",sep=" "),sep="\n")
	#
	indnames1				<- as.character(mydataset1.inds$name)
	indnames2				<- as.character(mydataset2.inds$name)
	if(any(indnames1%in%indnames2))
		{
		cat("ERROR: the two datasets contain one or more samples with the same name, which is not allowed.")
		cat("The findoverlap function is designed to merge datasets containing different individuals.",sep="\n")
		return(cat("If the individuals are different but one or more happen to have the same name, please renames these individuals before running the findoverlap function.",sep="\n"))
		}
	popnames1				<- as.character(mydataset1.inds$pop)
	popnames2				<- as.character(mydataset2.inds$pop)
	if(any(popnames1%in%popnames2))
		{
		cat("ERROR: the two datasets contain one or more populations with the same name, which can causes problems when running the findoverlap function.")
		return(cat("Please rename these populations before running the findoverlap function.",sep="\n"))
		}
	#
	cat("Searching for SNPs present in both datasets...",sep="\n")
	### find overlapping snps (snps which occur in both datasets)
	snpstemp1				<- mydataset1.snps[mydataset1.snps$uniqpos,c("chr","pos")]
	snpstemp2				<- mydataset2.snps[mydataset2.snps$uniqpos,c("chr","pos")]	
	snpstemp1_name			<- mydataset1.snps[mydataset1.snps$uniqpos,c("chr","pos","name")]
	snpstemp2_name			<- mydataset2.snps[mydataset2.snps$uniqpos,c("chr","pos","name")]	
	chroms					<- as.vector(unique(snpstemp2$chr))
	common					<- list()
	howmany					<- vector()
	for (i in c(1:length(chroms)))
		{ 
		chro				<- chroms[i]
		temp1				<- snpstemp1$pos[snpstemp1$chr==chro]
		temp2				<- snpstemp2$pos[snpstemp2$chr==chro]	
		temp3				<- intersect(temp1,temp2)
		common[[i]]			<- temp3
		howmany[i]			<- length(temp3)
		}
	names(common)			<- chroms
	#sum(howmany)
	#
	### select the overlapping snps:
	mychroms				<- rep(chroms,howmany)
	mypos					<- unlist(common,use.names=FALSE)
	myoverlap				<- cbind(mychroms,mypos)
	myoverlap				<- as.data.frame(myoverlap)
	myoverlap				<<- myoverlap
	n_overlap				<- nrow(myoverlap)
	if(n_overlap>0)
		{
		cat(paste("Found",n_overlap,"SNPs shared between both datasets.",sep=" "),sep="\n")
		cat("Creating new dataset with shared SNPs...",sep="\n")
		}else{
		return(cat("The datasets don't have any loci in common. No new output files will be created.",sep="\n"))
		}
	### integrate boolean column (overlap yes or no) into input snp datasets:
	# into the first:
	snps					<- snpstemp1[,c("chr","pos")]
	snps$overlap			<- rep(NA,nrow(snps))
	for (i in c(1:nrow(myoverlap))) 
		{
		mychrom				<- as.vector(myoverlap$mychrom[i])
		mypos				<- as.numeric(as.vector(myoverlap$mypos[i]))
		snps$overlap[snps$chr==mychrom&snps$pos==mypos]<-TRUE	 
		}
	snps$overlap[is.na(snps$overlap)]<-FALSE
	snps$uniq				<- rep(NA,nrow(snps))
	for(j in c(1:nrow(snps)))
		{
		if(j==1)
			{
			snps$uniq[j]	<- TRUE
			}else{
			prevchrom		<- snps$chr[j-1]
			prevpos			<- snps$pos[j-1]
			currentchrom	<- snps$chr[j]
			currentpos		<- snps$pos[j]
			dupli			<- prevchrom==currentchrom&prevpos==currentpos
			snps$uniq[j]	<- ifelse(dupli,FALSE,TRUE)
			}
		}
	mygenlight				<- mydataset1.genlight[,mydataset1.snps$uniqpos]
	temp					<- as.matrix(mygenlight)
	overlap1				<- temp[,snps$overlap&snps$uniq]
	genlightpos1			<- colnames(overlap1) 
	snppos1					<- snpstemp1_name$name[snps$overlap&snps$uniq]
	# into the second:
	snps					<- snpstemp2[,c("chr","pos")]
	colnames(snps)			<- c("chr","pos")
	snps$overlap			<- rep(NA,nrow(snps))
	for (i in c(1:nrow(myoverlap))) 
		{
		mychrom				<- as.vector(myoverlap$mychrom[i])
		mypos				<- as.numeric(as.vector(myoverlap$mypos[i]))
		snps$overlap[snps$chr==mychrom&snps$pos==mypos] <-TRUE	 
		}
	snps$overlap[is.na(snps$overlap)] 	<-FALSE
	snps$uniq				<- rep(NA,nrow(snps))
	for(j in c(1:nrow(snps)))
		{
		if(j==1)
			{
			snps$uniq[j]	<- TRUE
			}else{
			prevchrom		<- snps$chr[j-1]
			prevpos			<- snps$pos[j-1]
			currentchrom	<- snps$chr[j]
			currentpos		<- snps$pos[j]
			dupli			<- prevchrom==currentchrom&prevpos==currentpos
			snps$uniq[j]	<- ifelse(dupli,FALSE,TRUE)
			}
		}
	mygenlight				<- mydataset2.genlight[,mydataset2.snps$uniqpos]
	temp					<- as.matrix(mygenlight)
	overlap2				<- temp[,snps$overlap&snps$uniq]
	genlightpos2			<- colnames(overlap2) 
	snppos2					<- snpstemp2_name$name[snps$overlap&snps$uniq]
	#
	# combine inds datasets:
	inds1					<- mydataset1.inds[,c("name","pop","popcol")]
	inds2					<- mydataset2.inds[,c("name","pop","popcol")]	
	indscombi				<- rbind(inds1,inds2)
	indscombi$nr			<- c(1:nrow(indscombi))
	indscombi$name2			<- NA
	poporder				<- as.character(unique(indscombi$pop))
	indscombi$poporder		<- factor(indscombi$pop,levels=poporder)
	#	
	if(grepl(".",as.vector(indscombi$name[1])))
		{
		for (i in c(1:nrow(indscombi)))
			{
			indscombi$name2[i]	<- strsplit(as.vector(indscombi$name[i]), "[.]")[[1]][1]
			}
		}else{
		indscombi$name2			<- substr(indscombi$name,start=1,stop=12)
		}
	for (i in c(1:nrow(indscombi))) 
		{
		indscombi$popcol[i]		<- mycolours[which(populationscombi==indscombi$pop[i])]
		}
	indscombi$pop2			<- indscombi$pop
	#
	# combine genlight objects:
	alloverlap				<- rbind(overlap1,overlap2)
	genlightcombi			<- as.genlight(alloverlap)
	# combine snp datasets:
	snpscombi				<- myoverlap
	colnames(snpscombi)		<- c("chr","pos")
	#
	# add additional columns to snps:
	snpscombi$name			<- paste(snpscombi$chr,snpscombi$pos,sep="_")
	mydataset1.snps$name2	<- paste(mydataset1.snps$chr,mydataset1.snps$pos,sep="_")
	mydataset2.snps$name2	<- paste(mydataset2.snps$chr,mydataset2.snps$pos,sep="_")
	snpstemp1				<- mydataset1.snps[mydataset1.snps$uniqpos,c("name2","minor","major")]
	snpstemp2				<- mydataset2.snps[mydataset2.snps$uniqpos,c("name2","minor","major")]
	colnames(snpstemp1)		<- c("name","minor_data1","major_data1")
	colnames(snpstemp2)		<- c("name","minor_data2","major_data2")
	merged1					<- merge(x = snpscombi, y = snpstemp1, by="name", all.x=TRUE)
	merged2					<- merge(x = merged1, y = snpstemp2, by="name", all.x=TRUE)
	snpscombi				<- merged2
	snpscombi$name			<- as.factor(snpscombi$name)
	snpscombi$uniqpos		<- TRUE			# safe to assume? needed to run filters function later.
	snpscombi$samepos		<- FALSE
	snpscombi$depthfilter	<- TRUE
	snpscombi$poly			<- TRUE
	snpscombi$placed		<- TRUE
	snpscombi$name_dataset1	<- snppos1
	snpscombi$name_dataset2	<- snppos2
	snpscombi$stackbp_dataset1	<- NA
	snpscombi$stackbp_dataset2	<- NA
	for(j in c(1:nrow(snpscombi)))
		{
		snpscombi$stackbp_dataset1[j]	<- strsplit(as.character(snpscombi$name_dataset1[j]),split='_', fixed=TRUE)[[1]][2]
		snpscombi$stackbp_dataset2[j]	<- strsplit(as.character(snpscombi$name_dataset2[j]),split='_', fixed=TRUE)[[1]][2]
		}
	snpscombi$samestackbp	<- snpscombi$stackbp_dataset1==snpscombi$stackbp_dataset2
	my_overlap				<<- data.frame("snpname1"=snppos1,"genlightname1"=genlightpos1,"snpname2"=snppos2,"genlightname2"=genlightpos2,"pos"=snpscombi$name)
	#
	# now we have to check for each locus whether the datasets had the same minor allele or whether it is reversed:
	snpscombi$minorequal	<- snpscombi$minor_data1==snpscombi$minor_data2
	snpscombi$majorequal	<- snpscombi$major_data1==snpscombi$major_data2
	snpscombi$inversed		<- (snpscombi$major_data1==snpscombi$minor_data2)&(snpscombi$minor_data1==snpscombi$major_data2)
	n_equal	 				<- nrow(snpscombi[snpscombi$minorequal&snpscombi$majorequal,])
	n_inverse				<- nrow(snpscombi[snpscombi$inversed,])
	cat(paste(n_equal," out of ",n_overlap," SNPs have corresponding minor and major alleles among the two input datasets.",sep=""),sep="\n")
	cat(paste(n_inverse," out of ",n_overlap," SNPs have inversed minor and major alleles.",sep=""),sep="\n")
	cat("Correcting for inversed minor allele frequencies...",sep="\n")
	# make a correction for inversed mafs in genlight object:
	# inversion is done for individuals of mypops2 (rather than for individuals of mypops1)
	# 03072019: to improve: inversion should be done based on which dataset is bigger. i.e. n_ind1 > nind2
	mypopmatrix 			<- as.matrix(genlightcombi[which(indscombi$pop %in% mylist2$populations),])
	otherpopsmatrix 		<- as.matrix(genlightcombi[which(indscombi$pop %in% mylist1$populations),])
	for (i in c(1:(ncol(mypopmatrix))))
		{
		if (snpscombi$inversed[i])
			{
			# edit data in genlight object:
			temp				<- mypopmatrix[,i]
			temp[temp==0]		<- 3
			temp[temp==2]		<- 0
			temp[temp==3]		<- 2
			mypopmatrix[,i]		<- temp
			}
		}
	if(!silent){cat("Recombining...",sep="\n")}
	combinedmatrix			<- rbind(mypopmatrix,otherpopsmatrix)
	genlightcombi			<- as.genlight(combinedmatrix)
	genlightcombi@pop		<- as.factor(indscombi$pop)
	snpscombi$minor			<- snpscombi$minor_data1
	snpscombi$major			<- snpscombi$major_data1
	snpscombi$minor2		<- NA
	snpscombi$major2		<- NA
	snpscombi$nr_neworder	<- c(1:nrow(snpscombi))	
	for(i in c(1:nrow(snpscombi)))
		{
		snpscombi$minor2[i]		<- c("A","C","G","T")[snpscombi$minor[i]]
		snpscombi$major2[i]		<- c("A","C","G","T")[snpscombi$major[i]]
		}
	#
	# reorder data based on individual names:
	if(!silent){cat("Reorder based on names of individuals...",sep="\n")}
	indscombi$name	<- as.character(indscombi$name)
	indscombi		<- indscombi[order(indscombi$name),]
	indscombi$nr	<- c(1:nrow(indscombi))
	# reorder genlight object based on individual names:
	matrixtemp		<- as.matrix(genlightcombi)
	tempnames		<- rownames(matrixtemp)	
	matrixtemp2		<- matrixtemp[order(tempnames),]
	genlightcombi	<- as.genlight(matrixtemp2)
	# 
	# change colnames of genlight matrix:
	if(!silent){cat("Edit snpnames in new genlight object...",sep="\n")}
	matrixtemp			<- as.matrix(genlightcombi)
	colnames(matrixtemp)<- snpscombi$name
	genlightcombi		<- as.genlight(matrixtemp)
	#
	# store objects in new Sambar list object:
	cat("Creating new sambar list and output directories...",sep="\n")
	cat("Overwriting existing mysambarcombined-list if already present.",sep="\n")
	mysambarcombined				<<- list()
	mysambarcombined$populations	<<- populationscombi
	mysambarcombined$inds			<<- indscombi
	mysambarcombined$snps			<<- snpscombi
	mysambarcombined$genlight		<<- genlightcombi 
	### create SambaR directories:
	cat("Creating output directories...",sep="\n")
	sambardir			<- paste(inputdatadir,"SambaR_output",sep="/")
	QCdir				<- paste(sambardir,"QC",sep="/")
	structuredir		<- paste(sambardir,"Structure",sep="/")
	divergencedir		<- paste(sambardir,"Divergence",sep="/")
	diversitydir		<- paste(sambardir,"Diversity",sep="/")
	demographydir		<- paste(sambardir,"Demography",sep="/")
	selectiondir		<- paste(sambardir,"Selection",sep="/")
	inputfilesdir		<- paste(sambardir,"Inputfiles",sep="/")
	geomapsdir			<- paste(structuredir,"Maps",sep="/")
	if(!file.exists(inputdatadir)){dir.create(file.path(inputdatadir))}
	if(!file.exists(sambardir)){dir.create(file.path(sambardir))}
	if(!file.exists(QCdir)){dir.create(file.path(QCdir))}
	if(!file.exists(structuredir)){dir.create(file.path(structuredir))}
	if(!file.exists(divergencedir)){dir.create(file.path(divergencedir))}
	if(!file.exists(diversitydir)){dir.create(file.path(diversitydir))}
	if(!file.exists(demographydir)){dir.create(file.path(demographydir))}
	if(!file.exists(selectiondir)){dir.create(file.path(selectiondir))}
	if(!file.exists(inputfilesdir)){dir.create(file.path(inputfilesdir))}
	if(!file.exists(geomapsdir)){dir.create(file.path(geomapsdir))}
	#
	###
	# create mysambar list object with sambar settings, paths and data objects:
	mysambarcombined[[5]]	<<- inputdatadir
	mysambarcombined[[6]]	<<- sambardir
	mysambarcombined[[7]]	<<- QCdir
	mysambarcombined[[8]]	<<- structuredir
	mysambarcombined[[9]]	<<- divergencedir
	mysambarcombined[[10]]	<<- diversitydir
	mysambarcombined[[11]]	<<- demographydir
	mysambarcombined[[12]]	<<- selectiondir
	mysambarcombined[[13]]	<<- inputfilesdir
	mysambarcombined[[14]]	<<- "sans"
	mysambarcombined[[17]]	<<- mycolours
	mysambarcombined[[18]]	<<- geomapsdir
	names(mysambarcombined)	<<- c("populations","inds","snps","genlight","inputdatadir","sambardir","QCdir","structuredir","divergencedir","diversitydir","demographydir","selectiondir","inputfilesdir","myfont","mystructure","mydnabin","mycolours","geomapsdir")
	mysambarcombined$populations2	<<- mysambarcombined$populations	# needed for excludepop()
	mysambarcombined$poporder		<<- mysambarcombined$populations2	# needed for excludepop()
	mysambarcombined$poporder2		<<- mysambarcombined$populations2	# needed for excludepop()
	mysambarcombined$mycolours2		<<- mysambarcombined$mycolours		# needed for excludepop()
	defaultcolours2					<- defaultcolours[!defaultcolours%in%mycolours]
	mysambarcombined$defaultcolours	<<- defaultcolours2
	mysambarcombined$os				<<- as.vector(Sys.info()["sysname"])	# operation system
	mysambarcombined$datasource		<<- "intersectdata"
	#
	cat("Datasets with shared loci have been written to a list object called 'mysambarcombined'.",sep="\n")
	cat("New (still empty) output folders have been created at:",sep="\n")
	cat(inputdatadir,sep="\n")
	#
	cat("Checking if the objects of the new dataset (inds,snps,genlight) correspond with each other...",sep="\n")
	if(nrow(indscombi)!=nrow(as.matrix(genlightcombi)))
		{
		ninds		<- nrow(indscombi)
		ngenlight	<- nrow(nrow(as.matrix(genlightcombi)))	
		cat("ERROR: number of rows of new inds dataframe does not correspond with number of rows of new genlight object. Contact developer of SambaR.",sep="\n")
		cat(paste("Number of individuals in new inds dataset: ",ninds,".",sep=""),sep="\n")
		cat(paste("Number of individuals in new genlight object: ",ngenlight,".",sep=""),sep="\n")
		}
	if(any(!row.names(as.matrix(genlightcombi))==as.vector(indscombi$name)))
		{
		cat("ERROR: rownames of genlight object do not correspond with inds$name column. Contact developer of SambaR.",sep="\n")
		return(cat("To compare both vectors, type 'rownames(as.matrix(mysambarcombined$genlight))' and 'mysambarcombined$inds$name'.",sep="\n"))
		}
	if(nrow(snpscombi)!=ncol(as.matrix(genlightcombi)))
		{
		nsnps		<- nrow(snpscombi)
		ngenlight	<- nrow(ncol(as.matrix(genlightcombi)))	
		cat("ERROR: number of rows of new snps dataframe does not correspond with number of columns of new genlight object. Contact developer of SambaR.",sep="\n")
		cat(paste("Number of snps in new snps dataset: ",ninds,".",sep=""),sep="\n")
		cat(paste("Number of snps in new genlight object: ",ngenlight,".",sep=""),sep="\n")
		}
	if(any(is.na(snpscombi$genlightname)))
		{
		cat("WARNING: NA-values in snps$genlightname column.",sep="\n")
		}
	if(any(!colnames(as.matrix(genlightcombi))==snpscombi$genlightname))
		{	
		cat("ERROR: column names of genlight object do not correspond with snps$genlightname column. Contact developer of SambaR.",sep="\n")
		return(cat("To compare both vectors, type 'colnames(as.matrix(mysambarcombined$genlight))' and 'mysambarcombined$snps$genlightname'.",sep="\n"))
		}
	cat("Everything seems fine :-)",sep="\n")
	#	
	if(combine_divstats)
		{
		cat("Combining genetic diversity scores...",sep="\n")
		# combine TajimaD scores:
		taj1	<- read.table(paste(mylist1$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),header=TRUE)
		taj2	<- read.table(paste(mylist2$diversitydir,"TajimaD.statistics.perpop.txt",sep="/"),header=TRUE)
		tajboth	<- rbind(taj1,taj2)
		tajboth <- tajboth[order(as.character(tajboth$pop)),]
		write.table(tajboth,paste(mysambarcombined$diversitydir,"TajimaD.statistics.perpop_nonsharedsnps.txt",sep="/"),row.names=FALSE,col.names=TRUE,quote=FALSE)
		# combine SFS scores:	
		if(length(mylist1$populations)>1)
			{
			sfs1	<- read.table(paste(mylist1$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=TRUE)
			}else{
			sfs1	<- read.table(paste(mylist1$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=FALSE)
			sfs1	<- as.data.frame(t(sfs1))[2,]
			colnames(sfs1)	<- c("X0.05","X0.15","X0.25","X0.35","X0.45")
			rownames(sfs1)	<- mylist1$populations
			}
		if(length(mylist2$populations)>1)
			{
			sfs2			<- read.table(paste(mylist2$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=TRUE)
			}else{
			sfs2			<- read.table(paste(mylist2$diversitydir,"SFS.binned.percentages.txt",sep="/"),header=FALSE)
			sfs2			<- as.data.frame(t(sfs2))[2,]
			colnames(sfs2)	<- c("X0.05","X0.15","X0.25","X0.35","X0.45")
			rownames(sfs2)	<- mylist2$populations
			}
		sfsboth	<- rbind(sfs1,sfs2)
		my_pops	<- as.vector(c(mylist1$populations,mylist2$populations))
		sfsboth <- sfsboth[order(my_pops),]
		write.table(sfsboth,paste(mysambarcombined$diversitydir,"SFS.binned.percentages_nonsharedsnps.txt",sep="/"),row.names=FALSE,col.names=TRUE,quote=FALSE)
		}
	#
	# Print info on screen:
	cat("To start working with the data, type getdata('mysambarcombined') and run the filterdata() function.",sep="\n")
	cat("To see the names of the overlapping snps, type: 'my_overlap'.",sep="\n")
	}

# Add output/results from other programs to inds or snps dataframe:
# The getfrom-input should be a matrix/dataframe with one line per snp/sample.
# This function needs updating, by including 'filterdata()' function in the end 

merger<-function(addtoinds=TRUE,getfrom,idto,idfrom,newdata,removecheck=FALSE)
	{
	if(addtoinds==TRUE)
		{
		getfrom$idcheck	<- getfrom[,idfrom]
		names(getfrom)[names(getfrom) == idfrom] <- idto
		inds 		<<- merge(x = inds, y = getfrom[,c(idto,"idcheck",newdata)], by = idto, all = TRUE)
		if(removecheck)
			{
			inds$idcheck<-NULL
			}
		}else{
		getfrom$idcheck	<- getfrom[,idfrom]
		names(getfrom)[names(getfrom) == idfrom] <- idto
		snps 		<<- merge(x = snps, y = getfrom[,c(idto,newdata)], by = idto, all = TRUE)
		if(removecheck)
			{
			inds$idcheck<-NULL
			}
		}
	}

# Possibly include check:
# check	<-!is.na(inds[,idto]==inds$idcheck)
# if(any(check==FALSE))
#	{
#	print("Something seems to have gone wrong. Compare 'idcheck'-column to original identifier column.")
#	}
 



################### MANAGE PLOTS ###################


# Change population assignment:
changepop<-function(samplevec=NULL,popvec=NULL,silent=TRUE,editpop2=TRUE)
	{
	if(is.null(samplevec))
		{
		return(cat("ERROR: provide a vector with (one or more) sample names to the samplevec flag.",sep="\n"))
		}
	if(is.null(popvec))
		{
		return(cat("ERROR: provide a vector with (one or more) colour names to the popvec flag.",sep="\n"))
		}
	if(length(samplevec)!=length(popvec))
		{
		return(cat("ERROR: lengths of samplevec and colvec do not correspond.",sep="\n"))
		}
	if(any(!samplevec%in%inds$name))
		{
		return(cat("ERROR: one or more specified samples not present in inds$name column.",sep="\n"))
		}
	if(any(!popvec%in%mysambar$populations2))
		{
		return(cat("ERROR: one or more specified populations not present in Sambar objects.",sep="\n"))
		}
	npops	<- length(popvec)
	nsamples<- length(samplevec)
	if(npops!=nsamples)
		{
		return(cat("ERROR: length of samplevec and popvec do not correspond.",sep="\n"))
		}
	for(indnr in c(1:nsamples))
		{
		mypop		<- as.character(popvec[indnr])
		mysample	<- as.character(samplevec[indnr])
		cat(paste("Assigning individual '",mysample,"' to population '",mypop,"'.",sep=""),sep="\n")
		mypopcol	<- mysambar$colorder2[mysambar$poporder2==mypop]
		#
		if(!silent){cat("inds...",sep="\n")}
		inds$pop[inds$name==mysample]		<<- mypop
		if(editpop2)
			{
			inds$pop2[inds$name==mysample]		<<- mypop
			}
		inds$poporder[inds$name==mysample] 	<<- as.factor(mypop)
		inds$popcol[inds$name==mysample]	<<- mypopcol
		inds$popcol2[inds$name==mysample]	<<- mypopcol
		#
		if(!silent){cat("inds2...",sep="\n")}
		inds2$pop1[inds2$name1==mysample]	<<- mypop
		if(editpop2)
			{
			inds2$pop2[inds2$name2==mysample]	<<- mypop
			}
		inds2$popcol1[inds2$name1==mysample]<<- mypopcol 
		inds2$popcol2[inds2$name2==mysample]<<- mypopcol
		}
	cat("Sample information has been updated.",sep="\n")
	}

# Change colour sets:
changepopcol<-function(popvec=NULL,colvec=NULL)
	{
	if(is.null(colvec))
		{
		return(cat("ERROR: provide a vector with (one or more) colour names to the colvec flag.",sep="\n"))
		}
	if(is.null(popvec))
		{
		return(cat("ERROR: provide a vector with (one or more) colour names to the popvec flag.",sep="\n"))
		}
	if(any(!popvec%in%mysambar$populations2))
		{
		return(cat("ERROR: one or more specified populations not present in Sambar objects.",sep="\n"))
		}
	npops	<- length(popvec)
	if(npops!=length(colvec))
		{
		return(cat("ERROR: length of popvec and colvec do not correspond.",sep="\n"))
		}
	for(popnr in c(1:npops))
		{
		mypop	<- as.character(popvec[popnr])
		mycol	<- colvec[popnr]
		cat(paste("Assigning colour '",mycol,"' to population '",mypop,"'.",sep=""),sep="\n")
		inds$popcol[inds$pop==mypop]						<<- mycol
		inds2$popcol1[inds2$pop1==mypop]					<<- mycol 
		inds2$popcol2[inds2$pop2==mypop]					<<- mycol
		pops2$popcol1[pops2$pop1==mypop]					<<- mycol 
		pops2$popcol2[pops2$pop2==mypop]					<<- mycol
		mysambar$mycolours2[mysambar$populations2==mypop]	<<- mycol
		mysambar$mycolours[mysambar$populations==mypop]		<<- mycol
		mysambar$colorder2[mysambar$poporder2==mypop]		<<- mycol
		mysambar$colorder[mysambar$poporder==mypop]			<<- mycol
		}
	cat("Colour coding has been updated.",sep="\n")
	}

# 15-08-2022: depreciated, replaced by changepopcol.
# length of colvector should correspond to length of populations vector
editcol<-function(colvector=NULL)
	{
	return(cat("The function 'editcol' has been depreciated. Use instead the function 'changepopcol(colvec=NULL,popvec=NULL)'.",sep="\n"))
	if(is.null(colvector))
		{
		return(cat("ERROR: specify vector with colours to colvector flag.",sep="\n"))
		}
	if(length(colvector)!=length(mysambar$populations))
		{
		return(cat("ERROR: length of colvector does not correspond to length of mysambar$populations.",sep="\n"))
		}
	excludepop()
	cat("Updating mysambar object...",sep="\n")
	mysambar$mycolours	<<- colvector
	mysambar$mycolours2	<<- colvector
	# 
	for(k in c(1:length(mysambar$poporder)))
		{
		mypop					<- mysambar$poporder[k]
		mysambar$colorder[k]	<<- mysambar$mycolours[mysambar$populations==mypop]  
		mysambar$colorder2[k]	<<- mysambar$mycolours[mysambar$populations==mypop] 
		}
	#
	cat("Updating inds object...",sep="\n")
	for (i in (1:nrow(inds)))
		{
		mypop			<- inds$pop[i]
		inds$popcol[i]	<<- mysambar$mycolours2[mysambar$populations2==mypop]
		}
	cat("Colour coding has been updated.",sep="\n")
	}

getfonts<-function(importfonts=FALSE)
	{
	if("extrafont" %in% rownames(installed.packages()) == FALSE) {install.packages("extrafont",repos=myrepos)}					# needed for 'Arial' font type in plots 
	library(extrafont)
	if(importfonts)
		{
		font_import(prompt=FALSE)
		}
	loadfonts(quiet = TRUE)											# load for PDF
	loadfonts(device = "postscript",quiet = TRUE)					# load for eps
	}







######################### RELATEDNESS ###########################

# Needs input file generated by plink -genome (with estimates of pi_hat)
relatedness<-function(infile="plink.genome",popnames=populations)
	{	
	# Read table and add a column to indicate whether individuals are from same population:
	ibd				<- read.table(infile,header=TRUE)
	ibd$samepop		<- ibd$FID1==ibd$FID2
	# Pairwise population comparisons:
	combitable		<- combn(popnames,m=2)
	# Make vector for names of between population comparisons (one way):
	combivector1		<- paste(combitable[1,],combitable[2,],sep="_")	
	# Make vector for names of between population comparisons (the other way):
	combivector2		<- paste(combitable[2,],combitable[1,],sep="_")	
	# Make vector for names of within population comparisons:
	combivector3		<- vector()
	samepopmean			<<- vector()
	diffpopmean1		<<- vector()
	diffpopmean2		<<- vector()
	for (i in (1:length(popnames)))
		{
		combivector3[i]	<- paste(popnames[i],popnames[i],sep="_")
		}
	##### Create an empty list to save results:
	results 		<<- list()
	##### How many relatives does a individual have within it's own population?
	for (i in (1:length(combivector3)))
		{
		# select all rows with pi above 0.1825 and column for samepop is TRUE:
		ibdwithin			<- ibd[ibd$PI_HAT>0.1825&ibd$samepop&ibd$FID1==popnames[i],]
		ibdwithinall		<- ibd[ibd$samepop&ibd$FID1==popnames[i],]
		samepopmean[i]		<<- mean(ibdwithinall$PI_HAT,na.rm=TRUE)
		# select columns with individual names, and sort on alphabetical and numerical order:
		relativeswithin		<- sort(c(ibdwithin$IID1,ibdwithin$IID2))
		# assign(paste("ibdwithin",popnames[i],sep="_"),relativeswithin)
		# If sample occurs more than once, it is listed more than once. To collapse, make a table (which we save):
		results[[i]]		<<- table(relativeswithin)
		}
	##### How many relatives does a sample has within any other populations?
	ibdbetween		<- ibd[ibd$PI_HAT>0.1825&ibd$samepop=="FALSE",]
	ibdbetweenall	<- ibd[ibd$samepop=="FALSE",] 
	# For one direction of pairwise comparisons (how many relatives do individuals in pop A have with pop B?)
	for (i in (1:length(combivector1)))
		{
		diffpopmean1[i]		<<- mean(ibdbetweenall$PI_HAT[ibdbetweenall$FID1==combitable[1,i]&ibdbetweenall$FID2==combitable[2,i]],na.rm=TRUE)
		relativesbetween<-c(ibdbetween$IID1[ibdbetween$FID1==combitable[1,i]&ibdbetween$FID2==combitable[2,i]],ibdbetween$IID2[ibdbetween$FID2==combitable[1,i]&ibdbetween$FID1==combitable[2,i]])
		results[[i+length(combivector3)]]	<<- table(relativesbetween)
		}
	# For the other direction of pairwise comparison (how many relatives do individuals in pop B have with pop A?)
	for (i in (1:length(combivector2)))	
		{
		diffpopmean2[i]		<<- mean(ibdbetweenall$PI_HAT[ibdbetweenall$FID1==combitable[2,i]&ibdbetweenall$FID2==combitable[1,i]],na.rm=TRUE)
		relativesbetween<-c(ibdbetween$IID1[ibdbetween$FID1==combitable[2,i]&ibdbetween$FID2==combitable[1,i]],ibdbetween$IID2[ibdbetween$FID2==combitable[2,i]&ibdbetween$FID1==combitable[1,i]])
		results[[i+length(combivector3)+length(combivector1)]]	<<- table(relativesbetween)
		}
	##### Give names to list elements:
	# This has to be after the last loop, otherwise names are overwritten.
	combivector	<- c(combivector3,combivector1,combivector2)
	list.names	<- as.list(combivector)
	names(results)	<<- list.names
	# The results output table shows for each individual (indicated by nr) how many relatives they have in the other population.   
	}


############################# PLOTS ###############################


# Boxplot sample inbreeding coefficients per population:  
F_boxplot<-function(export=FALSE,exportname="filtereddata",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	if(!(any(names(inds)=="F")))
		{
		print("This function can only be executed if the 'inds'-dataframe contains a column (called 'F') with inbreeding coefficients. This estimates can be generated with PLINK.")
		}
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"F.wmf",sep = "."))}
	graphics.off()
	boxplot(inds$F~inds$pop,na.rm=TRUE,col=unique(colourcode),ylab="Inbreeding coefficient F",xlab="Populations",frame=F)
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"F.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}


##### Functions to plot individual heterozygosities:

##### Boxplot:
He_boxplot<-function(export=FALSE,exportname="filtereddata",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	if(!(any(names(inds)=="hetero")))
		{
		print("This function can only be executed if the 'inds'-dataframe contains a column (called 'hetero') with sample heterozygosities. This estimates can be generated with the 'heterozygosities'-function.")
		}
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"Heboxplot.wmf",sep = "."))}
	graphics.off()
	boxplot(inds$hetero[inds$filter]~inds$pop[inds$filter],notch=FALSE,col=unique(colourcode),main=NULL, xlab="Populations",ylab="Sample heterozygosity") 
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"Heboxplot.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}


# Ugly plot:
##### Histogram (with optionally distinction between X-chromosome and autosomal chromosomes):
He_histo<-function(export=FALSE,exportname="mygenlight",popnames=populations,colourcode=inds$popcol,yrange=c(0,8))
	{
	# Export file?
	if(export==TRUE){win.metafile(paste(exportname,"indhe.wmf",sep = "."))}
	# Some prep:
	mymax	<- max(inds$hetero)
	if(max(inds$hetero)>0.5)
		{
		breakpoints<-seq(0,mymax+0.05,0.01)
		}else{
		breakpoints<-seq(0,0.5,0.01)
		}
	graphics.off()
	par(mfrow=c(1,length(popnames)),mai=c(0.75,0.75,0.125,0.25),oma=c(1,0,1,0))
	for (i in (1:length(popnames)))
		{
		hist(inds$hetero[inds$pop==popnames[i]&inds$filter],breaks=breakpoints,col=colourcode[inds$pop==popnames[i]&inds$filter],lty=0,xlim=c(0,mymax),ylim=yrange,xlab=NULL,ylab="# individuals",main=popnames[i])
		if(length(snps$chr[snps$chr=="X"])>0)
			{
			hist(inds$heteroX[inds$pop==popnames[i]&inds$filter],breaks=breakpoints,add=T,col=NULL,main=NULL,ylim=yrange,xlab=NULL,ylab=NULL)
			mtext("Individual heterozygosities for autosomal (filled bar) and X-chromosome (open bar)", side = 1, outer = TRUE,line=-1.5)
			}else{
			mtext("Individual heterozygosities", side = 1, outer = TRUE,line=-1.5)
			}
		}
	if(export==TRUE)
		{
		dev.off()
		path1<- paste(getwd(),exportname,sep="/")
		path2<- paste(path1,"indhe.wmf",sep = ".")
		print(paste("Plot has been written to", path2, sep=" "))
		}
	}

################################################################











############################### START OF SIMULATION SECTION ###############################

# Use R package 'MetaPopGen':
# Vector of number of alleles and mutation rate per locus:
runmpg<-function(do_install=FALSE,asexual=TRUE,u=1.2*10^-8,nloci=2,do_analyses=FALSE,r_rate=0.5,tmax=10,runcommands=FALSE)
	{
	# limitation: at maximum 26 loci. In reality even less, due to memory allocation error.
	if(do_install)
		{
		devtools::install_github('MarcoAndrello/MetaPopGen-2.0')
		}
	#
	# DEFINE SETTINGS:
	if(runcommands)
		{
		nloci=2;r_rate=0.5;tmax=10;u=1.2*10^-8;asexual=TRUE
		}
	ndemes		<- 3						# number of demes
	k			<- 100						# carrying capacity per deme
	n_age		<- 1						# number of age classes
	u_gen		<- u*k
	mu_vec		<- rep(u_gen,nloci)			# The mutation rate for each locus (mu)
	r_rate		<- ifelse(nloci>2,0.5,r_rate)					# The recombination rate r (has to be 0.5 in case of more than 2 loci, so assuming independence)
	mysex		<- ifelse(asexual,"monoecious","dioecious")
	nalleles	<- 2
	allele_vec	<- rep(nalleles,nloci)
	init.par 	<- initialize.multilocus(allele_vec=allele_vec,mu=mu_vec,r=r_rate,n=ndemes,z=n_age,kappa0=k,sexuality=mysex)
	#
	# edit starting frequencies:
	ngeno				<- nrow(init.par$N)
	init.par$N1[,,] 	<- 0
	init.par$N1[1,1,1] 	<- k		# deme1 (column 1)
	init.par$N1[1,2,1] 	<- k		# deme2 (column 2)
	init.par$N1[ngeno,3,1] 	<- k	# deme3 (column 3)
	#
	# survival probabilities:
	sigma 				<- array(0.75,c(init.par$m,init.par$n,init.par$z,tmax))
	name.dim 			<- dimnames(init.par$N1)
	name.dim$time 		<- c(1:tmax)
	dimnames(sigma) 	<- name.dim
	sigma				<<- sigma
	#
	# fecundities (number of gametes): 
	# Under the “fixed” option, each individual of genotype i of age x in deme j at time t produces exactly phi_F[i,j,x,t] and phi_M[i,j,x,t] gametes.
	# phi_M[i,j,x,t]: number of gametes of genotype i in deme j of age x at time t.
	phi_F 				<- array(30,c(init.par$m,init.par$n,init.par$z,tmax))
	phi_M 				<- array(100,c(init.par$m,init.par$n,init.par$z,tmax))
	dimnames(phi_F) 	<- dimnames(phi_M) <- name.dim
	#
	# migration rates:
	# in case of no migration:
	delta.ad 			<- diag(init.par$n)
	dimnames(delta.ad) 	<- list(destination=c(1:3),origin=c(1:3))
	#
	# propagule dispersal rates:
	#delta.prop 		<- matrix(c(0.9,0.4,0,0.1,0.5,0.1,0,0.1,0.9),nrow=3,ncol=3,byrow=T)
	delta.prop 			<- diag(init.par$n)
	dimnames(delta.prop)<- list(destination=c(1:3),origin=c(1:3))
	#
	# RUN SIMULATIONS:
	if(asexual)
		{
		res 			<- sim.metapopgen.monoecious.multilocus(init.par=init.par,sigma=sigma,phi_F=phi_F,phi_M=phi_M,delta.prop=delta.prop,delta.ad=delta.ad,T_max=tmax,output.var="N")
		}else{
		res 			<- sim.metapopgen.dioecious.multilocus(init.par=init.par,sigma=sigma,phi_F=phi_F,phi_M=phi_M,delta.prop=delta.prop,delta.ad=delta.ad,T_max=tmax,output.var="N")
		}
	res		<<- res
	cat("Output is stored in 'res'.",sep="\n")
	#
	# extract minor allele frequencies at last time point:
	# output structure: res$N[i,j,x,t]
	# i = genotype
	# j = deme
	# x = age_class
	# t = time_step
	#
	p			<<- matrix(NA,nrow=nloci,ncol=ndemes)
	colnames(p)	<<- paste("deme",c(1:ndemes),sep="")
	rownames(p)	<<- paste("locus",c(1:nloci),sep="")
	for (j in c(1:ndemes))
		{
		myfreqs	<- freq_alleles(res$N[,j,1,tmax],init.par)$frequencies
		p[,j]	<<- as.vector(do.call(rbind,myfreqs)[,1])
		}
	cat("Minor allele frequencies are stored in 'p'.",sep="\n")
	#
	# ANALYZE RESULTS:
	if(do_analyses)
		{
		# allele frequencies:
		# Expects a vector of allele frequencies. For example allele frequencies in deme 2, age 1 at time 5:
		freq_alleles(res$N[,2,1,5],init.par)
		#
		# genotype frequencies:
		freq_genotypes(res$N[,2,1,5],init.par)
		#
		# population differentiation:
		fst_multilocus(res$N[,,1,5],init.par)
		# 
		# See also other functions to calculate gamete frequencies (freq_gametes), observed and expected heterozygosities (het.obs and het.exp), and linkage disequilibrium (ld).
		}
	}

getsimpackages<-function ()
	{
	library(grid)
	library(gridGraphics)
	library(gridExtra)
	library(adegenet)
	library(OutFLANK) 
	library(pcadapt)
	library(gplots)
	}

fp<-function(nfp=5,nloci=1000,sigma=0.05,cum=FALSE,bonf=FALSE)
	{
	# n_fp is number of false positives
	n		<- seq(0,nloci,nloci/100)
	sigma	<- ifelse(bonf,sigma/nloci,sigma)
	if(!cum)
		{
		k			<- nfp
		pr			<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
		mytitle		<- paste("Probability of exactly",nfp,"false positives",sep=" ")
		plot(n,pr,type='l',ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		}else{
		mytitle		<- paste("Probability of maximum",nfp,"false positives",sep=" ")
		plot(n,n,ylim=c(0,1),type='l',col="white",ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		pr			<- rep(0,length(n))
		for(k in c(1:nfp))
			{
			pr_k	<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
			pr		<- pr+pr_k
			lines(n,pr_k,col="grey",lwd=2)
			}
		lines(n,pr,lwd=2)
		}
	}

fpratio<-function(fpratio=0.01,nloci=1000,sigma=0.05,cum=FALSE,bonf=FALSE,addnfp=TRUE)
	{
	# n_fp is number of false positives
	if(nloci>10000)
		{
		n	<- seq(0,nloci,nloci/100)
		}else{
		n	<- c(1:nloci)
		}
	sigma	<- ifelse(bonf,sigma/nloci,sigma)
	nfppern	<- round(fpratio*n)
	nfp		<- as.vector(unique(nfppern))
	nfp		<- nfp[2:length(nfp)]	# no zero's
	if(!cum)
		{
		k			<- nfp
		pr			<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
		mytitle		<- paste("Probability of proportion of",fpratio,"false positives",sep=" ")
		plot(n,pr,type='l',ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		if(addnfp)
			{
			par(new=TRUE)
			plot(n,nfppern,xaxt='n',yaxt='n',col="darkgrey",type='l',lty=2)
			axis(side=4)
			}
		}else{
		mytitle		<- paste("Probability of maximum proportion of",fpratio,"false positives",sep=" ")
		plot(n,n,ylim=c(0,1),type='l',col="white",ylab="Probability",xlab="Number of loci",main=mytitle,las=1)
		pr			<- rep(0,length(n))
		for(k in nfp)
			{
			pr_k	<- choose(n,k)*(1-sigma)^(n-k)*(sigma)^k
			pr		<- pr+pr_k
			lines(n,pr_k,col="grey",lwd=2)
			}
		lines(n,pr,lwd=2)
		if(addnfp)
			{
			par(new=TRUE)
			plot(n,nfppern,xaxt='n',yaxt='n',col="darkgrey",type='l',lty=2)
			axis(side=4)
			}
		}
	}
	


###### User-defined function:


getsimdata<-function(n_loci=50000,n_selectedloci=1000,which_comparison=3,get_power=TRUE)
	{
	n_gen					<- 20
	selcoefvector			<- seq(0,0.2,0.025)  
	nevector				<- seq(20,200,20)
	allcombi				<- as.data.frame(expand.grid(selcoefvector,nevector, stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("s","ne")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	mean_source_maf			<- 0.15
	parallelsel				<- TRUE	
	#
	current_dir				<- getwd()
	simdata_resultslist		<<- list() 
	simdata_results			<<- matrix(NA,nrow=nruns,ncol=10)
	#
	# get files:
	for(myrun in c(1:nruns))
		{
		sel_coef				<- allcombi$s[myrun]
		ne_F					<- allcombi$ne[myrun]
		n_gen					<- 
		cat(paste(sel_coef,ne_F,sep="_"),sep="\n")
		out_dir					<- paste("Simulated",n_sourcepop,ne_F,n_gen,ne_F,n_sample,n_loci,n_selectedloci,sel_coef,"in_both",sep=".")
		my_dir					<- paste(current_dir,out_dir,sep="/")
		setwd(my_dir)
		my_file					<- paste("Simulated",n_sourcepop,ne_F,n_gen,ne_F,n_sample,n_loci,n_selectedloci,sel_coef,"bothpop.testscores2.txt",sep=".")
		simdata_table			<<- read.table(my_file,header=TRUE,row.names = 1) 
		simdata_results[myrun,]	<<- c(unlist(simdata_table[which_comparison,]),sel_coef,ne_F) 
		simdata_resultslist[[myrun]]<<- simdata_table
		setwd(current_dir)
		}
	# get power:
	if(get_power)
		{
		colnames(simdata_results)	<<- c(colnames(simdata_table),"s","ne_F")
		testlist					<<- list()
		testlist[[1]]				<<- xtabs(gwds_power ~ s + ne_F, simdata_results)
		testlist[[2]]				<<- xtabs(OutFLANK_power ~ s + ne_F, simdata_results)
		testlist[[3]]				<<- xtabs(PCadapt_power ~ s + ne_F, simdata_results)
		testlist[[4]]				<<- xtabs(gwds_specificity  ~ s + ne_F, simdata_results)
		testlist[[5]]				<<- xtabs(OutFLANK_specificity  ~ s + ne_F, simdata_results)
		testlist[[6]]				<<- xtabs(PCadapt_specificity  ~ s + ne_F, simdata_results)
		}
	# get retained selected loci:
	retainedlist					<<- list()
	retainedlist[[1]]				<<- xtabs(loss_adaptive ~ s + ne_F, simdata_results)
	retainedlist[[2]]				<<- xtabs(loss_neutral ~ s + ne_F, simdata_results)
	setwd(current_dir)
	}

venn_sim<-function(export=FALSE)
	{
	setwd("C:/Users/Tatiana/Menno/ReindeerCombined/ReinasRef/Multiplesnpsperread/Stacksrefmap/Simulation_output/80000loci/Simulated.1000.10.20.50.30.80000.1000.0.1.in_both")
	gwdsout		<- as.vector(read.table("GWDS_pheno_outliers.txt")$V1)
	pcadaptout	<- as.vector(read.table("PCadapt_pheno_outliers.txt")$V1)
	#outflankout<- as.vector(read.table("OutFLANK_pheno_outliers.txt")$V1)	# no lines to read
	outflankout	<- vector()
	bayescanout	<- as.vector(read.table("Bayescan_pheno_outliers.txt")$V1)
	selectedloci<- paste(c(79001:80000),"L",sep="")
	#
	# plot:
	if(export){pdf("venn.simulated.pdf",height=6,width=8)}
	v1 <- venn.diagram(list(selected_loci=selectedloci,Bayescan=bayescanout,GWDS=gwdsout,PCadapt=pcadaptout,OutFLANK=outflankout),filename=NULL,alpha=0.6,cex=2,cat.cex=2,fill=c("grey70","darkred","blue","darkgreen","orange"),col=c("grey70","darkred","blue","darkgreen","orange"),margin=0.15)
	grid.newpage()
	grid.draw(v1)
	if(export){dev.off()}
	}
	
runsim_power<-function(n_gen=50,n_loci=1000,mycorr="none",n_selectedloci=100,selcoefvector=c(0.05,0.1),nevector=c(50,100),founders_nr=NULL,do_export=TRUE,dohaploid=TRUE,my_comparison=1,n_sample=30,n_sourcepop=1000,mean_source_maf=0.15,parallelsel=TRUE,show_adjusted_p=FALSE,sdiscrete=TRUE) 
	{
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	cat("###### SETTINGS WHILST RUNNING RUNSIM_POWER ######",sep="\n")
	cat(paste("  Specified number of loci: ",n_loci,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",n_selectedloci,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficients: ",paste(selcoefvector,collapse=", "),".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",n_gen,".",sep=""),sep="\n")
	cat(paste("  Specified Ne source population: ",n_sourcepop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder populations: ",paste(nevector,collapse=", "),".",sep=""),sep="\n")
	cat(paste("  When calculating FN, FP and FDR for the pooled comparison, only consider SNPs which have been retained in both populations: ",parallelsel,".",sep=""),sep="\n")
	if(is.null(founders_nr))
		{
		cat("  No bottleneck specified (flag 'founders_nr' is set to NULL).",sep="\n")
		}else{
		cat(paste("  Specified number of founders: ",founders,".",sep=""),sep="\n")
		}
	cat(paste("  Specified samplesize: ",n_sample,".",sep=""),sep="\n")
	cat(paste("  Parallel selection: ",parallelsel,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",sdiscrete,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",dohaploid,".",sep=""),sep="\n")
	#
	allcombi			<- as.data.frame(expand.grid(selcoefvector,nevector,stringsAsFactors = FALSE))
	allcombi			<- as.data.frame(expand.grid(selcoefvector,nevector,stringsAsFactors = FALSE))
	multiplescenarios	<- ifelse(nrow(allcombi)>1,TRUE,FALSE)
	colnames(allcombi)	<- c("s","ne")
    nruns				<- nrow(allcombi)
    #
    # call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("loss_adaptive","loss_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2","gwds_FDR","OutFLANK_FDR","PCadapt_FDR")
	testresults				<- as.data.frame(matrix(NA,ncol=30,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	overlapresults			<- as.data.frame(matrix(NA,ncol=3,nrow=nruns))
	colnames(overlapresults)<- c("gwds","pcadapt","outflank")
	for(myrun in c(1:nruns))
		{
		sel_coef				<- allcombi$s[myrun]
		ne_F					<- allcombi$ne[myrun]
		if(is.null(founders_nr))
			{
			founders_nr			<- ne_F
			}
		cat(" ",sep="\n")
		cat(paste(sel_coef,ne_F,mycorr,sep="_"),sep="\n")
		mysettings				<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=do_export,mycorrection=mycorr,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,nefounderpop1=ne_F,nefounderpop2=ne_F,meansourcemaf=mean_source_maf,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_haploid=dohaploid,show_adjustedp=show_adjusted_p,s_discrete=sdiscrete)
		myscores				<- mysambarsim$mytestscores2[my_comparison,]
		fdrrates				<- mysambarsim$testFDR[my_comparison,]
		testresults[myrun,]		<- c(myscores,fdrrates,mysettings)
		overlapresults[myrun,]	<- round(apply(mysambarsim$overlapdf,1,mean),2)
		}
	# return table:
	# testresults		<<- testresults
	write.table(testresults,"Power_analysis.txt",quote=FALSE)
	# heatmap:
	if(multiplescenarios)
		{
		gwdspower		<- xtabs(gwds_power ~ s + ne_F, testresults)
		gwdsspec		<- xtabs(gwds_specificity  ~ s + ne_F, testresults)
		pcadaptpower	<- xtabs(PCadapt_power ~ s + ne_F, testresults)
		pcadaptspec		<- xtabs(PCadapt_specificity  ~ s + ne_F, testresults)
		outflankpower	<- xtabs(OutFLANK_power ~ s + ne_F, testresults)
		outflankspec	<- xtabs(OutFLANK_specificity  ~ s + ne_F, testresults)
		gwdsfdr			<- xtabs(gwds_FDR ~ s + ne_F, testresults)
		pcadaptfdr		<- xtabs(PCadapt_FDR ~ s + ne_F, testresults)
		outflankfdr		<- xtabs(OutFLANK_FDR ~ s + ne_F, testresults)
		graphics.off()
		#
		if(all(dim(gwdspower)>1))
			{
			cat("Generating heatmaps showing power and specificity scores...",sep="\n")
			if(do_export){pdf("Matrix_GWDS_power.pdf")}
			make_heatmap(mymatrix=round(gwdspower,2),myBreaks=seq(0,1,0.025),mytitle="power GWDS")
			if(do_export){dev.off()}	
			if(do_export){pdf("Matrix_GWDS_specificity.pdf")}
			make_heatmap(mymatrix=round(gwdsspec,5),myBreaks=seq(0.999,1,0.00005),mytitle="specificity GWDS",note_cex=1,mycol2="darkgreen")
			if(do_export){dev.off()}
			#
			if(do_export){pdf("Matrix_PCadapt_power.pdf")}
			make_heatmap(mymatrix=round(pcadaptpower,2),myBreaks=seq(0,1,0.025),mytitle="power PCadapt")
			if(do_export){dev.off()}	
			if(do_export){pdf("Matrix_PCadapt_specificity.pdf")}
			make_heatmap(mymatrix=round(pcadaptspec,5),myBreaks=seq(0.999,1,0.00005),mytitle="specificity PCadapt",note_cex=1,mycol2="darkgreen")
			if(do_export){dev.off()}
			#
			if(do_export){pdf("Matrix_OutFLANK_power.pdf")}
			make_heatmap(mymatrix=round(outflankpower,2),myBreaks=seq(0,1,0.025),mytitle="power OutFLANK")
			if(do_export){dev.off()}	
			if(do_export){pdf("Matrix_OutFLANK_specificity.pdf")}
			make_heatmap(mymatrix=round(outflankspec,5),myBreaks=seq(0.999,1,0.00005),mytitle="specificity OutFLANK",note_cex=1,mycol2="darkgreen")
			if(do_export){dev.off()}
			}else{
			cat("Skipping heatmaps because only one value specified for either Ne or s.",sep="\n")
			}
		#
		testlist		<- list()
		testlist[[1]]	<- gwdspower 
		testlist[[2]]	<- outflankpower
		testlist[[3]]	<- pcadaptpower
		testlist[[4]]	<- gwdsspec
		testlist[[5]]	<- outflankspec	
		testlist[[6]]	<- pcadaptspec
		fdrlist			<- list()
		fdrlist[[1]]	<- gwdsfdr
		fdrlist[[2]]	<- outflankfdr
		fdrlist[[3]]	<- pcadaptfdr
		names(testlist)	<- c("gwdspower","outflankpower","pcadaptpower","gwdsspec","outflankspec","pcadaptspec")
		names(fdrlist)	<- c("gwdsfdr","outflankfdr","pcadaptfdr")
		dput(testlist,"powertable.txt")
		mysambarsim$testlist	<<- testlist
		mysambarsim$fdrlist		<<- fdrlist
		mysambarsim$powertable	<<- c(testlist,fdrlist)
		}
	print(Sys.time())
	}

runfix_multi<-function()
	{
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0)
	fix0.0	<<- mysambarsim$testlist
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0.01)
	fix0.01	<<- mysambarsim$testlist
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0.05)
	fix0.05	<<- mysambarsim$testlist
	runsim_fixation(n_loci=5100,n_selectedloci=5000,sel_coef=0.1)
	fix0.1	<<- mysambarsim$testlist
	}

# depends on functions plot_retained_variation and make_heatmap
runsim_retained<-function(n_loci=1100,n_selectedloci=1000,sel_coef=0.1,sourcemafmean=NULL,ne=NULL,do_heatmap=TRUE,do_export=FALSE)
	{
	# propability of retaining a minor allele equals:
	# 1 - (probability of drawing major alleles only) =
	# 1 - ((1-maf)^(nfounders*2))
	if(is.null(sourcemafmean))
		{
		sourcemafmean		<- c(0.01,0.02,0.05,0.08,0.1,0.12,0.15,0.2,0.25,0.3,0.35,0.4)	
		}
	if(is.null(ne))
		{
		ne						<- c(1,2,5,10,20,40,60,80,100,125,150,200)
		}
	if(length(sourcemafmean)!=length(ne))
		{
		return(cat("ERROR: inputvectors to sourcemafmean and ne need to be of the same length",sep="\n"))
		}
	allcombi				<- as.data.frame(expand.grid(sourcemafmean,ne,stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("sourcemaf","ne")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	n_gen 					<- 2		# minimum is 2
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	parallelsel				<- TRUE	
	#
	# call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("retained_adaptive","retained_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2")
	testresults				<- as.data.frame(matrix(NA,ncol=27,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	for(myrun in c(1:nruns))
		{
		mean_source_maf		<- allcombi$sourcemaf[myrun]
		ne_F				<- allcombi$ne[myrun]
		cat(paste(mean_source_maf,ne_F,sep="_"),sep="\n")
		mysettings			<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=FALSE,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,meansourcemaf=mean_source_maf,sim_source=FALSE,nefounderpop1=ne_F,nefounderpop2=ne_F,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_selectionscan=FALSE,do_venn=FALSE,createplots=FALSE)
		myscores			<- mysambarsim$mytestscores[1,]
		testresults[myrun,]	<- c(myscores,mysettings)
		}
	# return table:
	testresults		<<- testresults
	write.table(testresults,"Retained_analysis.txt",quote=FALSE)
	if(do_heatmap)
		{
		# heatmap:
		retainedneutral	<<- xtabs(retained_neutral  ~ mean_maf_S + ne_F, testresults)
		graphics.off()
		make_heatmap(mymatrix=round(retainedneutral,2),myBreaks=seq(0,1,0.1),mytitle="Retained variation",note_cex=1.5,myylab="q",myxlab="Number of founders")
		testlist		<<- list()
		testlist[[1]]	<<- retainedneutral
		names(testlist)	<<- c("retainedneutral")
		}
	print(Sys.time())
	# Expected values:	
	matrix1				<- matrix(rep(sourcemafmean,length(ne)),ncol=length(ne),nrow=length(sourcemafmean),byrow=FALSE)
	matrix2				<- matrix(rep(ne,length(ne)),ncol=length(sourcemafmean),nrow=length(sourcemafmean),byrow=TRUE)	
	expretained			<<- round(1-((1-matrix1)^(2*matrix2)),2)
	colnames(expretained)<<- ne
	rownames(expretained)<<- sourcemafmean
	#
	plot_retained_variation(export=do_export)
	}

plot_retained_variation<-function(export=FALSE)
	{
	# expects to find a table called retainedneutral and a matrix called expretained, generated by runsim_retained function 
	if(export){pdf("Retainedvariation.plot.pdf")}
	nmaf		<- nrow(retainedneutral)
	mycol1		<- "grey75"
	mycol2		<- "black"
	mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
	my_colours	<- mycolfunc1(nmaf)
	ret			<- round(retainedneutral[1,],3)
	exp			<- round(expretained[1,],3)
	plot(names(ret),exp,col=my_colours[1],type='l',xlab="Number of founders",ylab="",ylim=c(0,1),cex.axis=1.5,cex.lab=2,lwd=2,log="x",main="Retained variation",cex.main=2)
	points(names(ret),ret,col=my_colours[1],lwd=2,cex=1.5)
	abline(h=1,lty=2)
	for(j in c(2:nrow(retainedneutral)))
		{
		ret		<- round(retainedneutral[j,],3)
		exp		<- round(expretained[j,],3)
		lines(names(ret),ret,col=my_colours[j],lwd=2)
		points(names(ret),ret,col=my_colours[j],lwd=2,cex=1.5)
		}
	mtext("Proportion retained alleles",side=2,line=2.5,cex=2)
	legend("bottomright",legend=rownames(retainedneutral),fill=my_colours,bty="n",cex=1.5,title="maf")
	if(export){dev.off()}
	}

# depends on plot_fixation and make_heatmap
runsim_fixation<-function(n_loci=1100,ne_F=50,n_selectedloci=1000,do_export=FALSE,n_gen=500,dohaploid=TRUE,doexport=FALSE)
	{
	# Fixation probs are a bit below expected when simulation with small Ne (like <= 10), probably because of rounding errors. 
	s_mafvector				<- c(0.05,0.1,0.15,0.2,0.25)
	selcoefvector			<- c(0,0.01,0.05,0.1)
	#
	#if(length(s_mafvector)!=length(selcoefvector))
	#	{
	#	return(cat("ERROR: vectors s_mafvector and selcoefvector need to be of the same length",sep="\n"))
	#	}
	allcombi				<- as.data.frame(expand.grid(s_mafvector,selcoefvector, stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("maf","s")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	#n_gen					<- 500	# high number to allow enough time for fixation to occur
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	parallelsel				<- TRUE	
	#
	# call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("retained_adaptive","retained_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2")
	testresults				<- as.data.frame(matrix(NA,ncol=27,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	for(myrun in c(1:nruns))
		{
		sel_coef			<- allcombi$s[myrun]
		mean_source_maf		<- allcombi$maf[myrun]
		cat(paste(sel_coef,ne_F,sep="_"),sep="\n")
		mysettings			<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=do_export,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,nefounderpop1=ne_F,nefounderpop2=ne_F,meansourcemaf=mean_source_maf,sim_source=FALSE,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_selectionscan=FALSE,do_venn=FALSE,do_haploid=dohaploid,createplots=FALSE)
		myscores			<- mysambarsim$mytestscores[1,]
		testresults[myrun,]	<- c(myscores,mysettings)
		}
	# return table:
	testresults		<<- testresults
	write.table(testresults,"Power_analysis.txt",quote=FALSE)
	# heatmap:
	fixedsel			<<- xtabs(fixed_adaptive2  ~ s + mean_maf_S, testresults)
	#retainedsel		<<- xtabs(retained_adaptive2  ~ s + mean_maf_S, testresults)
	graphics.off()
	make_heatmap(mymatrix=round(fixedsel,2),myBreaks=seq(0,1,0.1),mytitle="Fixation probability",note_cex=1.5,mycol2="darkgreen",myylab="s",myxlab="q")
	testlist			<<- list()
	testlist[[1]]		<<- fixedsel
	names(testlist)		<<- c("fixedsel")
	# calculate expected fixation:
	matrix1				<- matrix(rep(selcoefvector,length(s_mafvector)),ncol=length(s_mafvector),nrow=length(selcoefvector),byrow=FALSE)
	matrix2				<- matrix(rep(s_mafvector,length(selcoefvector)),ncol=length(s_mafvector),nrow=length(selcoefvector),byrow=TRUE)	
	expfixation			<<- round((1-exp(-2*ne_F*(matrix1+0.0001)*matrix2))/(1-exp(-2*ne_F*(matrix1+0.0001))),2)
	rownames(expfixation)<- selcoefvector
	colnames(expfixation)<- s_mafvector
	print(Sys.time())
	plot_fixation(export=do_export)
	}	

plot_fixation<-function(export=FALSE)
	{
	# expects to find a table called fixedsel and a matrix called expfixation, generated by runsim_fixation function
	if(export){pdf("Fixationprob.plot.pdf")}
	nmaf		<- nrow(fixedsel)
	mycol1		<- "grey75"
	mycol2		<- "black"
	mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
	my_colours	<- mycolfunc1(nmaf)
	fix			<- round(fixedsel[1,],3)
	exp			<- round(expfixation[1,],3)
	plot(names(fix),exp,col=my_colours[1],type='l',xlab="q",ylab="",ylim=c(0,1),cex.axis=1.5,cex.lab=2,lwd=2,main="Fixation probability",cex.main=2)
	points(names(fix),fix,col=my_colours[1],lwd=2,cex=1.5)
	for(j in c(2:nmaf))
		{
		fix		<- round(fixedsel[j,],3)
		exp		<- round(expfixation[j,],3)
		lines(names(fix),exp,col=my_colours[j],lwd=2)
		points(names(fix),fix,col=my_colours[j],lwd=2,cex=1.5)
		}
	mtext("Fixation probability",side=2,line=2.5,cex=2)
	legend("topleft",legend=rownames(fixedsel),fill=my_colours,bty="n",cex=1.5,title="s")
	if(export){dev.off()}
	}

runsim_fixationtime<-function(n_loci=1100,n_selectedloci=1000,sel_coef=0.1,maf_source=0.15,do_export=FALSE,dohaploid=TRUE,sel_discrete=TRUE)
	{
	# expected: 2/s * ln (2*Ne) generations
	ngen					<- c(25,50,100,200,500)
	ne						<- c(25,50,100,200,500)
	allcombi				<- as.data.frame(expand.grid(ngen,ne,stringsAsFactors = FALSE))
	colnames(allcombi)		<- c("ngen","ne")
	nruns					<- nrow(allcombi)
	#
	# run settings:
	n_sample				<- 30		
	n_sourcepop				<- 1000	
	mean_source_maf			<- maf_source
	parallelsel				<- TRUE	
	#
	# call objects:
	setnames				<- c("s","ne_F","gen","mean_maf_S","nloci","nselect","samplesize","ne_S","parallel")
	outnames				<- c("retained_adaptive","retained_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","fixed_adaptive2","fixed_neutral2")
	testresults				<- as.data.frame(matrix(NA,ncol=27,nrow=nruns))
	colnames(testresults)	<- c(outnames,setnames)
	for(myrun in c(1:nruns))
		{
		n_gen				<- allcombi$ngen[myrun]
		ne_F				<- allcombi$ne[myrun]
		cat(paste(sel_coef,ne_F,sep="_"),sep="\n")
		mysettings			<- c(sel_coef,ne_F,n_gen,mean_source_maf,n_loci,n_selectedloci,n_sample,n_sourcepop,parallelsel)
		outliersim(export=do_export,nloc=n_loci,ngen=n_gen,nesourcepop=n_sourcepop,nefounderpop1=ne_F,nefounderpop2=ne_F,meansourcemaf=mean_source_maf,sim_source=FALSE,nfounders=ne_F,samplesize=n_sample,testgeno=FALSE,nselectedloci=n_selectedloci,selcoef=sel_coef,parallelselection=parallelsel,do_selectionscan=FALSE,do_venn=FALSE,do_haploid=dohaploid,s_discrete=sel_discrete)
		myscores			<- mysambarsim$mytestscores[1,]
		testresults[myrun,]	<- c(myscores,mysettings)
		}
	# return table:
	testresults		<<- testresults
	write.table(testresults,"Power_analysis.txt",quote=FALSE)
	# heatmap:
	retainedsel		<<- xtabs(retained_adaptive ~ gen + ne_F, testresults)
	fixedsel		<<- xtabs(fixed_adaptive2  ~ gen + ne_F, testresults)
	graphics.off()
	#make_heatmap(mymatrix=round(retainedsel,2),myBreaks=seq(0.7,1,0.025),mytitle="Retained variation",myylab="G",myxlab="Ne")
	make_heatmap(mymatrix=round(fixedsel,2),myBreaks=seq(0,0.3,0.025),mytitle="Fixation probability",note_cex=1.5,mycol2="darkgreen",myylab="G",myxlab="Ne")
	testlist		<<- list()
	testlist[[1]]	<<- retainedsel 
	testlist[[2]]	<<- fixedsel
	names(testlist)	<<- c("retainedsel","fixedsel")
	print(Sys.time())
	}	
	
make_heatmap<-function(mymatrix=myinput,export=NULL,mycol1="grey85",mycol2="red",myBreaks=seq(0,1,0.025),mytitle="Power",note_cex=1.5,my_margins=c(4.5,6),myylab="s",myxlab="Ne")
	{
	# define colour scale:
	mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
	myColours	<- c(mycolfunc1(length(myBreaks)-1))
	# plot:
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(mytitle,"pdf",sep="."))}
		if(export=="wmf"){win.metafile(paste(mytitle,"wmf",sep="."))}
		}
	heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=note_cex,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=0,key=FALSE,margins=my_margins,adjCol=c(NA,0.5),adjRow=c(0,NA),offsetRow = -0.5)
	mtext(myylab, side = 4, line = -0.5, cex = 2, las=2)
	mtext(myxlab, side = 1, line = 3.5, cex = 2)
	mtext(mytitle, side = 3, line = 1, cex = 2.5)
	if(!is.null(export)){dev.off()}
	}	

export_heatmaps_single<-function(export_type=NULL)
	{
	# export_type should be "pdf" or "wmf"
	make_heatmap(mymatrix=round(gwdspower,2),mytitle="power_GWDS",export=export_type)
	make_heatmap(mymatrix=round(gwdsspec,4),mytitle="specificity_GWDS",myBreaks=seq(0.999,1,0.00005),note_cex=1,mycol2="darkgreen",export=export_type)
	make_heatmap(mymatrix=round(outflankpower,2),mytitle="power_OutFLANK",export=export_type)
	make_heatmap(mymatrix=round(outflankspec,4),mytitle="specificity_OutFLANK",myBreaks=seq(0.999,1,0.00005),note_cex=1,mycol2="darkgreen",export=export_type)
	make_heatmap(mymatrix=round(pcadaptpower,2),mytitle="power_PCadapt",export=export_type)
	make_heatmap(mymatrix=round(pcadaptspec,4),mytitle="specificity_PCadapt",myBreaks=seq(0.999,1,0.00005),note_cex=1,mycol2="darkgreen",export=export_type)
	}

export_heatmaps_fixation<-function(export=NULL,exportname="Alltestscores",mylist=testlist,inverse=FALSE,myxlab="Ne",myylab="G")
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	# library(grid)
	# install.packages("gridGraphics")
	# library(gridGraphics)
	# library(gridExtra)
	gl <- lapply(1:length(mylist), function(i){
		mycol1		<- "grey85"
		mymatrix	<- data.matrix(mylist[[i]])
		if(inverse)
			{
			mymatrix<- 1 - mymatrix
			}
		myBreaks<-seq(0,1,0.1)
		mycol2	<- "darkgreen"
		note_cex<- 1.5
		mymatrix<- round(mymatrix,2)
		mytitle	<- "Fixation probability"
		mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
		myColours	<- c(mycolfunc1(length(myBreaks)-1))
		my_margins=c(4,4)	# under/above,right/left
		heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=note_cex,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=0,key=FALSE,margins=my_margins,adjCol=c(NA,0.5),adjRow=c(0,NA),offsetRow = -0.5)
		mtext(myylab, side = 4, line = 0.75, cex = 2, las=2)
		mtext(myxlab, side = 1, line = 3.5, cex = 2)
		mtext(mytitle, side = 3, line = 0.5, cex = 2)
		mystat		<- ifelse(i==1,"s = 0",(ifelse(i==2,"s = 0.01",ifelse(i==3,"s = 0.05","s = 0.10")))) 
		mtext(mystat, side = 2, line = 0.5, cex = 2)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=13,width=15,onefile=FALSE)}
		if(export=="png"){png(paste(exportname,"png",sep="."),height=975,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=975,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=2, clip=TRUE)	
	if(!is.null(export)){dev.off()}
	}

export_heatmaps_power<-function(export=NULL,exportname="Alltestscores",mylist=mysambarsim$testlist,inverse=FALSE,myxlab="Ne",myylab="s")
	{
	# export can be pdf or png or jpeg
	# depends on ggplot2
	gl <- lapply(1:length(mylist), function(i){
		mycol1		<- "grey85"
		mymatrix	<- data.matrix(mylist[[i]])
		if(inverse)
			{
			mymatrix<- 1 - mymatrix
			}
		if(i<4)
			{
			myBreaks<- seq(0,1,0.025)
			mycol2	<- "red"
			note_cex<- 1.5
			mymatrix<- round(mymatrix,2)
			mystat	<- "power"
			}else{
			myBreaks<-seq(0.999,1,0.00005)
			mycol2	<- "darkgreen"
			note_cex<- 1
			mymatrix<- round(mymatrix,4)
			mystat	<- "specificity"
			}
		mycolfunc1 	<- colorRampPalette(c(mycol1,mycol2))
		myColours	<- c(mycolfunc1(length(myBreaks)-1))
		mytitle		<- "Power"
		my_margins=c(4,5)	# under/above,right/left
		heatmap.2(mymatrix,cellnote=mymatrix,lhei=c(0.5,4),lwid=c(0.5,4),labRow=rownames(mymatrix),labCol=colnames(mymatrix),
			notecol="black",notecex=note_cex,Rowv=NA,Colv=NA,scale="none",col=myColours,breaks=myBreaks,dendrogram="none",trace="none",cexCol=1.5,cexRow=1.5,
			ylab="",xlab="",srtRow=0,srtCol=0,key=FALSE,margins=my_margins,adjCol=c(NA,0.5),adjRow=c(0,NA),offsetRow = -0.5)
		mtext(myylab, side = 4, line = 0.5, cex = 2, las=2)
		mtext(myxlab, side = 1, line = 3.25, cex = 2)
		mtext(mystat, side=2, line = 0.5, cex = 2)
		mytitle		<- ifelse((i+2)%%3==0,"GWDS",ifelse((i+2)%%3==1,"OutFLANK","PCadapt")) 
		mtext(mytitle, side = 3, line = 0.5, cex = 2)
		grid.echo()
		grid.grab()})
	graphics.off()
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(exportname,"pdf",sep="."),height=17,width=13,onefile=FALSE)}
		if(export=="png"){png(paste(exportname,"png",sep="."),height=1325,width=975)}
		if(export=="jpeg"){jpeg(paste(exportname,"jpeg",sep="."),height=1325,width=975)}
		}
	grid.newpage()
	grid.arrange(grobs=gl, ncol=2, clip=TRUE, as.table = FALSE)	
	if(!is.null(export)){dev.off()}
	}


multioverlap_approach_sim<-function(doexport=NULL,add_numbers=FALSE)
	{
	if(!is.null(doexport))
		{
		if(doexport=="pdf"){pdf("Overlap_between_comparisons_simulated.pdf",width=12,height=4)}
		}
	par(mfrow=c(1,3),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	plotpoverlap_approach_sim(mycomparison=1,addnumbers=add_numbers)
	plotpoverlap_approach_sim(mycomparison=2,addnumbers=add_numbers)
	plotpoverlap_approach_sim(mycomparison=3,addnumbers=add_numbers)
	if(!is.null(doexport)){dev.off()}
	}	

plotpoverlap_approach_sim<-function(mycomparison=1,mycex=1,addnumbers=FALSE,pmax=11,nloci=60000,nsel=1000)
	{
	if(mycomparison==1)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[1]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[1]]
		mytest1	<- "founder1_source"
		mylog2	<- mysambarsim$gwdslognewplist[[2]]
		myout2	<- mysambarsim$gwdsoutlierslist[[2]]
		mytest2	<- "founder2_source"
		}
	if(mycomparison==2)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[1]]
		myout1	<- mysambarsim$gwdsoutlierslist[[1]]
		mytest1	<- "founder1_source"
		mylog2	<- mysambarsim$gwdslognewplist[[3]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest2	<- "bothfounders_source"
		}
	if(mycomparison==3)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[2]]
		myout1	<- mysambarsim$gwdsoutlierslist[[2]]
		mytest1	<- "founder2_source"
		mylog2	<- mysambarsim$gwdslognewplist[[3]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest2	<- "bothfounders_source"
		}
	#
	mybonf		<- -log10(0.05/length(mysambarsim$gwdslogplist[[3]]))
	mylim		<- c(0,pmax)
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=mylim,ylim=mylim,las=1,col="grey50")
	points(mylog1[nloci-nsel+1:nloci],mylog2[nloci-nsel+1:nloci],pch=16,cex=mycex,col="red")
	mtext(mytest1,side=1,cex=1.5,line=3)
	mtext(mytest2,side=2,cex=1.5,line=3)
	abline(v=mybonf,lty=2)
	abline(h=mybonf,lty=2)
	#mymin1	<- min(mylog1[myout1])
	#mymin2	<- min(mylog2[myout2])
	#abline(v=mymin1,lty=2)
	#abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
			if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

getbayescansim<-function(bayescanfile=NULL,FDR=0.01,dolog10=TRUE)
	{
	if(is.null(bayescanfile))
		{
		return(cat("ERROR: provide the name of the Bayescan output file to the bayescanfile flag.",sep="\n")) 
		}else{
		if(!file.exists(bayescanfile))
			{
			cat(paste("ERROR: file called ",bayescanfile," not found in the working directory:",sep=""),sep="\n")
			return(cat(getwd(),sep="\n"))
			}else{
			x			<- read.table(bayescanfile) 
			}
		x$bayescanout	<- x$qval<FDR
		noutliers		<- length(which(x$bayescanout))
		if(dolog10)
			{
			x$bayescanlogp	<- -log10(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log10(x$qval)
			}else{
			x$bayescanlogp	<- -log(1-x$prob)	# x$prob is the posterior probability of the selection model. I choose to display the inverse (the posterior probability of the neutral model), to allow Manhattan plots.
			x$bayescanlogq	<- -log(x$qval)
			}
		simbayescan		<<- x
		cat("Bayescan file saved as object 'simbayescan'.",sep="\n")
		}
	}

multiplotp_sim<-function(export=NULL,add_numbers=TRUE,nr_loci=1000,nr_selected=100,silent=TRUE,comp_nr=3,logpmax=11,bayescanfile=NULL,bayescanFDR=0.01)
	{
	if(!is.null(bayescanfile)){getbayescansim(bayescanfile=bayescanfile,FDR=bayescanFDR)}
	ncombi	<- ifelse(is.null(bayescanfile),3,6)
	if(!is.null(export))
		{
		plotname	<- ifelse(!is.null(bayescanfile),"Teststatistic.2D.simulated.withbayescan","Teststatistic.2D.simulated")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),width=ncombi*4+1,height=4)}
		}
	par(mfrow=c(1,ncombi),mar=c(5,6.5,1,1),cex.axis=1.5,cex.lab=2)
	# what is maximum p-value? (not considering Bayescan)
	if(is.null(logpmax))
		{
		mypvalues	<-c(mysambarsim$gwdslognewplist[[comp_nr]],mysambarsim$outflanklogplist[[comp_nr]],mysambarsim$pcadaptlogplist[[comp_nr]])
		mypvalues	<- mypvalues[is.finite(mypvalues)]
		logpmax		<- max(mypvalues,na.rm=TRUE)
		}
	if(!is.null(bayescanfile))
		{
		plotpvalues_sim(mycomparison=4,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
		plotpvalues_sim(mycomparison=5,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
		plotpvalues_sim(mycomparison=6,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
		}
	plotpvalues_sim(mycomparison=1,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
	plotpvalues_sim(mycomparison=2,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
	plotpvalues_sim(mycomparison=3,addnumbers=add_numbers,nrloci=nr_loci,nrselected=nr_selected,silent=silent,my_comp_nr=comp_nr,pmax=logpmax)
	if(!is.null(export))
		{
		dev.off()
		cat("2D-Plot exported to the directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}

plotpvalues_sim<-function(export=NULL,mycomparison=1,mycex=0.75,addnumbers=FALSE,nrloci=1000,nrselected=100,my_comp_nr=3,silent=TRUE,pmax=NULL,textcol="grey50",nsample=NULL)
	{
	# my_comp_nr defines population comparison, i.e. whether to plot output for pairwise (1 or 2) or pooled approach (3)
	# mycomparison defines selection scan comparison
	if(!silent){cat("Obtaining test results from list objects generated by outliersim function...",sep="\n")} 
	if(mycomparison==1)
		{
		mylog1	<- mysambarsim$outflanklogplist[[my_comp_nr]]
		myout1	<- mysambarsim$outflankoutlierslist[[my_comp_nr]]
		mytest1	<- "OutFLANK"
		mylog2	<- mysambarsim$pcadaptlogplist[[my_comp_nr]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[my_comp_nr]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==2)
		{
		mylog1	<- mysambarsim$outflanklogplist[[my_comp_nr]]
		myout1	<- mysambarsim$outflankoutlierslist[[my_comp_nr]]
		mytest1	<- "OutFLANK"
		mylog2	<- mysambarsim$gwdslognewplist[[my_comp_nr]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[my_comp_nr]]
		mytest2	<- "GWDS"
		}
	if(mycomparison==3)
		{
		mylog1	<- mysambarsim$gwdslognewplist[[my_comp_nr]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[my_comp_nr]]
		mytest1	<- "GWDS"
		mylog2	<- mysambarsim$pcadaptlogplist[[my_comp_nr]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[my_comp_nr]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==4)
		{
		mylog1	<- simbayescan$bayescanlogp
		myout1	<- which(simbayescan$bayescanout)
		mytest1	<- "bayescan"
		mylog2	<- mysambarsim$outflanklogplist[[my_comp_nr]]
		myout2	<- mysambarsim$outflankoutlierslist[[my_comp_nr]]
		mytest2	<- "OutFLANK"
		}
	if(mycomparison==5)
		{
		mylog1	<- simbayescan$bayescanlogp
		myout1	<- which(simbayescan$bayescanout)
		mytest1	<- "bayescan"
		mylog2	<- mysambarsim$pcadaptlogplist[[my_comp_nr]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[my_comp_nr]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==6)
		{
		mylog1	<- simbayescan$bayescanlogp
		myout1	<- which(simbayescan$bayescanout)
		mytest1	<- "bayescan"
		mylog2	<- mysambarsim$gwdslognewplist[[my_comp_nr]] 
		myout2	<- mysambarsim$gwdsoutlierslist[[my_comp_nr]]
		mytest2	<- "GWDS"
		}
	mylog1[is.infinite(mylog1)]	<- NA
	mylog2[is.infinite(mylog2)]	<- NA
	if(is.null(pmax))
		{
		myxmax	<- max(mylog1,na.rm=TRUE)
		myxmax	<- max(mylog2,na.rm=TRUE)
		}else{
		myxmax	<- pmax
		myymax	<- pmax
		}
	if(!silent){cat("Plotting...",sep="\n")}
	if(!is.null(export))
		{
		plotname<-paste("Selectionscan.sim.logpvalues.2D",my_comp_nr,mytest1,mytest2,sep=".")
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=4,width=4)}
		par(mar=c(1,1,1,1),oma=c(2.5,2.5,0,0))
		}
	if(!is.null(nsample))
		{
		sampleset	<- sample(c(1:length(mylog1)),nsample)
		plot(mylog1[sampleset],mylog2[sampleset],pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		}else{
		plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,xlim=c(0,pmax),ylim=c(0,pmax),las=1)
		#plot(mylog1[1:(nrloci-nrselected)],mylog2[1:(nrloci-nrselected)],cex=1,pch=16,xlab="",ylab="",yaxt='n',xlim=c(0,myxmax),ylim=c(0,myymax))
		}
	myxline	<- ifelse(!is.null(export),2.5,3.5)
	myyline	<- ifelse(!is.null(export),2,3.5)
	mtext(mytest1,side=1,cex=1.5,line=myxline)
	mtext(mytest2,side=2,cex=1.5,line=myyline)
	axis(side=2,las=1)
	selectednr	<- nrloci-nrselected+1	
	if(!silent){cat("Adding outliers in red...",sep="\n")}
	points(mylog1[(nrloci-nrselected+1):nrloci],mylog2[(nrloci-nrselected+1):nrloci],pch=16,cex=mycex,col="red")
	if(!silent){cat("Adding threshold lines...",sep="\n")}
	mymin1		<- min(mylog1[myout1],na.rm=TRUE)
	mymin2		<- min(mylog2[myout2],na.rm=TRUE)
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		if(!silent){cat("Adding numbers...",sep="\n")}
		nout1	<- length(myout1)
		if(!silent){cat(paste("Number of outliers test 1: ",nout1,".",sep=""),sep="\n")}
		nout2	<- length(myout2)
		if(!silent){cat(paste("Number of outliers test 1: ",nout2,".",sep=""),sep="\n")}
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- nrselected-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=2.25,col=textcol)
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=2.25,col=textcol)
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=2.25,col=textcol)
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=2.25,col=textcol)
		#text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=2.25,col=textcol)
		}
	if(!is.null(export)){dev.off()}
	}
	
plotpvalues_old_sim<-function(mycomparison=1,mylog="",mycex=1,addnumbers=FALSE)
	{
	if(mycomparison==1)
		{
		mylog1	<- mysambarsim$gwdslogplist[[3]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest1	<- "GWDS"
		mylog2	<- bayescanlogqlist[[3]]
		myout2	<- bayescanoutlierslist[[3]]
		mytest2	<- "Bayescan"
		}
	if(mycomparison==2)
		{
		mylog1	<- mysambarsim$gwdslogplist[[3]] 
		myout1	<- mysambarsim$gwdsoutlierslist[[3]]
		mytest1	<- "GWDS"
		mylog2	<- mysambarsim$pcadaptlogplist[[3]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[3]]
		mytest2	<- "PCadapt"
		}
	if(mycomparison==3)
		{
		mylog1	<- bayescanlogqlist[[3]] 
		myout1	<- bayescanoutlierslist[[3]]
		mytest1	<- "Bayescan"
		mylog2	<- mysambarsim$pcadaptlogplist[[3]]
		myout2	<- mysambarsim$pcadaptoutlierslist[[3]]
		mytest2	<- "PCadapt"
		}
	mylog1[mylog1==0]	<- 0.01
	mylog2[mylog2==0]	<- 0.01
	plot(mylog1,mylog2,pch=16,xlab="",ylab="",cex=mycex,log=mylog,yaxt='n')
	mtext(mytest1,side=1,cex=1.5,line=3)
	if(mylog=="y")
		{
		axis(side=2,at=format(axTicks(2),scientific=FALSE),format(axTicks(2),scientific=FALSE),las=1)
		mtext(mytest2,side=2,cex=1.5,line=4.5)
		}else{
		axis(side=2,las=1)
		mtext(mytest2,side=2,cex=1.5,line=3)
		}
	points(mylog1[79001:80000],mylog2[79001:80000],pch=16,cex=mycex,col="red")
	mymin1	<- min(mylog1[myout1])
	mymin2	<- min(mylog2[myout2])
	abline(v=mymin1,lty=2)
	abline(h=mymin2,lty=2)
	if(addnumbers)
		{
		nout1	<- length(myout1)
		nout2	<- length(myout2)
		noutboth<- length(myout1[myout1%in%myout2])
		nout1	<- nout1-noutboth
		nout2	<- nout2-noutboth
		nrest	<- 1000-noutboth-nout1-nout2
		nall	<- c(nrest,nout1,nout2,noutboth)
		if(nout1<10)
			{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.5,1.5),cex=1.75,col="grey50")
			}else{
			text(x=mymin1,y=mymin2,nout1,adj=c(-0.25,1.5),cex=1.75,col="grey50")
			}
		text(x=mymin1,y=mymin2,nout2,adj=c(1.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,noutboth,adj=c(-0.25,-0.5),cex=1.75,col="grey50")
		text(x=mymin1,y=mymin2,nrest,adj=c(1.25,1.5),cex=1.75,col="grey50")
		}
	}

multimafburnin<-function(mymaf_means=c(0.1,0.125,0.15,0.2),maf_vector=NULL)
	{
	# This function is to run the function mafburnin with several starting minor allele frequencies.
	if(is.null(maf_vector))
		{
		return(cat("ERROR: provide an input vector with observed locus specific minor allele frequencies (e.g. snps$maf_popname[snps$filter]) to the maf_vector flag.",sep="\n"))  
		}
	for(my_m in mymaf_means)
		{
		cat(my_m,sep="\n")
		mafburnin(nsamples=30,truedata=snps$maf_Norway[snps$filter],ngen_vec=c(100,200,300,400),export=TRUE,maf_mean=my_m,y_max=13)
		}
	}

mafburnin<-function(nsamples=30,truedata=snps$maf_Norway[snps$filter],ngen_vec=c(100,200,300,400),export=FALSE,maf_mean=0.15,y_max=13)
	{
	# Which burn-in (number of generations) needed to acquire realistic maf-distribution?
	if(is.null(truedata))
		{
		return(cat("ERROR: provide an input vector with observed locus specific minor allele frequencies to the truedata flag.",sep="\n"))  
		}
	nalleles	<- nsamples*2
	if(export)
		{
		pdf(paste("MAF",maf_mean,"burnin.pdf",sep="_"),height=10,width=10)
		}
	layout(matrix(c(1:4),2,2,byrow = TRUE))
	par(mar=c(1.5,1.5,1,0.5),oma=c(3,3,1.5,1),cex.axis=2.25,cex.lab=2.5,cex.main=2.5)
	for (my_k in c(1:length(ngen_vec)))
		{
		sourcemaf	<- mafsim(nloci=10000,popsize=1000,ngens=ngen_vec[my_k],meanmaf=maf_mean)
		mysample	<- sapply(sourcemaf,function(sourcemaf){rbinom(1,nalleles,sourcemaf)})
		# plot:
		hist(truedata,freq=FALSE,main="",ylim=c(0,y_max),col="grey")
		hist(mysample/nalleles,add=TRUE,freq=FALSE,breaks=seq(0,1,0.05),col=rgb(1,0,0,1/6))
		mtext(side=3,paste("burn-in: ",ngen_vec[my_k]," ngen",sep=""),line=-2.5,cex=2)
		if(my_k==2)
			{
			legend("right",legend=c("observed","simulated"),fill=c("grey","red"),bty="n",cex=2)
			}
		}
	mtext(side=1,outer=TRUE,"Allele frequency",line=1.5,cex=2)
	mtext(side=2,outer=TRUE,"SNP density",line=1.25,cex=2)
	mtext(side=3,outer=TRUE,paste("Uniform allele frequency prior to burn-in: ",maf_mean,sep=""),line=-1,cex=2)
	if(export){dev.off()}
	}

plotfdr<-function(do_analysis=FALSE,do_export=TRUE,my_comp=1,loci_nr=10000,gen_nr=20,selected_nr=1000,vector_ne=c(20,40,60,80,100,120,160,200),founders_nr=NULL,my_ylims=NULL,samples_nr=30,selection_coefficient=0.1,sel_discrete=TRUE,dohaploidy=TRUE,myinputmatrix=NULL,plot_fdr=FALSE,add_bh=TRUE)
	{
	# note: false discovery rate does not depend on power and specificity only, but also on the proportion of adaptive loci in your dataset
	# for example: say power is 40% and specificity is 99.9%.
	# if you have 100.000 SNPs, of which 10.000 are adaptive, then false discovery rate is:
	# ((1-0.999)*90000)/(0.4*10000+((1-0.999)*90000)) = 0.022 = 2.2%
	# however, if you have 100K SNPs, of which only 10 are adaptive, then false discovery rate:
	# ((1-0.999)*90000)/(0.4*10+((1-0.999)*90000)) = 0.957 = 96%
	# therefore FDR is only informative if calculated for a range of proportions of adaptive loci 
	#
	# my_comp can be 1 (founder1 vs source), 2 (founder 2 vs source), or 3 (both founders combined vs source)
	#
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	cat("###### SETTINGS WHILST RUNNING PLOT_FDR ######",sep="\n")
	cat(paste("  Specified number of loci: ",loci_nr,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",selected_nr,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficients: ",paste(selection_coefficient,collapse=", "),".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",gen_nr,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder populations: ",paste(vector_ne,collapse=", "),".",sep=""),sep="\n")
	if(is.null(founders_nr))
		{
		cat("  No bottleneck specified (flag 'founders_nr' is set to NULL).",sep="\n")
		}else{
		cat(paste("  Specified number of founders: ",founders,".",sep=""),sep="\n")
		}
	cat(paste("  Specified samplesize: ",samples_nr,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",sel_discrete,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",dohaploidy,".",sep=""),sep="\n")
	#
	if(do_analysis&is.null(myinputmatrix))
		{
		runsim_power(n_gen=gen_nr,n_loci=loci_nr,mycorr="bonferroni",n_selectedloci=selected_nr,selcoefvector=selection_coefficient,nevector=vector_ne,do_export=TRUE,dohaploid=dohaploidy,my_comparison=my_comp,n_sample=samples_nr,sdiscrete=sel_discrete)
		bonflist	<- mysambarsim$testlist
		bonffdr		<- mysambarsim$fdrlist
		runsim_power(n_gen=gen_nr,n_loci=loci_nr,mycorr="holm",n_selectedloci=selected_nr,selcoefvector=selection_coefficient,nevector=vector_ne,do_export=TRUE,dohaploid=dohaploidy,my_comparison=my_comp,n_sample=samples_nr,sdiscrete=sel_discrete)
		holmlist	<- mysambarsim$testlist
		holmfdr		<- mysambarsim$fdrlist
		runsim_power(n_gen=gen_nr,n_loci=loci_nr,mycorr="BH",n_selectedloci=selected_nr,selcoefvector=selection_coefficient,nevector=vector_ne,do_export=TRUE,dohaploid=dohaploidy,my_comparison=my_comp,n_sample=samples_nr,sdiscrete=sel_discrete)
		bhlist		<- mysambarsim$testlist
		bhfdr		<- mysambarsim$fdrlist
		}else{
		cat("WARNING: flag do_analysis is set to FALSE and/or myinputmatrix is not set to NULL. Plotting test scores from previous simulations (i.e. objects bonflist, holmlist, bhlist, and bonffdr, holmfdr, and bhfdr).",sep="\n")
		
		}
	# plot:
	mytestscans	<- c("GWDS","OutFLANK","PCadapt")
	mytestcols	<- c("blue","orange","darkgreen")
	if(do_export)
		{
		bhlabel			<- ifelse(add_bh,"withBH","withoutBH") 
		if(plot_fdr)
			{
			plotname	<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),bhlabel,"withFDR.pdf",sep=".")
			}else{
			plotname	<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),bhlabel,"withoutFDR.pdf",sep=".")
			}
		pdf(plotname)
		}
	if(!is.null(myinputmatrix))
		{
		cat("Reading matrices defined by myinputmatrix flag.",sep="\n")
		bonfmat		<- read.table(paste(myinputmatrix,"bonferroni.txt",sep="."))
		holmmat		<- read.table(paste(myinputmatrix,"holm.txt",sep="."))
		bhmat		<- read.table(paste(myinputmatrix,"BH.txt",sep="."))
		cat("Calculating FDR for various proportions of adaptive SNPs.",sep="\n")
		# (FP*(1-p_adaptive))/ (FP*(1-p_adaptive) + ((1-FN)+p_adaptive))  
		bonfmat[10,]	<- ((1-bonfmat[4,])*900000)/(bonfmat[1,]*100000+(1-bonfmat[4,])*900000)		# 10% 
		bonfmat[11,]	<- ((1-bonfmat[5,])*900000)/(bonfmat[2,]*100000+(1-bonfmat[5,])*900000)		# 10%
		bonfmat[12,]	<- ((1-bonfmat[6,])*900000)/(bonfmat[3,]*100000+(1-bonfmat[6,])*900000)		# 10%
		#
		bonfmat[13,]	<- ((1-bonfmat[4,])*990000)/(bonfmat[1,]*10000+(1-bonfmat[4,])*990000)		# 1%
		bonfmat[14,]	<- ((1-bonfmat[5,])*990000)/(bonfmat[2,]*10000+(1-bonfmat[5,])*990000)		# 1%
		bonfmat[15,]	<- ((1-bonfmat[6,])*990000)/(bonfmat[3,]*10000+(1-bonfmat[6,])*990000)		# 1%		
		#
		bonfmat[16,]	<- ((1-bonfmat[4,])*999000)/(bonfmat[1,]*1000+(1-bonfmat[4,])*999000)		# 0.1%
		bonfmat[17,]	<- ((1-bonfmat[5,])*999000)/(bonfmat[2,]*1000+(1-bonfmat[5,])*999000)		# 0.1%
		bonfmat[18,]	<- ((1-bonfmat[6,])*999000)/(bonfmat[3,]*1000+(1-bonfmat[6,])*999000)		# 0.1%
		#
		bonfmat[19,]	<- ((1-bonfmat[4,])*999900)/(bonfmat[1,]*100+(1-bonfmat[4,])*999900)		# 0.01%
		bonfmat[20,]	<- ((1-bonfmat[5,])*999900)/(bonfmat[2,]*100+(1-bonfmat[5,])*999900)		# 0.01%
		bonfmat[21,]	<- ((1-bonfmat[6,])*999900)/(bonfmat[3,]*100+(1-bonfmat[6,])*999900)		# 0.01%
		#
		bonfmat[22,]	<- ((1-bonfmat[4,])*999990)/(bonfmat[1,]*10+(1-bonfmat[4,])*999990)			# 0.001%
		bonfmat[23,]	<- ((1-bonfmat[5,])*999990)/(bonfmat[2,]*10+(1-bonfmat[5,])*999990)			# 0.001%
		bonfmat[24,]	<- ((1-bonfmat[6,])*999990)/(bonfmat[3,]*10+(1-bonfmat[6,])*999990)			# 0.001%
		#
		for (k in c(1:nrow(bonfmat)))
			{
			bonfmat[k,]	<- ifelse(is.na(as.vector(bonfmat[k,])),0,bonfmat[k,])
			}
		}
	cat("Creating plot...",sep="\n")
	if(plot_fdr)
		{
		layout(matrix(c(1:9),nrow=3,ncol=3,byrow=TRUE))
		par(mar=c(1,2.75,1,1),oma=c(3,1.5,3,1))
		}else{
		layout(matrix(c(1:6),nrow=3,ncol=2,byrow=TRUE))
		par(mar=c(1,3,1,1),oma=c(3,1.5,3,1))
		}
	if(is.null(my_ylims))
		{
		if(add_bh)
			{
			cat("Using a relatively low lower limit of the y-axis of the specificity plot, because add_bh is set to TRUE.",sep="\n") 
			my_ylims=c(1,0.98,1)
			}else{
			cat("Using a relatively high lower limit of the y-axis of the specificity plot, because add_bh is set to FALSE.",sep="\n") 
			my_ylims=c(1,0.9996,1)
			}
		}
	if(is.null(myinputmatrix))
		{
		for (k in (1:3))
			{
			# power:
			myxaxt	<- ifelse(k==3,'s','n')
			plot(colnames(bonflist[[k]]),bonflist[[k]][1,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,my_ylims[1]),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(colnames(bonflist[[k]]),holmlist[[k]][1,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(colnames(bonflist[[k]]),bhlist[[k]][1,],type='l',lwd=2,lty=3,col=mytestcols[k])}				
			if(k==1){mtext("power",side=3,cex=1.5,line=0.5)}
			if(add_bh)
				{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')}
				}else{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm"),lty=c(1,2),cex=1.5,bty='n')}
				}
			# specificity:
			plot(colnames(bonflist[[k]]),bonflist[[k+3]][1,],type='l',lwd=2,xlab="",ylab="",ylim=c(my_ylims[2],1),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(colnames(bonflist[[k]]),holmlist[[k+3]][1,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(colnames(bonflist[[k]]),bhlist[[k+3]][1,],type='l',lwd=2,lty=3,col=mytestcols[k])}
			if(k==1){mtext("specificity",side=3,cex=1.5,line=0.5)}
			if(plot_fdr)
				{
				# FDR:
				plot(colnames(bonflist[[k]]),bonffdr[[k]][1,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,my_ylims[3]),las=1,xaxt=myxaxt,col=mytestcols[k])
				lines(colnames(bonflist[[k]]),holmfdr[[k]][1,],type='l',lwd=2,lty=2,col=mytestcols[k])
				if(add_bh){lines(colnames(bonflist[[k]]),bhfdr[[k]][1,],type='l',lwd=2,lty=3,col=mytestcols[k])}
				if(k==1){mtext("FDR",side=3,cex=1.5,line=0.5)}
				mtext(mytestscans[k],side=4,cex=1.5,line=1)
				}
			}
		}else{
		for (k in (1:3))
			{
			# power:
			myxaxt	<- ifelse(k==3,'s','n')
			plot(vector_ne,bonfmat[k,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,my_ylims[1]),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(vector_ne,holmmat[k,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(vector_ne,bhmat[k,],type='l',lwd=2,lty=3,col=mytestcols[k])}
			if(k==1){mtext("power",side=3,cex=1.5,line=0.5)}
			if(add_bh)
				{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')}
				}else{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm"),lty=c(1,2),cex=1.5,bty='n')}
				}
			#legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')
			# specificity:
			plot(vector_ne,bonfmat[k+3,],type='l',lwd=2,xlab="",ylab="",ylim=c(my_ylims[2],1),las=1,xaxt=myxaxt,col=mytestcols[k])
			lines(vector_ne,holmmat[k+3,],type='l',lwd=2,lty=2,col=mytestcols[k])
			if(add_bh){lines(vector_ne,bhmat[k+3,],type='l',lwd=2,lty=3,col=mytestcols[k])}
			if(k==1){mtext("specificity",side=3,cex=1.5,line=0.5)}
			if(add_bh)
				{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm","BH"),lty=c(1,2,3),cex=1.5,bty='n')}
				}else{
				if(k==1){legend("bottomright",legend=c("Bonferroni","Holm"),lty=c(1,2,3),cex=1.5,bty='n')}
				}
			if(plot_fdr)
				{
				# FDR:
				plot(vector_ne,bonfmat[k+9,],type='l',lwd=2,xlab="",ylab="",ylim=c(0,1),las=1,xaxt=myxaxt,col=mytestcols[k])
				lines(vector_ne,bonfmat[k+12,],type='l',lwd=2,lty=2,col=mytestcols[k])
				lines(vector_ne,bonfmat[k+15,],type='l',lwd=2,lty=3,col=mytestcols[k])
				lines(vector_ne,bonfmat[k+18,],type='l',lwd=2,lty=4,col=mytestcols[k])
				#lines(vector_ne,bonfmat[k+21,],type='l',lwd=2,lty=5,col=mytestcols[k])
				if(k==1){mtext("FDR",side=3,cex=1.5,line=0.5)}
				#if(k==1){legend("topright",legend=c("0.00001","0.0001","0.001","0.01","0.1"),lty=c(5,4,3,2,1),cex=1.25,bty='n',title="p_adaptive:")}
				if(k==1){legend("topright",legend=c("0.0001","0.001","0.01","0.1"),lty=c(4,3,2,1),cex=1.5,bty='n',title="p_adaptive:")}
				mtext(mytestscans[k],side=4,cex=1.5,line=1)
				}
			}
		}
	mtext("Ne",outer=TRUE,side=1,line=1.75,cex=1.5)
	mtext("Test performances",outer=TRUE,side=2,line=-0.25,cex=1.5)
	myapproach	<- ifelse(my_comp==3,"pooled","pairwise")
	mtext(paste("ngen: ",gen_nr,", samplesize: ",samples_nr,", s: ",selection_coefficient,", ",myapproach,sep=""),outer=TRUE,side=3,line=1.5,cex=1.25)
	if(do_export){dev.off()}
	#
	if(is.null(myinputmatrix)&do_analysis)
		{
		# store all results in one list:
		cat("Storing resulting in list object called 'mysambarsim$plotfdr_scores'.",sep="\n")
		myfinallist				<- list()
		myfinallist$bonf		<- bonflist
		myfinallist$bonffdr		<- bonffdr
		myfinallist$holm		<- holmlist
		myfinallist$holmfdr		<- holmfdr
		myfinallist$holm		<- bhlist
		myfinallist$holmfdr		<- bhfdr
		mysambarsim$plotfdr_scores	<<- myfinallist  
		#
		# or export as matrix:
		cat("Exporting matrices...",sep="\n")
		mydf			<- rbind(data.frame(do.call(rbind,bonflist)),data.frame(do.call(rbind,bonffdr)))
		rownames(mydf)	<- c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt","FDR_GWDS","FDR_OutFLANK","FDR_PCadapt")
		tablename		<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),"bonferroni.txt",sep=".")
		write.table(mydf,tablename,quote=FALSE,sep="\t",row.names=TRUE,col.names=TRUE)	
		#
		mydf			<- rbind(data.frame(do.call(rbind,holmlist)),data.frame(do.call(rbind,holmfdr)))
		rownames(mydf)	<- c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt","FDR_GWDS","FDR_OutFLANK","FDR_PCadapt")
		tablename		<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),"holm.txt",sep=".")
		write.table(mydf,tablename,quote=FALSE,sep="\t",row.names=TRUE,col.names=TRUE)	
		#
		mydf			<- rbind(data.frame(do.call(rbind,bhlist)),data.frame(do.call(rbind,bhfdr)))
		rownames(mydf)	<- c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt","FDR_GWDS","FDR_OutFLANK","FDR_PCadapt")
		tablename		<- paste("FDR_vs_correctionmethod",paste("comp",my_comp,sep=""),paste("s",selection_coefficient,sep=""),paste("nSNPs",loci_nr,sep=""),paste("samplesize",samples_nr,sep=""),paste("ngen",gen_nr,sep=""),"BH.txt",sep=".")
		write.table(mydf,tablename,quote=FALSE,sep="\t",row.names=TRUE,col.names=TRUE)
		#
		# another way of presenting the data:
		bonfpowermat<-round(do.call("rbind",bonflist),5)
		rownames(bonfpowermat)<-c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt")
		write.table(bonfpowermat,"bonferroni_table.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
		#
		holmpowermat<-round(do.call("rbind",holmlist),5)
		rownames(holmpowermat)<-c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt")
		write.table(holmpowermat,"holm_table.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
		#
		bhpowermat<-round(do.call("rbind",bhlist),5)
		rownames(bhpowermat)<-c("power_GWDS","power_OutFLANK","power_PCadapt","spec_GWDS","spec_OutFLANK","spec_PCadapt")
		write.table(bhpowermat,"bh_table.txt",quote=FALSE,row.names=TRUE,col.names=TRUE,sep="\t")
		}
	cat("Finished :-)",sep="\n")
	}

#outliersim(export=TRUE,nloc=10000,ngen=12000,nesourcepop=10000,nefounderpop1=5000,nefounderpop2=5000,nfounders=5000,selcoef=0.01,samplesize=30,nselectedloci=100,do_selectionscan=TRUE,do_plotpvalues=FALSE)
	
# requires functions 'getfounderpopmaf', 'mafsim' and 'getgenotypesfrommaf'	
# outputs:
# - mymafstartmatrix with maf frequencies at ngen=0, so of source pop before founder event and founder pops just after founder event
# - with allele counts after ngen generations of founderpop1, founderpop2, both founders, and source 
# - mytestscores with power and specificity of GWDS, OutFLANK and PCadapt

# The manhattan plot shows gwds scores. All SNPs above threshold are marked as outlier by GWDS. All points in green are marked by PCadapt as outliers. All points in orange are marked by Outflank as outliers.
outliersim<-function(export=TRUE,my_alpha=0.05,my_quantile=1,mycorrection="none",nloc=1000,ngen=20,ngen_before_founder=200,sim_source=TRUE,nesourcepop=1000,meansourcemaf=0.1,nefounderpop1=20,nefounderpop2=200,nfounders=10,samplesize=30,testgeno=FALSE,nselectedloci=0,selcoef=0.1,s_discrete=TRUE,parallelselection=TRUE,neutralcol="#99CCFF",do_haploid=TRUE,do_venn=TRUE,do_Fdist=TRUE,do_logplot=TRUE,do_selectionscan=TRUE,my_round=5,power_for_retained_only=FALSE,show_adjustedp=FALSE,createplots=TRUE)
	{
	if(!do_haploid)
		{
		return(cat("ERROR: currently allele frequencies can only reliably be simulated using the haploid approach. Please set the do_haploid flag to TRUE.",sep="\n")) 
		}
	if(exists("macmatrix")){macmatrix	<<- NULL}
	if(exists("simscanout")){simscanout	<<- NULL}
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	# mycorrection for multiple testing can be:
	# "none" (no correction)
	# "bonferroni"
	# "holm"
	# "BH" (Benjamini-Hochberg)
	#
	# if parallelselection=TRUE, for pooled comparisons the function will generate estimates considering only SNPs of which both alleles are retained in both founder populations. 
	# downside of setting this flag to TRUE is that then we don't see possible signals of selection in the pooled comparison resulting from selection in one population only.  
	#
	# we need to round power and specificity estimates to many decimals (default 5) in order to avoid rounding confusion. 
	#
	if(nloc-nselectedloci<100&do_selectionscan)
		{
		return(cat("Error: less than 100 neutral loci (nloc-nselectedloci). Not enough neutral loci to infer a neutral distribution.",sep="\n"))
		}
	if(nselectedloci/nloc>0.1&do_selectionscan)
		{
		return(cat("Error: More than 10 percent of loci are adaptive (nselectedloci/nloc). PCadapt won't be able to infer a neutral distribution.",sep="\n"))
		}
	if(nselectedloci>=nloc)
		{
		return(cat("Error: nselectedloci needs to be lower than nloc.",sep="\n"))
		}
	#
	cat("###### SETTINGS WHILST RUNNING OUTLIERSIM ######",sep="\n")
	cat(paste("  Specified number of loci: ",nloc,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",nselectedloci,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficient: ",selcoef,".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",ngen,".",sep=""),sep="\n")
	cat(paste("  Specified Ne source population: ",nesourcepop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 1: ",nefounderpop1,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 2: ",nefounderpop2,".",sep=""),sep="\n")
	cat(paste("  Specified number of founders: ",nfounders,".",sep=""),sep="\n")
	cat(paste("  Specified samplesize: ",samplesize,".",sep=""),sep="\n")
	cat(paste("  Parallel selection: ",parallelselection,".",sep=""),sep="\n")
	cat(paste("  Simulate source MAF: ",sim_source,".",sep=""),sep="\n")
	cat(paste("  Testgeno: ",testgeno,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",s_discrete,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",do_haploid,".",sep=""),sep="\n")
	cat(paste("  When calculating FN, FP and FDR for the pooled comparison, only consider SNPs which have been retained in both populations: ",parallelselection,".",sep=""),sep="\n")
	if(!do_haploid&s_discrete)
		{
		return(cat("Error: The flag dodiscrete is set to TRUE but the flag s_discrete is set to FALSE. The function mafsim() does not allow to simulate simulation discretely if not assuming haploidy.",'\n'))
		} 
	#
	if(export)
		{
		current_dir		<- getwd()
		if(parallelselection)
			{
			out_dir			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"in_both",sep=".")
			}else{
			out_dir			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"either",sep=".")
			}
		my_dir			<- paste(current_dir,out_dir,sep="/")
		if(!file.exists(my_dir)){dir.create(file.path(my_dir))}
		setwd(my_dir)
		}else{
		current_dir		<- getwd()
		}
	founderpopsizes		<- rbind(nefounderpop1,nefounderpop2)
	# To store results:
	genotypecounts		<- list()
	pvaluevec			<- vector()
	pvaluepairwise		<- matrix(nrow=3,ncol=nloc) 
	macmatrix			<- matrix(nrow=8,ncol=nloc)
	rownames(macmatrix)	<- c("founder1_A","founder1_a","founder2_A","founder2_a","founders_A","founders_a","source_A","source_a")
	#
	# Simulate source mafs at the time of founder event:
	if(sim_source)
		{
		# generate a natural distribution of minor allele frequencies:
		# I tried poisson function, but that doesn't produce a typical maf-distribution
		cat("###### SIMULATING MAC DISTRIBUTION OF SOURCE POPULATION PRIOR TO FOUNDER EVENT ######",sep="\n") 
		sourcemaf			<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=ngen_before_founder,meanmaf=meansourcemaf,haploid=do_haploid)
		}else{
		# generate a flat distribution of minor allele frequencies:
		sourcemaf			<- rep(meansourcemaf,nloc)
		}
	#
	# Simulate source mac and after ngen generations:
	cat("###### GENERATING MAC DISTRIBUTION OF SOURCE POPULATION AFTER N GENERATIONS ######",sep="\n")
	mymafendmatrix		<- matrix(NA,nrow=3,ncol=nloc)
	mafvec				<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=ngen,mafstartvector=sourcemaf,haploid=do_haploid)		# population allele frequencies
	macmatrix[8,]		<- sapply(mafvec,function(mafvec){rbinom(1,(2*samplesize),mafvec)})									# sample allele counts
	mymafendmatrix[3,]	<- mafvec 
	if(testgeno)
		{
		genotypecounts[[4]]<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
		}
	#
	# Simulate founder macs directly after founder event and after ngen generations:
	cat("###### GENERATING MAC DISTRIBUTION OF FOUNDER POPULATIONS AFTER FOUNDER EVENT AND AFTER N GENERATIONS ######",sep="\n")
	founderstartmatrix	<- matrix(nrow=2,ncol=nloc)
	for (k in c(1:2))
		{
		cat(paste("FOUNDER POPULATION ",k,".",sep=""),sep="\n")
		mafvec					<- getfounderpopmaf(sourcemafvector=sourcemaf,nrfounders=nfounders,nefounderpop=founderpopsizes[k,],nrloci=nloc,ngenfounder=ngen,nselectloci=nselectedloci,selc=selcoef,dohap=do_haploid,dodiscrete=s_discrete)
		mymafendmatrix[k,]		<- mafvec 																						# population allele frequencies
		macmatrix[k*2,]			<- sapply(mafvec,function(mafvec){rbinom(1,(2*samplesize),mafvec)})							# sample allele counts
		founderstartmatrix[k,]	<- mysambarsim$founderstartmaf 
		if(testgeno)
			{
			genotypecounts[[k]]<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
			}
		}
	mymafstartmatrix			<- rbind(founderstartmatrix,sourcemaf)
	rownames(mymafstartmatrix)	<- c("founderstartmaf1","founderstartmaf2","sourcestartmaf")
	sourcemaf_nonzero			<- sourcemaf>0
	#
	mysambarsim$mymafstartmatrix<<- mymafstartmatrix
	mysambarsim$mymafendmatrix	<<- mymafendmatrix
	#
	###### Execute fisher's exact test on simulated data using built-in R-function:  
	cat("###### RUNNING SELECTION SCANS ######",sep="\n")
	if(testgeno)
		{
		# if testgeno (default is FALSE), execute rfisher test on genotype counts rather than on minor allele counts
		# Combine both founder populations into one founder population:
		genotypecounts[[3]]<- genotypecounts[[1]]+genotypecounts[[2]]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons, for source against source (pointless indeed), as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(7,8,2*j-1,2*j),i],2,2,byrow=TRUE)})
			pvaluepairwise[j,]	<<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
			}
		}else{
		# Combine both founder populations into one founder population:
		macmatrix[6,]	<- macmatrix[2,]+macmatrix[4,]
		# calculate number of major alleles:
		macmatrix[1,]	<- 2*samplesize-macmatrix[2,]
		macmatrix[3,]	<- 2*samplesize-macmatrix[4,]
		macmatrix[5,]	<- 4*samplesize-macmatrix[6,]
		macmatrix[7,]	<- 2*samplesize-macmatrix[8,]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons,as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(7,8,2*j-1,2*j),i],2,2,byrow=TRUE)})
			pvaluepairwise[j,]	<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
			}
		}
	mysambarsim$macmatrix		<<- macmatrix
	# negative log of pvalues:
	logp					<- (-log(pvaluepairwise))
	rownames(logp)			<- c("F1vsS","F2vsS","FcombivsS")
	# how many (minor) alleles passed through bottleneck event?
	# adaptive loci:
	nneutralloci			<- nloc-nselectedloci
	temp					<- sourcemaf_nonzero[c(1:nneutralloci)]
	nneutralloci_nonzero	<- length(temp[temp])
	if(nneutralloci<nloc)
		{
		temp					<- sourcemaf_nonzero[c((nneutralloci+1):nloc)]
		nadaptiveloci_nonzero	<- length(temp[temp])
		retained_variation		<- apply(founderstartmatrix[,c(nneutralloci+1):nloc],2,min)>0
		retained_variation_1	<- founderstartmatrix[1,c(nneutralloci+1):nloc]>0
		retained_variation_2	<- founderstartmatrix[2,c(nneutralloci+1):nloc]>0
		nretained_select_both	<- length(retained_variation[retained_variation])
		nretained_select_1		<- length(retained_variation_1[retained_variation_1])
		nretained_select_2		<- length(retained_variation_2[retained_variation_2])
		nretained_select_either	<- length(union(which(founderstartmatrix[1,c(nneutralloci+1):nloc]>0),which(founderstartmatrix[2,c(nneutralloci+1):nloc]>0)))
		retained_both_snpid		<- nneutralloci+(intersect(which(founderstartmatrix[1,c((nneutralloci+1):nloc)]>0),which(founderstartmatrix[2,c((nneutralloci+1):nloc)]>0)))
		retained_either_snpid	<- nneutralloci+(union(which(founderstartmatrix[1,c((nneutralloci+1):nloc)]>0),which(founderstartmatrix[2,c((nneutralloci+1):nloc)]>0)))
		}else{
		retained_both_snpid		<- NULL
		retained_either_snpid	<- NULL
		}
	# neutral loci:
	retained_variation_all	<- apply(founderstartmatrix[,c(1:nneutralloci)],2,min)>0
	retained_variation_all_1<- founderstartmatrix[1,c(1:nneutralloci)]>0
	retained_variation_all_2<- founderstartmatrix[2,c(1:nneutralloci)]>0
	nretained_neutral_both	<- length(retained_variation_all[retained_variation_all])
	nretained_neutral_1		<- length(retained_variation_all_1[retained_variation_all_1])
	nretained_neutral_2		<- length(retained_variation_all_2[retained_variation_all_2])
	nretained_neutral_either<- length(union(which(founderstartmatrix[1,c(1:nneutralloci)]>0),which(founderstartmatrix[2,c(1:nneutralloci)]>0)))
	#
	# how many alleles fixated?
	mytestscores			<- matrix(NA,ncol=16,nrow=4)
	colnames(mytestscores)	<- c("retained_adaptive","retained_neutral","gwds_FN","gwds_FP","PCadapt_FN","PCadapt_FP","OutFLANK_FN","OutFLANK_FP","fixed_adaptive","fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected")
	rownames(mytestscores)	<- c("F1_vs_S","F2_vs_S","pooled_F_vs_S","compare_F_vs_S")
	for(i in c(1:3))
		{
		myfactor			<- ifelse(i==3,4,2)		# if pooled approach, times 4, if pairwise approach, times 2. E.g. if samplesize is 30, then in total 60 alleles per population, and 120 alleles for both founder populations combined  
		# neutral loci:
		if(nneutralloci<nloc)
			{
			mactemp			<- macmatrix[2*i,c(1:nneutralloci)]
			}else{
			mactemp			<- macmatrix[2*i,]
			}
		maftemp				<- mactemp/(samplesize*myfactor)
		mytestscores[i,10]	<- round(length(maftemp[maftemp==1])/length(maftemp),3)
		# adaptive loci:
		if(nneutralloci<nloc)
			{
			mactemp			<- macmatrix[2*i,c((nneutralloci+1):nloc)]
			}else{
			mactemp			<- 0
			}
		maftemp				<- mactemp/(samplesize*myfactor)	
		mytestscores[i,9]	<- round(length(maftemp[maftemp==1])/length(maftemp),3)
		}
	# GWDS and Manhattan plot:
	mysambarsim$gwdsoutlierslist	<<- list() 
	mysambarsim$pcadaptoutlierslist	<<- list()
	mysambarsim$outflankoutlierslist<<- list()
	mysambarsim$gwdslogplist		<<- list()
	mysambarsim$gwdslognewplist		<<- list()
	mysambarsim$pcadaptlogplist		<<- list()
	mysambarsim$outflanklogqlist	<<- list()
	mysambarsim$outflanklogplist	<<- list()
	testFDR							<- as.data.frame(matrix(NA,ncol=3,nrow=3))
	colnames(testFDR)				<- c("gwds","outflank","pcadapt")
	rownames(testFDR)				<- c("pairwise1","pairwise2","pooled")
	#
	graphics.off()
	plotname				<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"manhattan.pdf",sep=".")
	if(export){pdf(plotname,height=8,width=14)}
	par(mfrow=c(3,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	mycomparisons			<- c("F1 vs S","F2 vs S","both_F vs S")
	for(i in (c(1:3)))
		{
		cat(paste("###### ",mycomparisons[i]," ######",sep=""),sep="\n")
		#mylogp				<<- logp
		mymax				<- round(max(logp[is.finite(logp)],na.rm=TRUE))
		plot(logp[i,],col=neutralcol,ylim=c(0,mymax),pch=16,ylab="",xlab="",main="",xaxt='n',las=2)
		if(i==3){axis(1,at=seq(0,nloc,nloc/5),labels=seq(0,nloc,nloc/5))}
		mytitle				<- ifelse(i==1,"founder_1 vs source",(ifelse(i==2,"founder_2 vs source","both founders vs source")))
		mtext(mytitle,side=4,line=1,cex=1.25)
		mylogp				<- logp[i,]
		mylogpneutral		<- mylogp[c(1:nneutralloci)]
		myreflogp			<- mylogp
		mymean				<- mean(mylogpneutral[mylogpneutral<quantile(mylogpneutral,my_quantile)])	
		cat(paste("Mean ln(fisher exact test p-value):",round(mymean,2),sep=" "),sep="\n")
		myrate				<- 1/mymean
		gwds_pvalues		<- 1-pexp(mylogp,myrate)			# 03-08-2020: convert fisher exact test p-values to GWDS p-values: 
		mythres				<- 1-(my_alpha/nneutralloci)
		myvalue				<- qexp(mythres,myrate)
		gwdsout				<- which(mylogp>=myvalue)
		gwds_pvalues_uncorrected	<- gwds_pvalues
		if(mycorrection=="none")
			{
			cat(paste("Threshold Fisher exact test log p-value: ",round(myvalue,2),".",sep=""),sep="\n")
			#cat(paste("Threshold:",round(myvalue,2),sep=" "),sep="\n")
			ndetected_neutral		<- length(mylogpneutral[mylogpneutral>myvalue])
			}else{
			cat(paste("Correcting GWDS p-values using the ",mycorrection," method.",sep=""),sep="\n")
			gwds_pvalues			<- p.adjust(gwds_pvalues,method=mycorrection)
			gwdsout					<- which(gwds_pvalues<=my_alpha)
			gwds_pvalues_neutral	<- gwds_pvalues[1:nneutralloci]
			ndetected_neutral		<- length(mylogpneutral[gwds_pvalues_neutral<=my_alpha])
			}
		cat(paste("GWDS detected",length(gwdsout),"outlier loci.",sep=" "),sep="\n")
		my_fdr					<- ifelse(ndetected_neutral>0,1,0)						# we next correct this value if the simulation includes loci under selection
		if(nneutralloci<nloc)
			{
			if(parallelselection)
				{
				mylogpoutliers			<- mylogp[retained_both_snpid]		
				pvalues_retainedadaptive<- gwds_pvalues[retained_both_snpid]
				}else{
				mylogpoutliers			<- mylogp[retained_either_snpid]
				pvalues_retainedadaptive<- gwds_pvalues[retained_either_snpid]
				}
			# mylogpoutliers	<- mylogp[c(nneutralloci+1):nloc]
			ndetected_outliers	<- length(mylogpoutliers[mylogpoutliers>myvalue])
			if(mycorrection!="none")
				{
				ndetected_outliers	<- length(pvalues_retainedadaptive[pvalues_retainedadaptive<=my_alpha]) 
				}
			# 07-08-2020: note: false discovery rate ultimately depends on the proportion of adaptive loci in your dataset, and is hence not really informative.
			# for example: say power is 40% and specificity is 99.9%.
			# if you have 100.000 SNPs, of which 10.000 are adaptive, then false discovery rate is:
			# ((1-0.999)*90000)/(0.4*10000+((1-0.999)*90000)) = 0.022 = 2.2%
			# however, if you have 100K SNPs, of which only 10 are adaptive, then false discovery rate:
			# ((1-0.999)*90000)/(0.4*10+((1-0.999)*90000)) = 0.957 = 96%
			#
			my_fdr				<- ndetected_neutral/(ndetected_neutral+ndetected_outliers)
			nretained_select	<- ifelse(i==1,nretained_select_1,(ifelse(i==2,nretained_select_2,ifelse(parallelselection,nretained_select_both,nretained_select_either))))
			mytestscores[i,1]	<- round(nretained_select/nadaptiveloci_nonzero,my_round)						# proportion retained
			mytestscores[i,3]	<- round((nretained_select-ndetected_outliers)/(nretained_select),my_round)		# inverse of power
			mytestscores[i,11]	<- ndetected_neutral
			}else{
			ndetected_outliers	<- 0
			}
		testFDR[i,1]				<- my_fdr 
		nretained_neutral			<- ifelse(i==1,nretained_neutral_1,(ifelse(i==2,nretained_neutral_2,ifelse(parallelselection,nretained_neutral_both,nretained_neutral_either))))
		mytestscores[i,2]			<- round(nretained_neutral/nneutralloci_nonzero,my_round)
		#mytestscores[i,4]			<- round(ndetected_neutral/nneutralloci_nonzero,nchar(nneutralloci))
		mytestscores[i,4]			<- round(ndetected_neutral/nneutralloci_nonzero,my_round)
		mytestscores[i,12]			<- ndetected_outliers
		# add threshold to plot:
		abline(h=myvalue,lty=2) 
		mylogp[is.na(mylogp)]		<- 0	
		mysambarsim$gwdslogplist[[i]]			<<- mylogp
		mysambarsim$gwdslognewplist[[i]]		<<- -log10(gwds_pvalues_uncorrected)
		# threshold if including outliers:
		# mymean				<- mean(mylogp)	
		# myrate				<- 1/mymean
		# mybonf				<- 1-(0.05/(length(mylogp)))
		# myvalue				<- qexp(mybonf,myrate)
		# abline(h=myvalue,lty=2) 
		# Note: If selected loci are included in the simulation, this affects the overall distribution of the test parameter (such a -logp.)
		# Therefore, best to obtain neutral distribution from neutral loci only.
		# This is possible for gwds and for Outflank.
		# Not possible for PCadapt.
		# However, PCadapt seems to find it easier to recognize neutral loci as non-outlier if outliers are included. 
		# PCadapt and OutFLANK:
		if(i==3)
			{
			nsamples			<- c(2*samplesize,samplesize)
			nretained_select	<- ifelse(nneutralloci<nloc,ifelse(parallelselection,nretained_select_both,nretained_select_either),0)			# choose whether allele should have been retained in both pops during bottleneck event
			nretained_neutral	<- ifelse(parallelselection,nretained_neutral_both,nretained_neutral_either)
			}else{
			nsamples			<- c(samplesize,samplesize)
			if(i==1)
				{
				nretained_select	<- ifelse(nneutralloci<nloc,nretained_select_1,0)
				nretained_neutral	<- nretained_neutral_1
				}else{
				nretained_select	<- ifelse(nneutralloci<nloc,nretained_select_2,0)
				nretained_neutral	<- nretained_neutral_2
				}
			}
		n_inds_founder		<- samplesize*2		# 2 populations combined
		# 30-08-2020: previously it stated for all comparisons: mymaf_1 <- macmatrix[i*2,]/(n_inds_founder*2) 
		if(i==3)
			{
			mymaf_1				<- macmatrix[i*2,]/(n_inds_founder*2)	
			}else{
			mymaf_1				<- macmatrix[i*2,]/(samplesize*2)
			}
		mymaf_2				<- macmatrix[8,]/(samplesize*2)
		cat(paste("Number of individuals per founder population: ",samplesize,".",sep=""),sep="\n")
		cat(paste("Number of individuals in both founder populations combined: ",n_inds_founder,".",sep=""),sep="\n")
		cat(paste("Number of individuals in source population: ",samplesize,".",sep=""),sep="\n")
		if(do_selectionscan)
			{
			simscanout		<- simscan(my_correction=mycorrection,myalpha=my_alpha,sample_sizes=nsamples,mafvector1=mymaf_1,mafvector2=mymaf_2,n_selected=nselectedloci,store_adjusted=show_adjustedp)
			outflankout		<- simscanout[[1]]	
			outflanklogq	<- simscanout[[2]]	
			pcadaptout		<- simscanout[[3]]	
			pcadaptlogp		<- simscanout[[4]]
			outflanklogp	<- simscanout[[5]]
			testFDR[i,2]	<- mysambarsim$outflankfdr_value
			testFDR[i,3]	<- mysambarsim$pcadaptfdr_value
			# cat(max(pcadaptlogp,na.rm=TRUE),sep="\n")
			# what are the logp scores of the outliers detected by pcadapt and outflank? 
			gwdslogp_pcadaptout		<- logp[i,pcadaptout]
			points(pcadaptout,gwdslogp_pcadaptout,col="darkgreen",cex=1.5,pch=16)
			gwdslogp_outflankout	<- logp[i,outflankout]
			#if(any(outflankout)
			#	{
				points(outflankout,gwdslogp_outflankout,col="orange",cex=2.5)
			#	}
			# what is the sensitivity and specificity of PCadapt?
			if(parallelselection)
				{
				npcadaptout_select	<- length(pcadaptout[pcadaptout%in%retained_both_snpid])
				outflankout_select	<- length(outflankout[outflankout%in%retained_both_snpid])
				}else{
				npcadaptout_select	<- length(pcadaptout[pcadaptout%in%retained_either_snpid])
				outflankout_select	<- length(outflankout[outflankout%in%retained_either_snpid])
				}
			#npcadaptout_select		<- length(pcadaptout[pcadaptout>nneutralloci])
			#outflankout_select		<- length(outflankout[outflankout>nneutralloci])
			npcadaptout_neutral		<- length(pcadaptout[pcadaptout<=nneutralloci])
			outflankout_neutral		<- length(outflankout[outflankout<=nneutralloci])
			if(nneutralloci<nloc)
				{
				mytestscores[i,5]		<- round((nretained_select-npcadaptout_select)/(nretained_select),3)
				mytestscores[i,7]		<- round((nretained_select-outflankout_select)/(nretained_select),3)
				}
			mytestscores[i,6]		<- round(npcadaptout_neutral/nretained_neutral,nchar(nneutralloci))
			mytestscores[i,8]		<- round(outflankout_neutral/nretained_neutral,nchar(nneutralloci))
			mytestscores[i,13]		<- outflankout_neutral
			mytestscores[i,14]		<- outflankout_select
			mytestscores[i,15]		<- npcadaptout_neutral
			mytestscores[i,16]		<- npcadaptout_select
			# store outlier loci:
			pcadaptlogp[is.na(pcadaptlogp)]		<- 0
			outflanklogq[is.na(outflanklogq)]	<- 0
			outflanklogp[is.na(outflanklogp)]	<- 0
			mysambarsim$pcadaptlogplist[[i]]	<<- pcadaptlogp
			mysambarsim$outflanklogqlist[[i]]	<<- outflanklogq
			mysambarsim$outflanklogplist[[i]]	<<- outflanklogp
			mysambarsim$gwdsoutlierslist[[i]]	<<- gwdsout
			mysambarsim$pcadaptoutlierslist[[i]]<<- pcadaptout
			mysambarsim$outflankoutlierslist[[i]]<<- outflankout
			}
		}
	mtext("Fisher exact test score",side=2,line=0.5,cex=2.5,outer=TRUE)
	mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
	if(export){dev.off()}
	if(export)
		{
		fileConn	<- file("README.txt")
		writeLines(c("The Manhattan plot shows the Fisher exact test scores for both pairwise comparisons and for the pooled comparisons (both founders vs source).",
		"Selected SNPs are at the right hand side of the plot.",
		"Dots above the dashed line are marked by GWDS as outliers.",
		"Green dots are marked by PCadapt as outliers.",
		"Yellow encircled dots are marked by OutFLANK as outliers.",
		"The Venn diagram shows the overlap between true selected SNPs and SNPs marked by the selection scans.", 
		"The Fdist plots show the Cockerham & Weir 1987 He and Fst values of SNPs for both pairwise comparisons (.1 and .2) and the pooled comparison (.3).",
		"Red dots in the left tile are true SNPs under selection.",
		"Red dots in the other tiles are SNPs marked by selection scans.",
		""),fileConn)
		close(fileConn)
		}
	#
	# compare outliers detected in pairwise comparisons to outliers detected by pooled approach:
	overlapmatrix		<- matrix(NA,ncol=2,nrow=3)
	gwdsoutlierslist	<- mysambarsim$gwdsoutlierslist
	if(length(gwdsoutlierslist)==3)
		{
		gwds1neutral		<- gwdsoutlierslist[[1]][gwdsoutlierslist[[1]]<=nneutralloci]
		gwds1adaptive		<- gwdsoutlierslist[[1]][gwdsoutlierslist[[1]]>nneutralloci]
		gwds2neutral		<- gwdsoutlierslist[[2]][gwdsoutlierslist[[2]]<=nneutralloci]
		gwds2adaptive		<- gwdsoutlierslist[[2]][gwdsoutlierslist[[2]]>nneutralloci]
		gwds3neutral		<- gwdsoutlierslist[[3]][gwdsoutlierslist[[3]]<=nneutralloci]
		gwds3adaptive		<- gwdsoutlierslist[[3]][gwdsoutlierslist[[3]]>nneutralloci]
		overlapmatrix[1,1]	<- length(which(gwds3adaptive %in% gwds1adaptive))/length(gwds3adaptive)
		overlapmatrix[1,2]	<- length(which(gwds3adaptive %in% gwds2adaptive))/length(gwds3adaptive)
		}else{
		overlapmatrix[1,1]	<- 0
		overlapmatrix[1,2]	<- 0
		}
	pcadaptoutlierslist	<- mysambarsim$pcadaptoutlierslist
	if(length(pcadaptoutlierslist)==3)
		{
		pcadapt1neutral		<- pcadaptoutlierslist[[1]][pcadaptoutlierslist[[1]]<=nneutralloci]
		pcadapt1adaptive	<- pcadaptoutlierslist[[1]][pcadaptoutlierslist[[1]]>nneutralloci]
		pcadapt2neutral		<- pcadaptoutlierslist[[2]][pcadaptoutlierslist[[2]]<=nneutralloci]
		pcadapt2adaptive	<- pcadaptoutlierslist[[2]][pcadaptoutlierslist[[2]]>nneutralloci]
		pcadapt3neutral		<- pcadaptoutlierslist[[3]][pcadaptoutlierslist[[3]]<=nneutralloci]
		pcadapt3adaptive	<- pcadaptoutlierslist[[3]][pcadaptoutlierslist[[3]]>nneutralloci]
		overlapmatrix[2,1]	<- length(which(pcadapt3adaptive %in% pcadapt1adaptive))/length(pcadapt3adaptive)
		overlapmatrix[2,2]	<- length(which(pcadapt3adaptive %in% pcadapt2adaptive))/length(pcadapt3adaptive)
		}else{
		overlapmatrix[2,1]	<- 0
		overlapmatrix[2,2]	<- 0
		}
	outflankoutlierslist	<- mysambarsim$outflankoutlierslist
	if(length(mysambarsim$outflankoutlierslist)==3)
		{
		outflank1neutral	<- outflankoutlierslist[[1]][outflankoutlierslist[[1]]<=nneutralloci]
		outflank1adaptive	<- outflankoutlierslist[[1]][outflankoutlierslist[[1]]>nneutralloci]
		outflank2neutral	<- outflankoutlierslist[[2]][outflankoutlierslist[[2]]<=nneutralloci]
		outflank2adaptive	<- outflankoutlierslist[[2]][outflankoutlierslist[[2]]>nneutralloci]
		outflank3neutral	<- outflankoutlierslist[[3]][outflankoutlierslist[[3]]<=nneutralloci]
		outflank3adaptive	<- outflankoutlierslist[[3]][outflankoutlierslist[[3]]>nneutralloci]
		overlapmatrix[3,1]	<- length(which(outflank3adaptive %in% outflank1adaptive))/length(outflank3adaptive)
		overlapmatrix[3,2]	<- length(which(outflank3adaptive %in% outflank2adaptive))/length(outflank3adaptive)
		}else{
		overlapmatrix[3,1]	<- 0
		overlapmatrix[3,2]	<- 0
		}
	overlapdf				<- as.data.frame(overlapmatrix)
	colnames(overlapdf)		<- c("Pop1","Pop2")
	rownames(overlapdf)		<- c("gwds","pcadapt","outflank")
	mysambarsim$overlapdf	<<- overlapdf
	#
	# comparison between outliers scored by GWDS in both pairwise comparisons separately:
	if(do_selectionscan&nneutralloci<nloc)
		{
		nretained_select	<- ifelse(parallelselection,nretained_select_both,nretained_select_either)			# choose whether allele should have been retained in both pops during bottleneck event
		nretained_neutral	<- ifelse(parallelselection,nretained_neutral_both,nretained_neutral_either)
		myoverlap			<- intersect(gwdsoutlierslist[[1]],gwdsoutlierslist[[2]])							# same as: gwdsoutlierslist[[1]] %in% gwdsoutlierslist[[2]]
		ndetected_overlap	<- length(myoverlap[myoverlap])
		falseneg			<- round((nretained_select-ndetected_overlap)/(nretained_select),my_round)
		myoverlap_neutral	<- myoverlap[myoverlap>nneutralloci]
		ndetected_overlap_neutral<- length(myoverlap_neutral[myoverlap_neutral])
		mytestscores[4,1]	<- round(nretained_select/nselectedloci,my_round)
		mytestscores[4,2]	<- round(nretained_neutral/nneutralloci,my_round)
		mytestscores[4,3]	<- round((nretained_select-ndetected_overlap)/(nretained_select),my_round)
		mytestscores[4,4]	<- (ndetected_overlap_neutral)/nretained_neutral
		}
	#
	if(createplots)
		{
		cat("##### GENERATING OUTPUT PLOTS ######",sep="\n")
		cat("Plotting minor allele counts...",sep="\n")
		plotmac(export=TRUE,nloci=nloc,nselect=nselectedloci,sample_size=samplesize)
		if(do_selectionscan&do_logplot)
			{
			cat("Plotting teststatistics...",sep="\n")
			if(mycorrection=="none")
				{
				# 04-03-19: my simulations showed that OutFlank has lowest FDR when not using qvalues (default), but when using holm corrected p values
				# plotlogvalues(do_export=export,nr_loci=nloc,nr_selected=nselectedloci,plotqvalue=TRUE)
				plotlogvalues(do_export=export,nr_loci=nloc,nr_selected=nselectedloci,plotqvalue=FALSE)
				}else{
				plotlogvalues(do_export=export,nr_loci=nloc,nr_selected=nselectedloci,plotqvalue=FALSE)
				}
			}else{
			cat("Skipping teststatistic plots.",sep="\n")
			}
		if(do_selectionscan&do_Fdist)
			{
			cat("Creating Fdist plots...",sep="\n")
			simFdist(addbayescan=FALSE,do_export=export,nloci=nloc,nselloci=nselectedloci,n_samples=samplesize,retainedin1pop=TRUE)
			}
		# Generate 2D Manhattan plot with negative log of pvalues:
		if(do_selectionscan&do_logplot)
			{
			cat("Generating 2D test statistic plots...",sep="\n")
			multiplotp_sim(export="pdf",nr_loci=nloc,nr_selected=nselectedloci)
			}
		if(do_venn)
			{
			if(nneutralloci<nloc)
				{
				if(parallelselection)
					{
					my_realoutliers		<- retained_both_snpid
					}else{
					my_realoutliers		<- retained_either_snpid
					}
				}else{
				my_realoutliers		<- NULL
				}
			venn_plotname			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"Venn",sep=".")
			if(nselectedloci>0)
				{
				plotvennsim(export="pdf",plotname=venn_plotname,myrealoutliers=my_realoutliers)
				}
			}
		if(nselectedloci>0)
			{
			multioverlap_approach_sim(doexport="pdf",add_numbers=FALSE)
			}
		if(exists("snps"))
			{
			if("Barff"%in%mysambar$population2)
				{
				exp_nout(bayescanfile=NULL,export="pdf")
				}
			}
		}
	#
	# output test scores:
	cat("Generating testscore tables...",sep="\n")
	mytestscores						<- as.data.frame(mytestscores)
	mytestscores$fixed_adaptive2		<- round(mytestscores$fixed_adaptive/mytestscores$retained_adaptive,my_round)
	mytestscores$fixed_neutral2			<- round(mytestscores$fixed_neutral/mytestscores$retained_neutral,my_round)
	mytestscores2						<- 1-mytestscores
	colnames(mytestscores2)				<- c("loss_adaptive","loss_neutral","gwds_power","gwds_specificity","PCadapt_power","PCadapt_specificity","OutFLANK_power","OutFLANK_specificity","non_fixed_adaptive","non_fixed_neutral","gwds_nout_neutral","gwds_nout_adaptive","outflank_nout_neutral","outflank_nout_adaptive","pcadapt_nout_neutral","pcadapt_nout_detected","non_fixed_adaptive2","non_fixed_neutral2")
	mytestscores2$gwds_nout_neutral		<- mytestscores$gwds_nout_neutral
	mytestscores2$gwds_nout_adaptive	<- mytestscores$gwds_nout_adaptive
	mytestscores2$outflank_nout_neutral	<- mytestscores$outflank_nout_neutral
	mytestscores2$outflank_nout_adaptive<- mytestscores$outflank_nout_adaptive
	mytestscores2$pcadapt_nout_neutral	<- mytestscores$pcadapt_nout_neutral
	mytestscores2$pcadapt_nout_detected	<- mytestscores$pcadapt_nout_detected
	#
	mysambarsim$mytestscores			<<- mytestscores
	mysambarsim$mytestscores2			<<- mytestscores2
	#
	if(parallelselection)
		{
		tablename			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"bothpop",sep=".")
		}else{
		tablename			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"eitherpop",sep=".")
		}
	if(export)
		{
		write.table(mytestscores,file=paste(tablename,"testscores1.txt",sep="."),quote=FALSE)
		write.table(mytestscores2,file=paste(tablename,"testscores2.txt",sep="."),quote=FALSE)
		setwd(current_dir)
		}
	#nneutralloci		<<- c(nneutralloci_nonzero,nneutralloci,nneutralloci_nonzero/nneutralloci)	
	if(do_selectionscan)
		{
		cat("Generating False Discovery Rate table...",sep="\n")
		testFDR2					<- as.matrix(testFDR)
		testFDR2[is.nan(testFDR2)] 	<- NA
		testFDR2[is.na(testFDR2)] 	<- 0
		testFDR2					<- round(testFDR2,my_round)
		testFDR						<- testFDR2
		}
	mysambarsim$testFDR				<<- testFDR
	}	

plotmac<-function(export=FALSE,nloci=10000,nselect=1000,sample_size=100)
	{
	macmatrix	<- mysambarsim$macmatrix
	if(export){pdf("Minor_allele_counts.pdf",height=8,width=8)}
	par(mfrow=c(4,1))
	par(mfrow=c(4,1),mar=c(1,1,1,1),oma=c(3,4,1,2.5),cex.axis=1.5,cex.lab=2.5)
	#mymax	<- max(macmatrix[6,])
	mymax	<- sample_size*2	# diploid (2 alleles per individual) 
	mymax2	<- sample_size*2*2	# diploid (2 alleles per individual); 2 populations combined 
	plot(macmatrix[2,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"founder 1",line=1,cex=1.25)
	plot(macmatrix[4,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"founder 2",line=1,cex=1.25)
	plot(macmatrix[6,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"both founders",line=1,cex=1.25)
	plot(macmatrix[8,],pch=16,col="grey50",ylim=c(0,mymax2),xlab="",ylab="",cex=0.5,las=1)
	mtext(side=4,"source",line=1,cex=1.25)
	mtext(side=1,"SNP index",outer=TRUE,line=2,cex=1.5)
	mtext(side=2,"Minor allele counts",outer=TRUE,line=2.5,cex=1.5)
	if(export){dev.off()}
	#
	# scatterplot:
	if(export){pdf("Minor_allele_counts_scatter.pdf",height=6,width=6)}
	plot(macmatrix[8,1:(nloci-nselect)],macmatrix[6,1:(nloci-nselect)],ylim=c(0,4*sample_size),xlim=c(0,2*sample_size),pch=16,cex=0.5,xlab="MAC source",ylab="MAC founders (combined)")
	if(nselect>0)
		{
		points(macmatrix[8,(nloci-nselect+1):nloci],macmatrix[6,(nloci-nselect+1):nloci],pch=16,cex=0.5,col="red")
		}
	if(export){dev.off()}
	}

plotvennsim<-function(export=NULL,plotname="Simulateddata.Venn",myrealoutliers=NULL,mycomp_nr=3,bayescanfile=NULL,bayescanFDR=0.01)
	{
	if(!is.null(bayescanfile)){getbayescansim(bayescanfile=bayescanfile,FDR=bayescanFDR)}
	gwdsoutlierslist	<- mysambarsim$gwdsoutlierslist
	outflankoutlierslist<- mysambarsim$outflankoutlierslist
	pcadaptoutlierslist	<- mysambarsim$pcadaptoutlierslist
	graphics.off()
	cat("Generating Venn diagram...",sep="\n")
	if(!is.null(export))
		{
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),height=6,width=8)}
		}
	#venn(list(GWDS=gwdsoutlierslist[[3]],OUTFLANK=outflankoutlierslist[[3]],adaptive=myrealoutliers,PCADAPT=pcadaptoutlierslist[[3]]))
	if(!is.null(myrealoutliers))
		{
		if(is.null(bayescanfile))
			{
			v1 <- venn.diagram(list(adaptive=myrealoutliers,GWDS=gwdsoutlierslist[[3]],PCadapt=pcadaptoutlierslist[[3]],OutFlank=outflankoutlierslist[[3]]),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("grey","blue","darkgreen","orange"),col=c("grey","blue","darkgreen","orange"),margin=0.12)
			}else{
			mybayescanout	<- which(simbayescan$bayescanout)
			v1 <- venn.diagram(list(adaptive=myrealoutliers,GWDS=gwdsoutlierslist[[3]],Bayescan=mybayescanout,PCadapt=pcadaptoutlierslist[[3]],OutFlank=outflankoutlierslist[[3]]),filename=NULL,alpha=0.6,cex=2.5,cat.cex=2.5,fill=c("grey","blue","darkred","darkgreen","orange"),col=c("grey","blue","darkred","darkgreen","orange"),margin=0.2)
			}
		grid.newpage()
		grid.draw(v1)
		if(!is.null(export)){dev.off()}
		vennlogfiles <- list.files(pattern = "\\.log$")
		unlink(vennlogfiles)
		}else{
		venn(list(GWDS=gwdsoutlierslist[[mycomp_nr]],OutFlank=outflankoutlierslist[[mycomp_nr]],PCadapt=pcadaptoutlierslist[[mycomp_nr]]))
		if(!is.null(export)){dev.off()}
		}
	}

plotvennsim_old<-function()
	{
	gwdsoutlierslist	<- mysambarsim$gwdsoutlierslist
	outflankoutlierslist<- mysambarsim$outflankoutlierslist
	pcadaptoutlierslist	<- mysambarsim$pcadaptoutlierslist
	pdf("venn.pdf",height=6,width=8)
	myrealoutliers		<- retained_either_snpid
	v1 <- venn.diagram(list(adaptive_loci=myrealoutliers,GWDS=gwdsoutlierslist[[2]],PCadapt=pcadaptoutlierslist[[2]],OutFLANK=outflankoutlierslist[[2]]),filename=NULL,alpha=0.6,cex=3,cat.cex=3,fill=c("grey","blue","darkgreen","orange"),col=c("grey","blue","darkgreen","orange"),margin=0.13)
	grid.newpage()
	grid.draw(v1)
	dev.off()
	}
	
# requires locWeirFst()
simFdist<-function(addbayescan=FALSE,do_export=FALSE,nloci=10000,nselloci=1000,n_samples=30,retainedin1pop=FALSE)
	{
	macmatrix				<- mysambarsim$macmatrix
	mymafstartmatrix		<- mysambarsim$mymafstartmatrix
	graphics.off()
	# myfstvalues			<<- matrix(ncol=3,nrow=nloci)
	nneutralloci			<- nloci-nselloci
	retained_founder1		<- nneutralloci+which(mymafstartmatrix[1,c((nneutralloci+1):nloci)]>0)
	retained_founder2		<- nneutralloci+which(mymafstartmatrix[2,c((nneutralloci+1):nloci)]>0)
	retained_both_snpid		<- nneutralloci+(intersect(which(mymafstartmatrix[1,c((nneutralloci+1):nloci)]>0),which(mymafstartmatrix[2,c((nneutralloci+1):nloci)]>0)))
	retained_either_snpid	<- nneutralloci+(union(which(mymafstartmatrix[1,c((nneutralloci+1):nloci)]>0),which(mymafstartmatrix[2,c((nneutralloci+1):nloci)]>0)))
	for(i in c(1:3))
		{
		#plotname			<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"Fdist",i,"pdf",sep=".")
		plotname			<- paste("Fdist",i,"pdf",sep=".")
		if(do_export){pdf(plotname,height=4,width=12)}
		par(mfrow=c(1,4),mar=c(0.5,0.5,0.5,0.5),oma=c(5,5,0.5,0.5),cex.axis=1.5,cex.lab=2.5)
		sample_sizes		<- c(2*n_samples,n_samples)									# 2 founder populations
		### First tile ###
		# plot all loci:
		if(i==3)
			{
			mafneutral1			<- macmatrix[i*2,]/(sample_sizes[1]*2)						# 2 alleles per individual
			}else{
			mafneutral1			<- macmatrix[i*2,]/(sample_sizes[2]*2)
			}
		mafneutral2			<- macmatrix[8,]/(sample_sizes[2]*2)						# 2 alleles per individual
		locWeirFst(mafvector1=mafneutral1,mafvector2=mafneutral2,plottitle="",xlabel="",ylabel="",dothin=TRUE)
		# add real outliers to plot:
		# myfstvalues[,i]		<<- WeirFst
		if(i==1)
			{
			myselection			<- retained_founder1
			mafselect_1			<- macmatrix[i*2,myselection]/(sample_sizes[2]*2)	
			}
		if(i==2)
			{
			myselection			<- retained_founder2
			mafselect_1			<- macmatrix[i*2,myselection]/(sample_sizes[2]*2)	
			}
		if(i==3)
			{
			myselection_either	<- retained_either_snpid
			myselection			<- retained_both_snpid
			mafselect_1			<- macmatrix[i*2,myselection]/(sample_sizes[1]*2)	
			if(retainedin1pop)
				{
				mafselect_1_either	<- macmatrix[i*2,myselection_either]/(sample_sizes[1]*2)
				mafselect_2_either	<- macmatrix[8,myselection_either]/(sample_sizes[2]*2)
				locWeirFst(mafvector1=mafselect_1_either,mafvector2=mafselect_2_either,addpoints=TRUE,outliercol="orange",dothin=TRUE)
				legend(x=0,y=0.95,legend=c("Both populations","One population"),fill=c("red","orange"),bty='n',cex=1.5)
				}
			}
		mafselect_2				<- macmatrix[8,myselection]/(sample_sizes[2]*2)
		locWeirFst(mafvector1=mafselect_1,mafvector2=mafselect_2,addpoints=TRUE,outliercol="red",dothin=TRUE)
		mtext("adaptive loci",side=3,line=-2.5,cex=1.75)
		### Other tiles ### 
		outlierlist				<- list()
		outlierlist[[1]]		<- mysambarsim$pcadaptoutlierslist[[i]]	
		if(addbayescan)
			{
			outlierlist[[2]]	<- bayescanoutlierslist[[i]]	
			}else{
			outlierlist[[2]]	<- mysambarsim$outflankoutlierslist[[i]]	
			}
		outlierlist[[3]]		<- mysambarsim$gwdsoutlierslist[[i]]
		if(addbayescan)
			{
			names(outlierlist)	<- c("PCadapt","Bayescan","GWDS")
			}else{
			names(outlierlist)	<- c("PCadapt","OutFLANK","GWDS")
			}
		# plot outliers detected by GWDS, OutFlank (or Bayescan), and PCadapt:
		# myoutlierlist			<<- outlierlist
		for(j in c(1:3))
			{
			myscan				<- names(outlierlist)[j]
			cat(myscan,sep="\n")
			myselection			<- outlierlist[[j]]
			if(i==3)
				{
				mafselect1			<- macmatrix[i*2,myselection]/(sample_sizes[1]*2)		# 2 alleles per individual
				}else{
				mafselect1			<- macmatrix[i*2,myselection]/(sample_sizes[2]*2)		# 2 alleles per individual
				}
			mafselect2			<- macmatrix[8,myselection]/(sample_sizes[2]*2)			# 2 alleles per individual
			# plot all loci:
			locWeirFst(mafvector1=mafneutral1,mafvector2=mafneutral2,plottitle="",xlabel="",ylabel="",myyaxis='n',dothin=TRUE)
			# add outliers to plot:
			locWeirFst(mafvector1=mafselect1,mafvector2=mafselect2,addpoints=TRUE,dothin=TRUE)
			mtext(myscan,side=3,line=-2.5,cex=1.75)
			}
		mtext("WC Fst",side=2,line=2,cex=2.5,outer=TRUE)
		mtext("WC He",side=1,line=3.5,cex=2.5,outer=TRUE)
		if(do_export){dev.off()}
		}
	}	
	
plotlogvalues<-function(do_export=FALSE,nr_loci=1000,nr_selected=100,plotqvalue=TRUE,addbayescan=FALSE)
	{
	#plotname	<- paste("Simulated",nesourcepop,nfounders,ngen,nefounderpop1[1],samplesize,nloc,nselectedloci,selcoef,"testscores.pdf",sep=".")
	alloci		<- c(1:nr_loci)
	for(i in c(1:3))
		{
		graphics.off()
		plotname	<- paste("Simulated.testscores",i,"pdf",sep=".")
		if(addbayescan)
			{
			if(do_export){pdf(plotname,height=14,width=14)}
			par(mfrow=c(4,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
			}else{
			if(do_export){pdf(plotname,height=10,width=14)}
			par(mfrow=c(3,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
			}
		# bayescan:
		if(addbayescan)
			{
			if(is.na(bayescanlogqlist[[i]]))
				{
				mylogq		<- runif(nr_loci)
				plot(alloci,mylogq,xaxt='n',ylab="",pch=16,las=1)
				}else{
				mylogq		<- bayescanlogqlist[[i]]
				myout		<- bayescanoutlierslist[[i]]
				myoutq		<- mylogq[myout]
				plot(alloci,mylogq,xaxt='n',ylab="",pch=16,las=1)
				points(myout,myoutq,col="red",pch=16)
				}
			mtext("Bayescan",side=4,line=1.5,cex=2)
			mtext("-log(q)",side=2,line=3.75,cex=2)
			}
		# gwds:
		gwdslogp		<- mysambarsim$gwdslogplist[[i]]
		myout			<- mysambarsim$gwdsoutlierslist[[i]]
		myoutp			<- gwdslogp[myout]
		plot(alloci,gwdslogp,xaxt='n',ylab="",pch=16,las=1)
		points(myout,myoutp,col="red",pch=16)
		mtext("GWDS",side=4,line=1.5,cex=2)
		mtext("-log(p)",side=2,line=3.75,cex=2)
		# outflank:
		if(plotqvalue)
			{
			plot(alloci,mysambarsim$outflanklogqlist[[i]],xlab="",ylab="",xaxt='n',pch=16,las=1)		
			myout		<- mysambarsim$outflankoutlierslist[[i]]
			myoutq		<- mysambarsim$outflanklogqlist[[i]][myout]
			points(myout,myoutq,col="red",pch=16)
			mtext("-log(q)",side=2,line=3.75,cex=2)
			}else{
			plot(alloci,mysambarsim$outflanklogplist[[i]],xlab="",ylab="",xaxt='n',pch=16,las=1)
			myout		<- mysambarsim$outflankoutlierslist[[i]]
			myoutp		<- mysambarsim$outflanklogplist[[i]][myout]
			points(myout,myoutp,col="red",pch=16)
			mtext("-log(p)",side=2,line=3.75,cex=2)
			}
		mtext("OutFLANK",side=4,line=1.5,cex=2)
		# pcadapt:
		plot(alloci,mysambarsim$pcadaptlogplist[[i]],ylab="",pch=16,las=1)
		myout		<- mysambarsim$pcadaptoutlierslist[[i]]
		myoutp		<- mysambarsim$pcadaptlogplist[[i]][myout]
		points(myout,myoutp,col="red",pch=16)
		mtext("PCadapt",side=4,line=1.5,cex=2)
		mtext("-log(p)",side=2,line=3.75,cex=2)
		mtext("SNP index",side=1,line=4,cex=2.5,outer=TRUE)
		# mtext("-log(test statistic)",side=2,line=0.5,cex=2.5,outer=TRUE)
		if(do_export){dev.off()}
		}
	}

plotlogtest<-function(do_export=FALSE,nr_loci=80000,nr_selected=1000,mytest=1)
	{
	alloci		<- c(1:nr_loci)
	if(mytest==1)
		{
		myloglist		<- bayescanlogqlist
		myoutlierlist	<- bayescanoutlierslist
		testname		<- "Bayescan"
		}
	if(mytest==2)
		{
		myloglist		<- mysambarsim$gwdslogplist
		myoutlierlist	<- mysambarsim$gwdsoutlierslist
		testname		<- "GWDS"
		}
	if(mytest==3)
		{
		myloglist		<- mysambarsim$outflanklogqlist
		myoutlierlist	<- mysambarsim$outflankoutlierslist
		testname		<- "OutFlank"
		}
	if(mytest==4)
		{
		myloglist		<- mysambarsim$pcadaptlogplist
		myoutlierlist	<- mysambarsim$pcadaptoutlierslist
		testname		<- "PCadapt"
		}
	graphics.off()
	plotname	<-paste(testname,"logvalues.pdf",sep=".")
	if(do_export){pdf(plotname,height=7,width=14)}
	#par(mfrow=c(3,1),mar=c(0.5,3,0.5,2.5),oma=c(6,3.5,0.5,2),cex.axis=1.5,cex.lab=2.5)
	par(mfrow=c(2,1),mar=c(0.5,3,0.5,2.5),oma=c(4,3.5,2,2),cex.axis=1.5,cex.lab=2.5)
	#
	for(i in c(2:3))
		{
		plot(alloci,myloglist[[i]],xaxt='n',ylab="",pch=16,las=1)
		myout		<- myoutlierlist[[i]]
		myoutp		<- myloglist[[i]][myout]
		points(myout,myoutp,col="red",pch=16)
		if(i==2){mtext("Pairwise",side=4,line=0.5,cex=2)}
		if(i==3){mtext("Pooled",side=4,line=0.5,cex=2)}
		}
	axis(side=1)
	mtext(testname,side=3,line=0,cex=2,outer=TRUE)
	mtext("SNP index",side=1,line=2.5,cex=2.5,outer=TRUE)
	mtext("-log(test statistic)",side=2.5,line=0.5,cex=2.5,outer=TRUE)
	if(do_export){dev.off()}
	}

plotlogvalues_3d<-function(make_snapshot=FALSE)
	{
	# This function creates a 3D scatterplot:
	#library(rgl)
	mydf		<- data.frame(x=mysambarsim$outflanklogqlist[[3]],y=mysambarsim$pcadaptlogplist[[3]],z=mysambarsim$gwdslogplist[[3]])
	mydf$color	<- c(rep("black",900),rep("red",100))
	plot3d(mydf$x,mydf$y,mydf$z, col=mydf$color, size=2, type='s',xlab="OutFLANK",ylab="PCadapt",zlab="GWDS",box=FALSE)
	if(make_snapshot)
		{
		rgl.snapshot("selectionscan.logpvalues.png")
		}
	}	

plottestpower<-function()
	{
	# This function creates a 3D scatter plot.
	# library(rgl)
	x <- 1:5/10
	y <- 1:5
	z <- x %o% y
	persp3d(x, y, z, col="skyblue",box=FALSE)
	#rgl.snapshot("myplot.png")
	}

# Returns a list with output, so assign this function to an object when calling it. 	
simscan<-function(mafvector1=NULL,mafvector2=NULL,myalpha=0.05,sample_sizes=c(30,30),n_selected=0,my_correction="none",store_adjusted=FALSE,right_trim=0.95)
	{
	# my_correction can be: "none","holm","BH" (Benjamini-Hochberg), or "bonferroni"
	if(is.null(mafvector1)|is.null(mafvector2)){return(cat("Error: simscan function expects two input vectors.",sep="\n"))}
	mafmatrix		<- rbind(mafvector1,mafvector2)
	ntotalsnps		<- length(mafvector1)
	nneutralsnps	<- length(mafvector1)-n_selected	
	getpedfrommaf(n_ind=c(sample_sizes[1],sample_sizes[2]),nloc=ntotalsnps,mafinput=mafmatrix,exportname="simdata")
	cat(paste("Number of individuals in OutFLANK input dataset: ",nrow(mysambarsim$mygenlightmatrix),".",sep=""),sep="\n")
	# run OutFLANK:
	mypops			<- c(rep("founder",sample_sizes[1]),rep("source",sample_sizes[2]))	
	mylocs			<- c(1:ntotalsnps)
	outflankinput	<- MakeDiploidFSTMat(SNPmat=mysambarsim$mygenlightmatrix,locusNames=mylocs,popNames=mypops)
	# we define threshold using neutral loci only:
	myqthreshold	<- myalpha		 
	# It is important to only include the neutral loci for generating the null distribution, otherwise OutFLANK will not find outliers:
	cat("Trimming...",sep="\n")
	outflankerror	<- FALSE
	if(!is.null(right_trim))
		{
		# According to the OutFLANK manual you have to remove the loci for which Fst estimates differs strongly from FstNoCorr estimate.
		# We assume that less than 5 percent are outliers (or other value specified by right_trim):
		cat(paste("Specified right_trim threshold: ",right_trim,". This means that whilst inferring the null Fst distribution, the SNPs with the top ",(1-right_trim)*100," percent Fst values will be ignored.",sep=""),sep="\n")
		mymean			<- mean(outflankinput$FSTNoCorr,na.rm=TRUE)
		myrate			<- 1/mymean
		myvalue			<- qexp(right_trim,myrate)
		prunevector		<- outflankinput$FSTNoCorr<myvalue&!is.na(outflankinput$FSTNoCorr)&is.finite(outflankinput$FSTNoCorr)
		myfstmax		<- round(max(outflankinput$FSTNoCorr[prunevector],na.rm=TRUE),3)
		cat(paste("Highest Fst-value of pruned dataset: ", myfstmax,".",sep=""),sep="\n")
		if(!myfstmax<=0.99)
			{
			# This is to prevent the error:
			# ERROR: The largest FST in the trimmed set must be < 1. Please use a larger RightTrimFraction.
			cat("Fst of pruned dataset ranges until 1. SambaR will not run OutFLANK and assume there are no outliers.",sep="\n")
			outflankout			<- mylocs[rep(FALSE,ntotalsnps)]
			outflanklogq		<- rep(0,ntotalsnps)
			outflanklogp		<- rep(0,ntotalsnps)
			mysambarsim$outflankfdr_value		<<- 0
			outflankerror		<- TRUE
			}else{
			out_trim 		<- OutFLANK(FstDataFrame=outflankinput[prunevector,],NumberOfSamples=2,qthreshold=myalpha,Hmin = 0.1)
			}
		}else{
		# alternatively do not trim and simply take the neutral snps as the null distribution
		cat("The flag right_trim is set to NULL. Inferring the null Fst distribution from all neutral SNPs.",sep="\n")
		out_trim 		<- OutFLANK(FstDataFrame=outflankinput[c(1:nneutralsnps),],NumberOfSamples=2,qthreshold=myqthreshold,Hmin = 0.1)
		}
	if(!outflankerror)
		{
		cat("Calculating p and q values...",sep="\n")
		P1 					<- pOutlierFinderChiSqNoCorr(outflankinput,Fstbar=out_trim$FSTNoCorrbar,dfInferred = out_trim$dfInferred, qthreshold = myqthreshold, Hmin=0.1)
		cat("Ordering...",sep="\n")
		P2					<- P1[order(P1$LocusName),]
		cat("Selecting outliers...",sep="\n")
		P2$p_uncorrected	<- P2$pvalues 
		if(my_correction=="none")
			{
			# 04-03-19: my simulations showed that OutFlank has lowest FDR when not using qvalues (default), but when using holm corrected p values.
			# outflankout	<- P2$LocusName[P2$OutlierFlag=="TRUE"&!is.na(P2$OutlierFlag)]
			cat("No multiple test correction method specified. Defaulting to Holm method.",sep="\n")
			P2$pvalues		<- p.adjust(P2$pvalues,method="holm")
			P2$OutlierFlag	<- P2$pvalues<0.05
			outflankout		<- P2$LocusName[P2$OutlierFlag=="TRUE"&!is.na(P2$OutlierFlag)]
			}else{
			cat(paste("Specified multiple test correction method: ",my_correction,".",sep=""),sep="\n")
			P2$pvalues		<- p.adjust(P2$pvalues,method=my_correction)
			P2$OutlierFlag	<- P2$pvalues<0.05
			outflankout		<- P2$LocusName[P2$OutlierFlag=="TRUE"&!is.na(P2$OutlierFlag)]
			}
		outflanklogq		<- -(log10(P2$qvalues))
		if(store_adjusted)
			{
			outflanklogp	<- -(log10(P2$pvalues))
			}else{
			outflanklogp	<- -(log10(P2$p_uncorrected))
			}
		noutliers			<- length(outflankout)
		mysambarsim$outflankfdr_value		<<- ifelse(noutliers>0,(length(which(outflankout<=nneutralsnps)))/noutliers,0)
		cat(paste("OutFLANK detected",noutliers,"outlier loci.",sep=" "),sep="\n")
		}
	# run PCadapt:
	inputdir			<- getwd()
	cat(paste("Reading PED file from:",inputdir,sep=" "),sep="\n")
	x					<- read.pcadapt("simdata.ped",type="ped")
	y					<- pcadapt(x,K=10)
	z					<- pcadapt(x,K=2)
	z$p_uncorrected		<- z$pvalues
	if(my_correction!="none")
		{
		# 04-03-19: my simulations showed that PCadapt has lowest FDR when wen using bonferroni corrected p values
		cat(paste("Specified multiple test correction method: ",my_correction,".",sep=""),sep="\n")
		padj 			<- p.adjust(z$pvalues,method=my_correction)	
		}else{
		# 04-03-19: my simulations showed that PCadapt has lowest FDR when wen using bonferroni corrected p values
		# padj 			<- z$pvalues
		cat("No multiple test correction method specified. Defaulting to Bonferonni method.",sep="\n")
		padj 			<- p.adjust(z$pvalues,method="bonferroni")	
		}
	pcadaptout			<- which(padj<myalpha)
	if(store_adjusted)
		{
		pcadaptlogp		<- -log10(padj)  
		}else{
		pcadaptlogp		<- -log10(z$p_uncorrected)  
		}
	cat(max(pcadaptlogp,na.rm=TRUE),sep="\n")
	noutliers			<- length(pcadaptout)
	mysambarsim$pcadaptfdr_value	<<- ifelse(noutliers>0,(length(which(pcadaptout<=nneutralsnps)))/noutliers,0)
	cat(paste("PCadapt detected",noutliers,"outlier loci.",sep=" "),sep="\n")
	myoutputlist		<- list()
	myoutputlist[[1]]	<- outflankout
	myoutputlist[[2]]	<- outflanklogq
	myoutputlist[[3]]	<- pcadaptout
	myoutputlist[[4]]	<- pcadaptlogp
	myoutputlist[[5]]	<- outflanklogp
	return(myoutputlist)
	}

get_bayescan_multi<-function(myrates=c(0,0.01,seq(0.05,1,0.05)),retainedratio=1,nneutral=5000,nadaptive=500,export=FALSE,my_input="simdata.bayescanout.fst.txt")
	{
	nrates				<- length(myrates)
	mymatrix			<- matrix(NA,ncol=3,nrow=nrates)	
	for (j in c(1:nrates))
		{
		myrate			<- myrates[j]
		cat(myrate,sep="\n")
		get_bayescan(my_FDR=myrate,myinput=my_input,n_neutral=nneutral,n_adaptive=nadaptive)
		mymatrix[j,2]	<- nbaye_out_select
		mymatrix[j,3]	<- nbaye_out_neutral
		}	
	bayeout				<<- as.data.frame(mymatrix)
	colnames(bayeout)	<<- c("FDR","adaptive","neutral")
	bayeout$FDR			<<- myrates
	bayeout$power		<<- bayeout$adaptive/(retainedratio*nadaptive)
	bayeout$specificity	<<- (retainedratio*nneutral-bayeout$neutral)/(retainedratio*nneutral)
	bayeout$power[bayeout$power>1]	<<- 1
	bayeout$specificity[bayeout$specificity<0]	<<- 0
	bayeout$FDR_obs		<<- bayeout$neutral/(bayeout$adaptive+bayeout$neutral)
	bayeout$FDR[!is.finite(bayeout$FDR)]	<<- 0
	if(export){pdf("Bayescan.power.pdf",width=12,height=5)}
	par(mfrow=c(1,2),oma=c(0,0,1,0),mar=c(5,7,1,3),cex.lab=2,cex.main=2)
	plot(bayeout$FDR,bayeout$power,type='b',ylab="",xlab="Expected FDR",lwd=2,las=1)
	mtext("Power",side=2,line=3,cex=2)
	par(new = T)
	plot(bayeout$FDR,bayeout$specificity,col="grey50",yaxt='n',ylab="",xaxt='n',xlab="",type='b',lwd=2,ylim=c(0.9,1))
	axis(side=4,las=1)
	mtext("Specificity",side=4,line=3.5,cex=2,col="grey50")
	plot(bayeout$FDR,bayeout$FDR_obs,type='b',lwd=2,xlab="Expected FDR",ylab="",las=1,ylim=c(0,1),xlim=c(0,1))
	mtext("Observed FDR",side=2,line=3,cex=2)
	if(export){dev.off()}
	}
	
get_bayescan<-function(add_to_plot=FALSE,my_FDR=0.3,myinput="simdata.bayescanout.fst.txt",n_neutral=9000,n_adaptive=1000)
	{
	x					<- read.table(myinput)	
	bayescanlogq		<<- -log10(x$qval) 
	bayescanout			<<- which(x$qval<my_FDR)
	nbaye_out			<- length(bayescanout)
	nbaye_out_select	<<- length(bayescanout[bayescanout>n_neutral])
	nbaye_out_neutral	<<- length(bayescanout[bayescanout<=n_neutral])
	cat(paste("Bayescan detected",nbaye_out_select,"out of",n_adaptive,"outlier loci.",sep=" "),sep="\n")
	cat(paste("Bayescan wrongly marked",nbaye_out_neutral,"out of",n_neutral,"neutral loci as outliers.",sep=" "),sep="\n")
	# what are the logp scores of the outliers detected by pcadapt? 
	if(add_to_plot)
		{
		bayescanoutlogp		<- logp[3,bayescanout]
		points(bayescanout,bayescanoutlogp,col="darkred",pch=16)
		}
	}

run_sel<-function(export=FALSE,nloci=1000,nselected=100,sel_coef=0.1,sample_size=30,n_gen=20)
	{
	foundernevector	<- c(20,50,100,1000)
	popmaflist		<- list()
	samplemaclist	<- list()
	for(k in c(1:length(foundernevector)))
		{
		founderne			<- foundernevector[k]
		outliersim(export=FALSE,nloc=nloci,ngen=n_gen,nefounderpop1=founderne,nefounderpop2=founderne,nfounders=founderne,samplesize=sample_size,nselectedloci=nselected,selcoef=sel_coef,parallelselection=TRUE,do_haploid=TRUE,do_venn=FALSE,do_Fdist=TRUE,do_selectionscan=FALSE,do_logplot=FALSE)
		popmaflist[[k]]		<- mysambarsim$mymafendmatrix
		samplemaclist[[k]]	<- mysambarsim$macmatrix
		}
	# Plot:
	graphics.off()
	if(export){pdf("Fdist_selection.pdf",width=12,height=6)}
	par(mar=c(0.5,1,1,0.5),oma=c(5,5,1,1),cex.axis=1.5)
	layout(matrix(c(1:8),nrow=2,ncol=4,byrow=FALSE))
	for(k in c(1:length(foundernevector)))
		{
		founderne		<- foundernevector[k]
		mymafendmatrix	<- popmaflist[[k]]
		mymafendmatrix	<- round(mymafendmatrix,nchar(founderne))
		macmatrix		<- samplemaclist[[k]]
		my_yaxis		<- ifelse(k==1,'s','n')
		locWeirFst(mafvector1=mymafendmatrix[1,],mafvector2=mymafendmatrix[3,],myyaxis=my_yaxis,myxaxis='n',dothin=TRUE,plottitle=paste("Ne =",founderne,sep=" "))
		locWeirFst(mafvector1=mymafendmatrix[1,c((nloci-nselected):nloci)],mafvector2=mymafendmatrix[3,c((nloci-nselected):nloci)],addpoints=TRUE,cexout=1)
		samplemaf1		<- macmatrix[2,]/(sample_size*2)
		samplemaf2		<- macmatrix[8,]/(sample_size*2)
		locWeirFst(mafvector1=samplemaf1,mafvector2=samplemaf2,myyaxis=my_yaxis,dothin=TRUE,plottitle=paste("Ne =",founderne,sep=" "),plotsubtitle=paste("n =",sample_size,sep=" "))
		locWeirFst(mafvector1=samplemaf1[((nloci-nselected):nloci)],mafvector2=samplemaf2[c((nloci-nselected):nloci)],addpoints=TRUE,cexout=1)
		}
	mtext("Weir & Cockerham Fst",side=2,line=2.5,outer=TRUE,cex=2)
	mtext("Weir & Cockerham He",side=1,line=3,outer=TRUE,cex=2)
	if(export){dev.off()}
	}

	
locWeirFst<-function(mafvector1=NULL,mafvector2=NULL,addpoints=FALSE,cexout=1,myyaxis='s',myxaxis='s',plottitle="Fst/He",plotsubtitle="",xlabel="Weir & Cockerham He",ylabel="Weir & Cockerham Fst",neutralcol="black",outliercol="red",dothin=FALSE)
	{
	mafpop1		<- mafvector1
	mafpop2		<- mafvector2
	pop1f0		<- (mafpop1*mafpop1)+((1-mafpop1)*(1-mafpop1))
	pop2f0		<- (mafpop2*mafpop2)+((1-mafpop2)*(1-mafpop2))
	f1			<- (mafpop1*mafpop2)+((1-mafpop1)*(1-mafpop2))	
	WeirHe		<- 1-f1 
	WeirFst		<- (0.5*(pop1f0+pop2f0)-f1)/WeirHe
	# select unique WeirHe, WeirFst combinations, so the plot gets let's heavy:
	if(dothin)
		{
		mydf		<- as.data.frame(cbind(WeirHe,WeirFst))
		mydf		<- unique(mydf)
		WeirHe		<- mydf$WeirHe
		WeirFst		<- mydf$WeirFst
		}
	# now plot:
	if(addpoints)
		{
		points(WeirHe,WeirFst,xlim=c(0,1),ylim=c(0,1),pch=16,col=outliercol,cex=cexout,las=1)
		}else{
		plot(WeirHe,WeirFst,xlim=c(0,1),ylim=c(0,1),pch=16,xlab=xlabel,ylab=ylabel,col=neutralcol,yaxt=myyaxis,xaxt=myxaxis,cex=0.5,las=1)
		mtext(plottitle,side=3,line=-2,cex=1.25)
		mtext(plotsubtitle,side=3,line=-3.5,cex=1.25)
		}	
	}
	
# requires function 'mafsim'
getfounderpopmaf<-function(nsamplesfounder=30,nsamplessource=30,sourcemafvector=NULL,nrfounders=10,nesourcepop=1000,nefounderpop=20,nrloci=5000,ngensource=200,ngenfounder=20,plotmaf=FALSE,histointervals=0.02,meanmafsource=0.1,nselectloci=0,selc=0.1,dohap=TRUE,dodiscrete=TRUE)
	{
	if(!dohap)
		{
		return(cat("ERROR: currently allele frequencies can only reliably be simulated using the haploid approach. Please set the dohap flag to TRUE.",sep="\n")) 
		}
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	### This function returns founderendmaf
	### The user can either provide vector with the maf of the source. 
	### If the user does not provide such a vector, the function will create the vector itself, based on user-defined settings. 
	### The argument 'nefounderpop' can be either one value (static Ne) or a vector, of which the length should equal number of generations. 
	#
	cat("Settings whilst running getfounderpopmaf:",sep="\n")
	cat(paste("  Specified number of loci: ",nrloci,".",sep=""),sep="\n")
	cat(paste("  Specified number of loci under positive selection: ",nselectloci,".",sep=""),sep="\n")
	cat(paste("  Specified selection coefficient: ",selc,".",sep=""),sep="\n")
	cat(paste("  Specified number of generations after founder event (i.e. age of founder populations): ",ngenfounder,".",sep=""),sep="\n")
	cat(paste("  Specified Ne source population: ",nesourcepop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 1: ",nefounderpop,".",sep=""),sep="\n")
	cat(paste("  Specified Ne founder pop 2: ",nefounderpop,".",sep=""),sep="\n")
	cat(paste("  Specified number of founders: ",nrfounders,".",sep=""),sep="\n")
	cat(paste("  Specified samplesize founder population(s): ",nsamplesfounder,".",sep=""),sep="\n")
	cat(paste("  Specified samplesize source population: ",nsamplessource,".",sep=""),sep="\n")
	cat(paste("  Simulate allele frequencies assuming haploidy: ",dohap,".",sep=""),sep="\n")
	cat(paste("  Simulate selection using discrete method: ",dodiscrete,".",sep=""),sep="\n")
	#
	if(!dohap&dodiscrete)
		{
		return(cat("Error: The flag dodiscrete is set to TRUE but the flag dohap is set to FALSE. The function mafsim() does not allow to simulate simulation discretely if not assuming haploidy.",'\n'))
		} 
	#
	# optionally simulate maf distribution of the source population:
	if(is.null(sourcemafvector))
		{
		sourcemafvec		<- mafsim(nloci=nrloci,popsize=nesourcepop,ngens=ngensource,meanmaf=meanmafsource,nselloci=0,haploid=dohap,do_discrete=dodiscrete)
		}else{
		sourcemafvec		<- sourcemafvector
		}	
	# effect of sampling (not used in downstream analyses, just to compare simulated distribution to observed distribution in Norway population):
	sourcesample			<- sapply(sourcemafvec,function(sourcemafvec){rbinom(1,(2*nsamplessource),sourcemafvec)})
	sourcesample			<- sourcesample/(2*nsamplessource)
	# get maf frequencies of the founders, by simulating bottleneck through sampling:
	if(length(nefounderpop)==1)
		{
		pop_ne				<- rep(nefounderpop,ngenfounder)
		}else{
		pop_ne				<- nefounderpop
		}
	founderstartmaf			<- sapply(sourcemafvec,function(sourcemafvec){rbinom(1,(2*nrfounders),sourcemafvec)})
	founderstartmaf			<- founderstartmaf/(2*nrfounders)
	# let the founder population drift for a number of generations:
	founderendmaf			<- mafsim(ngens=ngenfounder,nloc=nrloci,popsize=pop_ne,mafstartvector=founderstartmaf,nselloci=nselectloci,s=selc,haploid=dohap,do_discrete=dodiscrete)
	# effect of sampling:
	foundersample			<- sapply(founderendmaf,function(founderendmaf){rbinom(1,(2*nsamplesfounder),founderendmaf)})
	foundersample			<- foundersample/(2*nsamplesfounder)
	# plot:
	if(plotmaf)
		{
		breakpoints			<- seq(0,1,histointervals)
		par(mfrow=c(1,3))
		hist(sourcemafvec,breaks=breakpoints,xlim=c(0,1),ylim=c(0,nrloci/1.5),main="Source pop",xlab=NULL)
		hist(founderstartmaf,breaks=breakpoints,xlim=c(0,1),ylim=c(0,nrloci/1.5),main="Founder pop at founder event",xlab=NULL)
		hist(founderendmaf,breaks=breakpoints,xlim=c(0,1),ylim=c(0,nrloci/1.5),main="Founder pop at 20 gen",xlab=NULL)
		mtext("Simulated locus-specific minor allele frequencies", side = 1, outer = TRUE,line=-2)
		}
	mysambarsim$sourcemafvec	<<- sourcemafvec
	mysambarsim$founderstartmaf	<<- founderstartmaf
	mysambarsim$founderendmaf	<<- founderendmaf
	mysambarsim$foundersample	<<- foundersample
	mysambarsim$sourcesample	<<- sourcesample
	return(founderendmaf)
	}

mafsim<-function(nloci=1000,ngens=10,popsize=50,meanmaf=0.17,mafstartvector=NULL,nselloci=0,s=0.1,h=0.5,haploid=TRUE,r=1,do_discrete=TRUE)
	{
	if(!haploid)
		{
		return(cat("ERROR: currently allele frequencies can only reliably be simulated using the haploid approach. Please set the haploid flag to TRUE.",sep="\n")) 
		}
	if(!exists("mysambarsim"))
		{
		mysambarsim	<<- list()
		}
	cat("Settings whilst running mafsim:",sep="\n")
	if(length(unique(popsize))==1)
		{
		cat(paste("  Popsize: ",unique(popsize),".",sep=""),sep="\n")
		}else{
		cat("  Non-uniform population size.",sep="\n")
		#cat(paste("Popsize: ",paste(popsize,collapse=","),".",sep=""),sep="\n")
		}
	cat(paste("  Number of generations: ",ngens,".",sep=""),sep="\n")
	cat(paste("  Number of loci: ",nloci,".",sep=""),sep="\n")
	if(nselloci>0)
		{
		cat(paste("  Number of loci under positive selection: ",nselloci,".",sep=""),sep="\n")
		cat(paste("  Selection coefficient: ",s,".",sep=""),sep="\n")
		cat(paste("  Simulate selection using discrete method: ",do_discrete,".",sep=""),sep="\n")
		}
	cat(paste("  Simulate allele frequencies assuming haploidy: ",haploid,".",sep=""),sep="\n")
	if(!haploid&do_discrete)
		{
		return(cat("Error: The flag do_discrete is set to TRUE but the flag haploid is set to FALSE. The function mafsim() does not allow to simulate simulation discretely if not assuming haploidy.",'\n'))
		} 
	# define population size over generations:
	if(length(popsize)==1)
		{
		popne	<- rep(popsize,ngens)
		}else{
		popne	<- popsize
		}
	# Create empty matrix for neutral loci:
	nneutral<-nloci-nselloci	
	z		<- matrix(NA,ncol=nneutral,nrow=ngens)
	# Create empty matrix for adaptive loci:
	zs		<- matrix(NA,ncol=nselloci,nrow=ngens)
	# Minor allele frequency in generation 1:
	if(is.null(mafstartvector))
		{
		z[1,]	<- (rpois(nneutral,lambda=(meanmaf*100)))/100
		zs[1,]	<- (rpois(nselloci,lambda=(meanmaf*100)))/100
		}else{
		z[1,]	<- mafstartvector[1:nneutral]
		zs[1,]	<- mafstartvector[(nneutral+1):nloci]
		}
	# Now do the actual simulation:
	# loss of alleles is permanent, as it should be: 0 stays 0.
	for (i in c(2:ngens))
		{ 
		# neutral loci:
		if(nselloci<nloci)
			{
			ztemp	<- z[i-1,]
			ztemp2	<- sapply(ztemp,function(ztemp){rbinom(1,(2*popne[i]),ztemp)})
			z[i,]	<- ztemp2/(2*popne[i])
			}
		# adaptive loci:
		if(nselloci>0)
			{
			if(haploid)
				{
				# No diploid genotypes, so simply drawing n alleles out of the population.
				# A haploid hermaphrodite system?		
				stemp						<- zs[i-1,]
				stemp2						<- sapply(stemp,function(stemp){rbinom(1,popne[i],stemp)})
				if(s<=0.05&do_discrete)
					{
					prtemp					<- runif(nselloci)<s
					stemp2[prtemp]			<- 2*stemp2[prtemp]					# this is a discrete way: s denotes probability of selective event per generation. If selective event, minor allele count is doubled.
					stemp2					<- stemp2/(popne[i])
					}else{
					stemp2					<- round((1+s)*stemp2)/(popne[i])	# due to rounding, this way of incorporating selection only works for a certain minimum number of alleles (i.e.: high popsize and/or high minor allele frequency) 
					}
				stemp2[stemp2>1]<- 1 
				zs[i,]			<- stemp2
				}else{
				# the next generation starts with random reproduction of offspring:
				# r is the mean number of offspring per individual
				stemp			<- zs[i-1,]
				stemp2			<- sapply(stemp,function(stemp){rbinom(1,(2*popne[i]),stemp)})
				q				<- stemp2/(2*popne[i])
				p				<- 1-q
				n_offspring		<- 2*popne[i]*r
				offspring_AA	<- (p^2)*n_offspring
				offspring_Aa	<- (2*p*q)*n_offspring
				offspring_aa	<- (q^2)*n_offspring
				# during the lifespan differential survival:
				# AA and Aa individuals have a mortality probability (s and h*s); aa individuals do not.
				# probability of survival is: 
				expAA			<- round((1-s)*offspring_AA)
				expAa			<- round((1-h*s)*offspring_Aa)
				expaa			<- round((1)*offspring_aa)
				expall			<- sum(expAA,expAa,expaa)
				stemp3			<- round((2*expaa+expAa)/(2*(expAA+expAa+expaa)),nchar(popne[i]))
				stemp3[stemp3>1]<- 1	# Frequency can not exceed 1
				zs[i,]			<- stemp3			
				}
			}
		}
	if(nselloci>0&nselloci<nloci)
		{
		z	<- cbind(z,zs)
		}
	if(nselloci>nloci&nselloci==nloci)
		{
		z	<- zs
		}
	return(z[ngens,])
	}	

multilin_old<-function(foundervec=c(5,10,20),nriter=100,export=FALSE,nsamples=NULL,nrgen=NULL)
	{
	mylist		<<- list()
	mymafs1		<- c(0.05,0.05,0.05,0.1,0.1)
	mymafs2		<- c(0.05,0.1,0.15,0.2,0.3)
	combitable	<- rbind(mymafs1,mymafs2)
	mylabels	<- paste(combitable[1,],combitable[2,],sep="_")
	mycolfunc 	<- colorRampPalette(c("grey20","darkorange"))
	myColours	<- c(mycolfunc(length(mymafs)))			
	#
	if(export){pdf("Deltamaf.simulations.pdf",height=5,width=15)}
	par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5))
	for (k in 1:length(foundervec))
		{
		nrfounders	<- foundervec[k]
		for(j in 1:ncol(combitable))
			{
			add_to_plot	<- ifelse(j==1,FALSE,TRUE)
			my_col		<- myColours[j]
			lin(pop_ne=200,nfounders=nrfounders,n=nriter,mymaf1=combitable[1,j],mymaf2=combitable[2,j],addtoplot=add_to_plot,mycol=my_col,samplesize=nsamples,ngen=nrgen)
			mylist[[j]]	<- mydf
			}
		if(k==length(foundervec))
			{
			legend("topright",mylabels,fill=myColours,bty='n',title="Smaf1_Smaf2",cex=2)
			}
		}
	if(export){dev.off()}
	mydf2		<<- do.call(rbind,mylist)
	#plot(mydf2$S_diff,mydf2$F_diff,ylim=c(0,1),xlim=c(0,1),pch=16)
	}

	
 
# Next tool is to simulate allele frequency differences between pairs of linked SNPs (i.e. no recombination). 
# We sampled 2 bp binary haplotypes (in which 0 coded for major allele and 1 for minor allele) using built in R functions. 
# Founder events and data sampling were simulated as sampling without replacement. 
# Genetic drift was simulated as sampling with replacement. SNP pairs under selection contained 1 SNP under selection and 1 neutral SNP. 
# Selective events were simulated by increasing the numbers of adaptive haplotypes prior to sampling. 
# Adaptive haplotypes were defined as all haplotypes containing the adaptive allele. 
# The single purpose of these simulations is to test the general relation between positively selected SNPs and linked neutral SNPs. 

multilin<-function(foundervec=c(10,50,200),nriter=10000,nriter_sel=500,export=FALSE,nsamples=NULL,nrgen=NULL,selc=NULL,plot_maf=FALSE)
	{
	mylist		<- list()
	if(export){pdf("Deltamaf.simulations.pdf",height=5,width=15)}
	par(mfrow=c(1,3),oma=c(0,1.5,0.5,0.5))
	for (k in 1:length(foundervec))
		{
		nrfounders	<- foundervec[k]
		ne_founders	<- foundervec[k]
		cat(nrfounders,sep="\n")
		add_legend	<- ifelse(k==length(foundervec),TRUE,FALSE)
		lin(pop_ne=200,nfounders=nrfounders,ne_f=ne_founders,plotmaf=plot_maf,n=nriter,samplesize=nsamples,ngen=nrgen,s=NULL)
		if(!is.null(selc)&!(is.null(nrgen)))
			{
			cat("Selected loci",sep="\n")
			lin(pop_ne=200,nfounders=nrfounders,ne_f=ne_founders,plotmaf=plot_maf,n=nriter_sel,samplesize=nsamples,ngen=nrgen,s=selc,addlegend=add_legend,addtoplot=TRUE)
			}
		mylist[[k]]	<- mydf
		}
	if(export){dev.off()}
	mydf2		<<- do.call(rbind,mylist)
	#plot(mydf2$S_diff,mydf2$F_diff,ylim=c(0,1),xlim=c(0,1),pch=16)
	}

# this function visualizes distortion of ld between 2 linkage snps due to sampling:
lin<-function(pop_ne=200,nfounders=10,n=100,mymaf=0.1,diploidy=2,mycol="black",plotmaf=FALSE,addtoplot=FALSE,samplesize=NULL,ngen=NULL,ne_f=50,s=NULL,addlegend=TRUE)
	{
	# table2matrix function is part of 'psych' package:
	# install.packages('psych',repos='http://cran.us.r-project.org')
	# library(psych)
	#
	mydf			<<- as.data.frame(matrix(NA,ncol=7,nrow=n))
	colnames(mydf)	<<- c("S1","S2","S_diff","F1","F2","F_diff","snp2_FminusS")
	# maf1 is maf of first allele, maf2 is maf of second allele:
	mymaf1			<- round(rlnorm(n,meanlog=log(mymaf),sdlog=0.5),3)
	mymaf2			<- round(rlnorm(n,meanlog=log(mymaf),sdlog=0.5),3)
	mymaf1[mymaf1>0.5]<- 0.5
	mymaf2[mymaf2>0.5]<- 0.5
	nsnps			<- 2
	nhaplo_s		<- diploidy*pop_ne
	nhaplo_f1		<- diploidy*nfounders
	nhaplo_f2		<- diploidy*ne_f
	nhaplo_sample	<- diploidy*samplesize
	for(i in c(1:n))
		{
		# snp1:
		mygenos	<- as.vector(rbinom(1,size=nhaplo_s,prob=mymaf1[i]))
		myvec1	<- c(rep(1,mygenos),rep(0,(nhaplo_s-mygenos)))
		myvec1	<- sample(myvec1)
		# snp2:
		mygenos	<- as.vector(rbinom(1,size=nhaplo_s,prob=mymaf2[i]))
		myvec2	<- c(rep(1,mygenos),rep(0,(nhaplo_s-mygenos)))
		myvec2	<- sample(myvec2)
		# combine:
		myvec	<- c(myvec1,myvec2)
		smatrix	<- matrix(myvec,ncol=2,nrow=nhaplo_s)			
		smaf	<- apply(smatrix,2,sum)/nhaplo_s	
		# get founder genos directly after founder event:
		select	<- sample(c(1:nrow(smatrix)),nhaplo_f1,replace=FALSE)		
		fmatrix	<- smatrix[select,]
		fmaf	<- apply(fmatrix,2,sum)/nhaplo_f1
		# get pop and founder genos after certain number of generations following the founder event:
		if(!is.null(ngen))
			{
			for(g in c(1:ngen))
				{
				#cat(g,sep="\n")
				# incorporate selective events:
				if(!is.null(s))
					{
					if(runif(1)<s)
						{
						fdf				<- as.data.frame(fmatrix)
						colnames(fdf)	<- c("snp1","snp2")
						fd1				<- fdf[fdf$snp2==1,]
						fd0				<- fdf[fdf$snp2==0,]
						# selection:
						nalleles		<- nrow(fd1)
						selected		<- sample(c(1:nalleles),ceiling(nalleles*s),replace=TRUE)
						fdf_selected	<- fd1[selected,]
						fmatrix			<- rbind(as.matrix(fdf),as.matrix(fdf_selected))
						row.names(fmatrix)<-NULL
						}
					}
				select	<- sample(c(1:nrow(fmatrix)),nhaplo_f2,replace=TRUE)
				fmatrix <- fmatrix[select,]
				select	<- sample(c(1:nrow(smatrix)),nhaplo_s,replace=TRUE)
				smatrix <- smatrix[select,]
				}
			fmaf		<- apply(fmatrix,2,sum)/nhaplo_f2
			smaf		<- apply(smatrix,2,sum)/nhaplo_s
			}
		fmatrix	<<- fmatrix
		# correct for sample size (because we normally don't sample the entire population, but only a certain number of individuals):
		if(!is.null(samplesize))
			{
			# source:
			if(nhaplo_sample<nrow(smatrix))
				{
				select	<- sample(c(1:nrow(smatrix)),nhaplo_sample,replace=FALSE)	
				smatrix <- smatrix[select,]
				smaf	<- apply(smatrix,2,sum)/nhaplo_sample
				}
			# founder:
			if(nhaplo_sample<nrow(fmatrix))
				{
				select	<- sample(c(1:nrow(fmatrix)),nhaplo_sample,replace=FALSE)	
				fmatrix <- fmatrix[select,]
				fmaf	<- apply(fmatrix,2,sum)/nhaplo_sample
				}
			}
		mydf[i,]<<- c(smaf,abs(smaf[1]-smaf[2]),fmaf,abs(fmaf[1]-fmaf[2]),fmaf[2]-smaf[2])
		}		
	# gradient colour based on delta maf between populations:
	br				<- seq(-0.4,1,0.2)
	mids			<- vector() 
	for(i in c(1:length(br)-1))
		{
		mids[i]		<- sum(br[i],br[i+1])/2
		}
	mycolfunc1 		<- colorRampPalette(c("grey85","red"))
	mycolours		<- mycolfunc1(length(br)-1)
	mydf$distclass	<- cut(mydf$snp2_FminusS,breaks=br,labels=mids) 
	mydf$distclass2	<- as.numeric(cut(mydf$snp2_FminusS,breaks=br,labels=FALSE))
	mydf$mycol		<- mycolours[mydf$distclass2]
	mydf2			<- mydf[,c("S_diff","F_diff","mycol")]
	mydf			<- mydf[row.names(unique(mydf2)),]
	if(!plotmaf)
		{
		if(addtoplot)
			{
			points(mydf$S_diff[mydf$F1==0],mydf$F_diff[mydf$F1==0],col=mydf2$mycol)		# adjacent allele got lost
			points(mydf$S_diff[mydf$F1>0],mydf$F_diff[mydf$F1>0],pch=16,col=mydf2$mycol)	# adjacent allele still segregating
			if(addlegend)
				{
				legend("topright",legend=mids,fill=mycolours,bty='n',cex=1.5)
				}
			}else{
			par(mar=c(5,6,2.5,2))
			plot(mydf$S_diff,mydf$F_diff,xlim=c(0,1),ylim=c(0,1),pch=16,col=mycol,xlab="",ylab="",cex.axis=1.5,las=1)
			mtext("Founder Delta_MAF",side=2,line=3.5,cex=2.5)
			mtext("Source Delta_MAF",side=1,line=3.5,cex=2.5)
			mtext(paste("Ne =",nfounders,sep=" "),cex=2,side=3)
			if(!is.null(samplesize))
				{
				mtext(paste("n =",samplesize,sep=" "),cex=1.5,line=-2,side=3)
				}
			if(!is.null(ngen))
				{
				mtext(paste("G =",ngen,sep=" "),cex=1.5,line=-1.5,side=4)
				}
			}
		}else{
		if(addtoplot)
			{
			points(mydf$S2,mydf$F2,pch=16,col="red")
			}else{
			plot(mydf$S2,mydf$F2,pch=16,col="black",xlab="Source maf",ylab="Founder maf",xlim=c(0,1),ylim=c(0,1))				
			}
		}
	}

mafsim_dynamic<-function(nloci=100,ngens=10,popsize=50,meanmaf=0.17,mafstartvector=NULL,nselloci=0,s=0.1,h=0.5,alpha=1,K=200,beta=0.5)
	{
	cat("popsize equals:",sep="\n")
	cat(popsize,sep="\n")
	cat("Number of generations equals:",sep="\n")
	cat(ngens,sep="\n")
	# define start population size:
	popne	<- vector()
	popne[1]<- popsize
	# Create empty matrix:
	z	<<- matrix(NA,ncol=nloci,nrow=ngens)
	# Minor allele frequency in generation 1:
	if(is.null(mafstartvector))
		{
		z[1,]	<<- (rpois(nloci,lambda=(meanmaf*100)))/100	# this doesn't lead to ordinary maf distribution
		}else{
		z[1,]	<<- mafstartvector
		}
	# Now do the actual simulation:
	# First we simulate the population demography:
	# loss of alleles is permanent, as it should be: 0 stays 0.
	mymatrix	<<- matrix(NA,ncol=6,nrow=ngen)  
	for (i in c(2:ngens))
		{  
		# population demography:	
		n_offspring	<- popne[i-1]*alpha					# alpha is the mean number of offspring per individual:
		Pr_mort		<- (beta*(10^(n_offspring/K)))/n_offspring
		#if((nselloci>0)&(nselloci<nloci))
		#	{
		#	my_meanmaf	<- mean(z[i-1,c((nloci-nselloci):nloci)])
		#	Pr_mort_sel	<- (((1-my_meanmaf)^2)*n_offspring*s+(2*(1-my_meanmaf)*my_meanmaf)*n_offspring*(h*s))/n_offspring
		#	}else{
		#	my_meanmaf	<- mean(z[i-1,])
		#	Pr_mort_sel	<- 0
		#	}
		# popne[i]	<<- round((alpha-Pr_mort-Pr_mort_sel)*popne[i-1])
		# population genetics:
		for (j in c(1:nloci))
			{
			# the next generation starts with random reproduction of offspring (so no sexual selection):
			q			<- (rbinom(1,2*popne[i-1],z[i-1,j]))/(2*popne[i-1])
			p			<- 1-q
			offspring_AA<- (p^2)*n_offspring
			offspring_Aa<- (2*p*q)*n_offspring
			offspring_aa<- (q^2)*n_offspring
			offspring_total<- sum(offspring_AA,offspring_Aa,offspring_aa)
			# during the lifespan differential survival:
			# Random mortality numbers we model as 0.5*(10^density), with density between the ratio between popsize and carrying capacity 		
			# AA and Aa individuals have a mortality probability (s and h*s) due to a selection pressure. 
			if(j>nselloci)
				{
				expAA		<- round((1-Pr_mort-s)*offspring_AA)
				expAa		<- round((1-Pr_mort-s*h)*offspring_Aa)
				expaa		<- round((1-Pr_mort)*offspring_aa)
				}else{
				expAA		<- round((1-Pr_mort)*offspring_AA)
				expAa		<- round((1-Pr_mort)*offspring_Aa)
				expaa		<- round((1-Pr_mort)*offspring_aa)
				}
			expAA		<- ifelse(expAA<0,0,expAA)
			expAa		<- ifelse(expAa<0,0,expAa)
			expaa		<- ifelse(expaa<0,0,expaa)
			z[i,j]		<<- round((2*expaa+expAa)/(2*(expAA+expAa+expaa)),nchar(popne[i]))
			z[i,j]		<<- ifelse(z[i,j]>1,1,z[i,j])	# Frequency can not exceed 1.
			if(j==nloci)
				{
				popne[i]	<- sum(expAA,exAa,expaa)
				}
			}
		}
	return(z[ngens,])
	}	

simdemography<-function(startpop=50,K=200,alpha=1,beta=0,my_base=10,s_coef=0,startmaf=0.2,ngens=100,my_h=0.5,do_plot=TRUE)
	{
	# K is value of population size at which number of random deaths equals 1 per generation if beta is 1. Comparable with carying capacity but technically different.
	# beta is amplifier of number of random deaths per generation
	pop_ne		<- vector()
	pop_ne[1] 	<- startpop 
	q			<- startmaf
	p			<- 1-startmaf
	my_genos	<- matrix(NA,ncol=3,nrow=ngens)
	my_genos[1,]<- c(round((p^2)*startpop),round((2*p*q)*startpop),round((q^2)*startpop))	
	my_probs	<- vector()
	my_probs[1]	<- NA
	for (i in c(2:ngens))
		{ 
		## number of newborns:
		n_offspring	<- pop_ne[i-1]*alpha										# alpha is the mean number of offspring per individual
		q			<- rbinom(1,2*pop_ne[i-1],q)/(2*pop_ne[i-1])
		p			<- 1-q
		offspring_AA<- round((p^2)*n_offspring)
		offspring_Aa<- round((2*p*q)*n_offspring)
		offspring_aa<- round((q^2)*n_offspring)
		## survival through generation:						
		Pr_mort		<- (beta*(my_base^(n_offspring/K)))/n_offspring				# random mortality due to carrying capacity limits
		my_probs[i]	<- Pr_mort
		q			<- rbinom(1,2*pop_ne[i-1],q)/(2*pop_ne[i-1])
		exp_AA		<- round((1-Pr_mort-s_coef)*offspring_AA)
		exp_Aa		<- round((1-Pr_mort-s_coef*my_h)*offspring_Aa)
		exp_aa		<- round((1-Pr_mort)*offspring_aa)
		pop_ne[i]	<- sum(exp_AA,exp_Aa,exp_aa)
		my_genos[i,]<- c(exp_AA,exp_Aa,exp_aa)
		}
	pop_ne			<- pop_ne
	my_probs		<<- my_probs
	if(do_plot)
		{
		plot(pop_ne,type='l',ylim=c(0,1.2*max(pop_ne)),ylab="Number of individuals",lwd=2,xlab="Number of generations",cex.lab=2,cex.axis=1.5)
		lines(my_genos[,1],col="red",lwd=2)
		lines(my_genos[,2],col="blue",lwd=2)
		lines(my_genos[,3],col="darkgreen",lwd=2)
		legend("topleft",fill=c("red","blue","darkgreen"),legend=c("AA","Aa","aa"),bty='n',cex=1.5)
		}
	}
		
expfix<-function(s=0.1,ne=50,q=0.17)
	{
	# Fixation probability according to Kimura's formula:
	if(s==0)
		{
		cat("s is reset to 0.00001",sep="\n")
		s	<- 0.00001
		}
	cat(paste("s =",s,sep=" "),sep="\n")
	cat(paste("ne =",ne,sep=" "),sep="\n")
	cat(paste("q =",q,sep=" "),sep="\n")
	cat("Fixation probability according to Kimura's formula:",sep="\n")
	pfix	<- round((1-exp(-2*ne*s*q))/(1-exp(-2*ne*s)),2)
	cat(pfix,sep="\n")
	}

getgenotypesfrommaf<-function(mafvector,nsamples)
	{
	### function to convert mafvector into expected genotype counts data
	### function returns a matrix with 3 columns (AA,Aa,aa) 
	# call objects:
	expAA		<-rep(NA,length(mafvector))
	expAa		<-rep(NA,length(mafvector))
	expaa		<-rep(NA,length(mafvector))
	# do the calculation:
	for (i in 1:(length(mafvector)))
		{
		expAA[i]<-round((1-mafvector[i])*(1-mafvector[i])*nsamples)
		expAa[i]<-round(2*(mafvector[i])*(1-mafvector[i])*nsamples)
		expaa[i]<-round(mafvector[i]*mafvector[i]*nsamples)
		}
	# store results:
 	z		<- cbind(expAA,expAa,expaa)
	colnames(z)	<- c("AA","Aa","aa")
	return(z)
	}
	
# create genlight object given two mafvectors (one mafvector for pop1, the other mafvector for pop2) stored in a matrix of 2 rows and nloc columns. 
getpedfrommaf<-function(n_ind=c(50,50),nloc=5000,mafinput=mafmatrix,exportname="simdata")
	{
	genocounts	<- list()
	for (k in c(1:2))
		{
		nind		<- n_ind[k]
		mafvector	<- mafinput[k,]
		### Convert mafvector into genotype counts data:
		expAA		<- rep(NA,length(mafvector))
		expAa		<- rep(NA,length(mafvector))
		expaa		<- rep(NA,length(mafvector))
		for (i in 1:(length(mafvector)))
			{
			expAA[i]<- round((1-mafvector[i])*(1-mafvector[i])*nind)
			expAa[i]<- round(2*(mafvector[i])*(1-mafvector[i])*nind)
			expaa[i]<- round(mafvector[i]*mafvector[i]*nind)
			}
 	temp1			<- cbind(expAA,expAa,expaa)	
	genocounts[[k]]	<- temp1 
	}
	#### Convert genotype count matrix into a cummulative genotype counts:
	genotypecum		<- genocounts
	for (k in c(1:2))
		{	
		for (j in c(1:nloc))
			{
			genotypecum[[k]][j,2]	<- genocounts[[k]][j,1]+genocounts[[k]][j,2]
			genotypecum[[k]][j,3]	<- genocounts[[k]][j,1]+genocounts[[k]][j,2]+genocounts[[k]][j,3]
			}
		}
	#### Now use info in genotypecum to create a genlight object:
	genlightobj	<- list()
	for (k in c(1:2))
		{
		nind<- n_ind[k]
		z	<- matrix(nrow=nind,ncol=nloc)
		for (j in 1:nloc)
			{
			for (i in 1:(nind))
				{
				if(i<=genotypecum[[k]][j,1])				{z[i,j]<-0}
				if(i>genotypecum[[k]][j,1]&i<=genotypecum[[k]][j,2])	{z[i,j]<-1}
				if(i>genotypecum[[k]][j,2])				{z[i,j]<-2}
				}
			}
		# Now shuffle, to get data into linkage equilibrium:
		z	<- as.data.frame(z)
		z[]	<- lapply(z,sample)	# lapply means: apply to each column
		genlightobj[[k]]	<- z
		}
	#### Create genlightobject with neutral loci (combining both pops):
	mygenlightmatrix	<- as.matrix(rbind(genlightobj[[1]],genlightobj[[2]]))
	simgenlight			<- as.genlight(mygenlightmatrix)
  	### Now create vectors of minor and major alleles (should match with the columns of the x-matrix):
  	# We assume alleles are either A (1) or C (2):
	minor				<- rep(2,nloc)
	major				<- rep(1,nloc)
	# Now we are ready to create our PED-file, starting with an empty matrix:
	genot<-matrix(NA,nrow=nrow(mygenlightmatrix),ncol=ncol(mygenlightmatrix))
  	rownames(genot)<-rownames(mygenlightmatrix)
  	colnames(genot)<-colnames(mygenlightmatrix)
  	for (j in c(1:ncol(mygenlightmatrix))) 
		{
    		g			<- mygenlightmatrix[,j]
    		maj			<- as.character(major[j])
    		min			<- as.character(minor[j])
    		g[is.na(g)]	<- paste(0,0,sep=" ")  				
    		g[g==0]		<- paste(maj,maj,sep=" ") 			 
    		g[g==1]		<- paste(min,maj,sep=" ") 		
    		g[g==2]		<- paste(min,min,sep=" ") 		
    		genot[,j]	<- g
  		}
  	pedfiledata	<- as.data.frame(genot)
	# Include additional information to pedfile:
	temp1		<- rep(1,n_ind[1])
	temp2		<- rep(2,n_ind[2])
	pedfile		<- cbind(FID=c(temp1,temp2),IID=seq(1:sum(n_ind)),PAT=0,MAT=0,SEX=0,PHENOTYPE=-9,pedfiledata)
	# Next create the MAP-file:
	mapfile		<- cbind(chr=rep("unknown",nloc),name=seq(1:nloc),gd=0,pos=rep(0,nloc))
	# Finally, export the files:
	write.table(pedfile,file=paste(exportname,"ped",sep = "."),sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	write.table(mapfile,file=paste(exportname,"map",sep = "."),sep="\t",na="NA",row.names=FALSE,col.names=FALSE,quote=FALSE)
	path1		<- paste(getwd(),exportname,sep="/")
	cat(paste("PED and MAP files have been written to", path1, sep =" "),sep="\n")
	mysambarsim$mygenlightmatrix	<<- mygenlightmatrix
	}	
	
	
randomDNA<-function(nseq=1,nbases=200)
	{
	bases 	<- c(rep('A',nbases/4), rep('C',nbases/4), rep('G',nbases/4), rep('T',nbases/4))
	seqs 	<<- rep(NA,nseq)
	for (i in 1:nseq)
		{
		seqs[i] <<- paste(sample(bases,nbases), collapse = '')
		}
	}

#randomreads(nref=200,mypositions=seq(20,80,20),ninds=5,cover=10,add_indels=TRUE,insertionsize=10,insertpos=50,deletpos=70)
randomreads<-function(nref=200,mypositions=seq(20,80,20),ninds=2,cover=5,add_indels=TRUE,insertionsize=3,insertpos=50,deletpos=70)
	{
	current_dir	<- getwd()
	out_dir		<- "Testsequences"
	my_dir		<- paste(current_dir,out_dir,sep="/")
	if(!file.exists(my_dir)){dir.create(file.path(my_dir))}
	setwd(my_dir)
	bases 		<- c(rep('A',nref/4), rep('C',nref/4), rep('G',nref/4), rep('T',nref/4))
	myref 		<- paste(sample(bases,nref),collapse='')
	for(j in c(1:ninds))
		{
		cat(j,sep="\n")
		read1		<- substring(myref,1,100)
		read2		<- substring(myref,101,200)
		for (mypos in mypositions)
			{
			if(j<=ninds/2)
				{
				substring(read1,mypos,mypos)<- "T"
				substring(read2,mypos,mypos)<- "A"
				}else{
				substring(read1,mypos,mypos) <- "C"
				substring(read2,mypos,mypos) <- "G"
				}
			}
		qualityscore_read1			<- paste(rep('Z',100),collapse='')
		qualityscore_read2			<- paste(rep('Z',100),collapse='')
		# insertions:
		if((j<=ninds/2)&(add_indels)&(j%%2==0))
				{
				# insertion:
				my_insertion		<- paste(rep("T",insertionsize),collapse="")
				temp1				<- substring(read1,1,insertpos)
				temp2				<- substring(read1,insertpos+1,100)
				read1				<- paste(temp1,my_insertion,temp2,sep='')
				qualityscore_read1	<- paste(rep('Z',100+insertionsize),collapse='')
				#deletion:
				temp1				<- substring(read2,1,deletpos)
				temp2				<- substring(read2,deletpos+1+insertionsize,100)
				read2				<- paste(temp1,temp2,sep='')
				qualityscore_read2	<- paste(rep('Z',100-insertionsize),collapse='')
				}
		cat(read1,sep="\n")
		cat(qualityscore_read1,sep="\n")
		newread1	<- paste(">read",read1,"+",qualityscore_read1,sep="\n")
		newreads1	<- rep(newread1,cover)
		cat(read2,sep="\n")
		cat(qualityscore_read2,sep="\n")
		newread2	<- paste(">read",read2,"+",qualityscore_read2,sep="\n")
		newreads2	<- rep(newread2,cover)
		my_filename_1	<- paste("ind",j,"1.fq",sep=".")
		my_filename_2	<- paste("ind",j,"2.fq",sep=".")
		write.table(newreads1,my_filename_1,quote=FALSE,col.names=FALSE,row.names=FALSE)
		write.table(newreads2,my_filename_2,quote=FALSE,col.names=FALSE,row.names=FALSE)
		}
	myref_fasta			<- paste(">myreference ",myref,sep="\n")	# without white space sed command doesn't work 
	write.table(myref_fasta,"testreference.fa",quote=FALSE,col.names=FALSE,row.names=FALSE)
	setwd(current_dir)
	cat(paste("Fasta files have been written to:",my_dir,sep="\n"),sep="\n")
	}
	
	
####################	

# old version:
outliersim_old<-function(nloc=1000,ngen=20,nesourcepop=1000,nefounderpop1=20,nefounderpop2=200,nfounders=10,samplesize=30,testgeno=FALSE,nselectedloci=0,selcoef=0.1)
	{
	founderpopsizes			<<- rbind(nefounderpop1,nefounderpop2)
	# To store results:
	genotypecounts			<- list()
	pvalue					<<- vector()
	pvaluepairwise			<<- matrix(nrow=3,ncol=nloc) 
	macmatrix				<- matrix(nrow=8,ncol=nloc)
	rownames(macmatrix)		<- c("founder1_A","founder1_a","founder2_A","founder2_a","founders_A","founders_a","source_A","source_a")
	# Simulate source mafs before founder event:
	sourcemaf				<<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=200,meanmaf=0.1)
	# Simulate source mac after founder event and after sampling:
	mafvec					<<- mafsim(nloci=nloc,popsize=nesourcepop,ngens=ngen,mafstartvector=sourcemaf)
	for (j in c(1:nloc))
		{  
		macmatrix[8,j] 		<- rbinom(1,(2*samplesize),mafvec[j])
		}
	if(testgeno)
		{
		genotypecounts[[4]]	<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
		}
	# Simulate founder macs:
	for (k in c(1:2))
		{
		mafvec			<<- getfounderpopmaf(sourcemafvector=sourcemaf,nrfounders=nfounders,nefounderpop=founderpopsizes[k,],nrloci=nloc,ngenfounder=ngen,nselectloci=nselectedloci,selc=selcoef,dodiscrete=s_discrete)	
		for (j in c(1:nloc))
			{  
			macmatrix[k*2,j]<- rbinom(1,(2*samplesize),mafvec[j])
			}
		if(testgeno)
			{
			genotypecounts[[k]]<- getgenotypesfrommaf(mafvector=mafvec,nsamples=samplesize)
			}
		}
	###### Execute fisher's exact test on simulated data using built-in R-function:  
	if(testgeno)
		{
		# Combine both founder populations into one founder population:
		genotypecounts[[3]]	<- genotypecounts[[1]]+genotypecounts[[2]]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons, for source against source (pointless indeed), as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			for (i in c(1:nloc))
  				{
  				d	<- genotypecounts[[4]][i,1]
 				e	<- genotypecounts[[4]][i,2]
  				f	<- genotypecounts[[4]][i,3]
 				x	<- genotypecounts[[j]][i,1]
 				y	<- genotypecounts[[j]][i,2]
  				z	<- genotypecounts[[j]][i,3]
  				mytable	<- matrix(c(d,e,f,x,y,z),2,3,byrow=TRUE)
 				pvalue[i]<<-fisher.test(mytable)$p.value
  				}
			pvaluepairwise[j,]<<- pvalue
			}
		}else{
		# Combine both founder populations into one founder population:
		macmatrix[6,]		<- macmatrix[2,]+macmatrix[4,]
		# calculate number of major alleles:
		macmatrix[1,]		<- 2*samplesize-macmatrix[2,]
		macmatrix[3,]		<- 2*samplesize-macmatrix[4,]
		macmatrix[5,]		<- 4*samplesize-macmatrix[6,]
		macmatrix[7,]		<- 2*samplesize-macmatrix[8,]
		# Now we are ready to execute the exact test:
		# for both pairwise comparisons,as well as for the grouped founder vs source comparison: 
		for (j in c(1:3))
			{
			plist				<- lapply(1:ncol(macmatrix),function(i){matrix(macmatrix[c(7,8,2*j-1,2*j),i],2,2,byrow=TRUE)})
			pvaluepairwise[j,]	<<- unlist(lapply(plist,function(plist){fisher.test(plist)$p.value}))
			}
		}
	mysambarsim$macmatrix	<<- macmatrix
	# negative log of pvalues:
	logp					<- (-log(pvaluepairwise))
	rownames(logp)			<- c("F1vsS","F2vsS","FcombivsS")
	mysambarsim$logp		<<- logp
	# Plot:
	graphics.off()
	plot(logp[1,],col="blue",ylim=c(0,(max(logp))))
	points(logp[2,],col="red")
	points(logp[3,],col="green")
	legend(x=4/5*nloc,y=7/8*max(logp),legend=c("F1-S","F2-S","Fcomb-S"),fill=c("blue","red","green"))
	}

############################### END OF SIMULATION SECTION ###############################









############################### TREEMIX FUNCTIONS #############################

# functions for plotting Treemix output.
# Functions copy pasted from 'Treemix_plotting_funcs.R' on Treemix page (expect for plottreemix function).
# I added the option of specifying population colours.

plottreemix<-function(export=NULL,prefix=NULL,plotname="Treemixout",myxmin=0,labelcex=1.5,xmargin=0.02,mybg="white")
	{
	if(is.null(prefix))
		{
		return(cat("ERROR: provide base name of input files (i.e., without extension) to the prefix flag.",sep="\n")) 
		}
	myfile1		<- paste(prefix,"edges.gz",sep=".")
	if(!file.exists(myfile1))
		{
		cat("ERROR: Could not find files ending on 'edges.gz' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Needed are at least the files ending on 'edges.gz', 'vertices.gz' and 'covse.gz'.",sep="\n"))
		}
	myfile2		<- paste(prefix,"vertices.gz",sep=".")
	if(!file.exists(myfile2))
		{
		cat("ERROR: Could not find files ending on 'vertices.gz' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Needed are at least the files ending on 'edges.gz', 'vertices.gz' and 'covse.gz'.",sep="\n"))
		}
	myfile3		<- paste(prefix,"covse.gz",sep=".")
	if(!file.exists(myfile3))
		{
		cat("ERROR: Could not find files ending on 'covse.gz' in the directory:",sep="\n")
		cat(getwd(),sep="\n")
		return(cat("Needed are at least the files ending on 'edges.gz', 'vertices.gz' and 'covse.gz'.",sep="\n"))
		}
	if(!file.exists(myfile1)|!file.exists(myfile2)|!file.exists(myfile3))
		{
		cat("ERROR: Could not find input files in the directory:",sep="\n")
		return(cat(getwd(),sep="\n"))
		}
	if(!is.null(export))
		{
		mywidth		<- 8
		mywidth2	<- 720
		plotname	<- ifelse(mybg=="white",plotname,paste(plotname,mybg,sep="."))
		if(export=="eps"){postscript(paste(plotname,"eps",sep="."),family=mysambar$myfont,width=mywidth,height=8)}
		if(export=="pdf"){pdf(paste(plotname,"pdf",sep="."),family=mysambar$myfont,width=mywidth,height=8)}
		if(export=="png"){png(paste(plotname,"png",sep="."),family=mysambar$myfont,width=mywidth2,height=720)}
		if(export=="wmf"){win.metafile(paste(plotname,"wmf",sep="."),family=mysambar$myfont,width=mywidth,height=8)}
		}
	par(bg=mybg)
	plot_tree(stem=prefix,labelcolours=mypopcolours,cex=labelcex,disp=0.001,plus=xmargin,arrow=0.2,scale=T,ybar=0.1,mbar=T,plotmig=T,plotnames=T,xmin=myxmin,lwd=2,font=1)
	mtext(side=1,"Drift parameter",line=3,cex=2.25)
	if(!is.null(export))
		{
		dev.off()
		cat("Treemix plot exported to directory:",sep="\n")
		cat(getwd(),sep="\n")
		}
	}


# library(RColorBrewer)
set_y_coords = function(d)
	{
	i = which(d[,3]=="ROOT")
	y = d[i,8]/ (d[i,8]+d[i,10])
	d[i,]$y = 1-y
	d[i,]$ymin = 0
	d[i,]$ymax = 1
	c1 = d[i,7]
	c2 = d[i,9]
	ni = which(d[,1]==c1)
	ny = d[ni,8]/ (d[ni,8]+d[ni,10])
	d[ni,]$ymin = 1-y
	d[ni,]$ymax = 1
	d[ni,]$y = 1- ny*(y)
	ni = which(d[,1]==c2)
    ny = d[ni,8]/ (d[ni,8]+d[ni,10])
    d[ni,]$ymin = 0
    d[ni,]$ymax = 1-y
    d[ni,]$y = (1-y)-ny*(1-y)
	for (j in 1:nrow(d))
		{
		d = set_y_coord(d, j)
		}	
	return(d)
	}

set_y_coord = function(d, i)
	{
	index = d[i,1]
	parent = d[i,6]
	if (!is.na(d[i,]$y))
		{
		return(d)
		}
	tmp = d[d[,1] == parent,]
	if ( is.na(tmp[1,]$y))
		{
		d = set_y_coord(d, which(d[,1]==parent))
		tmp = d[d[,1]== parent,]
		}
	py = tmp[1,]$y
	pymin = tmp[1,]$ymin
	pymax = tmp[1,]$ymax
	f = d[i,8]/( d[i,8]+d[i,10])
	#print (paste(i, index, py, pymin, pymax, f))
	if (tmp[1,7] == index)
		{
		d[i,]$ymin = py
		d[i,]$ymax = pymax
		d[i,]$y = pymax-f*(pymax-py)
		if (d[i,5]== "TIP")
			{
			d[i,]$y = (py+pymax)/2
			}
		}else{
		d[i,]$ymin = pymin
		d[i,]$ymax = py
		d[i,]$y = py-f*(py-pymin)
		if (d[i,5]== "TIP")
			{
            d[i,]$y = (pymin+py)/2
            }	
		}
	return(d)
	}


set_x_coords = function(d, e)
	{
	i = which(d[,3]=="ROOT")
	index = d[i,1]
        d[i,]$x = 0
        c1 = d[i,7]
        c2 = d[i,9]
        ni = which(d[,1]==c1)
	tmpx =  e[e[,1]==index & e[,2] == c1,3]
	if (length(tmpx) == 0){
		tmp = e[e[,1] == index,]
		tmpc1 = tmp[1,2]
		if ( d[d[,1]==tmpc1,4] != "MIG"){
			tmpc1 = tmp[2,2]
		}
		tmpx = get_dist_to_nmig(d, e, index, tmpc1)
	}
	if(tmpx < 0){
		tmpx = 0
	}
        d[ni,]$x = tmpx

        ni = which(d[,1]==c2)
        tmpx =  e[e[,1]==index & e[,2] == c2,3]
	if (length(tmpx) == 0){
    		tmp = e[e[,1] == index,]
                tmpc2 = tmp[2,2]
                if ( d[d[,1]==tmpc2,4] != "MIG"){
                        tmpc2 = tmp[1,2]
                }
                tmpx = get_dist_to_nmig(d, e, index, tmpc2)
	}
        if(tmpx < 0){
                tmpx = 0
        }
        d[ni,]$x = tmpx
        
        for (j in 1:nrow(d)){
                d = set_x_coord(d, e, j)
        }
	return(d)
	print(d)
	}

set_x_coord = function(d, e, i)
	{
	index = d[i,1]
        parent = d[i,6]
        if (!is.na(d[i,]$x)){
                return(d)
        }
        tmp = d[d[,1] == parent,]
        if ( is.na(tmp[1,]$x)){
                d = set_x_coord(d, e, which(d[,1]==parent))
                tmp = d[d[,1]== parent,]
        }
	#print (paste(parent, index))
	tmpx =  e[e[,1]==parent & e[,2] == index,3]
	if (length(tmpx) == 0){
                tmp2 = e[e[,1] == parent,]
                tmpc2 = tmp2[2,2]
		#print
                if ( d[d[,1]==tmpc2,4] != "MIG"){
                        tmpc2 = tmp2[1,2]
                }
		tmpx = get_dist_to_nmig(d, e, parent, tmpc2)
	}
        if(tmpx < 0){
                tmpx = 0
        }
	d[i,]$x = tmp[1,]$x+ tmpx
	return(d)
	}

plot_tree_internal = function(d, e, o = NA, cex = 1, disp = 0.001, plus = 0.003, arrow = 0.05, ybar = 0.01, scale = T, mbar = T, mse = 0.01, plotmig = T, plotnames = T, xmin = 0, lwd = 1, font = 1, my_colours = NULL){
	# 18-07-2021: change of cex.axis added for use in SambaR:
	par(cex.axis=1.5)
	#plot(d$x, d$y, axes = F, ylab = "", xlab = "Drift parameter", xlim = c(xmin, max(d$x)+plus), pch = "")
	plot(d$x, d$y, axes = F, ylab = "", xlab = "", xlim = c(xmin, max(d$x)+plus), pch = "")
	axis(1)
	mw = max(e[e[,5]=="MIG",4])
	mcols = rev(heat.colors(150))
	for(i in 1:nrow(e)){
		col = "black"
		if (e[i,5] == "MIG"){
			w = floor(e[i,4]*200)+50
			if (mw > 0.5){
				w = floor(e[i,4]*100)+50
			}
			col = mcols[w]
			if (is.na(col)){
				col = "blue"
			}
		}
		v1 = d[d[,1] == e[i,1],]
		v2 = d[d[,1] == e[i,2],]
		if (e[i,5] == "MIG"){
			if (plotmig){
			# 18-07-2021: addition of lwd=lwd for use in SambaR
			arrows( v1[1,]$x, v1[1,]$y, v2[1,]$x, v2[1,]$y, col = col, length = arrow,lwd = lwd)
			}
		}
		else{
			lines( c(v1[1,]$x, v2[1,]$x), c(v1[1,]$y, v2[1,]$y), col = col, lwd = lwd)
		}
	}
	tmp = d[d[,5] == "TIP",]
	print(tmp$x)
	print(disp)
	if ( !is.na(o)){
		for(i in 1:nrow(tmp)){
			tcol = o[o[,1] == tmp[i,2],2]
			if(plotnames){
				#print(tmp[i,2])
				text(tmp[i,]$x+disp, tmp[i,]$y, labels = tmp[i,2], adj = 0, cex = cex, col  = tcol, font = font)
			}
		}
	}
	else{
		if (plotnames)
			{
			# 18-07-2021: following lines added for use in SambaR:
			treemixlabels	<- tmp[,2]
			mypopcolours	<<- vector()
			if(length(mysambar$populations)!=length(treemixlabels))
				{
				cat("ERROR: number of populations in input Treemix files does not correspond to number of populations at mysambar$populations.",sep="\n")
				dev.off()
				return(cat("Aborting Treemix plot.",sep="\n"))
				}
			for(k in c(1:length(treemixlabels)))
				{
				mypopcolours[k]	<<- mysambar$mycolours[which(mysambar$populations==treemixlabels[k])]
				}
			# 18-07-2021: until here, as well as else statement in the the next conditional:
			if(is.null(my_colours))
				{
				text(tmp$x+disp, tmp$y, labels = tmp[,2], adj = 0, cex = cex, font = font)
				}else{
				text(tmp$x+disp, tmp$y, labels = tmp[,2], adj = 0, cex = cex, font = font, col = my_colours)
				}
			}
	}
	if (scale){
	print (paste("mse", mse))
        lines(c(0, mse*10), c(ybar, ybar))
	text( 0, ybar - 0.04, lab = "10 s.e.", adj = 0, cex  = 0.8)
	lines( c(0, 0), c( ybar - 0.01, ybar+0.01))
	lines( c(mse*10, mse*10), c(ybar- 0.01, ybar+ 0.01))
	}
    if(mbar)
		{
        mcols = rev( heat.colors(150) )
        mcols = mcols[50:length(mcols)]
        ymi = ybar+0.15
        yma = ybar+0.35
        l = 0.2
        w = l/100
        xma = max(d$x/20)
        mbarcex	= 1.0		# 18-07-2021: addition of mbarcex for use in SambaR. Default is 0.7.
		rect( rep(0, 100), ymi+(0:99)*w, rep(xma, 100), ymi+(1:100)*w, col = mcols, border = mcols)
        text(xma+disp, ymi, lab = "0", adj = 0, cex = mbarcex)
		if(mw>0.5)
			{ 
			text(xma+disp, yma, lab = "1", adj = 0, cex = mbarcex)
			}else{
			text(xma+disp, yma, lab = "0.5", adj = 0, cex = mbarcex)
			}
		text(0, yma+0.06, lab = "Migration", adj = 0 , cex = mbarcex)
		text(0, yma+0.03, lab = "weight", adj = 0 , cex = mbarcex)
		}		
	}

set_mig_coords = function(d, e){
	for (j in 1:nrow(d)){
		if (d[j,4] == "MIG"){
			p = d[d[,1] == d[j,6],]
			c = d[d[,1] == d[j,7],]
			tmpe = e[e[,1] == d[j,1],]
			y1 = p[1,]$y
			y2 = c[1,]$y
			x1 = p[1,]$x
			x2 = c[1,]$x

			mf = tmpe[1,6]	
			if (is.nan(mf)){
				mf = 0
			}
			#d[j,]$y = (y1+y2)* mf
                        #d[j,]$x = (x1+x2) *mf
                        d[j,]$y = y1+(y2-y1)* mf
			print(paste(mf, x1, x2))
                        d[j,]$x = x1+(x2-x1) *mf
		}	

	}
	return(d)

}

get_f = function(stem){
	d = paste(stem, ".cov.gz", sep = "")
	d2 = paste(stem, ".modelcov.gz", sep = "")
	d = read.table(gzfile(d), as.is = T, comment.char = "", quote = "")
	d2 = read.table(gzfile(d2), as.is = T, comment.char = "", quote = "")
	d = d[order(names(d)), order(names(d))]
	d2 = d2[order(names(d2)), order(names(d2))]
	tmpcf = vector()
        tmpmcf = vector()
        for (j in 1:nrow(d)){
                for (k in (j+1):nrow(d)){
                        tmpcf = append(tmpcf, d[j,k])
                        tmpmcf = append(tmpmcf, d[j,k] - d2[j,k])
                }
        }
        tmpv = var(tmpmcf)/var(tmpcf)
	return(1-tmpv)

}

plot_tree = function(stem, o = NA, cex = 1, disp = 0.004, plus = 0.02, flip = vector(), arrow = 0.05, scale = T, ybar = 0.1, mbar = T, plotmig = T, plotnames = T, xmin = 0, lwd = 1, font = 1, labelcolours = NULL)
	{
	d = paste(stem, ".vertices.gz", sep = "")
	e = paste(stem, ".edges.gz", sep = "")
	se = paste(stem, ".covse.gz", sep = "")
	d = read.table(gzfile(d), as.is = T, comment.char = "", quote = "")
	e = read.table(gzfile(e), as.is  = T, comment.char = "", quote = "")
	if (!is.na(o))
		{
		o = read.table(o, as.is = T, comment.char = "", quote = "")
		}
	e[,3] = e[,3]*e[,4]
	e[,3] = e[,3]*e[,4]
	se = read.table(gzfile(se), as.is = T, comment.char = "", quote = "")
	m1 = apply(se, 1, mean)
	m = mean(m1)
	#m = 0
	for(i in 1:length(flip))
		{
		d = flip_node(d, flip[i])
		}
	d$x = "NA"
	d$y = "NA"
	d$ymin = "NA"
	d$ymax = "NA"
	d$x = as.numeric(d$x)
	d$y = as.numeric(d$y)
	d$ymin = as.numeric(d$ymin)
	d$ymax = as.numeric(d$ymax)
	d = set_y_coords(d)
	d = set_x_coords(d, e)
	print(d)
	d = set_mig_coords(d, e)
	# 18-07-2021: my_colours argument added for use in SambaR:
	plot_tree_internal(d, e, o = o, cex = cex, xmin = xmin, disp = disp, plus = plus, arrow = arrow, ybar = ybar, mbar = mbar, mse = m, scale = scale, plotmig = plotmig, plotnames = plotnames, lwd = lwd, font = font, my_colours = labelcolours)
	return(list( d= d, e = e))
	}

get_dist_to_nmig = function(d, e, n1, n2)
	{
	toreturn = e[e[,1] == n1 & e[,2] == n2,3]
	#print(toreturn)
	while ( d[d[,1] ==n2,4] == "MIG")
		{
		tmp = e[e[,1] == n2 & e[,5] == "NOT_MIG",]
		toreturn = toreturn+tmp[1,3]
		n2 = tmp[1,2]
		}
	return(toreturn)
	}

flip_node = function(d, n)
	{
	i = which(d[,1] == n)
	t1 = d[i,7]
	t2 = d[i,8]
	d[i,7] = d[i,9]
	d[i,8] = d[i,10]
	d[i,9] = t1
	d[i,10] = t2
	return(d)
	}

plot_modelcov = function(stem, pop_order, min = -0.009, max = 0.009, cex = 1, usemax = T){
        c = read.table(gzfile(paste(stem, ".modelcov.gz", sep = "")), as.is = T, head = T)
        o = read.table(pop_order, as.is = T, comment.char = "", quote = "")


        toplot = data.frame(matrix(nrow = nrow(c), ncol = ncol(c)))
        for(i in 1:nrow(o)){
                for( j in 1:nrow(o)){

                        toplot[i, j] = c[which(names(c)==o[i,1]), which(names(c)==o[j,1])]
                }
        }
        if (usemax){
                m1 = max(abs(toplot))
                max = m1*1.1
                min = -(m1*1.1)
        }
        names(toplot) = o[,1]
        plot_resid_internal(toplot, max = max, min = min)
}



plot_cov = function(stem, pop_order, min = -0.009, max = 0.009, cex = 1, usemax = T, wcols = ""){
        c = read.table(gzfile(paste(stem, ".cov.gz", sep = "")), as.is = T, head = T)
        o = read.table(pop_order, as.is = T)


        toplot = data.frame(matrix(nrow = nrow(c), ncol = ncol(c)))
        for(i in 1:nrow(o)){
                for( j in 1:nrow(o)){

                        toplot[i, j] = c[which(names(c)==o[i,1]), which(names(c)==o[j,1])]
                }
        }
        if (usemax){
                m1 = max(abs(toplot))
                max = m1*1.1
                min = 0
        }
        names(toplot) = o[,1]
        plot_cov_internal(toplot, max = max, min = min, wcols = wcols, o = o, cex = cex)
}


plot_resid = function(stem, pop_order, min = -0.009, max = 0.009, cex = 1, usemax = T, wcols = "r"){
	c = read.table(gzfile(paste(stem, ".cov.gz", sep = "")), as.is = T, head = T, quote = "", comment.char = "")
	m = read.table(gzfile(paste(stem, ".modelcov.gz", sep = "")), as.is = T, head = T, quote = "", comment.char = "")
	names(c) = rownames(c)
	names(m) = rownames(m)
	o = read.table(pop_order, as.is = T, comment.char = "", quote = "")
	se = read.table(gzfile(paste(stem, ".covse.gz", sep = "")), as.is = T, head = T, quote = "", comment.char = "")
	mse = apply(se, 1, mean)
	mse = mean(mse)
	print(mse)	
	c = c[order(names(c)), order(names(c))]
	m = m[order(names(m)), order(names(m))]
	tmp = c -m 
	#tmp = m - c
	#tmp = (m-c)/m
	#print(tmp)
	toplot = data.frame(matrix(nrow = nrow(tmp), ncol = ncol(tmp)))
	for(i in 1:nrow(o)){
	        for( j in 1:nrow(o)){
			#print(paste(o[i,1], o[j,1]))
			if (o[i,1] %in% names(tmp) ==F){
				print(paste("not found", o[i,1]))
			}
			if (o[j,1] %in% names(tmp) ==F){
				print(paste("not found", o[j,1]))
			}
        	        toplot[i, j] = tmp[which(names(tmp)==o[i,1]), which(names(tmp)==o[j,1])]
        	}
	}
	#print(toplot)
	if (usemax){
		m1 = max(abs(toplot), na.rm = T)
		max = m1*1.02
		min = -(m1*1.02)	
	}
	print("here")
	names(toplot) = o[,1]
	toreturn = plot_resid_internal(toplot, max = max, min = min, wcols = wcols, mse = mse, o = o, cex = cex)
	return(toreturn)
}

plot_cov_internal = function(d, o = NA, max = 0.009, min = -0.009, cex =0.5, wcols = "", mse = 5){
        npop = nrow(d)
        width = 1/npop
        height = 1/npop
        colors = brewer.pal(9, "Spectral")
        colors = c("red", "orange","yellow", "white", "green", "blue", "black")
        pal = colorRampPalette(colors)
        ncol = 80
        cols = pal(ncol)
        plot("NA", xlim = c(0, 1), ylim = c(0, 1), axes = F, xlab = "", ylab = "")
        for (i in 1:npop){
                for( j in 1:i){
                        v = d[i,j]
                        col= "white"
                        if (v < 0){
                                if (wcols == "rb"){
                                col = rgb(0, 0, 1, v/min)
                                }
                                else{
                                #col = rgb(0, 0, 1, 0.1+0.9*(v/min))
                                col = cols[ncol/2-floor( (v/min)*(ncol/2))]
                                }
                        }
                        else{
                                if (wcols == "rb"){
                                col = rgb(1, 0, 0, v/max)
                                }
                                else{
                                #col = rgb(1, 0, 0, 0.1+0.9*(v/max))
                                col = cols[ceiling((v/max)*(ncol))]
                                }
                        }
                        xmin = j/npop - 1/npop
                        xmax = j/npop
                        ymin = 1-(i/npop)
                        ymax = 1-(i/npop)+1/npop
			if (v == 0){ col = "white"}
                        rect(xmin, ymin, xmax, ymax, col = col, border = col)
                }
                tcol = "black"
                tmp = o[o[,1] == names(d)[i],]
                if (length(tmp) != 1){
                        tcol = tmp[1,2]
                }
                mtext(names(d)[i], side = 2, at = 1-i/npop+0.5/npop, las = 1, cex = cex, col = tcol)
                mtext(names(d)[i], side = 1, at =  i/npop-0.5/npop, las = 3, cex = cex, col = tcol)
        }
        if ( !is.na(mse)){
                ymi = 0.5
                yma = 0.9
                w = (yma-ymi)/ncol
                xma = 0.80
                lmi = round(min, digits = 1)
                lma = round(max, digits = 1)
                print(cols)
                print(ymi+(0:ncol)*w)
                rect( rep(0.75, ncol), ymi+(0:(ncol-1))*w, rep(xma, ncol), ymi+(1:ncol)*w, col = cols, border = cols)
                text(xma+0.01, ymi, lab = paste(lmi),  adj = 0, cex = 0.8)
                text(xma+0.01, yma, lab = paste(lma, "(Variance)"), adj = 0, cex = 0.8)

        }
        return(d)
        #image(as.matrix(d), col = cols)
}

plot_resid_internal = function(d, o = NA, max = 0.009, min = -0.009, cex =0.5, wcols = "rb", mse = NA){
        npop = nrow(d)
        width = 1/npop
        height = 1/npop
	colors = brewer.pal(9, "Spectral")
	colors = c("red", "orange","yellow", "white", "green", "blue", "black")
	pal = colorRampPalette(colors)
	ncol = 80
	cols = pal(ncol)
        plot("NA", xlim = c(0, 1), ylim = c(0, 1), axes = F, xlab = "", ylab = "")
        for (i in 1:npop){
                for( j in 1:i){
                        v = d[i,j]
			print(paste(i, j, v))
                        col= "white"
                        if (v < 0){
				if (wcols == "rb"){
				col = rgb(0, 0, 1, v/min)
				}
				else{
                                #col = rgb(0, 0, 1, 0.1+0.9*(v/min))
				col = cols[ncol/2-floor( (v/min)*(ncol/2))]
				#col = "white"
				}
                        }
                        else{
				if (wcols == "rb"){
				col = rgb(1, 0, 0, v/max)
				}
				else{
                                #col = rgb(1, 0, 0, 0.1+0.9*(v/max))
				col = cols[ncol/2+ceiling((v/max)*(ncol/2))]
				}
                        }
                        xmin = j/npop - 1/npop
                        xmax = j/npop
                        ymin = 1-(i/npop)
                        ymax = 1-(i/npop)+1/npop
                        rect(xmin, ymin, xmax, ymax, col = col, border = col)
                }
		tcol = "black"
		tmp = o[o[,1] == names(d)[i],]
		if (length(tmp) != 1){
			tcol = tmp[1,2]
		}
                mtext(names(d)[i], side = 2, at = 1-i/npop+0.5/npop, las = 1, cex = cex, col = tcol)
                mtext(names(d)[i], side = 1, at =  i/npop-0.5/npop, las = 3, cex = cex, col = tcol)
        }
	if ( !is.na(mse)){
                ymi = 0.5
                yma = 0.9
                w = (yma-ymi)/ncol
                xma = 0.80
		lmi = round(min/mse, digits = 1)
		lma = round(max/mse, digits = 1)
		print(cols)
		print(ymi+(0:ncol)*w)
                rect( rep(0.75, ncol), ymi+(0:(ncol-1))*w, rep(xma, ncol), ymi+(1:ncol)*w, col = cols, border = cols)
                text(xma+0.01, ymi, lab = paste(lmi, "SE"),  adj = 0, cex = 0.8)
                text(xma+0.01, yma, lab = paste(lma, "SE"), adj = 0, cex = 0.8)

	}
	return(d)
	#image(as.matrix(d), col = cols)
	}

########## END OF TREEMIX FUNCTIONS ##########




































cat("SambaR loaded.",sep="\n")
cat("Now you can run the commands getpackages(), importdata(), filterdata(), and afterwards findstructure(), calcdistance(), calcdiversity() and selectionanalyses().",sep="\n")
cat("See the manual for more details and for solutions to potential errors you might encounter.",sep="\n")
cat("Make sure that none of the SambaR plots and other output files are opened in a file viewer when (re)running a function, otherwise you will encounter errors (e.g.: 'ERROR: cannot open file...: (Permission denied)').",sep="\n")
cat("Also, please prepare your commands in a plain text editor (e.g. Notepad) and not in Word, because Word might deform quotes, which will lead to the error: 'Error: unexpected input in...'.",sep="\n")    
cat(" ",sep="\n")
cat("IMPORTANT NOTE:",sep="\n")
cat("SambaR is meant to free its users from the disproportionate time investment which without SambaR is needed for trivial task associated with execution and presentation of population-genetic analyses.",sep="\n")
cat("SambaR is NOT meant for superficial data analyses without critical thinking and understanding of the theoretical underpinnings of these analyses.",sep="\n")
cat("SambaR users are expected to use the freed up time for critical evaluation of analyses outcomes as well as for the study of the algorithms behind population-genetic analyses.",sep="\n") 
cat("The file 'SambaR_methods2.txt' (included in download from Github) provides an overview of the SambaR commands which call functions of other R packages.",sep="\n")
cat("The section 10.3 in the SambaR manual contains detailed explanations of calculations performed by SambaR functions.",sep="\n")

if(getRversion()<'4.0.0')
	{
	cat("",sep="\n")
	cat("WARNING: SambaR depends on certain packages which can only be installed on R versions 4.0.0 or higher.",sep="\n")
	cat(paste("Your current R version is: ",getRversion(),sep=""),sep="\n")
	cat("If you have succesfully run the getpackages() function on this R installation on your computer before, you are probably fine.",sep="\n")
	cat(paste("If not, the getpackages() function might throw errors like: 'ERROR: package 'packagename' is not available for R ",getRversion(),".",sep=""),sep="\n")
	cat("To avoid these errors, you are recommended to install the latest version of R and run SambaR there.",sep="\n")
	cat("",sep="\n")
	#cat("If you are working on a relatively recent version of R, you might be able to safe the effort of reinstalling R and all dependencies by omitting a package or trying to install an older version of the particular package which causes the error.",sep="\n")
	#cat("In that case, first run the getpackages() function to find out which package can not be installed.",sep="\n")
	#cat("Afterwards, look on the CRAN, Bioconductor or Github webpage of this particular R package to find an older version of this package.",sep="\n")
	#cat("Define this version in the 'required_version' column of the 'mypackageslist.txt' file.",sep="\n")
	#cat("Then try to install this older version of this package using the install_version() function of devtools (which normally should have been installed when running the getpackages() function).",sep="\n")
	#cat("For example, if you want to install version 0.9.1 of the ggplot2 package, you would run the command:",sep="\n")
	#cat("install_version('ggplot2',version='0.9.1',repos='http://cran.us.r-project.org')",sep="\n")
	#cat("Afterwards run the getpackages() function and repeat the same procedure for other packages until the getpackages() function completes without throwing errors.",sep="\n")
	#if("car" %in% rownames(installed.packages()))
	#	{
	#	cat("Because the package 'car' is already installed in this R version on your computer, this won't cause problems for now.",sep="\n")
	#	cat("It is still worth considering installing a newer R version at some point.",sep="\n")
	#	}else{
	#	cat("The package 'car' is not yet installed in this R version on your computer.",sep="\n")
	#	cat("Therefore, you need to install a newer version of R (3.5.0 or newer) and run SambaR on this newer version.",sep="\n")
	#	}
	}

cat(" ",sep="\n")
cat("Update 25-04-2021 (SambaR version 1.04 and newer): inbreeding and relatedness calculations are no longer part of the filterdata function, but instead included in the new function 'calckinship'.",sep="\n")
cat(" ",sep="\n")
cat("Update 08-02-2022 (SambaR version 1.06 and newer): the calcdiversity does (by default) no longer generate SFS-vectors.",sep="\n") 
cat("You are advised to construct SFS-vectors using other software (e.g., ANGSD, easySFS or Popgen Pipeline Platform).",sep="\n")
cat(" ",sep="\n")
cat("Update 21-04-2022 (SambaR version 1.07 and newer): gene flow analyses are no longer part of the calcdistance() function, but instead included in the new function 'inferdemography'.",sep="\n")



#my_os<-as.vector(Sys.info()["sysname"])
#if(my_os=="Linux")
#	{
#	cat("",sep="\n")
#	cat("You are running R on a Linux computer. This might cause problems for SambaR when trying to install the package 'devtools'.",sep="\n")
#	cat("Unfortunately at this point I do not have a solution for this problem yet.",sep="\n")
#	}

#cat("",sep="\n")
#cat("SambaR update 1:",sep="\n")
#cat("As of May 2020, SambaR offers the option to define the order of your populations in the admixture plot. Use the 'pop_order' flag of the findstructure function.",sep="\n")    
#cat("For example: if your populations are named 'America', 'Asia', 'Europe', you can specify an order (from left to right) by typing (for example):",sep="\n")
#cat("findstructure(pop_order=c('Europe','Asia','America'))",sep="\n")
#cat("",sep="\n")
#cat("SambaR update 2:",sep="\n")
#cat("Also, as of May 2020, users can define subpopulation structure, by including in the sample file a column called 'pop2'.",sep="\n")
#cat("For example: if in the 'pop'-column samples are assigned to populations 'America', 'Asia', 'Europe', you can can use the 'pop2'-column to assign your samples to countries within these continents.",sep="\n")   
#cat("When running the findstructure() function, SambaR will use this information to run pcoa analyses per population individually.",sep="\n")


